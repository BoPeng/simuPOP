<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>
<tagfile>
  <compound kind="page">
    <name>index</name>
    <title></title>
    <filename>index</filename>
    <docanchor>features</docanchor>
    <docanchor>introduction</docanchor>
    <docanchor>test</docanchor>
    <docanchor>EasyPOP</docanchor>
    <docanchor>TOC</docanchor>
    <docanchor>random</docanchor>
    <docanchor>visualizer</docanchor>
    <docanchor>GUI</docanchor>
    <docanchor>goals</docanchor>
    <docanchor>script</docanchor>
    <docanchor>misc</docanchor>
    <docanchor>matlab</docanchor>
    <docanchor>design</docanchor>
    <docanchor>parallelization</docanchor>
  </compound>
  <compound kind="file">
    <name>fastBernulli.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00132</filename>
  </compound>
  <compound kind="file">
    <name>individual.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00133</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <namespace>simuPOP</namespace>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGEAGE</name>
      <anchor>a0</anchor>
      <arglist>(age)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>initializer.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00134</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <includes id="a00149" name="random.h" local="yes">random.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>install.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00135</filename>
    <member kind="variable">
      <type>Note</type>
      <name>__pad0__</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>main.cpp</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00136</filename>
    <includes id="a00149" name="random.h" local="yes">random.h</includes>
    <includes id="a00153" name="simulator.h" local="yes">simulator.h</includes>
    <includes id="a00133" name="individual.h" local="yes">individual.h</includes>
    <includes id="a00148" name="population.h" local="yes">population.h</includes>
    <includes id="a00138" name="mating.h" local="yes">mating.h</includes>
    <includes id="a00140" name="migrator.h" local="yes">migrator.h</includes>
    <member kind="typedef">
      <type>ConstSizePopulation&lt; Individual&lt; std::pair&lt; int, int &gt; &gt; &gt;</type>
      <name>population</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char *argv[])</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mainPage.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00137</filename>
  </compound>
  <compound kind="file">
    <name>mating.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00138</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00148" name="population.h" local="yes">population.h</includes>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <includes id="a00149" name="random.h" local="yes">random.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>migration.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00139</filename>
  </compound>
  <compound kind="file">
    <name>migrator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00140</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>mutation.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00141</filename>
  </compound>
  <compound kind="file">
    <name>mutator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00142</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>operator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00143</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00162" name="utility.h" local="yes">utility.h</includes>
    <includes id="a00156" name="streamman.h" local="yes">streamman.h</includes>
    <includes id="a00148" name="population.h" local="yes">population.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>optDevel.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00144</filename>
  </compound>
  <compound kind="file">
    <name>outputer.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00145</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
    <member kind="define">
      <type>#define</type>
      <name>GENERATION_STRING</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>REPLICATE_STRING</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>GROUP_STRING</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ploidy.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00146</filename>
  </compound>
  <compound kind="file">
    <name>popDevel.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00147</filename>
  </compound>
  <compound kind="file">
    <name>population.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00148</filename>
    <includes id="a00162" name="utility.h" local="yes">utility.h</includes>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00133" name="individual.h" local="yes">individual.h</includes>
    <includes id="a00138" name="mating.h" local="yes">mating.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>random.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00149</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>recombinator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00150</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>roadmap.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00151</filename>
  </compound>
  <compound kind="file">
    <name>selector.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00152</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>simulator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00153</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00162" name="utility.h" local="yes">utility.h</includes>
    <includes id="a00138" name="mating.h" local="yes">mating.h</includes>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>simupop_cfg.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00154</filename>
    <namespace>simuPOP</namespace>
    <member kind="define">
      <type>#define</type>
      <name>toStr</name>
      <anchor>a0</anchor>
      <arglist>(str)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>RESOLVESUBPOP</name>
      <anchor>a1</anchor>
      <arglist>(subpop)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>RESOLVECHROM</name>
      <anchor>a2</anchor>
      <arglist>(chrom)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>RESOLVELOCUS</name>
      <anchor>a3</anchor>
      <arglist>(chrom, locus)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>RESOLVEABSLOCUS</name>
      <anchor>a4</anchor>
      <arglist>(locus)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGEPLOIDY</name>
      <anchor>a5</anchor>
      <arglist>(p)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGESEX</name>
      <anchor>a6</anchor>
      <arglist>(sex)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGESUBPOP</name>
      <anchor>a7</anchor>
      <arglist>(subpop)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGECHROM</name>
      <anchor>a8</anchor>
      <arglist>(chrom)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGELOCUS</name>
      <anchor>a9</anchor>
      <arglist>(chrom, locus)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGEABSLOCUS</name>
      <anchor>a10</anchor>
      <arglist>(locus)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGEGENOSIZE</name>
      <anchor>a11</anchor>
      <arglist>(p)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGESEX</name>
      <anchor>a12</anchor>
      <arglist>(sex)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>CHECKRANGESUBPOPMEMBER</name>
      <anchor>a13</anchor>
      <arglist>(ind, sp)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>SEX</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ALLELE</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>FLOAT</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>LONG</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; int &gt;</type>
      <name>vectori</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; SEX &gt;</type>
      <name>vectors</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; FLOAT &gt;</type>
      <name>vectorf</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; ALLELE &gt;</type>
      <name>vectora</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; LONG &gt;</type>
      <name>vectorl</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; int &gt;::iterator</type>
      <name>veci_iter</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; SEX &gt;::iterator</type>
      <name>vecs_iter</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; FLOAT &gt;::iterator</type>
      <name>vecf_iter</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; LONG &gt;::iterator</type>
      <name>vecl_iter</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; ALLELE &gt;::iterator</type>
      <name>veca_iter</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>stator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00155</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00148" name="population.h" local="yes">population.h</includes>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
    <member kind="define">
      <type>#define</type>
      <name>POPSIZE_STRING</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>NUMOFMALE_STRING</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>NUMOFFEMALE_STRING</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>streamman.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00156</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00162" name="utility.h" local="yes">utility.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>tagger.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00157</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>techDetails.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00158</filename>
  </compound>
  <compound kind="file">
    <name>terminator.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00159</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <includes id="a00148" name="population.h" local="yes">population.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>usersManual.dox</name>
    <path>/home/bpeng/research/simupop/doc/</path>
    <filename>a00160</filename>
  </compound>
  <compound kind="file">
    <name>utility.cpp</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00161</filename>
    <includes id="a00149" name="random.h" local="yes">random.h</includes>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00162" name="utility.h" local="yes">utility.h</includes>
    <includes id="a00133" name="individual.h" local="yes">individual.h</includes>
    <includes id="a00156" name="streamman.h" local="yes">streamman.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>utility.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00162</filename>
    <includes id="a00154" name="simupop_cfg.h" local="yes">simupop_cfg.h</includes>
    <includes id="a00156" name="streamman.h" local="yes">streamman.h</includes>
    <includes id="a00149" name="random.h" local="yes">random.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="file">
    <name>visualizer.h</name>
    <path>/home/bpeng/research/simupop/src/</path>
    <filename>a00163</filename>
    <includes id="a00143" name="operator.h" local="yes">operator.h</includes>
    <namespace>simuPOP</namespace>
  </compound>
  <compound kind="page">
    <name>ref_fastBernulli</name>
    <title>Fast algorithm on a sequence of Bernulli trials</title>
    <filename>ref_fastBernulli</filename>
    <docanchor>conc</docanchor>
    <docanchor>solution1</docanchor>
    <docanchor>intro</docanchor>
    <docanchor>choose</docanchor>
    <docanchor>dis</docanchor>
    <docanchor>solution</docanchor>
  </compound>
  <compound kind="page">
    <name>ref_migration</name>
    <title>Migration models</title>
    <filename>ref_migration</filename>
  </compound>
  <compound kind="page">
    <name>ref_operator</name>
    <title>class Operator users guide</title>
    <filename>ref_operator</filename>
    <docanchor>app_out</docanchor>
    <docanchor>app_when</docanchor>
    <docanchor>app_gen</docanchor>
  </compound>
  <compound kind="page">
    <name>ref_ploidy</name>
    <title>Info about ploidy and its implication in simuPOP</title>
    <filename>ref_ploidy</filename>
    <docanchor>haplodiploid</docanchor>
    <docanchor>haploid</docanchor>
    <docanchor>diploid_uni_sex</docanchor>
    <docanchor>diploid</docanchor>
  </compound>
  <compound kind="page">
    <name>population_ext</name>
    <title>Population developer&apos;s guide</title>
    <filename>population_ext</filename>
    <docanchor>pop_const</docanchor>
    <docanchor>pop_ind</docanchor>
    <docanchor>pop_pop</docanchor>
    <docanchor>pop_intro</docanchor>
    <docanchor>pop_genostrutrait</docanchor>
    <docanchor>pop_genostru</docanchor>
    <docanchor>pop_itertors</docanchor>
  </compound>
  <compound kind="page">
    <name>ref_roadmap</name>
    <title>roadmap of simuPOP</title>
    <filename>ref_roadmap</filename>
  </compound>
  <compound kind="page">
    <name>ref_tech</name>
    <title>Python/C++/SWIG and other techniques used</title>
    <filename>ref_tech</filename>
    <docanchor>swig</docanchor>
    <docanchor>note</docanchor>
    <docanchor>stl</docanchor>
    <docanchor>other</docanchor>
    <docanchor>python</docanchor>
    <docanchor>cpp</docanchor>
    <docanchor>template</docanchor>
  </compound>
  <compound kind="page">
    <name>ref_userManual</name>
    <title>simuPOP User&apos;s Manual</title>
    <filename>ref_userManual</filename>
    <docanchor>population</docanchor>
    <docanchor>use</docanchor>
    <docanchor>operators</docanchor>
    <docanchor>intro</docanchor>
    <docanchor>Mutation</docanchor>
    <docanchor>gen</docanchor>
    <docanchor>simulator</docanchor>
    <docanchor>example</docanchor>
    <docanchor>tabbled</docanchor>
    <docanchor>individuals</docanchor>
    <docanchor>Statistics</docanchor>
    <docanchor>Selection</docanchor>
    <docanchor>Migration</docanchor>
  </compound>
  <compound kind="namespace">
    <name>simuPOP</name>
    <filename>a00164.html</filename>
    <class kind="class">simuPOP::GenoStructure</class>
    <class kind="class">simuPOP::GenoStruTrait</class>
    <class kind="class">simuPOP::Individual</class>
    <class kind="class">simuPOP::IndividualWithAge</class>
    <class kind="class">simuPOP::Initializer</class>
    <class kind="class">simuPOP::InitByFreq</class>
    <class kind="class">simuPOP::InitSex</class>
    <class kind="class">simuPOP::Mating</class>
    <class kind="class">simuPOP::NoMating</class>
    <class kind="class">simuPOP::BinomialSelection</class>
    <class kind="class">simuPOP::RandomMating</class>
    <class kind="class">simuPOP::Migrator</class>
    <class kind="class">simuPOP::Migrator::MigrantType</class>
    <class kind="class">simuPOP::Mutator</class>
    <class kind="class">simuPOP::KAMMutator</class>
    <class kind="class">simuPOP::SSMMutator</class>
    <class kind="class">simuPOP::mixedMutator</class>
    <class kind="class">simuPOP::Operator</class>
    <class kind="class">simuPOP::Outputer</class>
    <class kind="class">simuPOP::OutputHelper</class>
    <class kind="class">simuPOP::Dumper</class>
    <class kind="class">simuPOP::GappedAlleleIterator</class>
    <class kind="class">simuPOP::ConstSizePopulation</class>
    <class kind="class">simuPOP::RNG</class>
    <class kind="class">simuPOP::BernulliTrials</class>
    <class kind="class">simuPOP::Recombinator</class>
    <class kind="class">simuPOP::NoRecombination</class>
    <class kind="class">simuPOP::UnifRecombinator</class>
    <class kind="class">simuPOP::Selector</class>
    <class kind="class">simuPOP::Simulator</class>
    <class kind="class">simuPOP::Exception</class>
    <class kind="class">simuPOP::OutOfMemory</class>
    <class kind="class">simuPOP::IOError</class>
    <class kind="class">simuPOP::RangeError</class>
    <class kind="class">simuPOP::TypeError</class>
    <class kind="class">simuPOP::ValueError</class>
    <class kind="class">simuPOP::SystemError</class>
    <class kind="class">simuPOP::Stator</class>
    <class kind="class">simuPOP::SubPopStat</class>
    <class kind="class">simuPOP::AlleleCounter</class>
    <class kind="class">simuPOP::OstreamManager</class>
    <class kind="class">simuPOP::Tagger</class>
    <class kind="class">simuPOP::InheritTagger</class>
    <class kind="class">simuPOP::ParentsTagger</class>
    <class kind="class">simuPOP::Terminator</class>
    <class kind="class">simuPOP::FixationChecker</class>
    <class kind="class">simuPOP::isMale</class>
    <class kind="class">simuPOP::isFemale</class>
    <class kind="class">simuPOP::Visualizer</class>
    <class kind="class">simuPOP::MatlabPlotter</class>
    <member kind="typedef">
      <type>boost::dynamic_bitset</type>
      <name>BitSet</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Sex</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Male</name>
      <anchor>a24a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Female</name>
      <anchor>a24a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;out, GenoStructure &amp;gs)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a9</anchor>
      <arglist>(ostream &amp;out, const Individual&lt; Tag &gt; &amp;ind)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a10</anchor>
      <arglist>(ostream &amp;out, const IndividualWithAge&lt; Tag &gt; &amp;ind)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>my_new_handler</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxAllocableMemory</name>
      <anchor>a12</anchor>
      <arglist>(int size)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>verboseLevel</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVerboseLevel</name>
      <anchor>a14</anchor>
      <arglist>(int v)</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxAllocableMemory</name>
      <anchor>a15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>allocatedMemory</name>
      <anchor>a16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>addToAllocatedMemory</name>
      <anchor>a17</anchor>
      <arglist>(double change)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>substractFromAllocatedMemory</name>
      <anchor>a18</anchor>
      <arglist>(double change)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>initialize</name>
      <anchor>a19</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>OstreamManager &amp;</type>
      <name>persistentOstreams</name>
      <anchor>a20</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RNG &amp;</type>
      <name>rng</name>
      <anchor>a21</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a22</anchor>
      <arglist>(ostream &amp;out, const vector&lt; T &gt; &amp;vec)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a23</anchor>
      <arglist>(ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;pair)</arglist>
    </member>
    <member kind="variable">
      <type>long</type>
      <name>g_maxAllocableMemory</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g_allocatedMemory</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>g_verboseLevel</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>OstreamManager</type>
      <name>g_ostreams</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RNG</type>
      <name>g_RNG</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::GenoStructure</name>
    <filename>a00090.html</filename>
    <member kind="function">
      <type></type>
      <name>GenoStructure</name>
      <anchor>a0</anchor>
      <arglist>(int ploidy, vectori loci, vectorf lociDist)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~GenoStructure</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_ploidy</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_totNumLoci</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_numChrom</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>m_numLoci</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorf</type>
      <name>m_lociDist</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>m_chromIndex</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>n0</anchor>
      <arglist>(ostream &amp;out, GenoStructure &amp;gs)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::GenoStruTrait</name>
    <filename>a00091.html</filename>
    <member kind="function">
      <type></type>
      <name>GenoStruTrait</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGenoStructure</name>
      <anchor>a1</anchor>
      <arglist>(GenoStructure *stru)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>destroyGenoStructure</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>GenoStructure &amp;</type>
      <name>genoStru</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>ploidy</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>ploidyName</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numLoci</name>
      <anchor>a6</anchor>
      <arglist>(int chrom) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>totNumLoci</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FLOAT</type>
      <name>locusDist</name>
      <anchor>a8</anchor>
      <arglist>(int locus) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>genoSize</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numChrom</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>chromBegin</name>
      <anchor>a11</anchor>
      <arglist>(int chrom) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>chromEnd</name>
      <anchor>a12</anchor>
      <arglist>(int chrom) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>absLocusIndex</name>
      <anchor>a13</anchor>
      <arglist>(int chrom, int locus)</arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; int, int &gt;</type>
      <name>chromLocusPair</name>
      <anchor>a14</anchor>
      <arglist>(int locus) const</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>GenoStructure *</type>
      <name>m_genoStru</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Individual</name>
    <filename>a00092.html</filename>
    <templarg>Tag</templarg>
    <base>simuPOP::GenoStruTrait</base>
    <member kind="function">
      <type>bool</type>
      <name>shallowCopied</name>
      <anchor>z9_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setShallowCopied</name>
      <anchor>z9_1</anchor>
      <arglist>(bool shallowCopied)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>shallowCopiedFlagOn</name>
      <anchor>z9_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>clearShallowCopiedFlag</name>
      <anchor>z9_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>char *</type>
      <name>outputSeparator</name>
      <anchor>z9_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setOutputSeparator</name>
      <anchor>z9_5</anchor>
      <arglist>(char sep)</arglist>
    </member>
    <member kind="typedef">
      <type>ALLELE *</type>
      <name>GenoIterator</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tag</type>
      <name>TagType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>int</type>
      <name>InfoType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Individual</name>
      <anchor>z1_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Individual</name>
      <anchor>z1_1</anchor>
      <arglist>(const Individual&lt; Tag &gt; &amp;ind)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Individual</name>
      <anchor>z1_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGenoPtr</name>
      <anchor>z1_3</anchor>
      <arglist>(ALLELE *pos)</arglist>
    </member>
    <member kind="function">
      <type>Individual &amp;</type>
      <name>operator=</name>
      <anchor>z1_4</anchor>
      <arglist>(const Individual &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Individual &amp;</type>
      <name>copyFrom</name>
      <anchor>z1_5</anchor>
      <arglist>(const Individual &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ALLELE *</type>
      <name>genoPtr</name>
      <anchor>z3_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>ALLELE</type>
      <name>allele</name>
      <anchor>z5_0</anchor>
      <arglist>(int index) const</arglist>
    </member>
    <member kind="function">
      <type>ALLELE</type>
      <name>allele</name>
      <anchor>z5_1</anchor>
      <arglist>(int index, int p) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setAllele</name>
      <anchor>z5_2</anchor>
      <arglist>(int index, ALLELE allele)</arglist>
    </member>
    <member kind="function">
      <type>TagType</type>
      <name>tag</name>
      <anchor>z5_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTag</name>
      <anchor>z5_4</anchor>
      <arglist>(TagType tag)</arglist>
    </member>
    <member kind="function">
      <type>Sex</type>
      <name>sex</name>
      <anchor>z5_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>sexChar</name>
      <anchor>z5_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSex</name>
      <anchor>z5_7</anchor>
      <arglist>(Sex sex)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>affected</name>
      <anchor>z5_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>affectedChar</name>
      <anchor>z5_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setAffected</name>
      <anchor>z5_10</anchor>
      <arglist>(bool affected)</arglist>
    </member>
    <member kind="function">
      <type>InfoType</type>
      <name>info</name>
      <anchor>z5_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInfo</name>
      <anchor>z5_12</anchor>
      <arglist>(InfoType info)</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoBegin</name>
      <anchor>z5_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoEnd</name>
      <anchor>z5_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoBegin</name>
      <anchor>z5_15</anchor>
      <arglist>(int p) const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoEnd</name>
      <anchor>z5_16</anchor>
      <arglist>(int p) const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoBegin</name>
      <anchor>z5_17</anchor>
      <arglist>(int p, int chrom) const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoEnd</name>
      <anchor>z5_18</anchor>
      <arglist>(int p, int chrom) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z7_0</anchor>
      <arglist>(const Individual &amp;rhs) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>z7_1</anchor>
      <arglist>(const Individual &amp;rhs) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>z7_2</anchor>
      <arglist>(Individual &amp;ind, bool swapContent=true)</arglist>
    </member>
    <member kind="typedef" protection="protected">
      <type>unsigned char</type>
      <name>FlagType</name>
      <anchor>x0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>status_flags</name>
      <anchor>x4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_sex</name>
      <anchor>x4x1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_shallowCopied</name>
      <anchor>x4x2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_affected</name>
      <anchor>x4x3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlagType</type>
      <name>flag</name>
      <anchor>b0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setFlag</name>
      <anchor>b1</anchor>
      <arglist>(FlagType flag)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlagType</type>
      <name>setf</name>
      <anchor>b2</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlagType</type>
      <name>unsetf</name>
      <anchor>b3</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>issetf</name>
      <anchor>b4</anchor>
      <arglist>(FlagType val) const</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ALLELE *</type>
      <name>m_genoPtr</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>FlagType</type>
      <name>m_flags</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>TagType</type>
      <name>m_tag</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>InfoType</type>
      <name>m_info</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>char</type>
      <name>s_sep</name>
      <anchor>t0</anchor>
      <arglist>[2]</arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>bool</type>
      <name>s_shallowCopied</name>
      <anchor>t1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::IndividualWithAge</name>
    <filename>a00093.html</filename>
    <templarg>Tag</templarg>
    <base>simuPOP::Individual</base>
    <member kind="function">
      <type>int</type>
      <name>age</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setAge</name>
      <anchor>a1</anchor>
      <arglist>(int age)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IndividualWithAge</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IndividualWithAge</name>
      <anchor>a3</anchor>
      <arglist>(const IndividualWithAge&lt; Tag &gt; &amp;ind)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~IndividualWithAge</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a5</anchor>
      <arglist>(IndividualWithAge &amp;ind, bool swapContent=true)</arglist>
    </member>
    <member kind="function">
      <type>IndividualWithAge &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const IndividualWithAge &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a7</anchor>
      <arglist>(const IndividualWithAge&lt; Tag &gt; &amp;rhs) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_age</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Initializer</name>
    <filename>a00096.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Initializer</name>
      <anchor>a0</anchor>
      <arglist>(string output, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Initializer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::InitByFreq</name>
    <filename>a00095.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Initializer</base>
    <member kind="function">
      <type></type>
      <name>InitByFreq</name>
      <anchor>a0</anchor>
      <arglist>(vectorf freq, int start=1, int end=1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>apply</name>
      <anchor>a1</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorf</type>
      <name>m_freq</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::InitSex</name>
    <filename>a00097.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Initializer</base>
    <member kind="function">
      <type></type>
      <name>InitSex</name>
      <anchor>a0</anchor>
      <arglist>(vectorf malfreq=vectorf(), vectorf femfreq=vectorf(), int start=1, int end=1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>apply</name>
      <anchor>a1</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorf</type>
      <name>m_freq</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Mating</name>
    <filename>a00102.html</filename>
    <templarg>Pop</templarg>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>isCompatible</name>
      <anchor>a0</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Mating</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Mating</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Mating *</type>
      <name>clone</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>name</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>mate</name>
      <anchor>a5</anchor>
      <arglist>(Pop &amp;pop, Pop &amp;scratch, vector&lt; Operator&lt; Pop &gt; * &gt; &amp;ops, int curGen, int endGen, int rep, int group)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::NoMating</name>
    <filename>a00108.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mating</base>
    <member kind="function">
      <type></type>
      <name>NoMating</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~NoMating</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Mating&lt; Pop &gt; *</type>
      <name>clone</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>name</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>mate</name>
      <anchor>a4</anchor>
      <arglist>(Pop &amp;pop, Pop &amp;scratch, vector&lt; Operator&lt; Pop &gt; * &gt; &amp;ops, int curGen, int endGen, int rep, int group)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::BinomialSelection</name>
    <filename>a00084.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mating</base>
    <member kind="function">
      <type></type>
      <name>BinomialSelection</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BinomialSelection</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Mating&lt; Pop &gt; *</type>
      <name>clone</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>name</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>mate</name>
      <anchor>a4</anchor>
      <arglist>(Pop &amp;pop, Pop &amp;scratch, vector&lt; Operator&lt; Pop &gt; * &gt; &amp;ops, int curGen, int endGen, int rep, int group)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::RandomMating</name>
    <filename>a00116.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mating</base>
    <member kind="function">
      <type></type>
      <name>RandomMating</name>
      <anchor>a0</anchor>
      <arglist>(bool ignoreParentsSex=false, bool contWhenUniSex=true, int maxDraw=10)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RandomMating</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>contWhenUniSex</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setContWhenUniSex</name>
      <anchor>a3</anchor>
      <arglist>(bool b)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>ignoreParentsSex</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setIgnoreParentsSex</name>
      <anchor>a5</anchor>
      <arglist>(bool b)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxDraw</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxDraw</name>
      <anchor>a7</anchor>
      <arglist>(int maxDraw)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Mating&lt; Pop &gt; *</type>
      <name>clone</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>isCompatible</name>
      <anchor>a9</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>name</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>mate</name>
      <anchor>a11</anchor>
      <arglist>(Pop &amp;pop, Pop &amp;scratch, vector&lt; Operator&lt; Pop &gt; * &gt; &amp;ops, int curGen, int endGen, int rep, int group)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Pop::IndType *</type>
      <name>findOppositeSex</name>
      <anchor>d0</anchor>
      <arglist>(typename Pop::IndType *partner, Pop &amp;pop, int sp)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_ignoreParentsSex</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_contWhenUniSex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_maxDraw</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; typename Pop::IndType * &gt;</type>
      <name>m_index</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Migrator</name>
    <filename>a00104.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="typedef">
      <type>std::list&lt; MigrantType &gt;</type>
      <name>MigrantList</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Migrator</name>
      <anchor>a0</anchor>
      <arglist>(vectorf rates, int mode=1, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Migrator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>migrate</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="function">
      <type>vectorf</type>
      <name>rates</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRates</name>
      <anchor>a4</anchor>
      <arglist>(vectorf rates, int mode)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a5</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMigrant</name>
      <anchor>b0</anchor>
      <arglist>(int ind, int fromSubPop, int toSubPop)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MigrantList</type>
      <name>m_migrants</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorf</type>
      <name>m_rates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_mode</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorl</type>
      <name>m_subPopID</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Migrator::MigrantType</name>
    <filename>a00105.html</filename>
    <member kind="function">
      <type></type>
      <name>MigrantType</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MigrantType</name>
      <anchor>a1</anchor>
      <arglist>(int ind, int fromSubPop, int toSubPop)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_index</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_fromSubPop</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_toSubPop</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Migrator::MigrantType</name>
    <filename>a00105.html</filename>
    <member kind="function">
      <type></type>
      <name>MigrantType</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MigrantType</name>
      <anchor>a1</anchor>
      <arglist>(int ind, int fromSubPop, int toSubPop)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_index</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_fromSubPop</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_toSubPop</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Mutator</name>
    <filename>a00107.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Mutator</name>
      <anchor>a0</anchor>
      <arglist>(FLOAT rate=0, vectorf rates=vectorf(), vectori applicableLoci=vectori(), int maxAllele=9, string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Mutator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>vectorf</type>
      <name>rate</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRate</name>
      <anchor>a3</anchor>
      <arglist>(FLOAT rate)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRates</name>
      <anchor>a4</anchor>
      <arglist>(vectorf rates)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxAllele</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxAllele</name>
      <anchor>a6</anchor>
      <arglist>(int maxAllele)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>a7</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>mutate</name>
      <anchor>a8</anchor>
      <arglist>(ALLELE *allele)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a9</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vectorf</type>
      <name>m_rates</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>m_maxAllele</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vectori</type>
      <name>m_applicableLoci</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>BernulliTrials *</type>
      <name>m_bt</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_initialized</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::KAMMutator</name>
    <filename>a00101.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mutator</base>
    <member kind="function">
      <type></type>
      <name>KAMMutator</name>
      <anchor>a0</anchor>
      <arglist>(FLOAT rate=0, vectorf rates=vectorf(), vectori applicableLoci=vectori(), int maxAllele=9, string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~KAMMutator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>mutate</name>
      <anchor>a2</anchor>
      <arglist>(ALLELE *allele)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::SSMMutator</name>
    <filename>a00122.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mutator</base>
    <member kind="function">
      <type></type>
      <name>SSMMutator</name>
      <anchor>a0</anchor>
      <arglist>(FLOAT rate=0, vectorf rates=vectorf(), vectori applicableLoci=vectori(), int maxAllele=9, string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SSMMutator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>mutate</name>
      <anchor>a2</anchor>
      <arglist>(ALLELE *allele)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::mixedMutator</name>
    <filename>a00106.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Mutator</base>
    <member kind="function">
      <type></type>
      <name>mixedMutator</name>
      <anchor>a0</anchor>
      <arglist>(FLOAT rate=0, vectorf rates=vectorf(), vectori applicableLoci=vectori(), int maxAllele=9, string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~mixedMutator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>Mutate</name>
      <anchor>a2</anchor>
      <arglist>(ALLELE *allele)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Operator</name>
    <filename>a00110.html</filename>
    <templarg>Pop</templarg>
    <member kind="typedef">
      <type>unsigned int</type>
      <name>FlagType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Pop::IndType</type>
      <name>IndType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>status_flags</name>
      <anchor>w15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_applyPreMating</name>
      <anchor>w15w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_applyDuringMating</name>
      <anchor>w15w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_applyPostMating</name>
      <anchor>w15w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamNoOutput</name>
      <anchor>w15w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamUseDefault</name>
      <anchor>w15w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamAppend</name>
      <anchor>w15w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamCloseAfterUse</name>
      <anchor>w15w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamNoPattern</name>
      <anchor>w15w9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamRealAppend</name>
      <anchor>w15w10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_ostreamReadable</name>
      <anchor>w15w11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_activeAtAllGen</name>
      <anchor>w15w12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_activeOnlyAtBegin</name>
      <anchor>w15w13</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_activeOnlyAtEnd</name>
      <anchor>w15w14</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Operator</name>
      <anchor>z11_0</anchor>
      <arglist>(string output, int start, int end, int every, vectorl at, int replicate, int group)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Operator</name>
      <anchor>z11_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isActive</name>
      <anchor>z13_0</anchor>
      <arglist>(int cur, int end=-1, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>applicableGroup</name>
      <anchor>z13_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setApplicableGroup</name>
      <anchor>z13_2</anchor>
      <arglist>(int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>applicableReplicate</name>
      <anchor>z13_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setApplicableReplicate</name>
      <anchor>z13_4</anchor>
      <arglist>(int rep=-1)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setActiveGenerations</name>
      <anchor>z13_5</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setApplicableStages</name>
      <anchor>z15_0</anchor>
      <arglist>(bool pre=false, bool during=false, bool post=false)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>canApplyPreMating</name>
      <anchor>z15_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>canApplyDuringMating</name>
      <anchor>z15_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>canApplyPostMating</name>
      <anchor>z15_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>canApplyPreOrPostMating</name>
      <anchor>z15_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyWithScratch</name>
      <anchor>z15_5</anchor>
      <arglist>(Pop &amp;pop, Pop &amp;scratch, int stage, int curGen, int endGen, int rep, int group)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>z15_6</anchor>
      <arglist>(Pop &amp;pop, int curGen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyDuringMating</name>
      <anchor>z15_7</anchor>
      <arglist>(Pop &amp;pop, typename Pop::IndIterator offspring, typename Pop::IndType *dad=NULL, typename Pop::IndType *mom=NULL)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>outputFileName</name>
      <anchor>z17_0</anchor>
      <arglist>(int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOutput</name>
      <anchor>z17_1</anchor>
      <arglist>(string output)</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>delimiter</name>
      <anchor>z17_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDelimiter</name>
      <anchor>z17_3</anchor>
      <arglist>(char ch)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>getOstream</name>
      <anchor>z17_4</anchor>
      <arglist>(bool readable, int gen, int rep, int group)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>closeOstream</name>
      <anchor>z17_5</anchor>
      <arglist>(ostream &amp;out)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>outputHeader</name>
      <anchor>z17_6</anchor>
      <arglist>(Pop &amp;pop, int gen, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlagType</type>
      <name>setf</name>
      <anchor>b0</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlagType</type>
      <name>unsetf</name>
      <anchor>b1</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>issetf</name>
      <anchor>b2</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>char *</type>
      <name>parseOutputFileName</name>
      <anchor>b3</anchor>
      <arglist>(int gen, int rep, int group, char *filename)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>analyzeOutputString</name>
      <anchor>b4</anchor>
      <arglist>(string output)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>analyzeActiveGenerations</name>
      <anchor>b5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_beginGen</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_endGen</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_everyGen</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorl</type>
      <name>m_atGen</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>m_output</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char</type>
      <name>m_delimiter</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlagType</type>
      <name>m_flags</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_replicate</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_group</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Outputer</name>
    <filename>a00113.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Outputer</name>
      <anchor>a0</anchor>
      <arglist>(string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Outputer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::OutputHelper</name>
    <filename>a00114.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Outputer</base>
    <member kind="function">
      <type></type>
      <name>OutputHelper</name>
      <anchor>a0</anchor>
      <arglist>(string str=&quot;\n&quot;, string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a1</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>outputHeader</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OutputHelper</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setString</name>
      <anchor>a4</anchor>
      <arglist>(string str)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>outputString</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>unsigned char</type>
      <name>FlagType</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>string_status</name>
      <anchor>y4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_simpleString</name>
      <anchor>y4y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_withBackspace</name>
      <anchor>y4y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_withSubstitution</name>
      <anchor>y4y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>analyzeString</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlagType</type>
      <name>setf</name>
      <anchor>d1</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlagType</type>
      <name>unsetf</name>
      <anchor>d2</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>issetf</name>
      <anchor>d3</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>m_string</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlagType</type>
      <name>m_flags</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Dumper</name>
    <filename>a00086.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Outputer</base>
    <member kind="function">
      <type></type>
      <name>Dumper</name>
      <anchor>a0</anchor>
      <arglist>(bool alleleOnly=false, char sep=&apos;\0&apos;, string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>separator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSeparator</name>
      <anchor>a2</anchor>
      <arglist>(char sep)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>alleleOnly</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setAlleleOnly</name>
      <anchor>a4</anchor>
      <arglist>(bool alleleOnly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a5</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Dumper</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char</type>
      <name>m_sep</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_alleleOnly</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::GappedAlleleIterator</name>
    <filename>a00089.html</filename>
    <member kind="typedef">
      <type>random_access_iterator_tag</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ALLELE</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>int</type>
      <name>difference_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>value_type &amp;</type>
      <name>reference</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>value_type *</type>
      <name>pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GappedAlleleIterator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GappedAlleleIterator</name>
      <anchor>a1</anchor>
      <arglist>(pointer p, difference_type s=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GappedAlleleIterator</name>
      <anchor>a2</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~GappedAlleleIterator</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>difference_type</type>
      <name>step</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setStep</name>
      <anchor>a6</anchor>
      <arglist>(difference_type step)</arglist>
    </member>
    <member kind="function">
      <type>value_type &amp;</type>
      <name>operator *</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>value_type &amp;</type>
      <name>operator[]</name>
      <anchor>a8</anchor>
      <arglist>(difference_type diff) const</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator</type>
      <name>operator++</name>
      <anchor>a9</anchor>
      <arglist>(difference_type)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator &amp;</type>
      <name>operator++</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator</type>
      <name>operator--</name>
      <anchor>a11</anchor>
      <arglist>(difference_type)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator &amp;</type>
      <name>operator--</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator &amp;</type>
      <name>operator+=</name>
      <anchor>a13</anchor>
      <arglist>(difference_type diff)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator &amp;</type>
      <name>operator-=</name>
      <anchor>a14</anchor>
      <arglist>(difference_type diff)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator</type>
      <name>operator+</name>
      <anchor>a15</anchor>
      <arglist>(difference_type diff)</arglist>
    </member>
    <member kind="function">
      <type>GappedAlleleIterator</type>
      <name>operator-</name>
      <anchor>a16</anchor>
      <arglist>(difference_type diff)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a17</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a18</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;=</name>
      <anchor>a19</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;=</name>
      <anchor>a20</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;</name>
      <anchor>a21</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a22</anchor>
      <arglist>(const GappedAlleleIterator &amp;rhs)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>difference_type</type>
      <name>m_step</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pointer</type>
      <name>m_ptr</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::ConstSizePopulation</name>
    <filename>a00085.html</filename>
    <templarg>Ind</templarg>
    <base>simuPOP::GenoStruTrait</base>
    <member kind="typedef">
      <type>Ind</type>
      <name>IndType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; IndType &gt;::iterator</type>
      <name>IndIterator</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GappedAlleleIterator</type>
      <name>AlleleIterator</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ALLELE &gt;::iterator</type>
      <name>SimpleIterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>IndType::GenoIterator</type>
      <name>GenoIterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>IndType::TagType</type>
      <name>TagType</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>IndType::InfoType</type>
      <name>InfoType</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>adjustGenoPosition</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstSizePopulation</name>
      <anchor>z19_0</anchor>
      <arglist>(int size=1, int ploidy=1, vectori loci=vectori(), vectorf lociDist=vectorf(), vectorl subpop=vectorl())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstSizePopulation</name>
      <anchor>z19_1</anchor>
      <arglist>(const ConstSizePopulation &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ConstSizePopulation</name>
      <anchor>z19_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyStructureFrom</name>
      <anchor>z19_3</anchor>
      <arglist>(ConstSizePopulation &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numSubPop</name>
      <anchor>z19_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>subPopSize</name>
      <anchor>z19_5</anchor>
      <arglist>(int subpop)</arglist>
    </member>
    <member kind="function">
      <type>LONG</type>
      <name>popSize</name>
      <anchor>z21_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LONG</type>
      <name>absIndIndex</name>
      <anchor>z21_1</anchor>
      <arglist>(LONG index, int sp)</arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; int, LONG &gt;</type>
      <name>subPopIndPair</name>
      <anchor>z21_2</anchor>
      <arglist>(LONG absInd)</arglist>
    </member>
    <member kind="function">
      <type>LONG</type>
      <name>subPopBegin</name>
      <anchor>z21_3</anchor>
      <arglist>(int subpop)</arglist>
    </member>
    <member kind="function">
      <type>LONG</type>
      <name>subPopEnd</name>
      <anchor>z21_4</anchor>
      <arglist>(int subpop)</arglist>
    </member>
    <member kind="function">
      <type>IndType &amp;</type>
      <name>individual</name>
      <anchor>z23_0</anchor>
      <arglist>(int ind)</arglist>
    </member>
    <member kind="function">
      <type>IndType &amp;</type>
      <name>individual</name>
      <anchor>z23_1</anchor>
      <arglist>(int ind, int subpop)</arglist>
    </member>
    <member kind="function">
      <type>IndIterator</type>
      <name>indBegin</name>
      <anchor>z23_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>IndIterator</type>
      <name>indEnd</name>
      <anchor>z23_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>IndIterator</type>
      <name>indBegin</name>
      <anchor>z23_4</anchor>
      <arglist>(int subpop)</arglist>
    </member>
    <member kind="function">
      <type>IndIterator</type>
      <name>indEnd</name>
      <anchor>z23_5</anchor>
      <arglist>(int subpop)</arglist>
    </member>
    <member kind="function">
      <type>AlleleIterator</type>
      <name>alleleBegin</name>
      <anchor>z23_6</anchor>
      <arglist>(int locus)</arglist>
    </member>
    <member kind="function">
      <type>AlleleIterator</type>
      <name>alleleEnd</name>
      <anchor>z23_7</anchor>
      <arglist>(int locus)</arglist>
    </member>
    <member kind="function">
      <type>AlleleIterator</type>
      <name>alleleBegin</name>
      <anchor>z23_8</anchor>
      <arglist>(int locus, int subpop)</arglist>
    </member>
    <member kind="function">
      <type>AlleleIterator</type>
      <name>alleleEnd</name>
      <anchor>z23_9</anchor>
      <arglist>(int locus, int subpop)</arglist>
    </member>
    <member kind="function">
      <type>SimpleIterator</type>
      <name>begin</name>
      <anchor>z23_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SimpleIterator</type>
      <name>end</name>
      <anchor>z23_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SimpleIterator</type>
      <name>begin</name>
      <anchor>z23_12</anchor>
      <arglist>(int subpop) const</arglist>
    </member>
    <member kind="function">
      <type>SimpleIterator</type>
      <name>end</name>
      <anchor>z23_13</anchor>
      <arglist>(int subpop) const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoBegin</name>
      <anchor>z23_14</anchor>
      <arglist>(LONG ind) const</arglist>
    </member>
    <member kind="function">
      <type>GenoIterator</type>
      <name>genoEnd</name>
      <anchor>z23_15</anchor>
      <arglist>(LONG ind) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSubPopulation</name>
      <anchor>z25_0</anchor>
      <arglist>(vectorl subpopsize)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSubPopByIndInfo</name>
      <anchor>z25_1</anchor>
      <arglist>(int numSubPop=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rearrangeByIndInfo</name>
      <anchor>z25_2</anchor>
      <arglist>(vectori order=vectori())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>z25_3</anchor>
      <arglist>(int id1, int id2, bool swapContent=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isActive</name>
      <anchor>z25_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>activate</name>
      <anchor>z25_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deactivate</name>
      <anchor>z25_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setIndInfoWithSubPopID</name>
      <anchor>z25_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LONG</type>
      <name>m_popSize</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_numSubPop</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorl</type>
      <name>m_subPopSize</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LONG</type>
      <name>m_popGenoSize</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectorl</type>
      <name>m_subPopIndex</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectora</type>
      <name>m_genotype</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; IndType &gt;</type>
      <name>m_inds</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_isActive</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::RNG</name>
    <filename>a00119.html</filename>
    <member kind="function">
      <type></type>
      <name>RNG</name>
      <anchor>a0</anchor>
      <arglist>(char *rng=NULL)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RNG</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRNG</name>
      <anchor>a2</anchor>
      <arglist>(char *p)</arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned long int</type>
      <name>randInt</name>
      <anchor>a4</anchor>
      <arglist>(unsigned long int n)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>randUniform01</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned long int</type>
      <name>randInt</name>
      <anchor>a6</anchor>
      <arglist>(unsigned long int n, FLOAT *freq)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>randBinomial</name>
      <anchor>a7</anchor>
      <arglist>(unsigned int n, double p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>std::vector&lt; std::string &gt;</type>
      <name>listAllRNG</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>gsl_rng *</type>
      <name>m_RNG</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::BernulliTrials</name>
    <filename>a00083.html</filename>
    <member kind="function">
      <type></type>
      <name>BernulliTrials</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BernulliTrials</name>
      <anchor>a1</anchor>
      <arglist>(RNG &amp;rng, size_t n, FLOAT p, bool fast=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BernulliTrials</name>
      <anchor>a2</anchor>
      <arglist>(RNG &amp;rng, size_t n, FLOAT *p=NULL, bool fast=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BernulliTrials</name>
      <anchor>a3</anchor>
      <arglist>(const BernulliTrials &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>BernulliTrials &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const BernulliTrials &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BernulliTrials</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setP</name>
      <anchor>a6</anchor>
      <arglist>(size_t index, FLOAT p)</arglist>
    </member>
    <member kind="function">
      <type>const BitSet &amp;</type>
      <name>trial</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>doCusum</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RNG *</type>
      <name>m_RNG</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned long</type>
      <name>m_n</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FLOAT</type>
      <name>m_p</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FLOAT *</type>
      <name>m_P</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FLOAT *</type>
      <name>m_cumP</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BitSet</type>
      <name>m_bitSet</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_fastAlgorithm</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Recombinator</name>
    <filename>a00118.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Recombinator</name>
      <anchor>a0</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Recombinator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>recombine</name>
      <anchor>b0</anchor>
      <arglist>(int numLoci, FLOAT *rate, ALLELE **par, ALLELE *off)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::NoRecombination</name>
    <filename>a00109.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Recombinator</base>
    <member kind="function">
      <type></type>
      <name>NoRecombination</name>
      <anchor>a0</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~NoRecombination</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyDuringMating</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop, typename Pop::IndIterator offspring, typename Pop::IndType *dad=NULL, typename Pop::IndType *mom=NULL)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::UnifRecombinator</name>
    <filename>a00129.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Recombinator</base>
    <member kind="function">
      <type></type>
      <name>UnifRecombinator</name>
      <anchor>a0</anchor>
      <arglist>(FLOAT rate, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~UnifRecombinator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>FLOAT</type>
      <name>rate</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRate</name>
      <anchor>a3</anchor>
      <arglist>(FLOAT rate)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepareRecRates</name>
      <anchor>a4</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyDuringMating</name>
      <anchor>a5</anchor>
      <arglist>(Pop &amp;pop, typename Pop::IndIterator offspring, typename Pop::IndType *dad=NULL, typename Pop::IndType *mom=NULL)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FLOAT</type>
      <name>m_rate</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BernulliTrials *</type>
      <name>m_bt</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Selector</name>
    <filename>a00120.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Selector</name>
      <anchor>a0</anchor>
      <arglist>(string output=&quot;&gt;&quot;, int start=0, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Selector</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Simulator</name>
    <filename>a00121.html</filename>
    <templarg>Pop</templarg>
    <member kind="typedef">
      <type>Pop</type>
      <name>PopType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PopType::IndType</type>
      <name>IndType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; Operator&lt; Pop &gt; * &gt;</type>
      <name>vectorop</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Simulator</name>
      <anchor>a0</anchor>
      <arglist>(Pop &amp;population, Mating&lt; Pop &gt; &amp;mate, int rep=1, vectori groups=vectori())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Simulator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LONG</type>
      <name>generation</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>replicates</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PopType &amp;</type>
      <name>population</name>
      <anchor>a4</anchor>
      <arglist>(int rep=1)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGeneration</name>
      <anchor>a5</anchor>
      <arglist>(LONG gen)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>step</name>
      <anchor>a6</anchor>
      <arglist>(const vectorop operators, const vectorop preop=std::vector&lt; simuPOP::Operator&lt; Pop &gt; * &gt;(), const vectorop postop=std::vector&lt; simuPOP::Operator&lt; Pop &gt; * &gt;())</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>evolve</name>
      <anchor>a7</anchor>
      <arglist>(const vectorop operators, const vectorop preop=std::vector&lt; simuPOP::Operator&lt; Pop &gt; * &gt;(), const vectorop postop=std::vector&lt; simuPOP::Operator&lt; Pop &gt; * &gt;(), int end=-1, bool showHeader=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>apply</name>
      <anchor>a8</anchor>
      <arglist>(const vectorop operators, bool showHeader=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>stopIfOneRepStop</name>
      <anchor>a9</anchor>
      <arglist>(bool on=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>applyOptToStoppedReps</name>
      <anchor>a10</anchor>
      <arglist>(bool on=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGroups</name>
      <anchor>a11</anchor>
      <arglist>(vectori groups)</arglist>
    </member>
    <member kind="function">
      <type>vectori</type>
      <name>groups</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>unsigned char</type>
      <name>flag_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>simu_value</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_stopIfOneRepStop</name>
      <anchor>y3y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>_applyOptToStoppedReps</name>
      <anchor>y3y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>flag_t</type>
      <name>setf</name>
      <anchor>d0</anchor>
      <arglist>(flag_t val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>flag_t</type>
      <name>unsetf</name>
      <anchor>d1</anchor>
      <arglist>(flag_t val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>issetf</name>
      <anchor>d2</anchor>
      <arglist>(flag_t val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PopType &amp;</type>
      <name>curPop</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PopType &amp;</type>
      <name>scratchPop</name>
      <anchor>d4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>activateScratchPopulation</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_curPop</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LONG</type>
      <name>m_generation</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Mating&lt; Pop &gt; *</type>
      <name>m_matingScheme</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_numRep</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Pop **</type>
      <name>m_ptrRep</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectori</type>
      <name>m_groups</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>flag_t</type>
      <name>m_flags</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Exception</name>
    <filename>a00087.html</filename>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>message</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::string</type>
      <name>msg</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::OutOfMemory</name>
    <filename>a00112.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>OutOfMemory</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::IOError</name>
    <filename>a00098.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>IOError</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::RangeError</name>
    <filename>a00117.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>RangeError</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::TypeError</name>
    <filename>a00128.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>TypeError</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::ValueError</name>
    <filename>a00130.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>ValueError</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::SystemError</name>
    <filename>a00125.html</filename>
    <base>simuPOP::Exception</base>
    <member kind="function">
      <type></type>
      <name>SystemError</name>
      <anchor>a0</anchor>
      <arglist>(string s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Stator</name>
    <filename>a00123.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Stator</name>
      <anchor>a0</anchor>
      <arglist>(string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Stator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::SubPopStat</name>
    <filename>a00124.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Stator</base>
    <member kind="typedef">
      <type>unsigned char</type>
      <name>FlagType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>stat_types</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>statPopSize</name>
      <anchor>w4w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>statNumOfMale</name>
      <anchor>w4w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>statNumOfFemale</name>
      <anchor>w4w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubPopStat</name>
      <anchor>a0</anchor>
      <arglist>(vectori stats=vectori(), vectori subpops=vectori(), string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stats</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setStats</name>
      <anchor>a2</anchor>
      <arglist>(vectori stats)</arglist>
    </member>
    <member kind="function">
      <type>vectori</type>
      <name>subPops</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSubPops</name>
      <anchor>a4</anchor>
      <arglist>(vectori subpops)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a5</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outputHeader</name>
      <anchor>a6</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlagType</type>
      <name>setf</name>
      <anchor>d0</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlagType</type>
      <name>unsetf</name>
      <anchor>d1</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>issetf</name>
      <anchor>d2</anchor>
      <arglist>(FlagType val)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlagType</type>
      <name>m_stats</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectori</type>
      <name>m_subPops</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::AlleleCounter</name>
    <filename>a00082.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Stator</base>
    <member kind="function">
      <type></type>
      <name>AlleleCounter</name>
      <anchor>a0</anchor>
      <arglist>(vectori loci=vectori(), vectora allele=vectora(), bool showPercentage=false, string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a1</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outputHeader</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>findAllAlleles</name>
      <anchor>a3</anchor>
      <arglist>(Pop &amp;pop)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectori</type>
      <name>m_loci</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectora</type>
      <name>m_alleles</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_showPercentage</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::OstreamManager</name>
    <filename>a00111.html</filename>
    <member kind="function">
      <type></type>
      <name>OstreamManager</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~OstreamManager</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream *</type>
      <name>getOstream</name>
      <anchor>a2</anchor>
      <arglist>(char *name, bool readable, bool realAppend)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasOstream</name>
      <anchor>a3</anchor>
      <arglist>(char *filename, bool readable)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>listOstreams</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>closeAll</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; string, ostream * &gt;</type>
      <name>ofstreamMap</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; string, ostream * &gt;::iterator</type>
      <name>ofstreamMapIterator</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; string, ostream * &gt;::value_type</type>
      <name>ofstreamMapValue</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstreamMap</type>
      <name>m_ostreams</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstreamMap</type>
      <name>m_readableOstreams</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Tagger</name>
    <filename>a00126.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Tagger</name>
      <anchor>a0</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Tagger</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::InheritTagger</name>
    <filename>a00094.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Tagger</base>
    <member kind="function">
      <type></type>
      <name>InheritTagger</name>
      <anchor>a0</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InheritTagger</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyDuringMating</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop, typename Pop::IndIterator offspring, typename Pop::IndType *dad=NULL, typename Pop::IndType *mom=NULL)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::ParentsTagger</name>
    <filename>a00115.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Tagger</base>
    <member kind="function">
      <type></type>
      <name>ParentsTagger</name>
      <anchor>a0</anchor>
      <arglist>(int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParentsTagger</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>applyDuringMating</name>
      <anchor>a2</anchor>
      <arglist>(Pop &amp;pop, typename Pop::IndIterator offspring, typename Pop::IndType *dad=NULL, typename Pop::IndType *mom=NULL)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Terminator</name>
    <filename>a00127.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Terminator</name>
      <anchor>a0</anchor>
      <arglist>(string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Terminator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::FixationChecker</name>
    <filename>a00088.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Terminator</base>
    <member kind="function">
      <type></type>
      <name>FixationChecker</name>
      <anchor>a0</anchor>
      <arglist>(vectori loci=vectori(), string output=&quot;&gt;&quot;, int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type>vectori</type>
      <name>loci</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLociToCheck</name>
      <anchor>a2</anchor>
      <arglist>(vectori loci=vectori())</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>a3</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>outputHeader</name>
      <anchor>a4</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FixationChecker</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isFixed</name>
      <anchor>a6</anchor>
      <arglist>(Pop &amp;pop, int locus)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectori</type>
      <name>m_loci</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::isMale</name>
    <filename>a00100.html</filename>
    <templarg>IndType</templarg>
    <member kind="function">
      <type></type>
      <name>isMale</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>(const IndType &amp;ind)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::isFemale</name>
    <filename>a00099.html</filename>
    <templarg>IndType</templarg>
    <member kind="function">
      <type></type>
      <name>isFemale</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>(const IndType &amp;ind)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::Visualizer</name>
    <filename>a00131.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Operator</base>
    <member kind="function">
      <type></type>
      <name>Visualizer</name>
      <anchor>a0</anchor>
      <arglist>(string input, bool hasHeader=true, int numFields=-1, vector&lt; string &gt; headers=vector&lt; string &gt;(), int genColumn=-1, vectori columns=vectori(), int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Visualizer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>readData</name>
      <anchor>a2</anchor>
      <arglist>(LONG gen, int rep, int group)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>headers</name>
      <anchor>a3</anchor>
      <arglist>(int field)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHeaders</name>
      <anchor>a4</anchor>
      <arglist>(vector&lt; string &gt; headers)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>genColumn</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>vectori</type>
      <name>columns</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>data</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numFields</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; string &gt;</type>
      <name>m_headers</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>m_numFields</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::vector&lt; double &gt;</type>
      <name>m_data</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::ios::off_type</type>
      <name>m_pos</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_firstLine</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_realNumFields</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_hasHeader</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_genColumn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vectori</type>
      <name>m_columns</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_curField</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>m_tmpData</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>simuPOP::MatlabPlotter</name>
    <filename>a00103.html</filename>
    <templarg>Pop</templarg>
    <base>simuPOP::Visualizer</base>
    <member kind="function">
      <type></type>
      <name>MatlabPlotter</name>
      <anchor>z27_0</anchor>
      <arglist>(string input, int windowSize=50, int colGroups=1, char *startCmd=NULL, bool hasHeader=true, int numFields=-1, vector&lt; string &gt; headers=vector&lt; string &gt;(), int genColumn=-1, vectori columns=vectori(), int start=1, int end=-1, int every=1, vectorl at=vectorl(), int rep=-1, int group=-1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MatlabPlotter</name>
      <anchor>z27_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>startEngine</name>
      <anchor>z29_0</anchor>
      <arglist>(char *startCmd)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>closeEngine</name>
      <anchor>z29_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>windowSize</name>
      <anchor>z30_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setWindowSize</name>
      <anchor>z30_1</anchor>
      <arglist>(int windowSize)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putDataInMatlab</name>
      <anchor>z30_2</anchor>
      <arglist>(LONG gen)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putHeader</name>
      <anchor>z30_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evalString</name>
      <anchor>z30_4</anchor>
      <arglist>(const string &amp;cmd)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>displayPlot</name>
      <anchor>z30_5</anchor>
      <arglist>(int windowSize=-1, int genColumn=1, bool firstColumnAsGen=false)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; string &gt;</type>
      <name>postPlotCmd</name>
      <anchor>z30_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clearPostPlotCmd</name>
      <anchor>z30_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPostPlotCmd</name>
      <anchor>z30_8</anchor>
      <arglist>(string cmd)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>apply</name>
      <anchor>z30_9</anchor>
      <arglist>(Pop &amp;pop, int gen=0, int rep=0, int group=0)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_ID</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_win</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>m_colGroups</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>m_putHeader</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>m_postPlotCmd</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>Engine *</type>
      <name>s_matlabEng</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>int</type>
      <name>s_engRefCount</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
</tagfile>
