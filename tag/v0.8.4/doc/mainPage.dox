/** 
\mainpage

\author Bo Peng (bpeng@rice.edu)
\date started June 2004

\section TOC Table of Contents
  - \ref news
  - \ref introduction 
    - \ref EasyPOP 
    - \ref goals
    - \ref features
  - \ref design
  -  \ref test 
    - \ref test_1 
    - \ref test_2 
    - \ref test_3 
    - \ref test_4 
    - \ref test_5 
    - \ref test_6 
    - \ref test_7 
    - \ref test_8 
    - \ref test_9 
    - \ref test_10 
    - \ref test_11 
    - \ref test_12 
    - \ref test_13 
    - \ref test_14 
    - \ref test_15 
    - \ref test_16
  - \ref examples
    - \ref example_1
    - \ref example_2
    - \ref example_3
    - \ref example_4

\section news Recent simuPOP news

\ref changelog

\htmlinclude NEWS


\section introduction Why simuPOP?

We are in need of a population genetics simulation program to simulate complex
diseases under the influences of mutation, recombination and migration (to form
certain population structure). 

Most of the currently available programs are coalescence based (ref... ??.
simuCOAL (link?), treevolve (http://www.cecalc.ula.ve/BIOINFO/servicios/herr2/TREEVOLVE/manual.html) ). It is widely recognized that coalescence approach, while quick, can
not simulate many genetic effects. On the contrary, forward based simulations
can in theory simulate all genetic models.

The reason why forward based simulation is not popular is that realistic forward
based simulation will need huge amount of memory and CPU time and can not
guarantee expected result. For example, to simulate rare diseases, we need 
to simulate a huge population which is usually beyond the ability of personal 
computers. Even we have a powerful computer, if we are going to track the 
spread of a
disease allele, the allele might get lost during simulation and will never show
up in the final population. 

However, the power of personal computer is increasing exponentially which makes
forward-based simulation a lot more feasible than that of several years ago.

\subsection EasyPOP EasyPOP by Dr. Balloux

There are already some (?) forward based simulation programs. One of the best 
ones is EasyPOP http://www2.unil.ch/izea/softwares/easypop.html by Dr. Balloux (ref....). It can simulate many models and can
perform quite large simulation. However, the design and user-interface of easyPOP is 
not flexible enough to accommodate complex simulations because of
the following reasons:

  - Expandability: easyPOP employees an all-in-one-piece design. This
makes debugging and adding of new features extremely difficult. 
Currently, adding one feature, say one migration model, needs 
modification in many places and tends to
introduce bugs.

  - User-friendliness and flexibility: easyPOP uses command line input (answer
lots of questions). This is painful for both users and developers. The
re-designed program can make use of a scripting language to specify lots of info
easily.


\subsection goals Design Goals of simuPOP

The design of simuPOP tries to borrow strength from object oriented programming
and user-friendliness of scripting languages. Specifically, simuPOP tries to reach
the following goals:

  - Modularity: The objects will be separated into population (with genotypic
data, population structure etc) and operators (migrator, mutator etc ) that work
on the population. Maximum separation of data and method, population and action
will be achieve.

  - Expandability: Using OOP methods, it should be easy to extend the system 
with minimal efforts. User
will be allowed to add new modules (e.g. reporter, new migration model) easily,
using either C++ or python. 

  - User-friendly: User will control the program through Python (other scripting
languages are under consideration). Users can run the following script 
interactively or as a batch file. The advantage of this approach is that
users can make use of everything Python provides. (please refer to test 
cases for examples.)

  - minimal-footprint and maximum performance: the program will be in nature very
demanding in RAM and CPU power. Various techniques will be applied to reduce
memory usage and parallelization methods will be applied to make use of modern
CPUs.


The core of simuPOP will be some classes written in C++, manipulated by
python (http://www.python.org) through C++/Python wrapper SWIG (http://www.swig.org ). 
class Population will
encapsulate genotypic and structural information of a population and 
class Operator and its subclasses will encapsulate all kinds of operations that can be
applied to Population objects. These operations will include real actions like
mutation, migration etc and info-getting actions like statistics calculator,
allele tracer and outputer.

These objects will be created and manipulated through high level scripting
language. Currently, python is used for this purpose because of its easy and
elegant grammar, easy integration with C++ and wide availability. Other
possibilities include tcl/tk, perl, R, even matlab.

For more information about techniques involved, see \ref ref_tech .

\subsection features Intended feature list

  - scripting language user-interface gives maximum control to the 
    behavior of simulation.
  - Populations will have genotypic data and provide methods to access them. 
    While having a uniform interface, internal data structure can 
    be implemented in a variety of ways according to the complexity
    of the population. More specifically, class Population will contain
    - storage and access methods to genotypic data.
    - maintain and change sub-population structure
    - provide basic utility functions 
  - Users can run several replicates of simulation simultaneously.
  - Anything that will change (or not change) population will be abstracted as an Operator.
    They will be provided as plug-ins and used as such. They should be
    easily extended as well. Opeartors can be applied pre, during and post-mating. Or, it
    can be applied any time to the current population. Many things can be implemented 
    in this frame work.
    - Initializer: (pre-mating Operator at generation 0) initialize allele
    - Migrator: (pre or post-mating Operator) many migration schemes
    - Mutator: (during-mating Operator) Many mutation models can be
      implemented
    - Recombinator: (during mating Operator) ...
    - Selector: (during mating Operator) work with Mating schemes to
      perform selection.
    - Stator: (pre or post mating Operator) statistics calculator that
      output statistics to file(s) 
    - Terminator: (post mating Operator) check certain conditions of a 
      population and return false to terminate evolution. For example,
      check fixation of an allele, in linkage disequilibrium or disappear of disease.
    - visualizer: read data/statistics (dynamically) and visualize them.
    - outputer: (post-mating Operator at generation -1 but can happen many
      times or it can happen any time to current generation) allow output in many 
      different formats.
  - different matings scheme can be implemented. Mating can change the 
    size of population.

\section design system design

The interface has not beed fixed so please refer to class 
document for a snapshot of them.

Briefly:

- class simuPOP::Simulator is the wrapper (template) class for actual populations
  (class simuPOP::ConstSizePopulation and its subclasses ). Internally, it maintains several
  replicates of populations including the "scratch population" and do the
  manage the evolution of populations.   This class provide interface to Operators.
- class simuPOP::Population : base class for all real populations.
  - class simuPOP::WFPopulation : subclass of Population. Wright Fisher population: no sex, single chromosome, 
   single locus, binomial mating.
- class WFPopSimulator = simulator<WFPopulation> runs the simulation.
  there will be other Simulators corresponding to different Populations.
- class simuPOP::Operator : base class for all Operators. 
  - class simuPOP::Initializer : subclass of Operator. Initialize alleles
  - class simuPOP::Outputer : subclass of Operator. Output.


Please refer to \ref ref_ploidy the implication of different ploidy types.


\section test Test programs (feature demonstration)

The following test cases demonstrate all the features of simuPOP.

\subsection test_1 population.py
  \includelineno population.py

\subsection test_2 individual.py 
  \includelineno individual.py 


\subsection test_3  operator1.py
  \includelineno   operator1.py


\subsection test_4  operator2.py
  \includelineno  operator2.py

   
\subsection test_5      operator3.py 
  \includelineno  operator3.py 
 
\subsection test_6   migration.py 
  \includelineno  migration.py 


\subsection test_7    mutation.py  
  \includelineno  mutation.py  

\subsection test_8  recombination.py 
  \includelineno  recombination.py 

\subsection test_9  visualization.py
  \includelineno  visualization.py


\subsection test_10 gendrift.py 
  \includelineno gendrift.py 


\subsection test_11 complex1.py 
  \includelineno  complex1.py 

 
\subsection test_12 complex2.py 
  \includelineno complex2.py 

\subsection test_13   tagging.py
  \includelineno  tagging.py


\subsection test_14    rng.py
  \includelineno  rng.py

\subsection test_15    expression.py  
  \includelineno   expression.py  

\subsection test_16    misc.py  
  \includelineno   misc.py  

\section examples real simulations!
\subsection example_1 drift.py
  \includelineno  drift.py

\subsection example_2 LD.py Linkage disequilibrium
  \includelineno LD.py

\subsection example_3 migration.py various migration models
  \includelineno migration.py

\subsection example_4 selection.py various selection models
  \includelineno selection.py

*/

