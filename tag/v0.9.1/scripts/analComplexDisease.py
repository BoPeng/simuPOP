#!/usr/bin/env python
#
# Purpose: Analyze population generated by simuComplexDisease.py
#
# Bo Peng (bpeng@rice.edu)
#
# $LastChangedDate: 2005-10-31 17:29:34 -0600 (Mon, 31 Oct 2005) $
# $Rev: 78 $
#
# Known bugs:
#     None
# 

"""
This program analyzes a population generated by simuComplexDisease.py. 
It basically provide a user interface to relevant functions in 
simuUtil.py.

The program is written in Python using simuPOP modules. For more information,
please visit simuPOP website http://simupop.sourceforge.net .
"""

import simuOpt, simuUtil
import os, sys, types, exceptions, os.path, operator, time
#
# declare all options. getParam will use these information to get parameters
# from a tk/wxPython-based dialog, command line, config file or user input
#
# detailed information about these fields is given in the simuPOP reference
# manual.
options = [
    {'arg': 'h',
     'longarg': 'help',
     'useDefault': True,
     'default': False, 
     'description': 'Print this usage message.',
     'allowedTypes': [types.NoneType, type(True)],
     'jump': -1                    # if -h is specified, ignore any other parameters.
    },
    {'longarg': 'markerType=',
     'default': 'SNP',
     'allowedTypes': [types.StringType],
     'label': 'Marker type used',
     'description': '''Marker type used to generated the sample. This is
        important since the file formats are not compatible between 
        binary and standard simuPOP modules''',
     'validate':    simuOpt.valueOneOf([ 'microsatellite', 'SNP']),
     'chooseOneOf': ['microsatellite', 'SNP']
    }, 
    {'longarg': 'dataset=',
     'default': 'simu.txt',
     'allowedTypes': [types.StringType],
     'label': 'Dataset to analyze',
     'description': 'Dataset generated by simuComplexDisease.py. ',
     'validate':    simuOpt.valueValidFile()
    },
    {'longarg': 'peneFunc=',
     'default': 'additive',
     'label': 'Penetrance function',
     'allowedTypes': [types.StringType],
     'description': ''' Penetrance functions to be applied to the final
        population. Two penetrance fucntions are provided, namely recessive
        or additive single-locus model with heterogeneity multi-locus model. 
        You can define another customized penetrance functions by modifying
        this script. ''',
     'validate':    simuOpt.valueOneOf(['recessive', 'additive', 'custom', 'None']),
     'chooseOneOf': [ 'recessive', 'additive', 'custom']
    },
    {'longarg': 'qtraitFunc=',
     'default': 'None',
     'label': 'Quantitative trait model',
     'allowedTypes': [types.StringType],
     'description': '''How to calculate quantitative trait. There is no default
        function so one has to provide a customized one.
        ''',
     'validate':    simuOpt.valueOneOf(['custom', 'None']),
     'chooseOneOf': [ 'custom', 'None']
    },
    {'longarg': 'parameter=',
     'default': [0.5],
     'label': 'Penetrance parameters',
     'description': '''Penetrance parameter for all DSL. An array of parameter 
        can be given to each DSL. The meaning of this parameter differ by 
        penetrance model. For a recessive model, the penetrance is 0,0,p for 
        genotype AA,Aa,aa (a is disease allele) respectively. For an additive 
        model, the penetrance is 0,p/2,p respectively.''',
     'allowedTypes': [types.ListType, types.TupleType],
     'validate':   simuOpt.valueOneOf([ 
             simuOpt.valueBetween(0,1), simuOpt.valueListOf(simuOpt.valueBetween(0,1))] )
    },
    {'longarg': 'sampleSize=',
     'default': 800,
     'label':    'Sample size',
     'allowedTypes':    [types.IntType, types.LongType],
     'description':    '''Size of the samples, that will mean N/4 affected 
        sibpair families (of size 4), N/2 cases and controls. Up to N total number
        of individuals for large pedigrees.''',
     'validate':    simuOpt.valueGT(1)
    },
    {'longarg': 'outputDir=',
     'default': '.',
     'allowedTypes': [types.StringType],
     'label': 'Output directory',
     'description': 'Directory into which the datasets will be saved. ',
     'validate':    simuOpt.valueValidDir()
    },
    {'longarg': 'analyses=',
     'default': [],
     'label': 'Gene mapping methods',
     'allowedTypes': [types.TupleType, types.ListType],
     'description': ''' Gene mapping methods to apply. geneHunter is needed for
        TDT and Linkage methods, and R/RPy are needed for chisq association 
        tests.''',
     'allowedTypes': [types.ListType, types.TupleType],
     'chooseFrom': [ 
        'affectedSibs_GH_TDT', 
        'affectedSibs_GH_linkage', 
        'affectedSibs_merlin_linkage', 
        'caseControl_Association', 
        'qtraitSibs_merlin_reg',
        'qtraitSibs_merlin_vc',
        'largePeds_merlin_reg', 
        'largePeds_merlin_vc',
        ]
    },
    # another two hidden parameter
    {'longarg': 'saveConfig=',
     'default': 'anal.cfg',
     'allowedTypes': [types.StringType, types.NoneType],
     'label': 'Save configuration',
     'description': 'Save current paremeter set to specified file.'
    },
    {'arg': 'v',
     'longarg': 'verbose',
     'useDefault': True,
     'default': False,
     'allowedTypes': [types.NoneType, types.IntType],
     'description': 'Verbose mode.'
    },
]

outputVars = {
    # basic information
    'dataset': 'name of the datafile',
    'logfile': 'Name of the log file generated by simuComplexDisease.py',
    'DSL': 'Location of DSL in the populations. Use them for the whole population',
    'DSLafter': 'Paramter you give to simuComplexDisease.py. They are the one you should use for the samples',
    # evolution related parameters
    'numSubPop': 'Number of subpopulation',
    'recRate': 'recombination rate',
    'initSize': 'Size of initial founder population',
    'endingSize': 'Population size of the last generation',
    'burninGen': 'Length of burnin stage',
    'splitGen': 'Generation at which population is split to subpopulations',
    'mixingGen': 'Generation at which migration is allowed',
    'endingGen': 'total evolution length',
    'migrModel': 'migration model',
    'migrRate': 'migration rate',
    'mutaModel': 'mutation model',
    'mutaRate': 'mutation rate',
    # population statistics
    'Fst': 'F_st: measure of population differentiation',
    'Fis': 'F_is',
    'Fit': 'F_it',
    'AvgFst': 'Average of F_st estimated from all loci',
    'AvgFis': 'Average of F_is estimated from all loci',
    'AvgFit': 'Average of F_it estimated from all loci',
    'AvgHetero': 'Averge heterozygosity',
    'Fprime': '',
    'K': 'Disease prevalence (penetrance dependent)',
    'Ks': 'Sibling recurrence risk',
    'Ls': 'Sibling recurrence risk ratio', 
    'P11': 'Pr( (N,N) | affected ): proportion of NN (normal) genotype among affected individuals',
    'P12': 'Pr( (N,S) | affected ): proportion of NS (normal, susceptible) or SN genotype among affected individuals',
    'P22': 'Pr( (S,S) | affected ): proportion of SS (susceptible) genotype among affected individuals',
    'LD': 'Linkage disequilibrium between DSL and its surrounding markers',
    'LD_prime': "D' measure of Linkage disequilibrium",
    'R2': 'R^2 measure of Linkage disequilibrium',
    'alleleFreq': 'allele frequency of DSL',    
    'mono': 'Number of fixed or lost loci on the last chromosome',
    # result of gene mapping methods
    'affectedSibs_GH_TDT' : '', 
    'affectedSibs_GH_linkage' : '', 
    'affectedSibs_merlin_linkage' : '', 
    'caseControl_Association' : '', 
    'qtraitSibs_merlin_reg' : '',
    'qtraitSibs_merlin_vc' : '',
    'largePeds_merlin_reg' : '', 
    'largePeds_merlin_vc' : '',
}

# penetrance generator functions. They will return a penetrance function
# with given penetrance parameter
def recessive(para):
    ''' recessive single-locus, heterogeneity multi-locus '''
    def func(geno):
        val = 1
        for i in range(len(geno)/2):
            if geno[i*2] + geno[i*2+1] == 2:
                val *= 1 - para[i]
        return 1-val
    return func
    

def additive(para):
    ''' additive single-locus, heterogeneity multi-locus '''
    def func(geno):
        val = 1
        for i in range(len(geno)/2):
            val *= 1 - (geno[i*2]+geno[i*2+1])*para[i]/2.
        return 1-val
    return func


# if you need some specialized penetrance function, modify this
# function here.
# NOTE:
# 
# 1. geno is the genptype at DSL. For example, if your DSL is [5,10]
#     geno will be something like [0,1,1,1] where 0,1 is the genotype at 
#     locus 5 and 1,1 is the genotype at locus 10.
# 2. in simuComplexDisease.py, 0 is wild type, 1 is disease allele.
def custom(para):
    ''' quantitative trait '''
    def func(geno):
        return 1
    return func


# this customized qtrait function provide quantitative trait
# for example2 in the plos paper.
# The basic form is
#
# Q = X1 + X2 + X3 + Env
# 
def customQtrait(para):
    ''' quantitative trait '''
    def func(geno):
        x = random.normalvariate(0, 0.5)
        for i in range(len(geno)/2):
            x += random.normalvariate(geno[2*i]+geno[2*i+1], 0.5)
        return x
    return func


def getOptions(details=__doc__):
    ''' get options from options structure,
        if this module is imported, instead of ran directly,
        user can specify parameter in some other way.
    '''
    # get all parameters, __doc__ is used for help info
    allParam = simuOpt.getParam(options, 
        '''    This program simulates the evolution of a complex common disease, subject 
     to the impact of mutation, migration, recombination and population size change. 
     Click 'help' for more information about the evolutionary scenario.''', details, nCol=1)
    # when user click cancel ...
    if len(allParam) == 0:
        sys.exit(1)
    # -h or --help
    if allParam[0]:    
        print simuOpt.usage(options, __doc__)
        sys.exit(0)
    # --saveConfig
    simuOpt.saveConfig(options, allParam[-2], allParam)
    # --verbose or -v (these is no beautifying of [floats]
    if allParam[-1]:                 # verbose
        simuOpt.printConfig(options, allParam)
    # return the rest of the parameters
    return allParam[1:-2]

def popStat(pop):
    'Calculate population statistics '
    # K -- populaiton prevalance
    print "Calculating population statistics "
    Stat(pop, numOfAffected=True, alleleFreq=range(pop.totNumLoci()))
    result = {}
    result['K'] = pop.dvars().numOfAffected * 1.0 / pop.popSize()
    # P11 = [ ] = proportion of 11 | affected, 
    # P12 = [ ] = proportion of 12 | affected
    DSL = pop.dvars().DSL
    P11 = [0.]*len(DSL)
    P12 = [0.]*len(DSL)
    P22 = [0.]*len(DSL)
    for ind in range(pop.popSize()):
        if pop.individual(ind).affected():
            for x in range(len(DSL)):
                s1 = pop.individual(ind).allele(DSL[x], 0)
                s2 = pop.individual(ind).allele(DSL[x], 1)
                if s1 == 0 and s2 == 0:
                    P11[x] += 1
                elif s1 == 1 and s2 == 1:
                    P22[x] += 1
                else:
                    P12[x] += 1
    # calculate the number of fixed/lost loci
    result['mono'] = 0
    for x in range(pop.chromBegin(pop.numChrom()-1), pop.chromEnd(pop.numChrom()-1)):
        #print  pop.dvars().alleleNum[x][0]
        if pop.dvars().alleleNum[x][0] == 0 or pop.dvars().alleleNum[x][0] == pop.popSize() * pop.ploidy():
            result['mono'] += 1
    N = pop.dvars().numOfAffected
    # some analysis does not have affected, or all affected
    if N == 0 or N == pop.popSize():
        return result
    result['P11'] = [ x/N for x in P11 ]
    result['P12'] = [ x/N for x in P12 ]
    result['P22'] = [ x/N for x in P22 ]
    result['Fprime'] = [ (P12[x]/2. + P22[x])/N for x in range(len(DSL)) ]
    # Ks = Pr(Xs=1 | Xp=1 ) = Pr(Xs=1, Xp=1) | P(Xp=1)
    Xsp = 0.
    for ind in range(pop.popSize()/2):
        s1 = pop.individual(ind*2).affected()
        s2 = pop.individual(ind*2+1).affected()
        if s1 and s2:
            Xsp += 1
    result['Ks'] = 2*Xsp / pop.dvars().numOfAffected
    # Lambda = Ks/K
    result['Ls'] = result['Ks'] / result['K']
    return result


def TDT_gh(file, gh='gh'):
    '''
    Analyze data using genehunter/TDT. Note that this function may not work under
    platforms other than linux, and may not work with your version of genehunter.
    As a matter of fact, it is almost unrelated to simuPOP and is provided only
    as an example how to use python to analyze data.

    Parameters
        file
            file to analyze. This function will look for file.dat and file.pre
            in linkage format.
        loci
            a list of loci at which p-value will be returned. If the list is empty,
            all p-values are returned.
        gh
            name (or full path) of genehunter executable. Default to 'gh'

    Return value
        A list (for each chromosome) of list (for each locus) of p-values.

    '''
    if not os.path.isfile(file + '.dat') or not os.path.isfile(file + '.pre'):
        print 'Data (%s.dat) or pedigree (%s.pre) file does not exist' % (file, file)
        sys.exit(2)
    # open the pipe for gh
    fin, fout = os.popen2(gh)
    cmds = '''load markers %s.dat
tdt %s.pre
q
''' % (file, file)
    print "Running GENEHUNTER with commands:"
    print cmds
    # write to fin
    print >> fin, cmds
    fin.close()
    # read output
    # get only loc number and p-value
    scan = re.compile('loc(\d+)\s+- Allele \d+\s+\d+\s+\d+\s+[\d.]+\s+([\d.]+|nan)\s*.*')
    head = re.compile('Marker loc(\d+).*')
    minPvalue = {}
    maxLoc = 0
    for l in fout.readlines():
        try:
            (loc,) = head.match(l).groups()
            maxLoc = max(int(loc), maxLoc)
        except:
            pass
        try:
            # get minimal p-value for all alleles at each locus
            # this is meaningless for binary alleles, and other method should be used
            # for multi-allele loci.
            # GH output: (for 20 markers)
            # marker loc1  <- locus 0
            # ...
            # marker loc19 <- locus 18
            #
            (loc, pvalue) = scan.match(l).groups()
            idx = int(loc) - 1
            if pvalue == 'nan':
                pvalue = -1
            else:
                pvalue = float(pvalue)
            if not minPvalue.has_key(idx):
                minPvalue[idx] = pvalue
            elif minPvalue[idx] > pvalue:
                minPvalue[idx] = pvalue
        except:
            # does not match
            continue
    fout.close()
    # sort by pos,...
    return [minPvalue.setdefault(x, -1) for x in range(maxLoc)]


def LOD_gh(file, gh='gh'):
    '''
    Analyze data using the linkage method of genehunter. Note that this function may not
    work under platforms other than linux, and may not work with your version of
    genehunter. As a matter of fact, it is almost unrelated to simuPOP and is provided
    only as an example how to use python to analyze data.

    Parameters
        file
            file to analyze. This function will look for file.dat and file.pre
            in linkage format.
        loci
            a list of loci at which p-value will be returned. If the list is empty,
            all p-values are returned.
        gh
            name (or full path) of genehunter executable. Default to 'gh'

    Return value
        A list (for each chromosome) of list (for each locus) of p-values.

    '''
    if not os.path.isfile(file + '.dat') or not os.path.isfile(file + '.pre'):
        print 'Data (%s.dat) or pedigree (%s.pre) file does not exist' % (file, file)
        sys.exit(2)
    # open the pipe for gh
    fin, fout = os.popen2(gh)
    # write to fin
    cmds = '''load markers %s.dat
single point on
scan pedigrees %s.pre
photo tmp.txt
total stat
q
''' % (file, file)
    print "Running GENEHUNTER with commands:"
    print cmds
    print >> fin, cmds
    fin.close()
    # read output
    # get only loc number and p-value
    scan = re.compile('loc(\d+)\s+[^\s]+\s+[^\s]+\s+([^\s]+)\s*.*')
    minPvalue = {}
    start = 0
    for l in fout.readlines():
        if "Totalling pedigrees:" in l:
            start = 1
        if not start:
            continue
        try:
            # get minimal p-value for all alleles at each locus
            (loc, pvalue) = scan.match(l).groups()
            #print loc, pvalue
            minPvalue[int(loc)-1] = float(pvalue)
        except:
            # does not match
            continue
    fout.close()
    # dict to list
    return [minPvalue.setdefault(x, -1) for x in range(len(minPvalue))]



def ChiSq_test(pop):
    '''perform case control test

    pop
        loaded population, or population file in simuPOP format.
        This function assumes that pop has two
        subpopulations, cases and controls, and have 0 as wildtype and 1 as
        disease allele. pop can also be an loaded population object.

    Return value
        A list of p-value at each locus.

    Note: this function requires rpy module.

'''
    # I can not load rpy with simuUtil.py, so here it is
    try:
        import rpy
    except:
        print "RPy module can not be loaded, association test can not be performed"
        sys.exit(1)
    if type(pop) == type(''):
        pop = LoadPopulation(pop)
    # at each locus
    pvalues = []
    Stat(pop, alleleFreq=range(pop.totNumLoci()))
    for loc in range(pop.totNumLoci()):
        # allele frequency
        caseNum = pop.dvars(0).alleleNum[loc]
        if len(caseNum) == 1:
            caseNum.append(0)
        elif len(caseNum) > 2:
            raise 'ChiSq: non-SNP markers are not supported.'
        contNum = pop.dvars(1).alleleNum[loc]
        if len(contNum) == 1:
            contNum.append(0)
        elif len(contNum) > 2:
            raise 'ChiSq: non-SNP markers are not supported.'
        pvalues.append(rpy.r.chisq_test(rpy.with_mode(rpy.NO_CONVERSION,
            rpy.r.matrix)( caseNum+contNum, ncol=2))['p.value'])
    return pvalues


def LOD_merlin(file, merlin='merlin'):
    '''run multi-point non-parametric linkage analysis using merlin
    '''
    cmd = 'merlin -d %s.dat -p %s.ped -m %s.map --npl' % (file, file, file)
    resline = re.compile('\s+[\d.+-]+\s+[\d.+-]+\s+[\d.+-]+\s+[\d.+-]+\s+[\d.+-]+\s+([\d.+-]+)')
    print "Running:"
    print cmd
    fout = os.popen(cmd)
    pvalues = []
    for line in fout.readlines():
        try:
            (pvalue,) = resline.match(line).groups()
            try:
                pvalues.append(float(pvalue))
            except:
                pvalues.append(-1)
        except:
            pass
    fout.close()
    return pvalues


def VC_merlin(file, merlin='merlin'):
    '''run variance component method

    file
        file.ped, file.dat, file.map and file,mdl are expected.
        file can contain directory name.

    '''
    cmd = 'merlin -d %s.dat -p %s.ped -m %s.map  --vc' % (file, file, file)
    resline = re.compile('\s+([\d.+-]+|na)\s+([\d.+-]+|na)%\s+([\d.+-]+|na)\s+([\d.+-]+|na)\s+([\d.+-]+|na)')
    print "Running"
    print cmd
    fout = os.popen(cmd)
    pvalues = []
    for line in fout.readlines():
        try:
            # currently we only record pvalue
            (pos, h2, chisq, lod, pvalue) = resline.match(line).groups()
            try:
                pvalues.append(float(pvalue))
            except:
                # na?
                pvalues.append(-1)
        except AttributeError:
            pass
    fout.close()
    return pvalues


def Regression_merlin(file, merlin='merlin-regress'):
    '''run merlin regression method'''
    # get information
    cmd = '%s -d %s.dat -p %s.ped -m %s.map' % (merlin, file, file, file)
    print "Running"
    print cmd
    fout = os.popen(cmd)
    #
    pvalues = []
    resline = re.compile('\s+([\d.+-]+|na)\s+([\d.+-]+|na)\s+([\d.+-]+|na)\s+([\d.+-]+|na)%\s+([\d.+-]+|na)\s+([\d.+-]+|na)')
    for line in fout.readlines():
        try:
            (pos, h2, stdev, info, lod, pvalue) = resline.match(line).groups()
            try:
                pvalues.append(float(pvalue))
            except:
                # na?
                pvalues.append(-1)
        except AttributeError:
            pass
    fout.close()
    return pvalues


def Sibpair_TDT_gh(pop, sampleSize, penetrance=None, recRate=None, daf=None, gh='gh', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles
        
    pene
        penetrance function, if not given (None), existing affection
        status will be used.

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    recRate
        recombination rate, used in the Linkage file. If not given,
        pop.dvars().recRate[0] will be used. If there is no such variable,
        0.0001 is used.

    daf
        disease allele frequency. This is needed for the linkage format
        but I am not sure if it is used by TDT.

    gh
        executable name of genehunter, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # apply penetrance
    if penetrance is not None:
        PyPenetrance(pop, loci=pop.dvars().DSL, func=penetrance)
    # draw affected sibpair sample
    print "Generating affected sibpair sample..."
    (sample,) = AffectedSibpairSample(pop, size=sampleSize/4, times=1)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    try:
        if recRate is not None:
            r = recRate
        else:
            r = pop.dvars().recRate[0]
    except:
        r = 0.0005
    if daf is not None:
        d = daf
    else:
        d = 0.1
    # save in Linkage format and apply TDT
    pvalues = []
    for ch in range(0, pop.numChrom() ):
        SaveLinkage(pop=sample, output = os.path.join(dir, "Aff_%d" % (ch+1)),
            recombination=r, loci = range(sample.chromBegin(ch), sample.chromEnd(ch)),
            daf=0.1)
        # process by TDT
        pvalues.extend(TDT_gh(os.path.join(dir, "Aff_%d" % (ch+1)), gh=gh))
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    # remove temporary directory
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def Sibpair_LOD_gh(pop, sampleSize, penetrance=None, recRate=None, daf=None, gh='gh', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run Linkage analysis using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    pene
        penetrance function, if not given (None), existing affection
        status will be used.

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    recRate
        recombination rate, used in the Linkage file. If not given,
        pop.dvars().recRate[0] will be used. If there is no such variable,
        0.0001 is used.

    daf
        disease allele frequency. This is needed for the linkage format
        but I am not sure if it is used by TDT.

    gh
        executable name of genehunter, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # apply penetrance
    if penetrance is not None:
        PyPenetrance(pop, loci=pop.dvars().DSL, func=penetrance)
    # draw affected sibpair sample
    print "Generating affected sibpair sample..."
    (sample,) = AffectedSibpairSample(pop, size=sampleSize/4, times=1)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    try:
        if recRate is not None:
            r = recRate
        else:
            r = pop.dvars().recRate[0]
    except:
        r = 0.0005
    if daf is not None:
        d = daf
    else:
        d = 0.1
    # save in Linkage format and apply linkage method
    pvalues = []
    for ch in range(0, pop.numChrom()):
        SaveLinkage(pop=sample, output = os.path.join(dir, "Aff_%d" % (ch+1)),
            recombination=r, loci = range(sample.chromBegin(ch), sample.chromEnd(ch)),
            daf=0.1)
        pvalues.extend(LOD_gh(os.path.join(dir, "Aff_%d" % (ch+1)), gh=gh))
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    # remove temporary directory
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def Sibpair_LOD_merlin(pop, sampleSize, penetrance=None, merlin='merlin', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run multi-point linkage
    analysis using merlin

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    pene
        penetrance function, if not given (None), existing affection
        status will be used.
        
    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    merlin
        executable name of merlin, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # apply penetrance
    if penetrance is not None:
        PyPenetrance(pop, loci=pop.dvars().DSL, func=penetrance)
    # draw affected sibpair sample
    print "Generating affected sibpair sample..."
    (sample,) = AffectedSibpairSample(pop, size=sampleSize/4, times=1)
    Stat(sample, numOfAffected=True)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # save in QTDT
    dir = tempfile.mkdtemp()
    pvalues = []
    for ch in range(0, pop.numChrom() ):
        SaveQTDT(pop=sample, output = os.path.join(dir, "Aff_%d" % (ch+1)),
                loci = range(sample.chromBegin(ch), sample.chromEnd(ch)),
                fields=['affection'])
        # process by merlin
        pvalues.extend(LOD_merlin(os.path.join(dir, "Aff_%d" % (ch+1)), merlin=merlin))
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    # remove temporary directory
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def CaseControl_ChiSq(pop, sampleSize, penetrance=None):
    '''
    Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles
        
    pene
        penetrance function, if not given (None), existing affection
        status will be used.

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # apply penetrance
    if penetrance is not None:
        PyPenetrance(pop, loci=pop.dvars().DSL, func=penetrance)
    # draw affected sibpair sample
    print "Generating affected sibpair sample..."
    (sample,) = CaseControlSample(pop, sampleSize/2, sampleSize/2, times=1)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    pvalues = ChiSq_test(sample)
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    return pvalues



def QtraitSibs_Reg_merlin(pop, sampleSize, qtrait=None, infoField='qtrait', merlin='merlin-regress', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    qtrait
        a function to calculate quantitative trait

    infoField
        information field to store quantitative trait. Default to 'qtrait'

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    merlin
        executable name of merlin, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # generate quantitative trait
    if not pop.hasInfoField(infoField):
        pop.addInfoField(infoField)
    if qtrait is not None:
        PyQuanTrait(pop, loci=pop.dvars().DSL, func=qtrait, infoFields=[infoField])
    # set everyone to be affected
    MaPenetrance(pop, loci=[0], penetrance=[1,1,1])
    # draw affected sibpair sample
    print "Generating sibpair sample..."
    (sample,) = AffectedSibpairSample(pop, size=sampleSize/4, times=1)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    # save in Linkage format
    pvalues = []
    for ch in range(0, pop.numChrom()):
        SaveQTDT(pop=sample, output = os.path.join(dir, "QTDT_%d" % (ch+1)),
            loci = range(sample.chromBegin(ch), sample.chromEnd(ch)), fields=['qtrait'])
        # process by TDT
        pvalues.extend(Regression_merlin(os.path.join(dir, "QTDT_%d" % (ch+1)), merlin=merlin))
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    # remove temporary directory
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def QtraitSibs_VC_merlin(pop, sampleSize, qtrait=None, infoField='qtrait', merlin='merlin', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    qtrait
        a function to calculate quantitative trait

    infoField
        information field to store quantitative trait. Default to 'qtrait'

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    merlin
        executable name of merlin, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # generate quantitative trait
    if not pop.hasInfoField(infoField):
        pop.addInfoField(infoField)
    if qtrait is not None:
        PyQuanTrait(pop, loci=pop.dvars().DSL, func=qtrait, infoFields=[infoField])
    # set everyone to be affected
    MaPenetrance(pop, loci=[0], penetrance=[1,1,1])
    # draw affected sibpair sample
    print "Generating affected sibpair sample..."
    (sample,) = AffectedSibpairSample(pop, size=sampleSize/4, times=1)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    # save in Linkage format
    pvalues = []
    for ch in range(0, pop.numChrom()):
        SaveQTDT(pop=sample, output = os.path.join(dir, "Aff_%d" % (ch+1)),
            loci = range(sample.chromBegin(ch), sample.chromEnd(ch)), fields=['qtrait'])
        pvalues.extend(VC_merlin(os.path.join(dir, "Aff_%d" % (ch+1)), merlin=merlin))
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    # remove temporary directory
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def LargePeds_Reg_merlin(pop, sampleSize, qtrait=None, infoField='qtrait', merlin='merlin-regress', keep_temp=False):
    '''
    Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    qtrait
        a function to calculate quantitative trait

    infoField
        information field to store quantitative trait. Default to 'qtrait'

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    merlin
        executable name of merlin, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # generate quantitative trait
    if not pop.hasInfoField(infoField):
        pop.addInfoField(infoField)
    if qtrait is not None:
        PyQuanTrait(pop, loci=pop.dvars().DSL, func=qtrait, infoFields=[infoField])
    # draw affected sibpair sample
    print "Generating large pedigress sample..."
    (sample,) = LargePedigreeSample(pop, minTotalSize=N, maxOffspring=5,
        minPedSize=8, minAffected=0)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    # save in Linkage format
    pvalues = []
    for ch in range(0, pop.numChrom()):
        SaveQTDT(pop=sample, output = os.path.join(dir, "QTDT_%d" % (ch+1)),
            loci = range(sample.chromBegin(ch), sample.chromEnd(ch)), fields=['qtrait'])
        pvalues.extend(Regression_merlin(os.path.join(dir, "Aff_%d" % (ch+1)), merlin=merlin))
    # remove temporary directory
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues


def LargePeds_VC_merlin(pop, sampleSize,  qtrait=None, infoField='qtrait', merlin='merlin', keep_temp=False):
    '''Draw affected sibpair sample from pop, run TDT using GENEHUNTER

    pop
        simuPOP population. It can be a string if path to a file is given.
        This population must

            - have at least one ancestral generation (parental generation)
            - have a variable DSL (pop.dvars().DSL) indicating
              the Disease susceptibility loci. These DSL will be removed from
              the samples.
            - has only binary alleles

    qtrait
        a function to calculate quantitative trait

    infoField
        information field to store quantitative trait. Default to 'qtrait'

    sampleSize
        total sample size N. N/4 is the number of families to ascertain.

    merlin
        executable name of merlin, full path name can be given.

    keep_temp
        if True, do not remove sample data. Default to False.

    '''
    # load population
    if type(pop) == type(''):
        print "Loading population %s " % pop
        pop = LoadPopulation(pop)
    # generate quantitative trait
    if not pop.hasInfoField(infoField):
        pop.addInfoField(infoField)
    if qtrait is not None:
        PyQuanTrait(pop, loci=pop.dvars().DSL, func=qtrait, infoFields=[infoField])
    # draw affected sibpair sample
    print "Generating large pedigree sample..."
    (sample,) = LargePedigreeSample(pop, minTotalSize=N, maxOffspring=5,
        minPedSize=8, minAffected=0)
    # remove DSL from the sample
    sample.removeLoci(pop.dvars().DSL)
    # parameters needed by SaveLinkage
    dir = tempfile.mkdtemp()
    pvalues = []
    for ch in range(0, pop.numChrom()):
        SaveQTDT(pop=sample, output = os.path.join("%s%d" % (dirPrefix, ns), "QTDT_%d" % (ch+1)),
            loci = range(sample.chromBegin(ch), sample.chromEnd(ch)), fields=['qtrait'])
        pvalues = VC_merlin(os.path.join(dir, "Aff_%d" % (ch+1)), merlin=merlin)
    # remove temporary directory
    if len(pvalues) != sample.totNumLoci():
        print "Only obtain", len(pvalues), "pvalues. (should have", sample.totNumLoci(), ")"
        sys.exit(0)
    if not keep_temp:
        shutil.rmtree(dir)
    return pvalues



if __name__ == '__main__':
    allParam = getOptions()
    # unpack options
    (markerType, dataset, peneFunc, qtraitFunc, parameter, N, outputDir, analyses) = allParam
    # load simuPOP libraries
    if markerType == 'microsatellite':
        simuOpt.setOptions(alleleType='short', quiet=True)
    else:
        simuOpt.setOptions(alleleType='binary', quiet=True)
    #
    from simuPOP import *
    from simuUtil import *
    #
    print "Loading population", dataset
    pop = LoadPopulation(dataset)
    nDSL = len(pop.dvars().DSL)
    if len(parameter) == 1:
        para = parameter * nDSL
    elif len(parameter) == nDSL:
        para = parameter
    else:
        print "Length of penetrance/quantitative trait parameter should be one or the number of DSL"
        sys.exit(0)
    #
    res = {}
    res.update({
        'dataset':  dataset,
        'logfile':  dataset[0:-4] + '.log',
        'alleleFreq': [1- pop.dvars().alleleFreq[i][0] for i in pop.dvars().DSL],
        'pene==Func': peneFunc,
    })
    # calculate LD (should be already there, just to make sure)
    Stat(pop, LD=[[x,x+1] for x in pop.dvars().DSL] + [[x,x+5] for x in pop.dvars().DSL])
    # get all the variables from pop
    res.update(pop.vars())

    #res = analyzePopulation(dataset, peneFunc, qtraitFunc, parameter, N, numSample, outputDir, 
    #    analyses)
    # penetrance function.
    # for debugging purpose
    keep_temp = True
    if 'recessive' == peneFunc:
        pene_func = recessive(para)
    elif 'additive' == peneFunc:
        pene_func = additive(para)
    elif 'custom' == peneFunc:
        pene_func = custom(para)
    else:
        pene_func = None
    if 'affectedSibs_GH_TDT' in analyses:
        res['affectedSibs_GH_TDT'] = Sibpair_TDT_gh(pop, N, pene_func, keep_temp=keep_temp)
    if 'affectedSibs_GH_linkage' in analyses:
        res['affectedSibs_GH_linkage'] = Sibpair_LOD_gh(pop, N, pene_func, keep_temp=keep_temp)
    if 'affectedSibs_merlin_linkage' in analyses: 
        res['affectedSibs_merlin_linkage'] = Sibpair_LOD_merlin(pop, N, pene_func, keep_temp=keep_temp)
    if 'caseControl_Association' in analyses: 
        res['caseControl_Association'] = CaseControl_ChiSq(pop, N, pene_func)
    if 'qtraitSibs_merlin_reg' in analyses:
        res['qtraitSibs_merlin_reg'] = QtraitSibs_Reg_merlin(pop, N, customQtrait(para), keep_temp=keep_temp)
    if 'qtraitSibs_merlin_vc' in analyses:
        res['qtraitSibs_merlin_vc'] = QtraitSibs_VC_merlin(pop, N, customQtrait(para), keep_temp=keep_temp)
    if 'largePeds_merlin_reg' in analyses: 
        res['largePeds_merlin_reg'] = LargePeds_Reg_merlin(pop, N, customQtrait(para), keep_temp=keep_temp)
    if 'largePeds_merlin_vc' in analyses:
        res['largePeds_merlin_vc'] = LargePeds_VC_merlin(pop, N, customQtrait(para), keep_temp=keep_temp)
    # calculate population statistics like prevalence
    res.update(popStat(pop))
    print
    print "Writing results to file %s/res.py" % outputDir
    resFile = open(os.path.join(outputDir, 'res.py'), 'w')
    print >> resFile, "# analysis of population %s, at %s" % (dataset, time.asctime())
    print >> resFile
    for key in outputVars.keys():
        if res.has_key(key):
            # description
            print >> resFile, '# %s' % outputVars[key]
            if type(res[key]) == type(''):
                print >> resFile, '%s = "%s"' % (key, res[key])
            else:
                print >> resFile, '%s = %s' % (key, str(res[key]))
            print >> resFile
    resFile.close()
    print 'Done'


