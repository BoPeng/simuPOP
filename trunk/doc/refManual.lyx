#LyX 1.5.0svn created this file. For more info see http://www.lyx.org/
\lyxformat 263
\begin_document
\begin_header
\textclass manual
\begin_preamble
\floatname{algorithm}{Example}

\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.7.6 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. MD Anderson Cancer Center}\\
{\bf Email: }{\textsf bpeng@mdanderson.org}\\
{\bf URL: }{\textsf http://simupop.sourceforge.net} \\
{\bf Mailing List: }{\textsf simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement h
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "Bo Peng" 
\end_header

\begin_body

\begin_layout Title
simuPOP Reference Manual
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
hspace{1cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{5in}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

{
\backslash
large
\backslash
textsf Acknowledgements: }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{.2cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Marek Kimmel
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Fran
\backslash
c cois Balloux
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 William Amos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} SWIG user community
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Python user community 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Keck Center for Computational and Structural Biology
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
vspace{.7in} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2007 Bo Peng 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
The core of simuPOP is a scripting language (Python) that provides a large
 number of building blocks (populations, mating schemes, various genetic
 forces in the form of operators, simulators and gene mapping methods) to
 construct a simulation.
 This provides a R/Splus or Matlab-like environment where users can interactivel
y create, manipulate and evolve populations, monitor and visualize population
 statistics and apply gene mapping methods.
 The full power of simuPOP and Python (even R) can be utilized to simulate
 arbitrarily complex evolutionary scenarios.
\end_layout

\begin_layout Abstract
simuPOP is written in C++ and is provided as Python modules.
 Besides a front-end providing an interactive shell and a scripting language,
 Python is used extensively to pass dynamic parameters, calculate complex
 statistics and write operators.
 Because of the openness of simuPOP and Python, users can make use of a
 wide variety of tools (Splus/R, Python/SciPy, MatPlotLib etc.) to perform
 tasks like statistical analysis, gene mapping and visualization.
 Depend on machine configuration, simuPOP can simulate large (think in millions)
 populations at reasonable speed.
\end_layout

\begin_layout Abstract
This is a reference manual to all variables, functions, and operators.
 This should be read after you learned the structure of simuPOP and how
 to write a simuPOP script from the 
\emph on
simuPOP user's guide.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP
\series default
 
\series bold

\begin_inset LatexCommand citeyearpar
key "Peng2005"

\end_inset

: 
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmel (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
(18): 3686-3687
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
Genotypic structure 
\begin_inset LatexCommand index
name "genotypic structure"

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to 
\end_layout

\begin_layout Itemize
ploidy, the number of copies of basic number of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset LatexCommand index
name "GenoStruTrait!ploidy"

\end_inset

(), ploidyName
\begin_inset LatexCommand index
name "GenoStruTrait!ploidyName"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
number of chromosomes (c.f.
 
\family typewriter
numChrom
\begin_inset LatexCommand index
name "GenoStruTrait!numChrom"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
existence of sex chromosome (c.f.
 
\family typewriter
sexChrom
\begin_inset LatexCommand index
name "GenoStruTrait!sexChrom"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
number of loci on each chromosome (c.f.
 
\family typewriter
numLoci
\begin_inset LatexCommand index
name "GenoStruTrait!numLoci"

\end_inset

(ch), totNumLoci
\begin_inset LatexCommand index
name "GenoStruTrait!totNumLoci"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
locus location on chromosome (c.f.
 
\family typewriter
locusPos
\begin_inset LatexCommand index
name "GenoStruTrait!locusPos"

\end_inset

(loc), arrlociPos
\begin_inset LatexCommand index
name "GenoStruTrait!arrLociPos"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
allele names, default to allele number (c.f.
 
\family typewriter
alleleName
\begin_inset LatexCommand index
name "GenoStruTrait!alleleName"

\end_inset

(allele)
\family default
 )
\end_layout

\begin_layout Itemize
maximum allele state (c.f.
 
\family typewriter
maxAllele
\begin_inset LatexCommand index
name "GenoStruTrait!maxAllele"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
name of the information fields (c.f.
 
\family typewriter
infoField
\begin_inset LatexCommand index
name "GenoStruTrait!infoField"

\end_inset

(idx), infoFields
\begin_inset LatexCommand index
name "GenoStruTrait!infoFields"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Standard
Here information fields refer to the numbers attached to each individual,
 such as fitness value, parent index, age etc.
 Individuals may need some information fields to use certain operators.
 For example, 
\family typewriter
'fitness'
\family default
 field is required by all selectors.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:Genotype-structure-functions"

\end_inset

 creates a population and displays some of genotypic information.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Genotype-structure-functions"

\end_inset

Genotype structure functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/genoStru.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Individuals in the same population share the same genotypic structure.
 Consequently, 
\emph on
genotypic information can be retrieved from individual, population and simulator
\emph default
 (consists of populations with the same genotypic structure) 
\emph on
level
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Calling genotype structure functions from individual or simulator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/indGenoStru.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may have noticed that locus Indices start from 0.
 
\series bold
As a matter of fact, all arrays in simuPOP start at index 0
\series default
.
 To avoid confusion, I will refer the first locus as locus zero, second
 locus as locus one; first individual in a population as individual zero,
 and so on.
 The reason why zero-based indices are used is because C++ and Python, using
 which simuPOP is built, are both zero-based.
\end_layout

\begin_layout Standard
Another concern is how we should refer to loci on different chromosomes.
 The solution is that we almost always use 
\emph on
absolute index
\begin_inset LatexCommand index
name "index!absolute"

\end_inset


\emph default
 and seldom 
\emph on
use relative index
\begin_inset LatexCommand index
name "index!relative"

\end_inset

.

\emph default
 For example, if there are five and seven loci on the first two chromosomes,
 the absolute indices of loci will be (0,1,2,3,4), (5,6,7,8,9,10,11).
 It may feel confusing at first but this avoids the trouble of having to
 use two numbers (chrom, index) to refer to a locus.
 If relative index is needed, functions 
\family typewriter
chromLocusPair(absIndex)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 can be used.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Conversion between absolute and relative indices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/absIndex.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Genotype structure functions
\end_layout

\begin_layout Standard
A full list of genotypic structure related functions, please use 
\family typewriter
help(population)
\family default
 or 
\family typewriter
help(individual)
\family default
 or directly 
\family typewriter
help(GenoStruTrait).

\family default
 (You may notice that both 
\family typewriter
population
\family default
 and 
\family typewriter
individual
\family default
 classes are inherited from 
\family typewriter
GenoStruTrait
\family default
 class.
 )
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Genotypic structure related functions
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="2">
<features islongtable="true">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ploidy()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
number of copies of chromosomes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ploidyName()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
haploid, diploid, triploid etc
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
numLoci(chrom)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
number of loci on a chromosome
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
sexChrom()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
whether or not the last chromosome is sex chromosome
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
totNumLoci()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
total number of loci on all chromosomes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
genoSize()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
totNumLoci()*ploidy()
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
locusPos(loc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
the position of a locus
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
arrLociPos()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
return an (editable) array of loci positions
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
numChrom()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
number of chromosomes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
chromBegin(chrom)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
index of the first locus on a chromosome
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
chromEnd(chrom)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
index of the last locus on a chromosome + 1 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
absLocusIndex(chrom, loc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
absolute index of a locus on a chromosome
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
chromLocusPair(loc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(chrom, loc) pair of an absolute index
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
alleleName(allele)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
name of an allele (if previously specified)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
alleleNames()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
array of names of alleles, the first one is for missing value
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
locusName(loc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
name of a locus
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
maxAllele()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
maximum allele state for all loci
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
setMaxAllele(max)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
set maximum allele state for all loci
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
infoIdx(name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
index of the field 
\family typewriter
name
\family default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
infoField(idx)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
name of the field 
\family typewriter
idx
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
infoFields()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
all information fields
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Sex chromosome
\end_layout

\begin_layout Standard
If 
\family typewriter
sexChrom()
\family default
 is false, all chromosomes are assumed to be autosomes.
 You can also create population/individuals with a sex chromosome.
 Please note that we currently only model the XY chromosomes in diploid
 population.
 Consequently,
\end_layout

\begin_layout Itemize
Sex chromosome is always the last chromosome.
 
\end_layout

\begin_layout Itemize
Sex chromosome can only be specified for diploid population.
 (
\family typewriter
ploidy()
\family default
=2)
\end_layout

\begin_layout Itemize
Sex chromosomes (XY) may differ in length.
 You should specify the length of the longer one as the chromosome length.
 If there are more loci on X than Y, the rest of the Y chromosome is unused.
 Mutation, recombination may still occur at this unused part of chromosome
 to simplify implementation and usage.
 
\end_layout

\begin_layout Itemize
It is assumed that male has XY and female has XX chromosomes.
 The sex chromosomes of male individuals will be arranged in the order of
 XY.
 
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
An individual will by default have genotype, sex and affectedness information,
 but other information is needed for some operations.
 For example, the fitness value of an individual is needed for selection,
 one or more trait values may be needed to calculate quantitative traits;
 and age may be needed if age-dependent mating schemes are used.
 Since the need for information fields varies from simulation to simulation,
 simuPOP does not fix the amount of information fields, and allow users
 to specify these fields during the construction of populations.
\end_layout

\begin_layout Standard
Operators may require certain information field to work properly.
 For example, all selectors require field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 
\family typewriter
parentTagger
\family default
 needs 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 to store index of the parents of each individual in the parental generation.
 You do need to add these fields to the 
\family typewriter
infoFields
\family default
 parameter of the population constructor.
 If you forget, an error message will appear and tells you to add certain
 field when a field is needed by some operators.
\end_layout

\begin_layout Standard
The information fields can be access from each individual (c.f.
 
\family typewriter
info(idx), info(name), setInfo(value, idx), setInfo(value, name), arrInfo()
\family default
 of individuals), or from the population as a whole (c.f.
 
\family typewriter
setindInfo(value), arrIndInfo(subPop)
\family default
).
 Some operators allows you to specify which information field(s) to use.
 Just to show what you can do with information fields, one can
\end_layout

\begin_layout Itemize
create a population with 5 trait values and some risk factors
\end_layout

\begin_layout Itemize
assign risk factors (environmental maybe) manually, or through some operators
\end_layout

\begin_layout Itemize
calculate each trait values using different quantitative trait operators,
 some gene may contribute to more than one trait values
\end_layout

\begin_layout Itemize
calualte a final trait values from these information fields.
\end_layout

\begin_layout Chapter
Population
\end_layout

\begin_layout Standard

\family typewriter
population
\begin_inset LatexCommand index
name "population"

\end_inset


\family default
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals,
 all have the same genotypic structure.
 A population can store arbitrary number of ancestral populations to facilitate
 pedigree analysis.
\end_layout

\begin_layout Section
Population overview
\end_layout

\begin_layout Standard
simuPOP uses one-level population structure.
 That is to say, there is no sub-subpopulation or families in subpopulations.
 Mating is within subpopulations only.
 Exchange of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
 More specifically
\end_layout

\begin_layout Itemize
Migration can change subpopulation size; create or remove subpopulations.
 Since migration can not generate new individuals, total population size
 will not be changed.
\end_layout

\begin_layout Itemize
Mating can fill any population/subpopulation structure with offsprings.
 Both population and subpopulation sizes can be changed.
 Since mating is within subpopulation, you can not create new subpopulation
 through mating.
\end_layout

\begin_layout Itemize
A special operator 
\family typewriter
pySubset
\family default
 can shrink population size.
 It removes individuals according to their 
\family typewriter
subPopID()
\family default
 status.
 (Will explain later.) This can be used to model sudden population decrease
 due to natural disaster.
 
\end_layout

\begin_layout Itemize
Subpopulations can be split or merged.
\end_layout

\begin_layout Standard
Note that migration will most likely change subpopulation size.
 To keep subpopulation sizes constant, you can set subpopulation sizes during
 mating so that the next generation will have desired subpopulation sizes.
\end_layout

\begin_layout Standard
Every population has its own variable space, or 
\emph on
local namespaces
\begin_inset LatexCommand index
name "local namespace"

\end_inset


\emph default
 in simuPOP term.
 This namespace is a Python dictionary that is attached to each population
 and can be exposed to the users through 
\family typewriter
vars()
\family default
 or 
\family typewriter
dvars()
\family default
 function.
 Many functions and operators work in these namespaces and store their results
 in them.
 For example, function 
\family typewriter
Stat
\family default
 set variables like 
\family typewriter
alleleFreq[loc]
\family default
 and you can access them like 
\family typewriter
pop.dvars().alleleFreq[loc][allele]
\family default
.
 
\end_layout

\begin_layout Standard
Population has a large number of member functions, ranging from reviewing
 simple property to generating new population from the current one.
 However, you do not have to know all the member functions to use a population.
 As a matter of fact, you will only use a small portion of these functions
 unless you need to write pure python functions/operators that involves
 complicated manipulation of populations.
\end_layout

\begin_layout Section
Population related functions
\end_layout

\begin_layout Standard
The following table lists all population related functions.
 Functions that are prefixed by 
\family typewriter
`p.'
\family default
 are member functions.
 That is to say, they should be called in the form of 
\family typewriter
pop.function()
\family default
 where pop is a population object created by functions like 
\family typewriter
population(...)
\family default
 or 
\family typewriter
LoadPopulation(...).
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Population related functions 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="60" columns="3">
<features islongtable="true" firstHeadBottomDL="true" headBottomDL="true">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0" special="|p{2in}|">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0" special="p{4in}|">
<row topline="true" bottomline="true" endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ref
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Creating-a-population"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
population
\begin_inset LatexCommand index
name "population!population"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Create a population.
 Note that this is techniquely the 
\family typewriter
__init__
\family default
 function of the population object.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Creating-a-population"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.clone
\begin_inset LatexCommand index
name "population!clone"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Deep copy of a population.
 (In python, 
\family typewriter
pop1 = pop
\family default
 will only create a reference to 
\family typewriter
pop.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.numSubPop
\begin_inset LatexCommand index
name "population!numSubPop"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Number of subpopulations in a population
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.subPopSize
\begin_inset LatexCommand index
name "population!subPopSize"

\end_inset

(sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Size of a subpopulation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.subPopSizes
\begin_inset LatexCommand index
name "population!subPopSizes"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an array of subpopulation sizes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.popSize
\begin_inset LatexCommand index
name "population!popSize"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Total population size
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.absIndIndex
\begin_inset LatexCommand index
name "population!absIndIndex"

\end_inset

(ind, sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the absolute index of an individual in a subpopulation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.subPopIndPair
\begin_inset LatexCommand index
name "population!subPopIndPair"

\end_inset

(ind)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the (sp,idx) pair from an absolute index of an individual
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.subPopBegin
\begin_inset LatexCommand index
name "population!subPopBegin"

\end_inset

(sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Index of the first individual of a subpopulation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Structure"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.subPopEnd
\begin_inset LatexCommand index
name "population!subPopEnd"

\end_inset

(sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Index of the last individual of a subpopulation + 1
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Individuals"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.individual
\begin_inset LatexCommand index
name "population!individual"

\end_inset

(ind)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an individual
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Individuals"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.individual
\begin_inset LatexCommand index
name "population!individual"

\end_inset

(ind, sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an individual from a subpopulation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Individuals"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.individuals
\begin_inset LatexCommand index
name "population!individuals"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an iterator that can be used to iterate through all individuals
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.individuals
\begin_inset LatexCommand index
name "population!individuals"

\end_inset

(subPop)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an iterator that can be used to iterate through all individuals in
 a subpopulation.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.arrGenotype
\begin_inset LatexCommand index
name "population!arrGenotype"

\end_inset

(order)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an editable array of all genotype of the population.
 You need to know how these genotype are organized to safely read/write
 genotype directly.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.arrGenotype
\begin_inset LatexCommand index
name "population!arrGenotype"

\end_inset

(sp, order)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an editable array of all genotype of a subpopulation.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.arrInfo
\begin_inset LatexCommand index
name "population!arrIndInfo"

\end_inset

(sp, order)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the editable array of all information field of a subpopulation (default
 to the whole population).
 Note that the order of individuals within each subpopulation is not hornored.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.indInfo
\begin_inset LatexCommand index
name "population!indInfo"

\end_inset

(idx or field, subPop, order)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Get information of all individuals (or in a subpopulation), the information
 does not have to be in the same order as the individuals.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setIndInfo
\begin_inset LatexCommand index
name "population!setIndInfo"

\end_inset

(values, subPop)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set indifivual information for the given information field (index or name),
 for the given subpopulation (default to all population).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.addInfoField
\begin_inset LatexCommand index
name "population!addInfoField"

\end_inset

(field)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Add a information field, for example, 'penetrance', for the analysis of
 an existing population.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setInfoFields
\begin_inset LatexCommand index
name "population!setInfoFields"

\end_inset

(fields)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
set the information fields of an existing population.
 The existing fields will be removed.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.exposeAffectedness
\begin_inset LatexCommand index
name "population!exposeAffectedness"

\end_inset

( name='affected')
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Expose (not editable) the effectedness field of all individuals
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setIndSubPopID
\begin_inset LatexCommand index
name "population!setIndInfo"

\end_inset

(info)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set info field of all individuals using an array of size 
\family typewriter
popSize()
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setIndSubPopIDWithID
\begin_inset LatexCommand index
name "population!setIndInfoWithSubPopID"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Fill info field of all individuals using their respective subpopulation
 ID.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setSubPopByIndID
\begin_inset LatexCommand index
name "population!setSubPopByIndInfo"

\end_inset

( info=[])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Rearrange individual and set subpopulation structure, using the info value
 of each individual as subpopulation ID.
 Individuals with negative info value will be removed.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.splitSubPop
\begin_inset LatexCommand index
name "population!splitSubPop"

\end_inset

( which, sizes, subPopID=[])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Split a subpopulation into subpopulations of gives sizes.
 (The sum of sizes should equal the size of 
\family typewriter
which
\family default
 subpopulation.) Subpopulation IDs can be specified.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setSubPopStru
\begin_inset LatexCommand index
name "population!setSubPopStru"

\end_inset

(newSubPopSizes, allowPopSizeChange=False)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set subpopulation structure.
 Population size may be changed but all genotype may be lost.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.splitSubPopByProportion
\begin_inset LatexCommand index
name "population!splitSubPopByProportion"

\end_inset

( which, proportions, subPopID=[])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Split a subpopulation info subpopulations of given proportions.
 (The sum of proportions should add up to one).
 Subpopulation IDs can be specifed.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.removeEmptySubPops
\begin_inset LatexCommand index
name "population!removeEmptySubPops"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Remove empty subpopulations by adjusting subpopulation IDs.
 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.removeSubPops
\begin_inset LatexCommand index
name "population!removeSubPops"

\end_inset

( subPops=[], shiftSubPopID=True, removeEmptySubPops=False)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Remove some subpopulations (and all individuals within).
 If 
\family typewriter
shiftSubPopID
\family default
 is false, subPopID will be keep intact.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.removeIndividuals
\begin_inset LatexCommand index
name "population!removeIndividuals"

\end_inset

( inds, subPop=-1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Remove individuals.
 If a valid subPop is given, remove individuals from this subpopulation.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.mergeSubPops
\begin_inset LatexCommand index
name "population!mergeSubPops"

\end_inset

( subPops, removeEmptySubPops=False)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Merge subpopulations, using the first subpopulation ID.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.reorderSubPops
\begin_inset LatexCommand index
name "population!reorderSubPops"

\end_inset

( order, rank, removeEmptySubPops=False)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reorder subpopulations by order or by rank.
 FIXME: details.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.newPopByIndInfo
\begin_inset LatexCommand index
name "population!newPopByIndInfo"

\end_inset

( keepAncestralPops=True, removeEmptySubPops=False)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
FIXME: details.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.removeLoci
\begin_inset LatexCommand index
name "population!removeLoci"

\end_inset

( remove=[], keep=[])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Remove some loci from the current population.
 One of remove or keep can be specified.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.newPopWithPartialLoci
\begin_inset LatexCommand index
name "population!newPopWithPartialLoci"

\end_inset

( remove=[], keep=[])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Copy current population to a new one and remove its loci.
 (Current population untouched)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Direct-populaiton-manipulation"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.pushAndDiscard
\begin_inset LatexCommand index
name "population!pushAndDiscard"

\end_inset

(pop)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(Almost) Internal use only.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.ancestralDepth
\begin_inset LatexCommand index
name "population!ancestralDepth"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ancestral depth of current population.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.setAncestralDepth
\begin_inset LatexCommand index
name "population!setAncestralDepth"

\end_inset

(depth)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set ancestral depth.
 0 for none, -1 for unlimited.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.ancestralPop
\begin_inset LatexCommand index
name "population!ancestralPop"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Current ancestral population selected.
 (0 for latest generation)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.useAncestralPop
\begin_inset LatexCommand index
name "population!useAncestralPop"

\end_inset

(idx)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Use an ancestral population.
 0 for latest generation.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.equalTo
\begin_inset LatexCommand index
name "population!equalTo"

\end_inset

(pop)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Compare two populations.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Save-and-Load"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.savePopulation
\begin_inset LatexCommand index
name "population!savePopulation"

\end_inset

( filename, format='auto', compress=True)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Save a population.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
SavePopulation( pop, filename, format='auto', compress=True)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Save a population.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
SavePopulations(pops, filename, format='auto')
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Save an array of populations to a file.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Save-and-Load"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.loadPopulation
\begin_inset LatexCommand index
name "population!loadPopulation"

\end_inset

( filename)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Load a population and replace the current one.
 (Use 
\family typewriter
LoadPopulation
\family default
 instead)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Save-and-Load"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
LoadPopulation( filename)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Load a population and return it.
 Format can be 'bin', 'xml', 'text' or 'auto'.
 If auto is specified, file format is determined by file extension '.bin',
 '.xml' or '.txt'.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
LoadPopulations( filename)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Load an array of populations from a single file.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.rep
\begin_inset LatexCommand index
name "population!rep"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Current replicate in a simulator
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.grp
\begin_inset LatexCommand index
name "population!grp"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Current group ID in a simulator
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.gen
\begin_inset LatexCommand index
name "population!gen"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Current generation during evolution.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.vars
\begin_inset LatexCommand index
name "population!vars"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return a dictionary of attached Python namespace.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.vars
\begin_inset LatexCommand index
name "population!vars"

\end_inset

(sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the namespace for a subpopulation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.dvars
\begin_inset LatexCommand index
name "population!dvars"

\end_inset

()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the dictionary 
\family typewriter
vars()
\family default
 with keys mapped to attributes.
 I.e., you can access 
\family typewriter
pop.vars()['LD']
\family default
 as 
\family typewriter
pop.dvars().LD.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.dvars
\begin_inset LatexCommand index
name "population!dvars"

\end_inset

(sp)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the attribute version of 
\family typewriter
vars(sp)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.hasVar
\begin_inset LatexCommand index
name "population!hasVar"

\end_inset

( name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Whether or not a variable exists in the local namespace
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ListVars( var, level=-1, subpop=True, useWxPython=True)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
List a dictionary returned by functions like 
\family typewriter
pop.dvars() or pop.vars(sp),
\family default
 up to certain level (default to all).
 You may use name parameter if you know the variable name, and set subPop=False
 if you are only interested in the overall population.
 wxPython will be automatically used if avaiable, unless you set 
\family typewriter
useWxPython=False.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.evaluate
\begin_inset LatexCommand index
name "population!evaluate"

\end_inset

(expr, stmts='')
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Evaluate an expression and return its result.
 Optionally run statement first.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
p.execute
\begin_inset LatexCommand index
name "population!execute"

\end_inset

(stmts)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Evaluate a statement (can be multi-line string).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Creating-a-population"

\end_inset

Creating a population
\end_layout

\begin_layout Standard
A population can be created through
\end_layout

\begin_layout Itemize
call 
\family typewriter
population
\family default
 function to create an instance of population from 
\family typewriter
population
\family default
 class.
\end_layout

\begin_layout Itemize
call 
\family typewriter
LoadPopulation
\family default
, 
\family typewriter
LoadFstat
\family default
 etc to load a population from a saved file.
 
\end_layout

\begin_layout Itemize
generated as a subset of an existing population by operators like 
\family typewriter
randomSample, caseControlSample
\family default
 or equivalent functions 
\family typewriter
RandomSample, CaseControlSample
\family default
.
 
\end_layout

\begin_layout Itemize
Obtained from an existing simulator through 
\family typewriter
simulator::getPopulation()
\end_layout

\begin_layout Standard
Help contents of all functions of population class can be displayed by 
\family typewriter
help
\begin_inset LatexCommand index
name "help"

\end_inset

(population)
\family default
.
 Help on a memeber function can be viewed by 
\family typewriter
help(population.func)
\family default
.
 In Python, constructor is named 
\family typewriter
__init__
\family default
 and you can use class name to create an instance of the class.
 Therefore, to display parameters of 
\family typewriter
population
\begin_inset LatexCommand index
name "population"

\end_inset


\family default
 function, you need to run 
\end_layout

\begin_layout LyX-Code

\family typewriter
help(population.__init__)
\end_layout

\begin_layout Standard
Some notes about the parameters:
\end_layout

\begin_layout Itemize

\family typewriter
size, subPop:
\family default
 size can be ignored if subPop is specified.
 If both parameters are provided, 
\family typewriter
subPop
\family default
 should add up to 
\family typewriter
size
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
loci:
\family default
 number of loci on each chromosome.
 The length of parameter 
\family typewriter
loci
\family default
 determines number of chromosomes.
 The last chromosome can be sex chromosome.
 In this case, please specify the maximum number of loci on X and Y.
 I.e., if there are 3 loci on Y chromosme and 5 on X chromosome, use 5.
 
\end_layout

\begin_layout Itemize

\family typewriter
sexChrom:
\family default
 true or false.
 Diploid population only.
 If true, the last homologous chromosomes will be treated as sex chromosomes.
 (XY for male and XX for female.) If X and Y have different number of loci,
 you should use the longer one as loci number of the last (sex) chromosome.
\end_layout

\begin_layout Itemize

\family typewriter
lociPos:
\family default
 a 1-d or 2-d array specifying positions of loci on each chromosome.
 For example, you can use 
\family typewriter
lociPos=[1,2,3]
\family default
 when 
\family typewriter
loci=[3]
\family default
 or 
\family typewriter
lociPos=[[1,2],[1.5,3,5]]
\family default
 for 
\family typewriter
loci=[2,3]
\family default
.
 simuPOP does not assume a unit for these locations, although they are usually
 intepreted as base pairs or centiMorgans, depending on types of simulation
 being performed.
 Currently, loci location is used only for specifying recombination intensity.
 The actual recombination rate is intensity times loci distance between
 adjacent loci.
\end_layout

\begin_layout Itemize

\family typewriter
ancestralDepth:
\family default
 number of most recent ancestral generations to keep during evolution.
 Default to 0.
 You can set it to a positive number 
\family typewriter
m
\family default
 to keep the latest 
\family typewriter
m
\family default
 generations in the population, or -1 to keep all ancestral populations.
 Note that keeping track of all ancestral populations may quickly exhaust
 your computer RAM.
 If you really need to do that, use 
\family typewriter
savePopulation
\family default
 operator to save each generation to a file is a much better choice.
 
\end_layout

\begin_layout Itemize

\family typewriter
alleleNames:
\family default
 Names of the alleles.
 They are used only for output.
\end_layout

\begin_layout Itemize

\family typewriter
maxAllele
\family default
: maximum allele state for the whole population.
 This will set a cap for all loci.
 For individual locus, you can specify 
\family typewriter
maxAllele
\family default
 in mutation models, which can be smaller than global 
\family typewriter
maxAllele
\family default
 but not larger.
 Note that this number is thee number of allele states minus 1 since allele
 number starts from 0.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:population-init"

\end_inset

 shows a few examples of using the population function to create populations.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:population-init"

\end_inset

Use of population function
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popInit.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Copying a population
\end_layout

\begin_layout Standard
Like many other python operations,
\end_layout

\begin_layout LyX-Code
pop = population(...)
\end_layout

\begin_layout LyX-Code
pop1 = pop
\end_layout

\begin_layout Standard
will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well.
 If you would like to have an independent copy, use
\end_layout

\begin_layout LyX-Code
pop1 = pop.clone()
\end_layout

\begin_layout Standard
This scenario also apply to simulator (see later sections), if 
\family typewriter
simu
\family default
 is a simulator with several replicates,
\end_layout

\begin_layout LyX-Code
pop = simu.population(idx)
\end_layout

\begin_layout Standard
will get a reference to one of the replicates.
 You can, although not recomended, modify simulator through this 
\family typewriter
pop
\family default
 reference.
 Note that this pop reference will become invalid when the simulator is
 distroyed so the following calling sequence will crash python.
\end_layout

\begin_layout LyX-Code
pop = simu.population(idx)
\end_layout

\begin_layout LyX-Code
simu = simulator(....)
\end_layout

\begin_layout LyX-Code
pop.savePopulation(....)
\end_layout

\begin_layout Standard
If you would like to get a real copy, use
\end_layout

\begin_layout LyX-Code
pop = simu.getPopulation(idx)
\end_layout

\begin_layout Section
Interaction with Operators and Functions
\end_layout

\begin_layout Standard
Operators are objects that can be applied to populations.
 They have special attributes like at which generations to be active, at
 what stage of a evolutionary life cycle to be applied.
 Usually, an operator is created and passed as a parameter to a simulator.
 When 
\family typewriter
simulator::evolve
\family default
 (or 
\family typewriter
step, apply
\family default
) is called, the simulator will call the 
\family typewriter
apply()
\family default
 function of these operators at appropriate times.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:popAndOp"

\end_inset

Population and operators
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popAndOperator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, operators 
\family typewriter
initByFreq, stat
\family default
 and two copies of 
\family typewriter
kamMutator
\family default
 are created in example 
\begin_inset LatexCommand ref
reference "alg:popAndOp"

\end_inset

.
 During evolution, 
\family typewriter
simu
\family default
 will apply 
\family typewriter
initByFreq
\family default
 once to each replicate of the simulator; apply the first 
\family typewriter
kamMutator
\family default
 to the first replicate and the second 
\family typewriter
kamMutator
\family default
 to the second replicate at every generation; apply 
\family typewriter
stat
\family default
 to count allele frequency and calculate 
\begin_inset Formula $F_{st}$
\end_inset

 every 10 generations.
 More details about operators will be described later.
\end_layout

\begin_layout Standard
You can ignore the specialties of an opertor and call its 
\family typewriter
apply()
\family default
 function directly.
 For example, you can initialize a population outside a simulator by 
\end_layout

\begin_layout LyX-Code
initByFreq( [0.3, .2, .5] ).apply(pop)
\end_layout

\begin_layout Standard
or dump the content of a population by
\end_layout

\begin_layout LyX-Code
dumper().apply(pop)
\end_layout

\begin_layout Standard
This style of calling is used so often that it deserves some simplification.
 Equivalent functions are defined for most of the operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Function InitByFreq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/InitByFreq.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Note that 
\end_layout

\begin_layout Enumerate
The following two calling sequences have different consequences:
\end_layout

\begin_deeper
\begin_layout LyX-Code
pop = population(10)
\end_layout

\begin_layout LyX-Code
simu = simulator(pop, randomMating(), rep=3)
\end_layout

\begin_layout LyX-Code
simu.evolve( preOps = [initByFreq([.8,.2]) ] )
\end_layout

\begin_layout Standard
initialize three replicates of the population independently, (
\family typewriter
initByFreq
\family default
 object is applied to three populations.) but
\end_layout

\begin_layout LyX-Code
pop = population(10)
\end_layout

\begin_layout LyX-Code
InitByFreq(pop, [.8, .2])
\end_layout

\begin_layout LyX-Code
simu = simulator(pop, randomMating(), rep=3)
\end_layout

\begin_layout Standard
initialize a population once and create a simulator with three copies of
 the initialized population.
 
\end_layout

\end_deeper
\begin_layout Enumerate
If you are going to call such a function many times, it is more efficient
 to do
\end_layout

\begin_deeper
\begin_layout LyX-Code
init = initByFreq([.8,.2])
\end_layout

\begin_layout LyX-Code
for i in range(0,1000):
\end_layout

\begin_layout LyX-Code
  init.apply(pop[i])
\end_layout

\begin_layout Standard
than 
\end_layout

\begin_layout LyX-Code
for i in range(0,1000):
\end_layout

\begin_layout LyX-Code
  InitByFreq(pop[i], [.8,.2])
\end_layout

\begin_layout Standard
The difference is that the second method creates and destroys an 
\family typewriter
initByFreq
\family default
 object each time it calls the function.
\end_layout

\end_deeper
\begin_layout Standard
Because 
\family typewriter
initByFreq
\family default
 and 
\family typewriter
dumper
\family default
 will be frequently used in this manual, I will briefly describe them here.
 
\end_layout

\begin_layout Itemize

\family typewriter
initByFreq
\begin_inset LatexCommand index
name "initByFreq"

\end_inset


\family default
 takes an array of probabilities (must add up to one).
 When applying to a population, each allele will be assigned 
\family typewriter
0,1,2,3,...

\family default
 etc according to the provided probabilities.
 
\family typewriter
InitByFreq
\begin_inset LatexCommand index
name "function!InitByFreq"

\end_inset

(pop,...)
\family default
 is its function form.
\end_layout

\begin_layout Itemize

\family typewriter
dumper
\begin_inset LatexCommand index
name "dumper"

\end_inset


\family default
 will simply display the population.
 The output format for each individual is: individual index, tag, sex, affected
 status, alleles on copy 
\family typewriter
1,2,...

\family default
 of all chromosomes, separated by 
\family typewriter
|
\family default
.
 Its function form is named 
\family typewriter
Dump
\begin_inset LatexCommand index
name "function!Dump"

\end_inset

(pop).
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:Operator-dumper-and-initByFreq"

\end_inset

 demonstrates the use of these two operators:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Operator-dumper-and-initByFreq"

\end_inset

Operator dumper and initByFreq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/dumpPop.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Population-Structure"

\end_inset

Population Structure
\end_layout

\begin_layout Standard
subpopulation structure can be accessed through the following member functions:
 
\end_layout

\begin_layout Itemize

\family typewriter
pop.popSize
\begin_inset LatexCommand index
name "population!popSize"

\end_inset

()
\family default
, total population size
\end_layout

\begin_layout Itemize

\family typewriter
pop.numSubPop
\begin_inset LatexCommand index
name "population!numSubPop"

\end_inset

()
\family default
, number of subpopulations
\end_layout

\begin_layout Itemize

\family typewriter
pop.subPopSize
\begin_inset LatexCommand index
name "population!subPopSize"

\end_inset

(sp)
\family default
, size of subpopulation, which can be zero.
 Note that sp is zero-indexed.
\end_layout

\begin_layout Itemize

\family typewriter
pop.subPopBegin
\begin_inset LatexCommand index
name "population!dubPopBegin"

\end_inset

(sp),
\family default
 the index of the first individual in subpopulation 
\family typewriter
sp
\end_layout

\begin_layout Itemize

\family typewriter
pop.subPopEnd
\begin_inset LatexCommand index
name "population!subPopEnd"

\end_inset

(sp)
\family default
, the index of the last individual in subpopulation 
\family typewriter
sp
\family default
 plus one.
\end_layout

\begin_layout Itemize

\family typewriter
pop.subPopIndPair
\begin_inset LatexCommand index
name "population!subPopIndPair"

\end_inset

(ind)
\family default
, return the subpopulation and relative index of individual ind.
\end_layout

\begin_layout Itemize

\family typewriter
pop.absIndIndex
\begin_inset LatexCommand index
name "population!absIndIndex"

\end_inset

(ind, sp).
 return the absolute index of an individual
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
population structure functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popStru.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are another set of functions that deal with population/subpopulation
 size changes.
 In these functions, the 
\family typewriter
info
\family default
 field of each individual plays an important role.
 This field represents an individual's (new) subpopulation ID most of the
 times.
 For example, function 
\family typewriter
rearrangeByIndID
\begin_inset LatexCommand index
name "population!rearrangeByIndInfo"

\end_inset

()
\family default
 rearrange individuals in the order of their info values.
 Similar functions are 
\end_layout

\begin_layout Itemize

\family typewriter
pop.setIndSubPopID
\begin_inset LatexCommand index
name "population!setIndInfo"

\end_inset

(info),
\family default
 set individual info using a vector of size of the population
\end_layout

\begin_layout Itemize

\family typewriter
pop.setIndSubPopIDWithID
\begin_inset LatexCommand index
name "population!setIndInfoWithSubPopID"

\end_inset

()
\family default
, use subpopulation id to set individual info
\end_layout

\begin_layout Itemize

\family typewriter
pop.setSubPopByIndID
\begin_inset LatexCommand index
name "population!setSubPopByIndInfo"

\end_inset

()
\family default
, rearrange individual and set subpopulation structure according individual
 info values
\end_layout

\begin_layout Itemize

\family typewriter
pop.removeEmptySubPops
\begin_inset LatexCommand index
name "population!removeEmptySubPops"

\end_inset

()
\family default
, remove empty subpopulations.
 
\end_layout

\begin_layout Itemize

\family typewriter
pop.removeSubPops
\begin_inset LatexCommand index
name "population!removeSubPops"

\end_inset

(subPops),
\family default
 remove subpopulation
\end_layout

\begin_layout Itemize

\family typewriter
pop.reorderSubPops
\begin_inset LatexCommand index
name "population!reorderSubPops"

\end_inset

(order, rank, removeEmptySubPops=False)
\family default
, 
\end_layout

\begin_layout Itemize

\family typewriter
pop.newPopByIndID
\begin_inset LatexCommand index
name "population!newPopByIndInfo"

\end_inset

(keepAncestralPops=True, info=[]), 
\end_layout

\begin_layout Itemize

\family typewriter
pop.removeLoci
\begin_inset LatexCommand index
name "population!removeLoci"

\end_inset

(remove=[], keep=[]),
\family default
 remove some loci from the population
\end_layout

\begin_layout Itemize

\family typewriter
pop.newPopWithPartialLoci
\begin_inset LatexCommand index
name "population!newPopWithPartialLoci"

\end_inset

(remove=[], keep=[]),
\family default
 return a new reduced population
\end_layout

\begin_layout Itemize

\family typewriter
pop.splitSubPop
\begin_inset LatexCommand index
name "population!splitSubPop"

\end_inset

(which, subPopSizes, subPopID),
\family default
 split subpopulation 
\family typewriter
which
\family default
 according to subPopSizes
\end_layout

\begin_layout Itemize

\family typewriter
pop.spliSubPopByProportion
\begin_inset LatexCommand index
name "population!spliSubPopByProportion"

\end_inset

(which, proportions, subPopID),
\family default
 use proportion
\end_layout

\begin_layout Itemize

\family typewriter
pop.mergeSubPop
\begin_inset LatexCommand index
name "population!mergeSubPop"

\end_inset

(subPops).

\family default
 merge subpopulations
\end_layout

\begin_layout Standard
These functions may look useful and appealing but you will almost never
 use them directly.
 All these operations will be performed by various operators, in a more
 user-friendly way.
 Only when you begin to write your own operators will you have to read about
 the details of these functions.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:population-structure-functions"

\end_inset

 demonostrate the use of functions 
\family typewriter
setIndSubPopID, setSubPopByIndID
\family default
 and 
\family typewriter
removeLoci.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:population-structure-functions"

\end_inset

population structure functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popStruManip.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Individuals"

\end_inset

Individuals
\end_layout

\begin_layout Standard
You can access individuals of a population through 
\family typewriter
individual
\begin_inset LatexCommand index
name "population!individual"

\end_inset

()
\family default
 function.
 There are two forms of this function, one with and one without parameter
 
\family typewriter
subPop,
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind)
\family default
 returns the 
\family typewriter
ind
\family default
'th individual (absolute index) of the whole population
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind, subPop)
\family default
 returns the 
\family typewriter
ind
\family default
'th (relative index) individual in the 
\family typewriter
subPop
\family default
'th subpopulation.
\end_layout

\begin_layout Itemize

\family typewriter
individuals(), individuals(subPop):
\family default
 returns an iterator that can be used to iterate through all individuals.
\end_layout

\begin_layout Standard
The iterator can simplify the access of individuals, by using
\end_layout

\begin_layout LyX-Code
for ind in pop.individuals(2):
\end_layout

\begin_layout LyX-Code
  # do something to ind
\end_layout

\begin_layout LyX-Code
  print ind.affected()
\end_layout

\begin_layout Standard
instead of the older
\end_layout

\begin_layout LyX-Code
for i in range(pop.popSize()):
\end_layout

\begin_layout LyX-Code
  ind = pop.individual(i)
\end_layout

\begin_layout LyX-Code
  print ind.affected()
\end_layout

\begin_layout Standard
The returned 
\family typewriter
individual
\family default
 object also has its own member functions.
 You can retrieve genotypic information of an individual through the same
 set of functions.
 You can also get/set genotype of an individual.
 Note that you can not create an individual object directly.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Individual member functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/ind.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, you will very seldom have to use these functions directly unless
 when you write pure python operators.
 
\end_layout

\begin_layout Standard
The following table lists all individual related functions.
 They are all member functions so they have to be access through an individual
 object in the form of 
\family typewriter
ind.function().
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Individual related functions 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="25" columns="2">
<features islongtable="true">
<column alignment="left" valignment="top" leftline="true" width="0" special="|p{2in}|">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0" special="p{4.5in}|">
<row topline="true" bottomline="true" endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.arrGenotype()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an editable array of the genotype of an individual.
 The layout of this array is explained in section 
\begin_inset LatexCommand ref
reference "sec:Accessing-genotype-and"

\end_inset

.
 Although this function is not as easy to use as other allele-access functions,
 it is the fastest one since you can read/write genotype directly after
 you get the handle of all genotype through this function.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.arrGenotype(p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return only the 
\family typewriter
p
\family default
-th copy of the chromosome.
 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.arrGenotype(p, ch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return only the 
\family typewriter
ch
\family default
-th chromosome of the 
\family typewriter
p
\family default
-th copy.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.allele(idx)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the allele at locus 
\family typewriter
idx 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.allele(idx, p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the allele at locus 
\family typewriter
idx
\family default
 of the 
\family typewriter
p
\family default
-th copy of the chromosomes,
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.allele(idx, p, ch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the allele at locus 
\family typewriter
idx
\family default
 of the 
\family typewriter
ch
\family default
-th chromosome of the 
\family typewriter
p
\family default
-th chromosome set
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.alleleChar(idx)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the name of allele 
\family typewriter
allele(idx)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.alleleChar(idx, p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the name of allele 
\family typewriter
allele(idx, p)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.alleleChar(idx, p, ch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the name of allele 
\family typewriter
allele(idx, p, ch)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setAllele(allele, idx)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the allele at locus 
\family typewriter
idx 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setAllele(allele, idx, p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the allele at locus 
\family typewriter
idx
\family default
 of the 
\family typewriter
p
\family default
-th copy of the chromosomes,
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setAllele(allele, idx, p, ch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the allele at locus 
\family typewriter
idx
\family default
 of the 
\family typewriter
ch
\family default
-th chromosome of the 
\family typewriter
p
\family default
-th chromosome set
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.info(idx or name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Get the the value of info field (indexed by 
\family typewriter
idx
\family default
 or 
\family typewriter
name
\family default
).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setInfo(value, idx or name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the value of info field (indexed by 
\family typewriter
idx
\family default
 or 
\family typewriter
name)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.arrInfo()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return an editable array of all information fields.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.sex()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the sex of an individual, 
\series bold
1 for Male and 2 for Female
\series default
.
 However, this is not guranteed so please use 
\family typewriter
sexChar()
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.sexChar()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the sex of an individual 
\series bold
M/F
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setSex(sex)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the sex.
 You should use 
\family typewriter
setSex(Male)
\family default
 or 
\family typewriter
setSex(Female)
\family default
 instead of 1 and 2.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.affected()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Whether or not an individual is affected
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.unaffected()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Not 
\family typewriter
affected()
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.affectedChar()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return '
\family typewriter
A
\family default
' or '
\family typewriter
U
\family default
' for affectedness status.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setAffected(aff)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set affectedness status.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.subPopID()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Return the info field of an individual
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
i.setSubPopID()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Set the info field of an individual
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Populations are associated with python variables.
 These variables are usually set by various operators.
 For example, 
\family typewriter
stat
\begin_inset LatexCommand index
name "operator!stat"

\end_inset


\family default
 operator calculates many population statistics and store results in population
 namespace.
 Example 
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset

 demonstrates how 
\family typewriter
stat
\family default
 set variables 
\family typewriter
popSize
\family default
, 
\family typewriter
alleleFreq
\family default
 etc.
 
\end_layout

\begin_layout Standard
You can refer to these variables using 
\family typewriter
population::vars
\begin_inset LatexCommand index
name "population!vars"

\end_inset

()
\family default
 or 
\family typewriter
population::
\begin_inset LatexCommand index
name "population!population"

\end_inset

dvars()
\family default
 function.
 The returned value of 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
 reflects the same dictionary.
 However, 
\family typewriter
dvars()
\family default
 uses a little Python magic so that you can use attribute syntax to access
 dictionary keys.
 Since 
\family typewriter
a.allaleFreq[0]
\family default
 is a lot easier to read than 
\family typewriter
a['alleleFre'][0]
\family default
, 
\family typewriter
dvars()
\family default
 is always preferred to 
\family typewriter
vars()
\family default
.
 A function 
\family typewriter
ListVars
\family default
 defined in 
\family typewriter
simuUtil
\family default
 can be used to display the variables.
 With wxPython installed, this function will open a nice window with a tree
 representing the variables.
 Without wxPython (or use parameter 
\family typewriter
useWxPython=False
\family default
), variables will be displayed in a indented form.
 Several parameters can be used to limit your display.
 They are
\end_layout

\begin_layout Itemize
level: level of tree, further nested variables will not be displayed
\end_layout

\begin_layout Itemize
name: name of variable to display.
 
\end_layout

\begin_layout Itemize
subPop: whether or not display variables for each subpopulations
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Population-variables"

\end_inset

Population variables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popVars.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
These variables form a Python dictionary, and furthermore a local namespace
 for functions like 
\family typewriter
population::evaluate
\family default

\begin_inset LatexCommand index
name "population!evaluate"

\end_inset

.
 
\emph on
Local namespace
\emph default
 means that you can use dictionary items as variables duing evaluation.
 For example: 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Local namespaces of populations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/localNamespace.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, these variables are 
\emph on
local
\emph default
 to the population and is not directly accessible from the main namespace.
 
\family typewriter
vars(subPop)
\family default
 and 
\family typewriter
dvars(subPop)
\family default
 function can be used.
 Both functions takes an optional 
\family typewriter
subPop
\family default
 option.
 If ignored, they will return population dictionary; otherwise, they will
 return dictionary for subpopulation 
\family typewriter
subPop
\family default
.
 This is a very convenient feature, because subpopulations and populations
 have similar keys, you can calculate the same statistics for the whole
 population and individual subpopulations, just by specifying different
 namespaces.
\end_layout

\begin_layout Section
Sample from a Population
\end_layout

\begin_layout Standard
Sampling (or ascertainment) is a complicated issue.
 simuPOP provides several methods to generate samples from an existing populatio
n.
 Details please refer to Chapter 
\begin_inset LatexCommand ref
reference "sec:Ascertainment"

\end_inset

.
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
The information fields are information that is attached to each individual.
 For example, an individual may need 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 to track pedigree information, may need 
\family typewriter
penetrance
\family default
 to set affectedness.
\end_layout

\begin_layout Standard
The information fields is usually set during population creation, in preparation
 for all the opeartors, using the 
\family typewriter
infoFields
\family default
 option of population constructor.
 It can also be set or added by functions
\end_layout

\begin_layout Itemize

\family typewriter
pop.setInfoFields(fields)
\end_layout

\begin_layout Itemize

\family typewriter
pop.addIndField(field)
\end_layout

\begin_layout Standard
Note that changing infoField for a simulator is dangerous since all populations
 in a simulator share the same genotypic structure.
 You should addIndField to all populations to avoid potential problems.
\end_layout

\begin_layout Standard
One can set/retrieve information at the level of individuals
\end_layout

\begin_layout Itemize

\family typewriter
ind.info(idx or field)
\end_layout

\begin_layout Itemize

\family typewriter
ind.setInfo(idx or field)
\end_layout

\begin_layout Itemize

\family typewriter
ind.arrInfo()
\end_layout

\begin_layout Standard
or set the population level
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx or field, order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx or field, subPop, order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.setIndInfo(idx or field, [subPop])
\end_layout

\begin_layout Itemize

\family typewriter
pop.arrIndInfo(order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.arrIndInfo(subPop, order)
\end_layout

\begin_layout Standard
Idx or field means that you can use field index obtained from infoIdx(field),
 or use field name directly.
 field is easier to use but idx is faster.
 Although population information is kept in a population object linearly,
 there is no gurantee that they are ordered.
 If you would like to access info individual by individual, passing 
\family typewriter
order=True
\family default
 will ensure that the returned information fields are ordered by individual
 order.
 If you only need to get a summary of some information fields, passing 
\family typewriter
order=False
\family default
 will speed up the process.
 
\end_layout

\begin_layout Standard
For each individual, 
\family typewriter
ind.arrInfo()
\family default
 will return 
\family typewriter
f1, f2, f3, ...

\family default
 etc for that individual.
 From a population point of view, 
\family typewriter
pop.arrIndInfo([subPop])
\family default
 will return a list of 
\family typewriter
f1, f2, f3, ..., f1, f2, f3, ...
\family default
.
 Note that the order of individuals may not be kept in this (sub)population-wise
 array.
 That is to say, 
\family typewriter
pop.arrIndInfo()[0]
\family default
 does not have to be the first field of the first individual.
 This property is also true for 
\family typewriter
setIndInfo(values, idx or name).

\family default
 That is to say, if you want to set information field for individuals in
 a population unordered, you can use 
\end_layout

\begin_layout LyX-Code
setIndInfo(values, idx)
\end_layout

\begin_layout Standard
Otherwise, you will have to use the less efficient way:
\end_layout

\begin_layout LyX-Code
for i in range(pop.popSize()):
\end_layout

\begin_layout LyX-Code
    pop.individual(i).setInfo(values[i], idx)
\end_layout

\begin_layout Standard
Note that 
\family typewriter
indInfo
\family default
 is more convenient but it is less efficient (fields must be copied out)
 than 
\family typewriter
arrIndInfo.

\family default
 To handle the return value of 
\family typewriter
arrIndInfo,
\family default
 you would usually do:
\end_layout

\begin_layout LyX-Code
idx = pop.infoIdx('trait2')
\end_layout

\begin_layout LyX-Code
step = pop.infoSize()
\end_layout

\begin_layout LyX-Code
arr = pop.arrIndInfo(subPop=2)
\end_layout

\begin_layout LyX-Code
for i in range(pop.subPopSize(2)):
\end_layout

\begin_layout LyX-Code
  # note again that arr is writable.
\end_layout

\begin_layout LyX-Code
  arr[idx + step*i] = something
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
By default, a population object only hold current generation.
 All ancestral populations (generations) will be discarded.
 You can, however, keep as many ancestral generations as you wish, provided
 that you have enough RAM to store all these extra information.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
ancestralDepth
\family default
 is used to specify number of generations to keep.
 This parameter is default to zero, meaning keeping no ancestral population.
 You can specify a positive number to store most recent 
\family typewriter
ancestry
\family default
 generations; or -
\family typewriter
1
\family default
 to store all populations.
 
\end_layout

\begin_layout Standard
Several important usage of ancestral populations:
\end_layout

\begin_layout Itemize

\family typewriter
dumper()
\family default
 operator and 
\family typewriter
Dump()
\family default
 function has a parameter 
\family typewriter
ancestralPops
\family default
.
 If set to true, they will dump all ancestral generations.
\end_layout

\begin_layout Itemize
function 
\family typewriter
population::setAncestralDepth()
\family default
 and operator 
\family typewriter
setAncestralDepth()
\family default
 set the number of ancestral generations to keep for a population.
 A typical use of 
\family typewriter
setAncestralDepth()
\family default
 is
\end_layout

\begin_deeper
\begin_layout LyX-Code
simu.evolve(...
\end_layout

\begin_layout LyX-Code
  setAncestralDepth(3, at=[-3])
\end_layout

\begin_layout LyX-Code
)
\end_layout

\begin_layout Standard
which save the last three generations in populations so that pedigree based
 sampling schemes can sample from the population.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
pop.useAncestralPop(idx)
\family default
 set current generation of population 
\family typewriter
pop
\family default
 to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 = 1 for the first ancestral generation, 2 for second ancestral ..., and 0
 for current generation.
 After this function, all functions, operators will be applied to this ancestral
 population.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examed the ancestral populations.
 
\end_layout

\begin_layout Standard
A typical use of this function is demonstrated in example 
\begin_inset LatexCommand ref
reference "alg:Ancestral-populations"

\end_inset

.
 In this example, a population with two loci is created and with intial
 genotype 0.
 Two kamMutator with different mutation rates are applied to these two loci.
 Five most recent populations are kept.
 The allele frequencies at these generations are calculated afterwards.
 (Note that this is not the best way to exam the changes of allele frequencies,
 a 
\family typewriter
stat
\family default
 operator should be used.)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/ancestralPop.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and Load a Population
\end_layout

\begin_layout Standard
Internally, population can be saved/loaded in 
\begin_inset Quotes eld
\end_inset


\family typewriter
txt
\family default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
xml
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
bin
\family default

\begin_inset Quotes erd
\end_inset

 formats using 
\family typewriter
savePopulation
\begin_inset LatexCommand index
name "savePopulation"

\end_inset

(file, format, compress=True)
\family default
 member function, global 
\family typewriter
SavePopulation
\begin_inset LatexCommand index
name "Function!SavePopulation"

\end_inset

(pop, file, format)
\family default
 and 
\family typewriter
LoadPopulation
\family default

\begin_inset LatexCommand index
name "function!LoadPopulation"

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 since 
\family typewriter
savePopulation
\family default
 is a member function and 
\family typewriter
LoadPopulation
\family default
 is a global function.) These formats have their own advantages and disadvantages
:
\end_layout

\begin_layout Itemize

\family typewriter
xml
\begin_inset LatexCommand index
name "xml format"

\end_inset

:
\family default
 most human readable, easy transformation to other formats, largest file
 size
\end_layout

\begin_layout Itemize

\family typewriter
bin
\begin_inset LatexCommand index
name "bin format"

\end_inset

:
\family default
 not readable, small file size.
 May not be portable.
\end_layout

\begin_layout Itemize

\family typewriter
txt
\begin_inset LatexCommand index
name "text format"

\end_inset

:
\family default
 human readable with no structure, portable, median file size.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Save and load population
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/popSaveLoad.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Populations are by default compressed in gzip format.
 If you are interested in viewing the content of the file, you can use 
\family typewriter
compress=False
\family default
 when saving a populaton, or decompress the saved files using 
\family typewriter
gzip -d
\family default
 command.
\end_layout

\begin_layout Standard
Populations can also be saved in other formats such as FSTAT so that they
 can be directly analyzed by other programs.
 These formats are not supported internally.
 They are handled in Python in the form of Python function or pure-Python
 operator.
 If you would like to save/load simuPOP population in your own format, you
 can do it by mimicing these functions in 
\family typewriter
simuUtil.py
\family default
.
 
\end_layout

\begin_layout Standard
It is also possible to save a bunch of populations in a single file, provided
 that they have the same genotypic structure.
 The functions are
\end_layout

\begin_layout Itemize

\family typewriter
SavePopulations
\begin_inset LatexCommand index
name "function!SavePopulations"

\end_inset

([pop1,pop2,...,], filename, format='auto', compress=True)
\end_layout

\begin_layout Itemize

\family typewriter
LoadPopulations
\begin_inset LatexCommand index
name "functions!LoadPopulations"

\end_inset

(filename)
\end_layout

\begin_layout Standard
Shared variables will also be saved (except for big objects like samples).
 Since the number of shared variables can be big, it maybe a good idea to
 clear these variables before you save a population.
 On the other hand, you may want to save key parameters used to generate
 this population in the local namespace so that you will know these parameters
 after the population is loaded.
 For example, you can 
\end_layout

\begin_layout LyX-Code
pop.vars().clear()
\end_layout

\begin_layout LyX-Code
pop.dvars().migrationRate = 0.002
\end_layout

\begin_layout LyX-Code
pop.dvars().diseaseLoci = [4, 30]
\end_layout

\begin_layout LyX-Code
SavePopulation(pop, 'pop.bin')
\end_layout

\begin_layout Section
View a population (GUI, wxPython required)
\end_layout

\begin_layout Standard
Introduced in ver 0.6.9, 
\family typewriter
simuViewPop.py
\family default
 can be used to view a population.
 It can be used as a standalone application, or in an interactive session.
 First, you can use this script as a standalone application, simply run
\end_layout

\begin_layout LyX-Code
simuViewPop.py mypop.bin
\end_layout

\begin_layout Standard
will fire a GUI and allow you to exam population property, genotype and
 calculate statistics.
 
\end_layout

\begin_layout Standard
In a Python session, import this module will provide a function 
\family typewriter
viewPop
\family default
, apply it on a in-memory population or a filename will have the same effect.
 For example,
\end_layout

\begin_layout LyX-Code
import simuViewPop
\end_layout

\begin_layout LyX-Code
simuViewPop.viewPop(myPop)
\end_layout

\begin_layout LyX-Code
simuViewPop.viewPop(filename='mypop.bin') 
\end_layout

\begin_layout Chapter
Mating Scheme
\begin_inset LatexCommand index
name "mating scheme"

\end_inset


\end_layout

\begin_layout Standard
Mating schemes specify how to generate offspring from the current population.
 It must be provided when a simulator is created.
 Mating can perform the following tasks:
\end_layout

\begin_layout Itemize
change population/subpopulation sizes.
 
\end_layout

\begin_layout Itemize
Randomly choose parent(s) to generate offsprings to fill the next generation.
 
\end_layout

\begin_layout Itemize
During-mating operators are applied to all offsprings.
\end_layout

\begin_layout Itemize
Apply selection if applicable.
 
\end_layout

\begin_layout Section
Create a Mating Scheme
\end_layout

\begin_layout Standard
Most mating schemes take the following parameters:
\end_layout

\begin_layout Itemize

\family typewriter
numOffsprings
\begin_inset LatexCommand index
name "simulator!numOffsprings"

\end_inset


\family default
 number of offsprings or 
\begin_inset Formula $p$
\end_inset

 for a random distribution.
 default to 1.
 This parameter determines number of offsprings a mating event will produce
 so it determines family size.
\end_layout

\begin_layout Itemize

\family typewriter
numOffspringsFunc
\begin_inset LatexCommand index
name "simulator!numOffspringsFunc"

\end_inset


\family default
 a python function that return number of offspring or 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
maxNumOffsprings
\begin_inset LatexCommand index
name "simulator!maxNumOffsprings"

\end_inset


\family default
 used when numOffsprings is generated from a binomial distribution.
\end_layout

\begin_layout Itemize

\family typewriter
mode
\family default
 
\family typewriter

\begin_inset LatexCommand index
name "simulator!mode"

\end_inset


\family default
 One of 
\family typewriter
MATE_NumOffspring, MATE_NumOffspringsEachFamily, MATE_GeometricDistribution,
 MATE_PoissonDistribution, MATE_BinomialDistribution
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
newSubPopSize
\begin_inset LatexCommand index
name "simulator!newSubPopSize"

\end_inset


\family default
 an array of sizes of subpopulaitons.
 
\end_layout

\begin_layout Itemize

\family typewriter
newSubPopSizeExpr
\begin_inset LatexCommand index
name "simulator!newSubPopSizeExpr"

\end_inset


\family default
 an expression that will return the new subpopulation size.
 Details about python expression will be discussed later.
\end_layout

\begin_layout Itemize

\family typewriter
newSubPopSizeFunc
\begin_inset LatexCommand index
name "simulator!newSubPopSizeFunc"

\end_inset


\family default
 Added for more convenience.
 This should be a function that accept a int parameter (generation), an
 array of current population size and return an array of subpopulation sizes.
 This is usually easier to use than the expression version of this parameter.
\end_layout

\begin_layout Section
Determine number of offsprings during mating
\end_layout

\begin_layout Standard
The default values 
\family typewriter
numOffsprings
\family default
 parameters makes a mating scheme produce one offspring per mating.
 This is the real random mating and should be used whenever possible.
 However, various situations requires larger family size or even changing
 family size.
 simuPOP provides a comprehensive way to deal with this problem.
\end_layout

\begin_layout Standard
The method to determine the number of offsprings are set by 
\family typewriter
mode
\family default
 parameter:
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffsprings:
\family default
 if 
\family typewriter
numOffspringsFunc
\family default
 is not given, number of offsprings will be constant 
\family typewriter
numOffsprings
\family default
 all the time.
 Otherwise, 
\family typewriter
numOffspringsFunc(gen)
\family default
 will be called 
\series bold
once
\series default
 for each generation to get the number of offsprings for the matings happen
 in this generation.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffspringsEachFamily:
\family default
 
\family typewriter
numOffspringsFunc
\family default
 has to be given and will be called whenever a mating happens.
 Since 
\family typewriter
numOffspringsFunc
\family default
 can be 
\series bold
any
\series default
 python function, this mode allows arbitrary model of assigning number of
 offsprings during mating.
 The mode can be slow though.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_GeometricDistribution: numOffsprings
\family default
 or result of 
\family typewriter
numOffspringsFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a geometric distribution.
 The number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_PoissonDistribution: numOffsprings
\family default
 or result of 
\family typewriter
numOffspringsFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a Poission distribution.
 The number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{p^{k-1}}{\left(k-1\right)!}e^{-p}\quad\textrm{ for }k\geq1\]

\end_inset

Since the mean of this shifted Poisson distribution is 
\begin_inset Formula $p+1$
\end_inset

, you need to specify, for example, 2, if you want a mean family size 3.
 (FIXME: this part needs more consideration.)
\end_layout

\begin_layout Itemize

\family typewriter
MATE_BinomialDistribution: numOffsprings
\family default
 or result of 
\family typewriter
numOffspringsFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a Binomial distribution.
 Let 
\begin_inset Formula $N$
\end_inset

=
\family typewriter
maxNumOffsprings
\family default
, the number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}\;\textrm{ for }N\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Standard
Note that all these distributions are adjusted to produce at least one offspring.
 
\end_layout

\begin_layout Section
Determine subpopulation sizes of next generation
\end_layout

\begin_layout Standard
The default behavior of simuPOP is to use the same population/subpopulation
 sizes as the parent generation.
 You can change this behavior by setting one of 
\family typewriter
newSubPopSize,
\family default
 
\family typewriter
newSubPopSizeExpr
\family default
 and 
\family typewriter
newSubPopSizeFunc
\family default
 parameters:
\end_layout

\begin_layout Itemize
If you would like to have fixed subpopulation sizes, use 
\family typewriter
newSubPopSize=some_fixed_values
\family default
 .
 This is useful when subpopulation sizes are changed by migration and you
 do want to keep constant subpopulation sizes.
\end_layout

\begin_layout Itemize
If subpopulation size can be easily calculated through an expression, you
 can use 
\family typewriter
newSubPopSizeExpr
\family default
 to determine the new subpopulation sizes.
 For example 
\family typewriter
newSubPopSizeExpr=`[gen+10]'
\family default
 uses generation number + 10 as the new population size.
 More complicated expression can be used, maybe along with 
\family typewriter
pyExec
\family default
 operators, but in this case, a specialized function and 
\family typewriter
newSubPopSizeFunc
\family default
 is recommened.
 Note that the expression uses variables from local namespace.
\end_layout

\begin_layout Itemize
A more organized (and thus recommended) way to set new population/subpopulation
 sizes is through parameter 
\family typewriter
newSubPopSizeFunc
\family default
.
 To use this paarmeter, you need to define a Python function that take two
 parameters: generation number and current subpopulation sizes and return
 an array of new subpoulation sizes.
 ( return 
\family typewriter
[newsize]
\family default
 instead of 
\family typewriter
newsize
\family default
 when you do not have any subpopulation structure).
 For example, the following function defines a linear expansion demographic
 scenario where a real example where a single population is splitted at
 200 generations (using a 
\family typewriter
spliPopulation
\family default
 operator).
\end_layout

\begin_deeper
\begin_layout LyX-Code
def lin_exp(gen, oldSize=[]):
\end_layout

\begin_layout LyX-Code
  if gen < 200:   # burn in, constant population size
\end_layout

\begin_layout LyX-Code
    return [1000]
\end_layout

\begin_layout LyX-Code
  else:           # increase subpopulation sizes
\end_layout

\begin_layout LyX-Code
    incSize = (10000-1000)/(500-200)/len(oldSize)
\end_layout

\begin_layout LyX-Code
    return [oldSize[x]+incSize for x in range(0, len(oldSize))]
\end_layout

\begin_layout Standard
you can then use this function as follows
\end_layout

\begin_layout LyX-Code
...randomMating(newSubPopSizeFunc=lin_exp) ...
\end_layout

\end_deeper
\begin_layout Section
Demographic change functions
\end_layout

\begin_layout Standard

\family typewriter
newSubPopSizeFunc
\family default
 can take a function with parameters 
\family typewriter
gen
\family default
 and 
\family typewriter
oldSize.

\family default
 A few functions are defined in 
\family typewriter
simuUtil.py
\family default
 that will return such a function with given parameters.
 All these functions support burnin and split to equal sized subpopulations.
 For all these function, you can test them by
\end_layout

\begin_layout LyX-Code
func = oneOfTheDemographicFunc(parameters)
\end_layout

\begin_layout LyX-Code
gen = range(0, yourEndGen)
\end_layout

\begin_layout LyX-Code
r.plot(gen, [func(x)[0] for x in gen])
\end_layout

\begin_layout Standard
NumSubPop is default to 1.
 split is default to 0 or burnin.
 Population size change happens 
\series bold
after
\series default
 burnin (start at burn+1) and split happens at 
\family typewriter
split.
\end_layout

\begin_layout Subsubsection*

\family typewriter
ConstSize(size, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
The population size is constant, but will split into 
\family typewriter
numSubPop
\family default
 subpopulations at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
LinearExpansion(initSize, endSize, end, burnin, split, numSubPop, bottleneckGen,
 bottleneckSize)
\end_layout

\begin_layout Standard
Linearly expand population size from intiSize to endSize after burnin, split
 the population at generation 
\family typewriter
split.
\family default
If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
ExponentialExpansion
\family default
(
\family typewriter
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
Exponentially expand population size from intiSize to endSize after burnin,
 split the population at generation 
\family typewriter
split.
\family default
If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
InstantExpansion
\family default
(
\family typewriter
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
Instaneously expand population size from intiSize to endSize after burnin,
 split the population at generation 
\family typewriter
split.
\family default
If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Different Mating Schemes
\end_layout

\begin_layout Standard
Currently, simuPOP provides the following mating schemes:
\end_layout

\begin_layout Itemize

\family typewriter
noMating
\begin_inset LatexCommand index
name "noMating"

\end_inset

()
\family default
 parent generation will be considered as offspring genertion.
 subpopsizes will be ignored although some during-mating operators can be
 applied.
\end_layout

\begin_layout Itemize

\family typewriter
\emph on
binomialSelection
\emph default

\begin_inset LatexCommand index
name "binomialSelection"

\end_inset

()
\family default
 no sex is involved.
 Offspring is chosen from parental generation by random or according to
 fitness values.
\end_layout

\begin_layout Itemize

\family typewriter
radomMating
\begin_inset LatexCommand index
name "radomMating"

\end_inset

()
\family default
 sexed random mating.
 A prameter 
\family typewriter
(contIfUniSex
\begin_inset LatexCommand index
name "contIfUniSex"

\end_inset

)
\family default
 can be set to determine the behavior when only one sex exists in a subpopulatio
n.
 Default is continue without warning.
\end_layout

\begin_layout Itemize

\family typewriter
pyMating
\begin_inset LatexCommand index
name "pyMating"

\end_inset

()
\family default
 (
\series bold
not usable right now)
\series default
 Hybird mating scheme.
 This mating scheme takes two parameters: 
\family typewriter
mateFunc
\family default
 and 
\family typewriter
keepSubPopStru
\family default
.
 
\family typewriter
mateFunc
\family default
 should be a python function that accept a (parental) population and return
 parent indices for each offspring.
 If 
\family typewriter
keepSubPopStru=True
\family default
 (default), parents should come from the same subpopulation and the offspring
 population will have subpopulation strcture.
 Otherwise, mating can across subpopulation strcuture.
 
\end_layout

\begin_layout Standard
Detailed information of each mating scheme can be found through 
\family typewriter
help(...)
\family default
 function.
 
\end_layout

\begin_layout Section
Sex chromosomes
\end_layout

\begin_layout Standard
Currently, only 
\family typewriter
randomMating()
\family default
 in diploid population supports sex chromosomes.
 When 
\family typewriter
sexChrom()
\family default
 is false, the sex of an offspring is determined randomly with prob 
\begin_inset Formula $1/2$
\end_inset

.
 Otherwise, it is determined by the existence of Y chromosome.
 I.e., what sex chromosome an offspring get from his father.
 
\end_layout

\begin_layout Standard
Recombinations on sex chromosomes of females (XX) is just like those on
 autosomes.
 However, this is not true in male.
 Currently, recombinations between male sex chromosomes (XY) are 
\emph on
not
\emph default
 allowed (a bug/feature of recombinators).
 This may change later if exchanges of genes between pseudoautosomal regions
 of XY need to be modeled.
\end_layout

\begin_layout Chapter
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They (there are exceptions) can be applied to populations directly using
 
\family typewriter
apply
\family default
() member function, but most of the time they are managed and applied by
 a simulator.
\end_layout

\begin_layout Section
Type of operators
\end_layout

\begin_layout Standard
There are three kinds of operators:
\end_layout

\begin_layout Itemize

\emph on
built-in:
\emph default
 written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\end_layout

\begin_layout Itemize

\emph on
hybrid
\emph default

\begin_inset LatexCommand index
name "hybrid"

\end_inset

: written in C++ but calls python function during simulation.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter
pyMutator
\family default
 will determine if an allele will be mutated and call a user--defined Python
 function to mutate it.
\end_layout

\begin_layout Itemize

\emph on
pure python
\emph default
: written in python.
 Same speed as python.
 For example, a 
\family typewriter
varPlotter
\begin_inset LatexCommand index
name "varPlotter"

\end_inset


\family default
 can plot python variables that are set by other operators.
\end_layout

\begin_layout Standard
You do not have to know the type of an operator to use them.
 The interface of them are all the same.
 Note that although it is possible to write pure python operators to operate
 directly on populations, it might work very slowly compared to the built-in
 ones.
\end_layout

\begin_layout Subsection
Applicable Stages
\begin_inset LatexCommand index
name "applicable stage"

\end_inset


\end_layout

\begin_layout Standard
Operators can be applied at different stage(s) of a life cycle.
 More specifically, at pre-, during- or post mating stage(s).
 Note that it is possible for an operator to apply multiple times in a life
 cycle.
 For example, an save-to-file operator might be applied before and after
 mating to trace parental information.
 Applicable stages are usually set by default but you can change it by setting
 
\family typewriter
stage=(PreMating|PostMating|DuringMating|PrePostMating)
\family default
 parameter.
 Note that some operators ignore 
\family typewriter
stage
\family default
 parameter since they only work at one stage.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Operator stage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/operatorstages.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Active Generations
\end_layout

\begin_layout Standard
Operators do not have to be applied at all generations.
 You can specify starting generation, ending generation, gaps between applicable
 generations, or even specific generations to apply.
 For example, you might want to start applying migrations after certain
 burn-in generation; or you want to calculate every 10 generations.
 Operators take the following parameters during initialization:
\end_layout

\begin_layout Itemize

\family typewriter
begin
\begin_inset LatexCommand index
name "begin"

\end_inset


\family default
 start generation.
 default to 1.
 negative number is interpreted as endGeneration + begin 
\end_layout

\begin_layout Itemize

\family typewriter
end
\begin_inset LatexCommand index
name "end"

\end_inset


\family default
 stop applying after this generation.
 negative number is allowed
\end_layout

\begin_layout Itemize

\family typewriter
step
\begin_inset LatexCommand index
name "step"

\end_inset


\family default
 number of generations between active generations.
 default to 1 
\end_layout

\begin_layout Itemize

\family typewriter
at
\begin_inset LatexCommand index
name "at"

\end_inset


\family default
 an array of active generations.
 If given, begin, end, step will be ignored.
\end_layout

\begin_layout Standard
For example
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Set active generations of an operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/operatorgen.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last example displays variable 
\family typewriter
gen
\family default
 for each replicate.
 Note that you can use negative generation number whenever you specifies
 the 
\family typewriter
end
\family default
 parameter of evolve.
 In this case, generation -1 is the last generation (end), -2 is end-1,
 and so on.
\end_layout

\begin_layout Subsection
Replicates and Groups
\end_layout

\begin_layout Standard
Most operators are applied to every replicate of a simulator during evolution.
 However, you can apply operators to one or a group of replicates only.
 For example, you can initialize different replicates with different initial
 values and then start evolution.
 c.f.
 
\family typewriter
simulator::setGroup
\family default
 .
 
\end_layout

\begin_layout Standard
The most useful example is 
\end_layout

\begin_layout LyX-Code
output('
\backslash
n',rep=REP_LAST)
\end_layout

\begin_layout Standard
that will output 
\family typewriter

\backslash
n
\family default
 at the end of each generation.
 Here is an example of using replicate groups:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Replicate group
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/operatorgrp.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Output Specification
\end_layout

\begin_layout Standard
Operators can have outputs.
 Output can be standard output (terminal) or a file, which can be constant,
 or change with generation or replicate.
 Different operators can append to the same file to form table-like outputs.
 
\end_layout

\begin_layout Standard
Filename can have the following format:
\end_layout

\begin_layout Itemize

\family typewriter
'filename'
\family default
 this file will be closed after each use.
 I.e., if several operators output to the same file, only the last one will
 succeed.
\end_layout

\begin_layout Itemize

\family typewriter
'>filename'
\family default
 the same as 'filename'
\end_layout

\begin_layout Itemize

\family typewriter
'>>filename'
\family default
 The file will be created at the beginning of evolution (
\family typewriter
simulator::evolve
\family default
) and close at the end.
 Several operators can output to this file to form a table.
\end_layout

\begin_layout Itemize

\family typewriter
'>>>filename'
\family default
 The same as 
\family typewriter
'>>filename'
\family default
 except that the file will not be cleared at the beginning of evolution
 if it is not empty.
 
\end_layout

\begin_layout Itemize

\family typewriter
'>'
\family default
 out put to standard output.
\end_layout

\begin_layout Itemize

\family typewriter
''
\family default
 suppress output.
\end_layout

\begin_layout Standard
The following example shows the difference between 
\family typewriter

\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset


\family default
 and 
\family typewriter

\begin_inset Quotes eld
\end_inset

>>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
log/operatoroutput
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/operatoroutput.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first simulator, all operators uses 
\family typewriter

\begin_inset Quotes eld
\end_inset

a.txt
\begin_inset Quotes erd
\end_inset


\family default
 (the same as 
\family typewriter

\begin_inset Quotes eld
\end_inset

>a.txt
\begin_inset Quotes erd
\end_inset


\family default
).
 This file is repeatedly covered by other operators so what we finally get
 is a newline written by 
\family typewriter
output(
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

)
\family default
.
 The second simulator works fine by using 
\family typewriter

\begin_inset Quotes eld
\end_inset

>>a.txt
\begin_inset Quotes erd
\end_inset


\family default
.
\end_layout

\begin_layout Standard
Output filename does not have to be fixed.
 If 
\family typewriter
outputExpr
\family default
 parameter is used (
\family typewriter
output
\family default
 will be ignored), it will be evaluated when a filename is needed.
 This is useful when you need to write to different files for different
 replicate/generations.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
log/operatoroutputexpr
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/operatoroutputexpr.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Python expression and statistics calculation
\end_layout

\begin_layout Subsection
Expressions and Statements
\end_layout

\begin_layout Standard
Expressions are used extensively in operators so basic knowldege of python
 is required.
 If you know almost nothing about Python, please spend some time on the
 Python tutorial from python website.
\end_layout

\begin_layout Standard
Unlike C/C++, assignments in Python do not return values.
 This is the biggest difference between Python expression and statement:
\end_layout

\begin_layout Itemize
expressions consist of constants, variables, operators, functions, but 
\emph on
no
\emph default
 assignments, condition, loop etc.
 Expression returns a value when executed.
 An example of expression is 
\family typewriter
range(1,5)+10
\family default
 .
\end_layout

\begin_layout Itemize
statements consist of arbitrary valid python code.
 Statement does 
\emph on
not
\emph default
 return a value when executed.
 An example of statement is 
\family typewriter
a=range(1,5)
\family default
 .
\end_layout

\begin_layout Subsection
simuPOP variables
\end_layout

\begin_layout Standard
All populations have their own attached variables.
 We have seen the structure of a population dictionary: it starts empty
 and will have many variables created by various operators.
 You can access local namespace of each replicate through a simulator's
 
\family typewriter
vars(rep)
\family default
 function:
\end_layout

\begin_layout LyX-Code
simu.vars(0)        simu.vars(1) ...
      // replicate
\end_layout

\begin_layout LyX-Code
  popSize             popSize            // local namespace
\end_layout

\begin_layout LyX-Code
  alleleFreq[0]       alleleFreq[0]      // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
  alleleFreq[1]       alleleFreq[1]      // at locus 2
\end_layout

\begin_layout LyX-Code
  ...
                 ....
\end_layout

\begin_layout LyX-Code
  subPop[0]           subPop[0]          // subpop namespace
\end_layout

\begin_layout LyX-Code
    popSize             popSize          // subpopulation 1 size
\end_layout

\begin_layout LyX-Code
    allaleFreq[0]       allaleFreq[0]    // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout LyX-Code
  subPop[1]           subPop[1]          // variables for subpop 2
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout Standard
It is important to know that
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(0), vars(1)
\family default
 etc are the 
\emph on
local namespaces
\emph default
 for each replicate.
\end_layout

\begin_layout Itemize

\family typewriter
subPop[0], subPop[1]
\family default
 etc have almost the same set of keys as those for the whole population.
 This is because 
\family typewriter
stat
\family default
 operator calculate statistics of each replicate of population, and all
 subpopulations.
\end_layout

\begin_layout Standard
To list these variables, you can use the 
\family typewriter
ListVars()
\family default
 function defined in 
\family typewriter
simuUtil.py
\family default
.
 For example
\end_layout

\begin_layout LyX-Code
ListVars(simu.vars(0), level=2)
\end_layout

\begin_layout Standard
list all variables for the first replicate.
 
\family typewriter
Level=2
\family default
 stops 
\family typewriter
ListVars
\family default
 from expanding lists and dictionaries after two levels.
 
\end_layout

\begin_layout Standard
Two functions can be used to access simulator and population variables:
 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
.
 We have known 
\family typewriter
population::vars()
\family default
 and 
\family typewriter
population::dvars()
\family default
, 
\family typewriter
simulator::vars()
\family default
 and 
\family typewriter
simulator::dvars()
\family default
 work in almost the same way.
 
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(rep
\family default
), 
\family typewriter
dvars(rep):
\family default
 return replicate 
\family typewriter
rep
\family default
's local namespace
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(rep, subPop
\family default
), 
\family typewriter
dvars(rep, subPop):
\family default
 return the namespace of 
\family typewriter
subPop
\family default
 subpopulation of replicate 
\family typewriter
rep.
\end_layout

\begin_layout Standard
The return values of 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
 are different.
 
\family typewriter
vars()
\family default
 returns a Python dictionary.
 You should access their keys in the usual Python way.
 
\family typewriter
dvars()
\family default
 returns a 'wrapped' Python dictionary.
 You can access dictionary keys as attributes.
 
\family typewriter
dvars()
\family default
 is usually considered to be easier to use.
\end_layout

\begin_layout Subsection

\family typewriter
evaluate
\begin_inset LatexCommand index
name "calculate"

\end_inset


\family default
 function and 
\family typewriter
pyEval
\begin_inset LatexCommand index
name "calc"

\end_inset


\family default
 and 
\family typewriter
pyExec
\begin_inset LatexCommand index
name "pyExec"

\end_inset


\family default
 operators
\end_layout

\begin_layout Standard
Function 
\family typewriter
population::evaluate
\family default
 and operator 
\family typewriter
pyEval/pyExec
\family default
 will work in local namespaces.
 For example, if there are 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 in the main namespace and 
\family typewriter
a
\family default
 in 
\family typewriter
pop
\family default
, 
\family typewriter
pop.evaluate('a')
\family default
 will return 
\family typewriter
pop.vars()['a']
\family default
, 
\family typewriter
pop.evaluate('b')
\family default
 will return global 
\family typewriter
b
\family default
 since there is no 
\family typewriter
b
\family default
 in the local namespace.
 It this is still too abstract, here is a real example
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
python expression
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/expr.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
simulator
\family default
 creates a simulator with two replicates 0 and 1.
 
\end_layout

\begin_layout Itemize
We evaluate 
\family typewriter
grp*2
\family default
 in different replicates and get different results.
\end_layout

\begin_layout Itemize

\family typewriter
gen
\family default
 is not in either replicate's namespace so the global one will be used.
\end_layout

\begin_layout Itemize
Using statements can create variables in local namespaces.
 (You can use 
\family typewriter
global
\family default
 statement to create global variable if you are familiar with python.)
\end_layout

\begin_layout Standard

\family typewriter
pyEval/pyExec
\family default
 operators execute python expression/statements, 
\emph on
using local namespaces
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
pyEval
\family default
 (operator) evaluate a Python expression and return its value, optional
 execute a list of statements beforehand.
\end_layout

\begin_layout Itemize

\family typewriter
pyExec
\family default
 (operator) execute a list of statements in the form of a multi-line string.
 No return value or output.
\end_layout

\begin_layout Standard
Here, 
\family typewriter
expr
\family default
 is a simple string containing an expression that will return a value when
 executed; 
\family typewriter
stmts
\family default
 is a string of statements, separated by 
\family typewriter
'
\backslash
n'
\family default
.
 
\end_layout

\begin_layout Standard
For example, you can return a string of 
\begin_inset Quotes eld
\end_inset

gen:rep
\begin_inset Quotes erd
\end_inset

 using the following function
\end_layout

\begin_layout LyX-Code
pop.evaluate(r
\begin_inset Quotes eld
\end_inset

'%d:%d' % (gen,rep)
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
but if you would like to change/create variables, you have to use statements
 like
\end_layout

\begin_layout LyX-Code
pop.evalulate(r
\begin_inset Quotes eld
\end_inset

myval
\begin_inset Quotes erd
\end_inset

, stmts=r
\begin_inset Quotes erd
\end_inset

myval=rep+1
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Since you are executing Python statements, you can of course do it directly
 in python.
 For example, the above function does exactly the following
\end_layout

\begin_layout LyX-Code
pop.vars()['myval'] = pop.vars()['rep'] + 1
\end_layout

\begin_layout LyX-Code
pop.vars()['myvar']
\end_layout

\begin_layout Standard
As a matter of fact, we seldom use 
\family typewriter
evaluate
\family default
 function directly (maybe for debuging), usually
\end_layout

\begin_layout Itemize
we use expressions for dynamic parameters.
 For example:
\end_layout

\begin_deeper
\begin_layout LyX-Code
newSubPopSizeExpr=
\begin_inset Quotes erd
\end_inset

range(10,20)*1.2
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
outputExpr= ' 
\begin_inset Quotes erd
\end_inset

saveAt%s.txt
\begin_inset Quotes erd
\end_inset

 % gen'
\end_layout

\begin_layout Standard
These parameters will be evaluated whenever they are referred.
\end_layout

\end_deeper
\begin_layout Itemize
we use expression/statements in 
\family typewriter
pyEval/pyExec
\family default
 operators.
 These statements will work in local namespaces.
 For example:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Expression evaluation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/expreval.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because of the interactive nature of python, it is very easy to write short
 programs, quote them in 
\family typewriter
r'''program'''
\family default
 and put them in to 
\family typewriter
pyEval/pyExec
\family default
 operators.
\end_layout

\begin_layout Chapter
Simulator
\begin_inset LatexCommand index
name "Simulator"

\end_inset


\end_layout

\begin_layout Standard
Simulators combine three important components of simuPOP: population, mating
 scheme and operators together.
 A simulator is usually created with an instance of population, a replicate
 number and a mating scheme.
 It makes '
\family typewriter
rep
\family default
' replicates of this population and control the evolution process of these
 populations.
\end_layout

\begin_layout Standard
The most important function of a simulator is 
\family typewriter
evolve()
\family default
.
 It accepts arrays of operators as its parameters, among which, '
\family typewriter
preOps
\family default

\begin_inset LatexCommand index
name "simulato!preOps"

\end_inset

' and '
\family typewriter
postOps
\family default

\begin_inset LatexCommand index
name "simulator!postOps"

\end_inset

' will be applied to the populations at the begining/end of evolution, whereas
 '
\family typewriter
ops
\family default
' will be applied at every generation.
 
\end_layout

\begin_layout Section
Generation Number
\end_layout

\begin_layout Standard
Several aspects of generation number may cause confusion:
\end_layout

\begin_layout Itemize
generation starts from zero
\end_layout

\begin_layout Itemize
a generation number presents a 'to-be-evolved' generation
\end_layout

\begin_layout Itemize
ending generation specified in 
\family typewriter
evolve()
\family default
 will be executed
\end_layout

\begin_layout Standard
That is to say, a new simulator will have generation 0 (at the beginning
 of generation 0).
 If you do 
\family typewriter
evolve(..., end=0), evolve
\family default
 will evolve one generation and stop at the beginning of generation 1.
\end_layout

\begin_layout Standard
It may sound strange that 
\end_layout

\begin_layout LyX-Code
evolve(end=2)
\end_layout

\begin_layout Standard
evolve the population three times.
 Generation 0, generation 1, and generation 2.
 At the end of simulation, current generation number is 3! (If you are familiar
 with C, this is like a for loop index).
 This is why you should test if a simulation is finished correctly by
\end_layout

\begin_layout LyX-Code
if(simu.gen() == endGen+1)
\end_layout

\begin_layout Standard
instead of 
\family typewriter
simu.gen() == endGen.

\family default
 (endGen is the value for parameter end).
\end_layout

\begin_layout Standard
When you use 
\family typewriter
start=0, step=5, end=10
\family default
 for your operator, it will be applied at generations 
\family typewriter
0,5,10
\family default
 etc.
 
\end_layout

\begin_layout Section
Operator calling sequence
\end_layout

\begin_layout Standard
Simulators separate operators into 
\family typewriter
pre-
\family default
, 
\family typewriter
during-
\family default
 and 
\family typewriter
post-
\family default
 mating operators.
 During evolution, simulator first apply all 
\family typewriter
PreMating
\family default
 operators and then call the 
\family typewriter
mate()
\family default
 function of the given mating scheme, which will call 
\family typewriter
DuringMating
\family default
 operators during the birth of each offspring.
 After the new generation is generated, 
\family typewriter
PostMating
\family default
 operators are applied in the order they appear in the operator list.
\end_layout

\begin_layout Standard
Anyway, operators are not always active.
 They can be applied to certain generations or certain replicate(s) of populatio
n.
 A simulator will always apply preOps and postOps operators, but will ask
 if an operator is active (by providing 
\family typewriter
rep, grp, gen
\family default
 information) before its is called.
\end_layout

\begin_layout Standard
The order of applying operators usually does not matter but errors can occur
 if you are not careful.
 For example, 
\family typewriter
stat(...)
\family default
 calculate the statistics of current population.
 It is a pre-mating operator so you should set 
\family typewriter
stage=PostMating
\family default
 and put it after all operators if you would like to measure post-mating
 population.
 However, it should be put before any operator (such as an terminator) that
 uses the shared variable set by 
\family typewriter
stat(...).
\end_layout

\begin_layout Standard
If you are not sure about the calling sequence of operators, you can set
 the 
\family typewriter
dryrun
\family default

\begin_inset LatexCommand index
name "simulator!dryun"

\end_inset

 parameter of 
\family typewriter
evolve()
\family default
 function to true.
 
\family typewriter
evolve
\family default
 will then print out the order of operators to apply.
 Consider that operators can be 
\family typewriter
PreMating
\begin_inset LatexCommand index
name "constant!PreMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PreMating"

\end_inset

, PostMating
\begin_inset LatexCommand index
name "constant!PostMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PostMating"

\end_inset

, PrePostMating
\begin_inset LatexCommand index
name "constant!PrePostMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PrePostMating"

\end_inset

, DuringMating
\begin_inset LatexCommand index
name "constant!DuringMating"

\end_inset


\begin_inset LatexCommand index
name "operator!DuringMating"

\end_inset


\family default
 and the default value (parameter 
\family typewriter
stage
\family default
) may not be what you expect, having a look at the calling sequence before
 real evolution is always a good idea.
\end_layout

\begin_layout Section
Evolution
\end_layout

\begin_layout Standard
Simulators can evolve a given number of generations (the 
\family typewriter
'end'
\family default
 parameter of evolve), or evolve indefinitely using a certain type of operators
 called terminators.
 In this case, one or more terminators will check the status of evolution
 and determine if the simulation should be stopped.
 An obvious example of such a terminator is a fixation-checker.
 Useful simulator functions are
\end_layout

\begin_layout Itemize

\family typewriter
gen
\begin_inset LatexCommand index
name "simulator!gen"

\end_inset

()
\family default
 return current generation number
\end_layout

\begin_layout Itemize

\family typewriter
setGen
\begin_inset LatexCommand index
name "simulator!setGen"

\end_inset

()
\family default
 set current generation.
 Usually used to reset a simulator
\end_layout

\begin_layout Itemize

\family typewriter
population
\begin_inset LatexCommand index
name "simulator!population"

\end_inset

()
\family default
 return temporary reference of one of the populations.
 'Reference' means that the changes to the referred population will reflect
 to the one in simulator.
 'Temporary' means that the referred population might be invalid after evolution.
\end_layout

\begin_layout Itemize

\family typewriter
evolve
\begin_inset LatexCommand index
name "simulator!evolve"

\end_inset

()
\family default
 evolve all replicates of the population
\end_layout

\begin_layout Itemize

\family typewriter
apply
\begin_inset LatexCommand index
name "simulator!apply"

\end_inset

()
\family default
 apply a list of operators to all populations.
\end_layout

\begin_layout Itemize

\family typewriter
step
\begin_inset LatexCommand index
name "simulator!step"

\end_inset

()
\family default
 evolve one generation.
\end_layout

\begin_layout Standard
The most useful function is of course 
\family typewriter
evolve
\family default
, which takes parameters
\end_layout

\begin_layout Itemize

\family typewriter
preOps:
\family default
 operators that will be applied before evolution
\end_layout

\begin_layout Itemize

\family typewriter
ops:
\family default
 opeartors that will be applied at each generation.
 
\end_layout

\begin_layout Itemize

\family typewriter
postOps:
\family default
 operators that will be applied after evolution.
\end_layout

\begin_layout Itemize

\family typewriter
end:
\family default
 ending generation.
 Default to -1.
 In this case, a simulator will only be ended by a terminator.
\end_layout

\begin_layout Itemize

\family typewriter
dryrun:
\family default
 dryrun mode.
 see previous section
\end_layout

\begin_layout Itemize

\family typewriter
saveAs:
\family default
 saveAt, format: see next section
\end_layout

\begin_layout Section
Save and Load
\end_layout

\begin_layout Standard
A simulator can be saved to a file in the format of 
\family typewriter
'txt', 'bin'
\family default
, or 
\family typewriter
'xml'
\family default
.
 This enables us to stop a simulation and resume it at another time or on
 another machine.
 It is also a good idea to save a snapshot of a simulation every several
 generations.
 Note that mating scheme can not be saved and has to be re-specified in
 
\family typewriter
LoadSimulator
\begin_inset LatexCommand index
name "loadSimulator"

\end_inset

()
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
save and load a simulator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/simulatorsaveload.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
simulators can also be saved during evolution.
 Three relevant parameters of 
\family typewriter
evolve()
\family default
 function are:
\end_layout

\begin_layout Itemize

\family typewriter
saveAs:
\family default
 filename to save the simulator.
 Default to 
\family typewriter
simu
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
saveAt:
\family default
 generations at which to save the simulator.
 Generation can be negative, meaning counting backwards.
\end_layout

\begin_layout Itemize

\family typewriter
format:
\family default
 format.
 Default to 'bin'.
\end_layout

\begin_layout Standard
During evolution, simulator will be saved at 
\family typewriter
saveAt
\family default
 generations with filenames 
\family typewriter
saveAs+gen+format
\family default
 (for example 
\family typewriter
simu1000.bin
\family default
).
\end_layout

\begin_layout Standard
It is also possible to build a simulator from a bunch of populations:
\end_layout

\begin_layout Itemize

\family typewriter
SimulatorFromPops(pops, mating)
\family default
, build a simulator with given populations and mating scheme
\end_layout

\begin_layout Itemize

\family typewriter
SimulatorFromFiles(files, mating)
\family default
, load populations from a given list of files (population images) and build
 a simulator with given mating scheme.
\end_layout

\begin_layout Chapter
Option handling
\end_layout

\begin_layout Section
Conventions of simuPOP scripts
\end_layout

\begin_layout Standard
A simuPOP script is usually composed of the following parts:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout LyX-Code
#!/usr/bin/env python
\end_layout

\end_deeper
\begin_layout Enumerate
Introduction to the whole script:
\end_layout

\begin_deeper
\begin_layout LyX-Code
'''
\end_layout

\begin_layout LyX-Code
This script simulates ....
\end_layout

\begin_layout LyX-Code
'''
\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Options: (see the next section)
\end_layout

\begin_deeper
\begin_layout LyX-Code
options = [ 
\end_layout

\begin_layout LyX-Code
...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
\end_layout

\end_deeper
\begin_layout Enumerate
Auxillary functions
\end_layout

\begin_layout Enumerate
Evolution function
\end_layout

\begin_deeper
\begin_layout LyX-Code
def simulation(....)
\end_layout

\end_deeper
\begin_layout Enumerate
Executable part:
\end_layout

\begin_deeper
\begin_layout LyX-Code
if __name__ == '__main__':  
\end_layout

\begin_layout LyX-Code
  allParam = simuOpt.getParam(options,
\end_layout

\begin_layout LyX-Code
    ''' A short description ''', __doc__)
\end_layout

\begin_layout LyX-Code
  # if user press cancel,
\end_layout

\begin_layout LyX-Code
  if len(allParam) == 0:
\end_layout

\begin_layout LyX-Code
    sys.exit(1)
\end_layout

\begin_layout LyX-Code
  # -h or --help
\end_layout

\begin_layout LyX-Code
  if allParam[0]:  
\end_layout

\begin_layout LyX-Code
    print simuOpt.usage(options, __doc__)
\end_layout

\begin_layout LyX-Code
    sys.exit(0)
\end_layout

\begin_layout LyX-Code
  # sace configuration, something like
\end_layout

\begin_layout LyX-Code
  if allParam[-2] != None:
\end_layout

\begin_layout LyX-Code
     simuOpt.saveConfig(options, allParam[-2]+'.cfg', allParam)  
\end_layout

\begin_layout LyX-Code
  # get the parameters, something like
\end_layout

\begin_layout LyX-Code
  N = allParam[1]
\end_layout

\begin_layout LyX-Code
  # run the simulation
\end_layout

\begin_layout LyX-Code
  simulation(N) 
\end_layout

\begin_layout LyX-Code
  
\end_layout

\end_deeper
\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, print usage, save configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
\end_layout

\begin_layout Standard
Note that these scripts, if proper written, can also be imported.
 Other scripts (or interactive session) can import a script and call its
 simulation function directly.
\end_layout

\begin_layout Section
Parameter handling and user input 
\end_layout

\begin_layout Standard
Although simuPOP scripts, simply Python scripts, can be in any valid Python
 style, it is highly recommended that all simuPOP scripts follow the same
 writing style and provide a uniform interface to users.
 From a user's point of view, a simuPOP script 
\family typewriter
cmd.py
\family default
 should
\end_layout

\begin_layout Enumerate
Start a Tk/wxPython dialog to accept user input when 
\family typewriter
--noDialog
\family default
 is not specified.
\end_layout

\begin_layout Enumerate
List all commandline/config file options through 
\family typewriter
-h
\family default
 or 
\family typewriter
--help
\family default
 option.
 
\end_layout

\begin_layout Enumerate
Accept 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
 parameter to read a configuration file and set parameters.
\end_layout

\begin_layout Enumerate
Be able to use command line arguments to set parameters if 
\family typewriter
--useDefault
\family default
 is not specified.
\end_layout

\begin_layout Enumerate
When 
\family typewriter
--noDialog
\family default
 and 
\family typewriter
--useDefault
\family default
 is specified, use default values for all parameters, if they can not be
 obtained from commandline parameters, configuration file, and have a default
 value.
\end_layout

\begin_layout Enumerate
Accept 
\family typewriter
--saveconfig file
\family default
 to save current configuration (input my commandline argument) into 
\family typewriter
file
\family default
.
\end_layout

\begin_layout Enumerate
Be able to make use of optimized libraries through the use of command line
 parameter ( 
\family typewriter
--optimized
\family default
), config file entry (
\family typewriter
optimized=True
\family default
) or environment variable (
\family typewriter
SIMUOPTIMIZED
\family default
).
 
\end_layout

\begin_layout Enumerate
Be able to make use of longallele libraries through the use of command line
 parameter (
\family typewriter
--longallele
\family default
), config file entry (
\family typewriter
longallele=True
\family default
) or environment variable (
\family typewriter
SIMULONGALLELE
\family default
).
 
\end_layout

\begin_layout Standard
To alleviate throuble of doing all these, 
\family typewriter
simuPOP
\family default
 has provided a set of functions.
 Here is how parameters should be handled.
 The first step is decribe each parameter in details.
 This includes (not all is necessary) short and long argument name, entry
 on a configuration file, prompt when asking for user input, default value,
 description that will be shown in usage, allowed types of parameter, function
 to validate the input value.
 All these should be put in a list of dictionaries like follows:
\end_layout

\begin_layout LyX-Code
options = [
\end_layout

\begin_layout LyX-Code
  { 'arg':'h', 'longarg':'help', 'default':False,
\end_layout

\begin_layout LyX-Code
    'allowedTypes':[IntType],
\end_layout

\begin_layout LyX-Code
    'description':'print this message'},
\end_layout

\begin_layout LyX-Code
  { 'longarg':'saveconfig=', 'default':'', 'allowedTypes':[StringType],
\end_layout

\begin_layout LyX-Code
    'description':'Save current configuration in a file.'},
\end_layout

\begin_layout LyX-Code
  { 'arg':'m', 'longarg':'mu', 'label'='mutationRate', 
\end_layout

\begin_layout LyX-Code
    'default':0.005,
\end_layout

\begin_layout LyX-Code
    'validate': simuOpt.valueBetween(0,1),
\end_layout

\begin_layout LyX-Code
    'description':'mutation rate (a number or an array of numbers) at each
 loci'
\end_layout

\begin_layout LyX-Code
  } ]
\end_layout

\begin_layout Standard
The entries:
\end_layout

\begin_layout Itemize

\family typewriter
arg
\family default
 and 
\family typewriter
longarg
\family default
 are command line argument format.
 For example,
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
arg:'h'
\family default
 checks the presence of argument 
\family typewriter
-h
\family default
, return 
\family typewriter
True
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
arg:'f:'
\family default
 checks the presence of argument pair 
\family typewriter
-f something
\family default
, return 
\family typewriter
something
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
longarg:'help'
\family default
 cheks the prescence of argument 
\family typewriter
--longarg
\family default
, return 
\family typewriter
True
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
longarg:'mu='
\family default
 checks the presence of argument pair 
\family typewriter
--mu number
\family default
, return 
\family typewriter
number
\family default
 if succeeds.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
label
\family default
 will be used as the label of input field in a parameter dialog, and as
 the prompt for user input.
\end_layout

\begin_layout Itemize

\family typewriter
default
\family default
 is used when prompt is empty, or when user press enter directly.
\end_layout

\begin_layout Itemize

\family typewriter
useDefault
\family default
 use default value without asking, if the value can not be determined from
 GUI, command line option or config file.
 This is useful for options that rarely need to be changed.
 Setting them to 
\family typewriter
useDfault
\family default
 allows shorter command lines, and easier user input.
 
\end_layout

\begin_layout Itemize

\family typewriter
description
\family default
 is the description of this parameter, will be put into usage information.
 ( 
\family typewriter
-h
\family default
 or help button in parameter dialog).
\end_layout

\begin_layout Itemize

\family typewriter
allowedTypes
\family default
 is the accepted types.
 If 
\family typewriter
allowedTypes
\family default
 is 
\family typewriter
types.ListType
\family default
 or 
\family typewriter
types.TupleType
\family default
 and user input is a scalar, the input will be converted to a list automatically.
\end_layout

\begin_layout Itemize

\family typewriter
validate
\family default
 is a function to validate the parameter.
 You can define your own functions or use the following from 
\family typewriter
simuOpt
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
valueGT(a), valueLT(a), valueGE(a), valueLE(a)
\family default
: check greater than, less than, greater equal, less equal to a value 
\family typewriter
a.
\end_layout

\begin_layout Itemize

\family typewriter
valueBetween(a,b), valueOneOf(list):
\family default
 check if the value is between 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 or is one of 
\family typewriter
list
\end_layout

\begin_layout Itemize

\family typewriter
valueValidFile(), valueValidDir():
\family default
 check if the parameter is a valid file/directory name.
\end_layout

\begin_layout Itemize

\family typewriter
valueIsNum():
\family default
 check if the parameter is a number.
\end_layout

\begin_layout Itemize

\family typewriter
valueListOf():
\family default
 check if parameter is a list of given type, in a list of types, or pass
 a validator.
 For example, you can use 
\family typewriter
valueListOf(types.IntType)
\family default
, 
\family typewriter
valueListOf([types.IntType, types.LongType])
\family default
 or 
\family typewriter
valueListOf( valueValidFile()).

\family default
 As you can see, validators can be nested.
\end_layout

\begin_layout Itemize

\family typewriter
valueOr(validator), valueAnd(val1, val2), valueOr(val1,val2)
\family default
 accepts other validators and perform respective logical calculation.
 For example
\end_layout

\begin_deeper
\begin_layout LyX-Code
valueOr( valueGT(0), valueListOf( valueGT(0) ))
\end_layout

\begin_layout Standard
accept a positive number, or a list of positive number.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family typewriter
chooseOneOf:
\family default
 If specified, 
\family typewriter
simuOpt
\family default
 will choose one from a list of values using a listbox (tk) or a combo box
 (wxPython) .
\end_layout

\begin_layout Itemize

\family typewriter
chooseFrom:
\family default
 If specified, 
\family typewriter
simuOpt
\family default
 will choose one or more items from a list of values using a listbox (tk)
 or a combo box (wxPython) .
 
\end_layout

\begin_layout Itemize

\family typewriter
separator:
\family default
 if specified, a blue label will be used to separate groups of parameters.
\end_layout

\begin_layout Itemize

\family typewriter
jump:
\family default
 jump is used to skip some parameter when doing interative user input.
 For example, 
\family typewriter
getParam
\family default
 will skip the rest of the parameters if 
\family typewriter
-h
\family default
 is specified since parameter 
\family typewriter
-h
\family default
 has item 
\family typewriter
'jump':-1
\family default
 which means jump to the end.
 Another use of this value is when you have a hierarchical parameter sets.
 For example, if mutation is on, specify mutation rate, otherwise proceed....
 
\end_layout

\begin_layout Itemize

\family typewriter
jumpIfFalse:
\family default
 The same as 
\family typewriter
jump
\family default
 but jump if current parameter is false.
\end_layout

\begin_layout Standard
With all these information at hand, the rest is routine, if you follow the
 coding conventions.
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
Operator and Function References
\end_layout

\begin_layout Standard
This chapter will list all functions, types and operators by category.
\end_layout

\begin_layout Section
Library-dependent functions/constants
\end_layout

\begin_layout Standard
Several functions and constants are defined for each library
\end_layout

\begin_layout Itemize

\family typewriter
alleleType()
\family default
: return 
\family typewriter
'binary'
\family default
, 
\family typewriter
'short'
\family default
, or 
\family typewriter
'long'
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
MaxAllele
\family default
: 1 for binary libraries, usually 255 for short libraries and 
\begin_inset Formula $2^{32}-1$
\end_inset

 for long libraries.
 Note that this number for short and long libraries might change on different
 platforms.
\end_layout

\begin_layout Itemize

\family typewriter
simuVer()
\family default
: return version string
\end_layout

\begin_layout Itemize

\family typewriter
simuRev()
\family default
: simuPOP revision number.
 If your script needs a recent version of simuPOP, it is a good idea to
 test 
\family typewriter
simuRev()
\family default
 against the revision when the feature you need became available.
\end_layout

\begin_layout Section

\family typewriter
carray
\begin_inset LatexCommand index
name "carray"

\end_inset


\family default
 type
\end_layout

\begin_layout Standard
The return value of simuPOP functions that start with 
\family typewriter
arr
\family default
 is of a special python type 
\family typewriter
carray
\family default
.
 This object reflects the underlying C/C++ array and you can read/write
 array element just as a regular list.
 Only a small subset of list member functions, 
\family typewriter
count, index
\family default
 to be exact, are available.
 This is because you are not allowed to change the size of underlying C/C++
 vector.
 The following is the operations allowed:
\end_layout

\begin_layout LyX-Code
# obtain an object using one of the arrXXX functions
\end_layout

\begin_layout LyX-Code
pop = population(loci=[3,4], lociPos=[1,2,3,4,5,6,7])
\end_layout

\begin_layout LyX-Code
arr = pop.arrLociPos()
\end_layout

\begin_layout LyX-Code
# print and expression (just like list)
\end_layout

\begin_layout LyX-Code
print arr
\end_layout

\begin_layout LyX-Code
str(arr)
\end_layout

\begin_layout LyX-Code
# count
\end_layout

\begin_layout LyX-Code
arr.count(2)
\end_layout

\begin_layout LyX-Code
# index 
\end_layout

\begin_layout LyX-Code
arr.index, 2)
\end_layout

\begin_layout LyX-Code
# can read write
\end_layout

\begin_layout LyX-Code
arr[0] = 0.5
\end_layout

\begin_layout LyX-Code
# convert to list
\end_layout

\begin_layout LyX-Code
arr.tolist()
\end_layout

\begin_layout LyX-Code
# or simply
\end_layout

\begin_layout LyX-Code
list(arr)
\end_layout

\begin_layout LyX-Code
# compare to list directly
\end_layout

\begin_layout LyX-Code
arr == [0.5, 1.0, 3.0, 3.5, 5.0, 6.0, 7.0]
\end_layout

\begin_layout LyX-Code
# you can also convert and compare
\end_layout

\begin_layout LyX-Code
list(arr) == [0.5, 1.0, 3.0, 3.5, 5.0, 6.0, 7.0])
\end_layout

\begin_layout LyX-Code
# slice
\end_layout

\begin_layout LyX-Code
arr[:] = [1,2,3,4,5,6,7]
\end_layout

\begin_layout LyX-Code
# arr1 is 1,2,3
\end_layout

\begin_layout LyX-Code
arr1 = arr[:3]
\end_layout

\begin_layout LyX-Code
# assign slice from a number
\end_layout

\begin_layout LyX-Code
# IMPORTANT NOTE that arr will also be affected
\end_layout

\begin_layout LyX-Code
# since arr1 point to a part of arr
\end_layout

\begin_layout LyX-Code
arr1[:] = 10
\end_layout

\begin_layout LyX-Code
# assign vector of the same length
\end_layout

\begin_layout LyX-Code
arr1[:] = [30,40]
\end_layout

\begin_layout LyX-Code
# assign from another part
\end_layout

\begin_layout LyX-Code
arr[1:3] = arr[3:5]
\end_layout

\begin_layout Standard
No other operation is allowed.
 
\end_layout

\begin_layout Standard

\series bold
Important note:
\series default
 Objects returned from 
\family typewriter
arrXXX
\family default
 functions should be considered temporary.
 There is no gurantee the underlying array will still be valid after any
 population operation.
 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Use of R (RPy) in Python
\end_layout

\begin_layout Standard
Most of the info can be found in rpy manual.
 One function in simuRPy may help though:
\end_layout

\begin_layout LyX-Code
def rmatrix(mat):
\end_layout

\begin_layout LyX-Code
  ' convert a python 2d list to r.matrix object'
\end_layout

\begin_layout LyX-Code
  return with_mode(NO_CONVERSION, r.do_call)('rbind',mat)
\end_layout

\begin_layout Standard
with this function, you can easily handle matrices in R.
 (List and array has been easy enough to be handled).
\end_layout

\begin_layout LyX-Code
>>> a = [[1,2],[4,5]]
\end_layout

\begin_layout LyX-Code
>>> r.image( rmatrix(a))
\end_layout

\begin_layout Standard
With the help of this function, you can call almost any R function directly,
 maybe except some R-only syntax like formula, expression etc.
 In this case, you can always do
\end_layout

\begin_layout LyX-Code
>>> r('''whatever R expression''')
\end_layout

\begin_layout Standard
Since Rpy is not always available, you may see the following scenario again
 and again in simuPOP scripts:
\end_layout

\begin_layout LyX-Code
try:
\end_layout

\begin_layout LyX-Code
  from simuRPy import *
\end_layout

\begin_layout LyX-Code
except:
\end_layout

\begin_layout LyX-Code
  hasRPy = False
\end_layout

\begin_layout LyX-Code
else:
\end_layout

\begin_layout LyX-Code
  hasRPy = True
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
if hasRPy:
\end_layout

\begin_layout LyX-Code
  r.....
\end_layout

\begin_layout Section
Operator (Hybrid) 
\family typewriter
pyOperator
\begin_inset LatexCommand index
name "operator!pyOperator"

\end_inset

, pyIndOperator
\begin_inset LatexCommand index
name "operator!pyIndOperator"

\end_inset


\end_layout

\begin_layout Standard
This is the single most powerful hybrid operator.
 Whenever you think that something is too complicated to be done by standard
 operators, you can do it here in python.
 This operator accepts a Python function which accepts a population and
 optionally a parameter.
 To use this operator, you will need to 
\end_layout

\begin_layout Itemize
define a function that handle a population as you wish.
\end_layout

\begin_deeper
\begin_layout LyX-Code
def myOperator(pop, para):
\end_layout

\begin_layout LyX-Code
  ' do whatever you want'
\end_layout

\begin_layout LyX-Code
  return True
\end_layout

\begin_layout Standard
If you return 
\family typewriter
False
\family default
, this operator will work like a terminator.
 
\family typewriter
para
\family default
 be ommitted.
\end_layout

\end_deeper
\begin_layout Itemize
use 
\family typewriter
pyOperator
\family default
 like
\end_layout

\begin_deeper
\begin_layout LyX-Code
pyOperator(mfunc=yOperator, param=para)
\end_layout

\begin_layout Standard
all parameters of an operator are supported except for 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
 which are ignored for now.
\end_layout

\end_deeper
\begin_layout Standard
When 
\family typewriter
pyOperator
\family default
 is called, it will simply pass the accepted population to the function.
 If your function returns 
\family typewriter
False
\family default
, the simulation will be stopped.
\end_layout

\begin_layout Standard
This operator allows implementation of arbitrarily complicated operators,
 at a cost of efficiency.
 Of course, to use this operator, you will have to know how to use population-re
lated functions.
 The following example shows how to implement a dynamic mutator which mutate
 loci according to their allele frequency.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
define a python operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pyOperator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
use of python operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pyOperatorUse.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\end_layout

\begin_layout Itemize
Currently, 
\family typewriter
pyOperator
\family default
 does not support parameter 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
.
 This is because of the incompatibility between the Python way and underlying
 C++ way of handling file I/O stream.
 Consequently, you will have to handle file input/output by yourself through
 
\family typewriter
param
\family default
 parameter.
 Be careful that you 
\series bold
can not
\series default
 mix output of 
\family typewriter
pyOperator
\family default
 with those of other (normal) operators.
\end_layout

\begin_layout Itemize
If parameter 
\family typewriter
param
\family default
 is ignored, 
\family typewriter
myOperator
\family default
 must be without 
\family typewriter
para
\family default
 as well.
 Note that you can pass arbitrary number of parameters by putting them into
 a tuple and pass to 
\family typewriter
myOpeartor.
\end_layout

\begin_layout Itemize
Since you can attach any information to a population, you can in practise
 use 
\family typewriter
pop.dvars()
\family default
 to pass parameters.
\end_layout

\begin_layout Itemize

\family typewriter
pyOperator
\family default
 is a post-mating operator by default.
 Remember to use 
\family typewriter
stage
\family default
 parameter to change this when necessary.
\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 can also be a DuringMating operator, you will need to define a function
 
\end_layout

\begin_layout LyX-Code
def Func(pop, off, dad, mom, para)
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
def shortFunc(off, para)
\end_layout

\begin_layout Standard
where 
\family typewriter
para
\family default
 can be ignored.
 To use this operator, you can do
\end_layout

\begin_layout LyX-Code
pyOperator(stage=DuringMating, func=Func, param=someparam, formOffGenotype=True)
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
pyOperator(stage=DuringMating, func=shortFunc, param=someparam,
\end_layout

\begin_layout LyX-Code
formOffGenotype=False, passOffspringOnly=True)
\end_layout

\begin_layout Standard
The two additional parameters are:
\end_layout

\begin_layout Itemize

\family typewriter
formOffGenotype: (
\family default
default to 
\family typewriter
False)
\family default
 By default, a mating scheme will set the genotype of offspring by copy
 one of the parental chromosomes.
 However, if 
\family typewriter
formOffGenotype
\family default
 is true, the mating scheme will let you do the job.
 You will have to set offspring genotype and sex by yourself.
\end_layout

\begin_layout Itemize

\family typewriter
passOffspringOnly:
\family default
 In case that your function will only deal with offspring, you can set this
 parameter to true and use a shorter form of the function.
 
\end_layout

\begin_layout Standard
Note that if your duringMating pyOpeartor returns False, the individual
 will be discarded.
 Therefore, you can write a filter in this way.
 However, since the python function will be called for each mating event,
 the cost of using such an operator is high, especially when population
 size is big.
\end_layout

\begin_layout Standard
An example of duringMating pyOperator can be found in 
\family typewriter
scripts/demoPyOperator.py
\family default
.
\end_layout

\begin_layout Standard
Another general python operator is 
\family typewriter
pyIndOperator
\family default
, it is similar to 
\family typewriter
pyOpertor
\family default
 but it passes the user individuals, rather than the whole population.
 
\end_layout

\begin_layout LyX-Code
def func(ind, param):
\end_layout

\begin_layout LyX-Code
  ind.setInfo(param[0], 'myinfo)
\end_layout

\begin_layout LyX-Code
pyIndOperator(func=func, param=(1,))
\end_layout

\begin_layout Standard
is the same as
\end_layout

\begin_layout LyX-Code
def func(pop, param):
\end_layout

\begin_layout LyX-Code
  for ind in pop.individuals():
\end_layout

\begin_layout LyX-Code
    ind.setInfo(param[0], 'myinfo')
\end_layout

\begin_layout LyX-Code
pyIndOperator(func=func, param=(1,))
\end_layout

\begin_layout Standard
The 
\family typewriter
pyIndOperator
\family default
 may have some performance advantage over 
\family typewriter
pyOperator
\family default
 in some cases.
\end_layout

\begin_layout Section
Initialization
\begin_inset LatexCommand index
name "initializer"

\end_inset


\end_layout

\begin_layout Standard
Initializers are used to initialize populations before evolution.
 They are set to be PreMating operators by default.
 simuPOP provides three initializers, one assigns alleles by random, one
 assigns a fixed set of genotype, and the last one calls a user-defined
 function.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
initByFreq
\begin_inset LatexCommand index
name "operator!initByFreq"

\end_inset

,
\family default
 function 
\family typewriter
InitByFreq
\begin_inset LatexCommand index
name "function!InitByFreq"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
initByFreq
\family default
 operator accepts 
\family typewriter
alleleFreq
\family default
 or 
\family typewriter
alleleFreqs
\family default
.
 The first one ignores subpopulation structure while the second one gives
 different initial allele frequencies to different subpop or ranges.
 These parameters are
\end_layout

\begin_layout Itemize

\family typewriter
subPop:
\family default
 specifies applicable subpopulations.
 If 
\family typewriter
alleleFreqs
\family default
 are given, 
\family typewriter
alleleFreqs
\family default
 should have the same length as subPop.
 (One freq each subPop)
\end_layout

\begin_layout Itemize

\family typewriter
indRange
\family default
: range(s) of absolute index of individuals.
 I.e., one (
\family typewriter
[1,2]
\family default
) or more (
\family typewriter
[[1,4],[5,6]]
\family default
) ranges are acceptable.This is how you can initialize individuals differently
 within subpopulations.
 Note that ranges are in the form of 
\family typewriter
[a,b)
\family default
.
 I.e., range 
\family typewriter
[4,6]
\family default
 will intialize individual 4, 5, but not 6.
 As a shortcut for 
\family typewriter
[4,5]
\family default
, you can use 
\family typewriter
[4]
\family default
 to specify one individual.
 (Note that some earlier versions of simuPOP may use [4,6] for 4,5 and 6.
 I changed this to let the range specification in line with the Python conventio
n.)
\end_layout

\begin_layout Itemize

\family typewriter
atLoci:
\family default
 loci at which initialization will be done.
\end_layout

\begin_layout Itemize

\family typewriter
maleFreq:
\family default
 intialize sex with this male frequency.
\end_layout

\begin_layout Itemize

\family typewriter
identicalInds:
\family default
 if true, copy the genotype of the first randomly initialized individual
 to other individuals in the subpop/range.
 
\end_layout

\begin_layout Standard
Here is an example of using 
\family typewriter
alleleFreq
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Init by freq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/initByFreq.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to 
\family typewriter
test/test_init.py
\family default
 for more complicated examples.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
initByValue
\begin_inset LatexCommand index
name "operator!initByValue"

\end_inset

,
\family default
 function 
\family typewriter
InitByValue
\begin_inset LatexCommand index
name "function!InitByValue"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
initByValue
\family default
 operator gets the one copy of chromosomes or the whole genotype (or of
 those corresponds to 
\family typewriter
atLoci
\family default
) of an individual and copy them to all or subset of individuals.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Init by value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/initByValue.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Parameters 
\family typewriter
subPop, indRange, atLoci, maleFreq
\family default
 are also supported.
 Note that
\end_layout

\begin_layout Itemize
If 
\family typewriter
value
\family default
 is an array of values, it should have the same length as 
\family typewriter
subpop, indRange
\family default
 or 
\family typewriter
proportions
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
proportions
\family default
: if given, assign given genotypes randomly.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
spread
\begin_inset LatexCommand index
name "operator!spread"

\end_inset

,
\family default
 function 
\family typewriter
Spread
\begin_inset LatexCommand index
name "function!Spread"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
Spread(ind, subPop)
\family default
 spread the genotype of ind to all individuals in an array of subpopulations.
 The default value of subPop is the subpopulation where ind resides.
\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyInit
\begin_inset LatexCommand index
name "operator!pyInit"

\end_inset

,
\family default
 function 
\family typewriter
PyInit
\begin_inset LatexCommand index
name "function!PyInit"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyInit
\family default
 is a hybrid initializer.
 User should define a function with parameters allele, ploidy and subpop
 indices, and return an allele value.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Init by value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pyInit.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Migration
\begin_inset LatexCommand index
name "migrator"

\end_inset


\end_layout

\begin_layout Standard
Mating is strictly within subpopulations in simuPOP so migrator is the only
 way to mix genotypes of several subpopulations.
 Migrators are quite flexible in simuPOP in the sense that
\end_layout

\begin_layout Itemize
Migration can happen from and to a subset of subpopulations.
\end_layout

\begin_layout Itemize
Migration can be done by probability, proportion or by counts.
 In the case of probability, 
\end_layout

\begin_deeper
\begin_layout Itemize
if the migration rate from subpopulation 
\family typewriter
a
\family default
 to 
\family typewriter
b
\family default
 is 
\begin_inset Formula $r$
\end_inset

, then everyone in subpopulation 
\family typewriter
a
\family default
 will have this probability to migrate to 
\family typewriter
b
\family default
.
 
\end_layout

\begin_layout Itemize
In the case of proportion, exactly 
\family typewriter
r*size_of_subPop_a
\family default
 individuals (chosen by random) will migrate to subpop b.
 
\end_layout

\begin_layout Itemize
In the last case, a given number of individuals will migrate.
\end_layout

\end_deeper
\begin_layout Itemize
New subpopulation can be generated through migration.
 You simply need to migrate to a new subpop number.
 
\end_layout

\begin_layout Standard
Note that overall population size will not change.
 (Mating schemes can do that).
 If you would like to keep subpop size after migration, you can use the
 
\family typewriter
newSubPopSize
\family default
 or 
\family typewriter
newSubPopSizeExpr
\family default
 parameter of a mating scheme.
\end_layout

\begin_layout Subsection
Constants: 
\family typewriter
MigrByProbability
\begin_inset LatexCommand index
name "constant!MigrByProbability"

\end_inset

, MigrByProportion
\begin_inset LatexCommand index
name "constant!MigrByProportion"

\end_inset

, MigrByCount
\begin_inset LatexCommand index
name "constant!MigrByCount"

\end_inset


\end_layout

\begin_layout Standard
Possible values of parameter 
\family typewriter
mode
\family default
.
\end_layout

\begin_layout Subsection
Opertor (C++) 
\family typewriter
migrator
\begin_inset LatexCommand index
name "operator!migrator"

\end_inset


\end_layout

\begin_layout Standard
Opertor 
\family typewriter
migrator
\family default
 is used to migrate from 
\family typewriter
'fromSubPop'
\family default
 to 
\family typewriter
'toSubPop'.

\family default
 From and to subpop can be a number or an array of subpopulations.
 The migration probability/rate/counts from 
\family typewriter
i->j
\family default
 is specified in the rate matrix.
 The 
\family typewriter
'fromSubPop'
\family default
 and 
\family typewriter
'toSubPop'
\family default
 are default to all subpopulations.
\end_layout

\begin_layout Standard
An detailed example can be found in 'some real examples' -> 'complex Migration
 Scheme' section.
\end_layout

\begin_layout Subsection
Functions (Python) 
\family typewriter
MigrIslandRates
\begin_inset LatexCommand index
name "Function!migrIslandRates"

\end_inset

, MigrStepstoneRates
\begin_inset LatexCommand index
name "Function!migrStepstoneRates"

\end_inset


\family default
 (simuUtil.py)
\end_layout

\begin_layout Standard
Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpops to
 any (even new) other subset of subpops.
 Several functions are defined in simuUtil.py, however, for easy use of popular
 migration models:
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrStepstoneRates(r,n,circular=False)
\family default
 returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default

\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
A lot of such functions may be defined later.
 I guess 2-d stepstone will be the first one?
\end_layout

\begin_layout Subsection
Operator (C++/Hybrid) 
\family typewriter
pyMigrator
\begin_inset LatexCommand index
name "operator!pyMigrator"

\end_inset


\end_layout

\begin_layout Standard
For evan more complicated migration schemes, you do DIY it using a 
\family typewriter
pyMigrator
\family default
.
 This operator is not strictly hybrid since it does not call python function.
 However, it takes a 
\family typewriter
carray
\family default
 as subPop id for each individual.
 
\family typewriter
pyMigrator
\family default
 then complete migration according its content.
 For example:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
pyMigrator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pyMigrator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\end_layout

\begin_layout Itemize
the application sequence of the operators is 
\family typewriter
initByFreq
\family default
, 
\family typewriter
dumper, pyMigrator
\family default
 and then 
\family typewriter
dumper
\family default
 again since its stage is set to 
\family typewriter
PrePostMating
\family default
.
\end_layout

\begin_layout Itemize
Usually you will use a 
\family typewriter
pyEval
\family default
 operator to re-assign 
\family typewriter
spID
\family default
 during evolution.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
splitSubPop
\family default

\begin_inset LatexCommand index
name "operator!splitSubPop"

\end_inset

, function 
\family typewriter
SplitSubPop
\begin_inset LatexCommand index
name "function!SplitSubPop"

\end_inset


\end_layout

\begin_layout Standard
This operator takes parameters
\end_layout

\begin_layout Itemize
which: which subpopulation to split.
 If there is no subpopulation structure, use 0 as the first (and only) subpopula
tion.
\end_layout

\begin_layout Itemize
sizes: new subpopulation sizes.
 The sizes should add up to the original subpopulation (subpop which) size.
\end_layout

\begin_layout Itemize
proportions: Optionally, you can specify proportions of new subpops.
 (easier to use) The proportions should add up to 1.
\end_layout

\begin_layout Itemize
subPopID: the operator will automatically set new subpop ID to new subpops.
 You can also specify the IDs.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mergeSubPops
\family default

\begin_inset LatexCommand index
name "operator!mergeSubPops"

\end_inset

, function 
\family typewriter
MergeSubPops
\begin_inset LatexCommand index
name "function!MergeSubPops"

\end_inset


\end_layout

\begin_layout Standard
This operator merges subPopulations 
\family typewriter
subPops
\family default
 (the only parameter) to a single subpopulation.
 If 
\family typewriter
subPops
\family default
 are ignored, all subpopulations will be merged.
\end_layout

\begin_layout Section
Mutation
\begin_inset LatexCommand index
name "Mutation"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
rate
\begin_inset LatexCommand index
name "rate"

\end_inset


\family default
 can be a number (uniform rate) or an array of mutation rates, 
\family typewriter
atLoci
\begin_inset LatexCommand index
name "atLoci"

\end_inset


\family default
 is defaulted to all loci.
 The only differences between the following mutors are they way they actually
 mutate an allele, and corresponding input parameters.
\end_layout

\begin_layout Standard
Mutators record the number of mutation events at each loci.
 You can retrieve this information using
\end_layout

\begin_layout LyX-Code
mut.mutationCount(locus)
\end_layout

\begin_layout LyX-Code
mut.mutationCounts()
\end_layout

\begin_layout Standard
where 
\family typewriter
mut
\family default
 is any mutator and 
\family typewriter
locus
\family default
 is locus index.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
kamMutator
\begin_inset LatexCommand index
name "operator!kamMutator"

\end_inset

,
\family default
 function 
\family typewriter
KamMutate
\begin_inset LatexCommand index
name "function!KamMutate"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
kamMutator
\family default
 (K-allele mutator
\begin_inset LatexCommand index
name "mutation!K-allele model"

\end_inset

) mutate an allele to another allelic state with equal probability.
 The specified mutation rate is actually 'probability to mutate' so the
 mutation rate to any other allelic state is actually 
\begin_inset Formula $\frac{r}{K-1}$
\end_inset

, where 
\begin_inset Formula $K$
\end_inset

 is specified by parameter 
\family typewriter
maxAllele
\family default

\begin_inset LatexCommand index
name "maxAllele"

\end_inset

.
 Here is an example of mutation:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
kamMutator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/kamMutator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also specify states for this mutator.
 If 
\family typewriter
states
\begin_inset LatexCommand index
name "kamMutator!states"

\end_inset


\family default
 parameter is given, all alleles must be one of the state and mutation will
 happen among them.
 
\family typewriter
states
\family default
 is defaulted to 
\family typewriter
1-maxAllele
\family default
.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
smmMutator
\begin_inset LatexCommand index
name "operator!smmMutator"

\end_inset

,
\family default
 function 
\family typewriter
SmmMutate
\begin_inset LatexCommand index
name "function!SmmMutate"

\end_inset


\end_layout

\begin_layout Standard
Stepwise mutation model
\begin_inset LatexCommand index
name "mutation!stepwise mutation model"

\end_inset

 (SMM) Mutation model assumes that alleles are represented by integer values
 and that a mutation either increases or decreases the allele value by one.
 For variable number tandem repeats loci (VNTR), the allele value is generally
 taken as the number of tandem repeats in the DNA sequence.
 
\end_layout

\begin_layout Standard
The following example demonstrate the use of 
\family typewriter
smmMutator
\family default
.
 Note that although the mutation rate is 1, some allele 1 is not mutated
 since they can not be mutated to 0.
 The same will hold for the upper bound 
\family typewriter
maxAllele
\family default
 which is defaulted to 99 in this case.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
smmMutator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/smmMutator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++/Hybrid) 
\family typewriter
gsmMutator
\begin_inset LatexCommand index
name "operator!gsmMutator"

\end_inset

,
\family default
 function 
\family typewriter
GsmMutate
\begin_inset LatexCommand index
name "function!GsmMutate"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Generalized stepwise model
\begin_inset LatexCommand index
name "mutation!generalized stepwise model"

\end_inset


\emph default
 is an extension to stepwise mutation model.
 In this model, the change in the allelic state is draw from a random distributi
on.
 A 
\emph on
geometric generalized stepwise model 
\begin_inset LatexCommand index
name "geometric generalized stepwise model"

\end_inset


\emph default
uses a geometric distribution with parameter 
\begin_inset Formula $p$
\end_inset

, which has mean 
\begin_inset Formula $\frac{p}{1-p}$
\end_inset

 and variance 
\begin_inset Formula $\frac{p}{\left(1-p\right)^{2}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Operator 
\family typewriter
gsmMutator
\family default
 implements both models.
 If you specify a python function without parameter, the operator will use
 its return value each time a mutation occur; otherwise, a parameter 
\begin_inset Formula $p$
\end_inset

 should be provided and the operator will act as a geometric generalized
 stepwise model.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
gsmMutator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/gsmMutator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyMutator
\begin_inset LatexCommand index
name "operator!pyMutator"

\end_inset

,
\family default
 function 
\family typewriter
PyMutate
\begin_inset LatexCommand index
name "function!PyMutate"

\end_inset


\end_layout

\begin_layout Standard
If you can not accomplish your task with the above normal mutator, you can
 always use this hybrid mutator.
 Mutation rate etc are set just like others and you are supposed to provide
 a python function to return a new allele state given an old state.
 
\family typewriter
pyMutator
\family default
 will choose an allele as usual and call your function to mutate it to another
 allele.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
pyMutator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pyMutator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
pointMutator
\begin_inset LatexCommand index
name "operator!pointMutator"

\end_inset

,
\family default
 function 
\family typewriter
PointMutate
\begin_inset LatexCommand index
name "function!PointMutate"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pointMutator,
\family default
 as its name suggest, does point mutation.
 It is syntax is:
\end_layout

\begin_layout LyX-Code
pointMutator(atLoci, toAllele, atPloidy=[], inds=[], ...)
\end_layout

\begin_layout Standard
This mutator will turn alleles at 
\family typewriter
atLoci
\family default
 on the first chromosome copy to 
\family typewriter
toAllele
\family default
 for individual 
\family typewriter
inds
\family default
.
 You can specify 
\family typewriter
atPloidy
\family default
 to mutate other, or all ploidy copy.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Recombination
\begin_inset LatexCommand index
name "recombination"

\end_inset


\end_layout

\begin_layout Standard
Only one recombinator is provided.
 Recombination events between loci a/b and b/c are independent.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
recombinator
\begin_inset LatexCommand index
name "operator!recombinator"

\end_inset


\end_layout

\begin_layout Standard
This operator takes similar parameters as a mutator.
 However, because of potentially uneven allelic distance, you should use
 one of the two parameters:
\end_layout

\begin_layout Itemize

\family typewriter
intensity:
\family default
 intensity of recombination.
 The actually recombination rate is 
\family typewriter
intensity*loci distance.
\end_layout

\begin_layout Itemize

\family typewriter
rate:
\family default
 recombination rate after all 
\family typewriter
afterLoci
\family default
.
 It can also be an array of recombination rates.
 Should have length 
\family typewriter
totNumLoci()
\family default
 or length of 
\family typewriter
afterLoci.

\family default
 The recombination rates are independent of loci distance.
\end_layout

\begin_layout Itemize

\family typewriter
afterLoci:
\family default
 recombine after loci 
\family typewriter
afterLoci.
 
\end_layout

\begin_layout Itemize

\family typewriter
maleIntensity, maleRate, maleAfterLoci:
\family default
 If you need to specify different recombination model for male and female,
 you can specify these parameters.
 In this case, 
\family typewriter
intensity, rate
\family default
 and 
\family typewriter
afterLoci
\family default
 will be treated as female parameters.
\end_layout

\begin_layout Standard
The following example forces recombination (with rate 1, an unrealistic
 value since the maximum recombination rate should be .5) at loci 2,6 and
 10.
 Here I use a 
\family typewriter
parentsTagger
\family default
 to mark the parents of each individual so you can (if you have enough patience)
 see exactly how recombination works.
 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Recombinator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/recombinator.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that if 
\family typewriter
sexChrom()
\family default
 is true, there is no recombination between the last chromosome (sex chromosomes
 XY) of male individuals.
 This may change later if the exchanges of genes between pseudoautosomal
 region of XY need to be modeled.
\end_layout

\begin_layout Standard
Recombinations after each locus will be recorded.
 You can retrieve this information through functions
\end_layout

\begin_layout LyX-Code
rec.recCount(locus)
\end_layout

\begin_layout LyX-Code
rec.recCounts()
\end_layout

\begin_layout Standard
where 
\family typewriter
rec
\family default
 is the recombinator, 
\family typewriter
locus
\family default
 is locus index.
 
\end_layout

\begin_layout Section
Selection
\begin_inset LatexCommand index
name "selection"

\end_inset

 
\end_layout

\begin_layout Subsection
Mechanism
\end_layout

\begin_layout Standard
Genetic selection is tricky to simulate since there are many difference
 
\emph on
fitness
\emph default
 values and many different way to apply selection.
 
\family typewriter
simuPOP
\family default
 employees an '
\emph on
ability-to-mate
\emph default
' approach.
 Namely, the probability that an individual will be chosen for mating is
 proportional to its fitness value.
 More specifically,
\end_layout

\begin_layout Itemize
PreMating selectors assign fitness values to each individual.
\end_layout

\begin_layout Itemize
During sexless mating (e.g.
 
\family typewriter
binomialSelection
\family default
), individuals are chosen at probabilities that are proportional to their
 fitness values.
 If there are 
\begin_inset Formula $N$
\end_inset

 individuals with fitness values 
\begin_inset Formula $f_{i},i=1,...,N$
\end_inset

, individual 
\begin_inset Formula $i$
\end_inset

 will have probability 
\begin_inset Formula $\frac{f_{i}}{\sum_{j}f_{j}}$
\end_inset

 to be chosen to be passed to the next generation.
\end_layout

\begin_layout Itemize
During 
\family typewriter
randomMating
\family default
, males and females are separated.
 Males and females are chosen from their respective groups in the same manner
 and mate.
 
\end_layout

\begin_layout Standard
It is not very clear that our method agrees with the traditional 'average
 number of offsprings' definition of fitness.
 (Note that this concept is very difficult to simulate since we do not know
 who will determine the number of offsprings if two parents are involved.)
 We can, instead, look at the consequence of selection in a simpler case
 (as derived in any population genetics textbook):
\end_layout

\begin_layout Quote
At generation 
\begin_inset Formula $t$
\end_inset

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset

 etc, should be
\end_layout

\begin_layout Quote
\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset


\end_layout

\begin_layout Standard
Now, using the ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset

 will be number of 
\begin_inset Formula $11$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, is exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset

The same argument applies to arbitrary number of genotypes and random mating.
 
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
selector along can not do selection! Only mating schemes can actually select
 on individuals.
\end_layout

\begin_layout Itemize
selector has to be 
\family typewriter
PreMating
\family default
 operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter
PreMating
\family default
.
 However, if you use the function form of these selectors in a 
\family typewriter
pyOperator
\family default
, make sure to set the stage of 
\family typewriter
pyOperator
\family default
 to 
\family typewriter
PreMating
\family default
.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapSelector
\begin_inset LatexCommand index
name "operator!mapSelector"

\end_inset

,
\family default
function 
\family typewriter
MapSelector
\begin_inset LatexCommand index
name "function!MapSelect"

\end_inset

 
\end_layout

\begin_layout Standard

\family typewriter
mapSelector
\family default
 implements selection at one locus.
 User should supply a dictionary (map) of fitness values for each genotype
 and this selector will set each individual's fitness value according to
 its genotype.
\end_layout

\begin_layout Standard
The following example is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequency will go to an equilibrium state.
 Theoretically, if
\begin_inset Formula \begin{eqnarray*}
s_{1} & = & w_{12}-w_{11}\\
s_{2} & = & w_{12}-w_{22}\end{eqnarray*}

\end_inset

the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
map selector
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/basicSelector.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maSelector
\begin_inset LatexCommand index
name "operator!maSelector"

\end_inset

,
\family default
 function 
\family typewriter
MaSelect
\begin_inset LatexCommand index
name "function!MaSelect"

\end_inset

 
\end_layout

\begin_layout Standard

\family typewriter
maSelector
\family default
 is called 'multiple-alleles
\begin_inset LatexCommand index
name "selection!multiple-alleles selection"

\end_inset

' selector.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter
wildtype
\family default
 and any other alleles are considered as diseased allele.
 
\family typewriter
maSelector
\family default
 accepts an array of fitness
\end_layout

\begin_layout Itemize
For single-locus, 
\family typewriter
fitness
\family default
 is the fitness for genotype AA, Aa, aa while A stands for wildtype alleles.
 
\end_layout

\begin_layout Itemize
For a two-locus model, 
\family typewriter
fitness
\family default
 is the fitness for genotype 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bb
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
AA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{12}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{13}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{21}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{22}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{23}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{31}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{32}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{33}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
in the order of 
\begin_inset Formula $w_{11},w_{12,}...,w_{32},w_{33}$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Itemize
For more than two-locus, use a table of length 
\begin_inset Formula $3^{n}$
\end_inset

 in a order similar to the two-locus model.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlSelector
\begin_inset LatexCommand index
name "operator!mlSelector"

\end_inset


\family default
, function 
\family typewriter
MlSelect
\begin_inset LatexCommand index
name "function!MlSelect"

\end_inset

 
\end_layout

\begin_layout Standard

\family typewriter
mlSelector
\family default
 is a 'multiple-loci model
\begin_inset LatexCommand index
name "selection!multiple-loci multiplicative model"

\end_inset

' selector.
 The selector takes a vector of selectors (can not be another 
\family typewriter
mlSelector
\family default
) and evaluate the fitness of an individual as the the product or sum of
 individual fitness values.
 The mode is determined by parameter 
\family typewriter
mode
\family default
, which takes the value
\end_layout

\begin_layout Subsubsection*
SEL_Multiplicative
\begin_inset LatexCommand index
name "constant!SEL\\_Multiplicative"

\end_inset

: 
\end_layout

\begin_layout Standard
The fitness is calculated as 
\begin_inset Formula $f=\prod_{i}f_{i}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
SEL_Additive
\begin_inset LatexCommand index
name "constant!SEL\\_Additive"

\end_inset

:
\end_layout

\begin_layout Standard
The fitness is calculated as 
\begin_inset Formula $f=\max\left(0,1-\sum_{i}(1-f_{i})\right)=\max\left(0,1-\sum_{i}s_{i}\right)$
\end_inset

.
 
\begin_inset Formula $f$
\end_inset

 is set to 0 when 
\begin_inset Formula $f<0$
\end_inset

.
 What is added are 
\begin_inset Formula $s_{i}$
\end_inset

, not 
\begin_inset Formula $f_{i}$
\end_inset

 directly.
\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pySelector
\begin_inset LatexCommand index
name "operator!pySelector"

\end_inset


\family default
, function 
\family typewriter
PySelect
\begin_inset LatexCommand index
name "function!PySelect"

\end_inset

 
\end_layout

\begin_layout Standard

\family typewriter
pySelector
\family default
 accept a list of susceptibility loci and a Python function.
 For each individual, this operator will pass the genotypes at these loci
 (in the order of 
\family typewriter
0-0,0-1,1-0,1-1
\family default
 etc where X-Y is locus X - ploidy Y, in case of diploid population), generation
 number, and expect a returned fitness value.
 This, at least in theory, can accommodate all selection scenarios.
 
\end_layout

\begin_layout Standard
The following example simulate the same scenario as above, with 
\begin_inset Formula $s_{1}=.2,s_{2}=.3$
\end_inset

 (so
\begin_inset Formula $p=.6$
\end_inset

) and a 
\family typewriter
pySelector
\family default
.
 Note that although alleles at two loci are passed, the 
\family typewriter
sel
\family default
 function only uses the first one.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
python selector
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/pySelector.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Penetrance
\begin_inset LatexCommand index
name "penetrance"

\end_inset


\end_layout

\begin_layout Standard
Penetrance is the probability that one will have the disease when he has
 certain genotype(s).
 Calculation of penetrance is similar to that of fitness.
 The parameter set is also similar.
 An individual will be randomly marked as affected/unaffected according
 to his penetrance value.
 For example, an individual will have .8 probability to be affected if the
 penetrance is .8.
 
\end_layout

\begin_layout Standard
Penetrance can be applied at any stage.
 The default stage is 
\family typewriter
DuringMating
\family default
.
 The penetrance will be calculated and affected status is set for each offspring
 during mating.
 You can also use penetrance as 
\family typewriter
PreMating, PostMating
\family default
 or even 
\family typewriter
PrePostMating
\family default
 operator.
 In these cases, affected status will be set to all individuals according
 to their penetrance value.
 It is also possible to store penetrance in a given information field if
 you provide on using the 
\family typewriter
infoFields
\family default
 parameter (e.g.
 
\family typewriter
infoFields=['penetrance']
\family default
).
 This is useful to actaully have a look at penetrance values and see if
 the values are as expected.
 
\end_layout

\begin_layout Standard
Affected status will be used for statistical purpose, and most importantly,
 ascertainment.
 They will be calculated along with fitness although they might not be used
 at every generation.
 You can use two operators: one for fitness/selection, active at every generatio
n; one for affected status, active only at ascertainment, to avoid unnecessary
 calculation of affected status.
\end_layout

\begin_layout Standard
Pentrance values are used to set the affectedness of individuals, and are
 usually not saved.
 If you would like to know the penetrance value, you need to
\end_layout

\begin_layout Itemize

\family typewriter
addInfoField('penetrance')
\family default
 to the population to analyze.
 (or use infoFields parameter of the population constructor), and
\end_layout

\begin_layout Itemize
use e.g., 
\family typewriter
mlPenetrance(...., infoFields=['penetrance'])
\family default
 to add penetrance field to the penetrance operator you use.
 You can choose a name other than 'penetrance' as long as the field name
 for the operaor and population match.
\end_layout

\begin_layout Standard
Penetrance functions can be applied to the current, all, or certain number
 of ancestral generations.
 This is controlled by the 
\family typewriter
ancestralGen
\family default
 parameter, which is default to 
\family typewriter
-1
\family default
 (all available ancestral generations).
 You can set it to 0 if you only need affection status for the current generatio
n, or specify a number 
\begin_inset Formula $n$
\end_inset

 for the number of ancestral generations (
\begin_inset Formula $n+1$
\end_inset

 total generations) to process.
 Note that 
\family typewriter
ancestralGen
\family default
 parameter is ignored if penetrance operator is used as a during mating
 operator.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapPenetrance
\family default

\begin_inset LatexCommand index
name "operator!mapPenetrance"

\end_inset

 (post, during-Mating), function 
\family typewriter
MapPenetrance
\begin_inset LatexCommand index
name "function!MapPenetrance"

\end_inset

 
\end_layout

\begin_layout Standard
Assign penetrance using a table with keys 'X-Y' where X and Y are allele
 numbers.
 For example,
\end_layout

\begin_layout LyX-Code
mapPenetrance(locus=1, penetrance={'1-1':0, '1-2':0.5, '2-2':1})
\end_layout

\begin_layout Standard
Note that this dictionary can be more than three elements to accommendate
 more than one disease alleles.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maPenetrance
\family default

\begin_inset LatexCommand index
name "operator!maPenetrance"

\end_inset

 (post, during-Mating), function 
\family typewriter
MaPenetrance
\begin_inset LatexCommand index
name "function!MaPenetrance"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
maPenetrance
\family default
 is called 'multiple-alleles
\begin_inset LatexCommand index
name "selection!multiple-alleles penetrance"

\end_inset

' penetrance.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter
wildtype
\family default
 and any other alleles are considered as diseased allele.
 
\family typewriter
maSelector
\family default
 accepts an array of fitness for AA, Aa, aa in the single-locus case, and
 a longer table for multi-locus case.
 Penetrance is then set for any given genotype.
 For example
\end_layout

\begin_layout LyX-Code
maPenetrance(loci=[1,5], wildtype=[1], penetrance=[0,0.5,1,0,0,1,0,1,1])
\end_layout

\begin_layout Standard
this operator behave the same as the 
\family typewriter
mapPenetrance
\family default
 example but will work if there are more than one disease alleles.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlPenetrance
\family default

\begin_inset LatexCommand index
name "operator!mlPenetrance"

\end_inset

(post, during-Mating), function 
\family typewriter
MlPenetrance
\begin_inset LatexCommand index
name "function!MlPenetrance"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
mlPentrance
\family default
 is the 'multiple-loci' penetrnace calculator.
 It accepts a list of penetrances and combine them according to the 
\family typewriter
mode
\family default
 parameter which can take the values:
\end_layout

\begin_layout Subsubsection*
PEN_Multiplicative
\begin_inset LatexCommand index
name "constant!PEN\\_Multiplicative"

\end_inset

: 
\end_layout

\begin_layout Standard
The penetrance is calculated as 
\begin_inset Formula $f=\prod f_{i}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
PEN_Additive
\begin_inset LatexCommand index
name "constant!PEN\\_Additive"

\end_inset


\end_layout

\begin_layout Standard
The penetrance is calculated as 
\begin_inset Formula $f=\min\left(1,\sum f_{i}\right)$
\end_inset

.
 
\begin_inset Formula $f$
\end_inset

 is set to 1 when 
\begin_inset Formula $f<0$
\end_inset

.
 What is added are 
\begin_inset Formula $s_{i}$
\end_inset

, not 
\begin_inset Formula $f_{i}$
\end_inset

 directly.
\end_layout

\begin_layout Subsubsection*
PEN_Heterogeneity
\begin_inset LatexCommand index
name "constant!PEN\\_Multiplicative"

\end_inset

: 
\end_layout

\begin_layout Standard
The penetrance is calculated as 
\begin_inset Formula $f=1-\prod\left(1-f_{i}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Please refer to 
\begin_inset LatexCommand citet
key "Risch1990"

\end_inset

 for detailed information about these models.
\end_layout

\begin_layout Standard
For example, if each locus follows an additive penetrance model, we can
 have
\end_layout

\begin_layout LyX-Code
pen = []
\end_layout

\begin_layout LyX-Code
for loc in loci:
\end_layout

\begin_layout LyX-Code
  pen.append( maPenetrance(locus=loc, wildtype=[1],
\end_layout

\begin_layout LyX-Code
    penetrance=[0.0.3,0.6] ) )
\end_layout

\begin_layout LyX-Code
# the multi-loci penetrance
\end_layout

\begin_layout LyX-Code
penMulti = mlPenetrance(mode=PEN_Multiplicative, peneOps=pen)
\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyPenetrance
\family default

\begin_inset LatexCommand index
name "operator!pyPenetrance"

\end_inset

(post, during-Mating), function 
\family typewriter
PyPenetrance
\begin_inset LatexCommand index
name "function!PyPenetrance"

\end_inset


\end_layout

\begin_layout Standard
For each individual, user provide a function to calculate penetrance.
 This method is very flexible but will be slower than previous operators
 since a function will be called for each individual.
 This operator accept the following parameters:
\end_layout

\begin_layout Itemize

\family typewriter
loci:
\family default
 disease susceptibility loci.
 The genotype 
\emph on
at these loci
\emph default
 will be passed to the provided python function in the form of 
\family typewriter
loc1_1, loc1_2, loc2_1, loc2_2, ...

\family default
 if the individuals are diploid.
\end_layout

\begin_layout Itemize

\family typewriter
func:
\family default
 a user-defined function that takes a array of genotype and return a penetrance
 value.
 The returned value should be between 0 and 1.
\end_layout

\begin_layout Standard
For example, for the same multi-locus model before, we can define is using
 
\family typewriter
pyPenetrance
\family default
 as
\end_layout

\begin_layout LyX-Code
def peneFunc(geno):
\end_layout

\begin_layout LyX-Code
  p = 1
\end_layout

\begin_layout LyX-Code
  for l in range(len(geno)/2):
\end_layout

\begin_layout LyX-Code
    p *= (geno[l*2]+geno[l*2+1]-2)*0.3
\end_layout

\begin_layout LyX-Code
  return p
\end_layout

\begin_layout LyX-Code
penMulti = pyPenetrance(loci=loci, func=peneFunc)
\end_layout

\begin_layout Standard
As you can see, using this operator, you can define arbitrarily complex
 penetrance functions.
 Typical such penetrance functions are interaction between loci (using a
 multi-locus penetrance table), even random ones.
\end_layout

\begin_layout Standard
It would be useful to let peneFunc take parameters.
 This can be done by defining a python function that return a penetrance
 function.
 This may sound intimidating but it is really easy:
\end_layout

\begin_layout LyX-Code
def peneFunc(table):
\end_layout

\begin_layout LyX-Code
  def func(geno):
\end_layout

\begin_layout LyX-Code
    return table[geno[0]-1][geno[1]-1]
\end_layout

\begin_layout LyX-Code
  return func
\end_layout

\begin_layout LyX-Code
# then, given a table, you can do
\end_layout

\begin_layout LyX-Code
pen = pyPenetrance(loci=loci, func=peneFunc( ((0,0.5),(0.3,0.8)) ) )
\end_layout

\begin_layout Standard
Now, for any table, you can use 
\family typewriter
peneFunc
\family default
 to return a penetrance function that uses this table.
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout Section
Quantitative Trait
\begin_inset LatexCommand index
name "quantitative trait"

\end_inset


\end_layout

\begin_layout Standard
Quantitative trait is the measure of certain phenotype for given genotype.
 Quantitative trait is similar to penetrance in that the consequence of
 penetrance is binary: affected or unaffected; while it is continuous for
 quantitative trait.
 
\end_layout

\begin_layout Standard
The following operators/functions calculate quantitative traits for each
 individual and store the values in the information field specified by the
 user (default to 
\family typewriter
qtrait
\family default
).
 
\end_layout

\begin_layout Standard
The quantitative trait operators also accept the 
\family typewriter
ancestralGen
\family default
 parameter to control the number of generations 
\family typewriter
qtrait
\family default
 information field will be set.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!mapQuanTrait"

\end_inset

, function 
\family typewriter
MapQuanTrait
\begin_inset LatexCommand index
name "function!MapQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
Assign quantitative trait using a table with keys 'X-Y' where X and Y are
 allele numbers.
 If 
\family typewriter
sigma
\family default
 is not zero, the returned value is the sum of trait plus 
\begin_inset Formula $N\left(0,\sigma^{2}\right)$
\end_inset

.
 This random part is usually considered as environmental factor of the trait.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!maQuanTrait"

\end_inset

, function 
\family typewriter
MaQuanTrait
\begin_inset LatexCommand index
name "function!MaQuanTrait"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
maQuanTrait
\family default
 is called 'multiple-alleles
\begin_inset LatexCommand index
name "selection!multiple-alleles penetrance"

\end_inset

' quantitative trait.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter
wildtype
\family default
 and any other alleles are considered as diseased allele.
 
\family typewriter
maQuanTrait
\family default
 accepts an array of fitness as described before.
 Quantitative trait is then set for any given genotype.
 
\begin_inset Formula $N\left(0,\sigma^{2}\right)$
\end_inset

 will be added to returned trait value.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!mlQuanTrait"

\end_inset

, function 
\family typewriter
MlQuanTrait
\begin_inset LatexCommand index
name "function!MlQuanTrait"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
mlQuanTrait
\family default
 is the 'multiple-loci' QT calculator.
 It accepts a list of QuanTraits and combine them according to the 
\family typewriter
mode
\family default
 parameter which can take the values:
\end_layout

\begin_layout Subsubsection*
QT_Multiplicative
\begin_inset LatexCommand index
name "constant!QT\\_Multiplicative"

\end_inset

: 
\end_layout

\begin_layout Standard
The mean of quantitative trait is calculated as 
\begin_inset Formula $f=\prod f_{i}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
QT_Additive
\begin_inset LatexCommand index
name "constant!QT\\_Additive"

\end_inset

:
\end_layout

\begin_layout Standard
The mean of quantitative trait is calculated as 
\begin_inset Formula $f=\sum f_{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Note that all 
\begin_inset Formula $\sigma_{i}$
\end_inset

 (for 
\begin_inset Formula $f_{i}$
\end_inset

) and 
\begin_inset Formula $\sigma$
\end_inset

 (for 
\begin_inset Formula $f$
\end_inset

 ) will all be considerd.
 I.e, the trait value should be 
\begin_inset Formula \[
f=\sum_{i}\left(f_{i}+N\left(0,\sigma_{i}^{2}\right)\right)+\sigma^{2}\]

\end_inset

for QT_Additive case.
 If this is not desired, you can set some of the 
\begin_inset Formula $\sigma$
\end_inset

 to zero.
\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!pyQuanTrait"

\end_inset

, function 
\family typewriter
PyQuanTrait
\begin_inset LatexCommand index
name "function!PyQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
For each individual, user provide a function to calculate quantitative trait.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Ascertainment"

\end_inset

Ascertainment
\begin_inset LatexCommand index
name "ascertainment"

\end_inset

 (subset of population)
\end_layout

\begin_layout Standard
Ascertainment/sampling refers to ways to select individuals from a population.
 In simuPOP, ascerntainment operators forms separate populations in a population
's namespace.
 All the following operators work like this except for 
\family typewriter
pySubset
\family default
 which thrink the population itself.
 
\end_layout

\begin_layout Standard
Individuals in sampled populations may or may not keep their original order
 but their index in the whole population is stored in a information field
 
\family typewriter
oldindex
\family default
.
 That is to say, you can use 
\family typewriter
ind.info('oldindex')
\family default
 to check the original position of an individual.
\end_layout

\begin_layout Standard
Most of the ascertainment operators support the following options:
\end_layout

\begin_layout Itemize

\family typewriter
times:
\family default
 how many times to sample from the population.
\end_layout

\begin_layout Itemize

\family typewriter
name
\family default
: name of samples in local namespace.
 This variable is an array of populations of size 
\family typewriter
times
\family default
.
 Default to 
\family typewriter
sample
\family default
.
 If 
\family typewriter
name=''
\family default
 is set, samples will not be saved in local namespace.
 
\end_layout

\begin_layout Itemize

\family typewriter
saveAs, format:
\family default
 filename and format to save the samples.
 
\end_layout

\begin_layout Itemize

\family typewriter
nameExpr, saveAsExpr:
\family default
 expression version of parameter 
\family typewriter
name
\family default
 and 
\family typewriter
saveAs
\family default
.
 They will be dynamically evaluated in population's local namespace.
 
\end_layout

\begin_layout Standard
Two forms of sample size specifications are supported: with/without subpopulatio
n structure.
 For example, the 
\family typewriter
size
\family default
 parameter of 
\family typewriter
randomSample
\family default
 can be a number or an array (of the length of number of subpopulations).
 If a number is given, sample will be drawn from the whole population, regardles
s of population structure.
 If an array is given, individuals will be draw from each subpopulation
 
\family typewriter
sp
\family default
 according to 
\family typewriter
size[sp]
\family default
.
\end_layout

\begin_layout Standard
An important special case of sample size specification is when 
\family typewriter
size=[]
\family default
 (default).
 In this case, usually all qualified individuals will be returned.
\end_layout

\begin_layout Standard
The function form of these operators are a bit different from others.
 They do return a value: an array of samples.
 
\end_layout

\begin_layout Subsection
function 
\family typewriter
population::shrinkByIndID
\begin_inset LatexCommand index
name "thrinkByIndInfo"

\end_inset

()
\end_layout

\begin_layout Standard
This function look at the 
\family typewriter
subPopID()
\family default
 field of each individual and remove anyone with value 0.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
pySubset
\family default

\begin_inset LatexCommand index
name "operator!pySubset"

\end_inset

, function 
\family typewriter
PySubset
\family default

\begin_inset LatexCommand index
name "function!PySubset"

\end_inset


\end_layout

\begin_layout Standard
This operator shrink a population according to a given array or the 
\family typewriter
subPopID()
\family default
 value of each indvidual.
 Subpopulations are kept intact.
 
\end_layout

\begin_layout Subsection
Operator (C++/hybrid) 
\family typewriter
pySample
\begin_inset LatexCommand index
name "operator!pySample"

\end_inset

,
\family default
 function 
\family typewriter
PySample
\begin_inset LatexCommand index
name "function!PySample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
PySample
\begin_inset LatexCommand index
name "function!PySample"

\end_inset

(pop, info, name, saveAs, format)
\family default
 or 
\family typewriter
Sample
\begin_inset LatexCommand index
name "function!Sample"

\end_inset

(pop)
\family default
 if you already set info for each individual using 
\family typewriter
setSubPopID
\begin_inset LatexCommand index
name "population!setInfo"

\end_inset

()
\family default
 function.
 The operator version of these functions are 
\family typewriter
pySample
\begin_inset LatexCommand index
name "operator!pySample"

\end_inset

(info, times, name, nameExpr, saveAs, saveAsExpr, format).
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
randomSample
\begin_inset LatexCommand index
name "operator!randomSample"

\end_inset

,
\family default
 function 
\family typewriter
RandomSample
\begin_inset LatexCommand index
name "function!RandomSample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
RandomSample
\begin_inset LatexCommand index
name "function!RandomSample"

\end_inset

(pop, size, times, name, saveAs, format)
\family default
 will randomly choose size individuals (or 
\family typewriter
sizes
\family default
 from subpopulations) and return a new population.
 The operator version is 
\family typewriter
randomSample
\family default

\begin_inset LatexCommand index
name "operator!randomSample"

\end_inset

(
\family typewriter
size, times, name, nameExpr, saveAs, saveAsExpr, format
\family default
).
 
\end_layout

\begin_layout Standard
The function form returns the samples directly.
 The operator keeps samples in an array 
\family typewriter
name
\family default
 in local namespace.
 You can acess them through 
\family typewriter
dvars()
\family default
 or 
\family typewriter
vars()
\family default
 functions.
 
\end_layout

\begin_layout Standard
The orginal subpopulation structure/boundary is kept in the samples.
\end_layout

\begin_layout Subsection
Opeartor (C++) 
\family typewriter
caseControlSample
\begin_inset LatexCommand index
name "operator!caseControlSample"

\end_inset

,
\family default
 function 
\family typewriter
CaseControlSample
\begin_inset LatexCommand index
name "function!CaseControlSample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
CaseControlSample(pop, cases, controls, times, name, saveAs, format)
\family default
 will randomly choose cases affected individuals and controls unaffected
 individuals.
 The operator version of this function is 
\family typewriter
caseControlSample(case, cases, control, controls, times, name, nameExpr,
 saveAs, saveAsExpr, format)
\family default
.
 The affected status is usually set by penetrance function/operators.
 The sample populations will have two subpopulations: cases and controls.
 
\end_layout

\begin_layout Standard
You can specify number of cases and controls from each subpop using the
 array form of the parameters.
 The sample population will still have only two subpoulations (case/control)
 though.
\end_layout

\begin_layout Standard
A special case of this sampling scheme is when one or both 
\family typewriter
cases
\family default
 and 
\family typewriter
controls
\family default
 are omitted (zeros).
 In this cases, all cases and/or controls are chosen.
 If both parameters are omitted, the sample is effectively the same population
 with affected and unaffected separated into two subpopulaitons.
\end_layout

\begin_layout Standard
The following example shows how to draw a random sample (without replacement
 of course) from an existing population.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
random sample
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/randomSample.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
affectedSibpairSample
\family default

\begin_inset LatexCommand index
name "operator!affectedSibpairsSample"

\end_inset

, function 
\family typewriter
AffectedSibpairSample
\family default

\begin_inset LatexCommand index
name "function!AffectedSibpairsSample"

\end_inset


\end_layout

\begin_layout Standard
The use of this operator needs special preparation for the population.
 Obviously, to obtain affected sibpairs, we need to know the parents and
 the affectedness tatus of each individual.
 Furthermore, to get parental genotype, the population should have ancestralDept
h at least 1.
 The biggest problem, however, comes from the mating scheme we are using.
\end_layout

\begin_layout Standard

\family typewriter
randomMating()
\family default
 is usually used for diploid populations.
 The 
\emph on
real random
\emph default
 mating requires that a mating will generate only one offspring.
 Since parents are chosen with replacement, a parent can have multiple offspring
s with different parents.
 On the otherhand, it is very unlikely that two offsprings will have the
 same parents.
 The probability of having a sibling for an offspring is 
\begin_inset Formula $\frac{1}{N^{2}}$
\end_inset

 (do not consider selection).
 Therefore, we will have to allow multiple offsprings per mating at the
 cost of smaller effective population size.
\end_layout

\begin_layout Standard
All these requirements come at a cost: multiple ancestral populations, judge
 affectedness status and tagging will slow down evolution; multiple offsprings
 will reduce effective population size.
 Fortunately, simuPOP is flexible enough to let all these happen only at
 the last several generations.
 For example, you can do
\end_layout

\begin_layout LyX-Code
endGen = 1000
\end_layout

\begin_layout LyX-Code
# having two offsprings only at the last three generations
\end_layout

\begin_layout LyX-Code
def numOffsprings(gen):
\end_layout

\begin_layout LyX-Code
  if gen >= endGen - 3:
\end_layout

\begin_layout LyX-Code
    return 2
\end_layout

\begin_layout LyX-Code
  else 
\end_layout

\begin_layout LyX-Code
    return 1
\end_layout

\begin_layout LyX-Code
# evolve ...
\end_layout

\begin_layout LyX-Code
simu = simulator(pop, randomMating(numOffspringsFunc = numOffsprings))
\end_layout

\begin_layout LyX-Code
simu.evolve( ...
\end_layout

\begin_layout LyX-Code
  parentsTagger(begin = endGen - 3),
\end_layout

\begin_layout LyX-Code
  mapPenetrance(...., begin = endGen - 2),
\end_layout

\begin_layout LyX-Code
  setAncestralDepth(1, at = endGen -2 )
\end_layout

\begin_layout LyX-Code
...)
\end_layout

\begin_layout Standard
to let your population evolve 
\emph on
normally
\emph default
 and start to store ancestral generations and allow multiple offsprings
 at the last several generations.
\end_layout

\begin_layout Standard
Briefly, you should
\end_layout

\begin_layout Itemize
set ancestral depth to at least 1 to allow analyzing of parental generation,
\end_layout

\begin_layout Itemize
use parentsTagger to track parents for each individual, with the usual limit
 of no post-mating migration, and 
\end_layout

\begin_layout Itemize
allow multiple offsprings at least at the last generation.
 (You do not have to use fixed number of offsprings.
 Other mating mode like 
\family typewriter
MATE_GeometricDistribution
\family default
 can also be used.)
\end_layout

\begin_layout Itemize
use a penetrance operator to set affected status of each individual
\end_layout

\begin_layout Standard
and finally use this operator (or function)
\end_layout

\begin_layout LyX-Code
affectedSibpairSample(size
\family typewriter
,
\family default
  
\family typewriter
times, name, saveAs, format
\family default
)
\end_layout

\begin_layout Standard
to get samples accessible from 
\family typewriter
dvars().name[i].

\family default
 Each sample will
\end_layout

\begin_layout Itemize
have 2*size of paired individuals.
 (e.g.
 
\family typewriter
individual(2n)
\family default
 and 
\family typewriter
individual(2n+1), n=0,1,..., size-1
\family default
 are siblings.
\end_layout

\begin_layout Itemize
have an ancestral generation of the same size, with parents to the sibpairs.
\end_layout

\begin_layout Itemize
if 
\family typewriter
size
\family default
 is an array, get 
\family typewriter
size[sp]
\family default
 sibpairs from subpop 
\family typewriter
sp
\family default
 .
\end_layout

\begin_layout Standard
Other than samples 
\family typewriter
name
\family default
, variable 
\family typewriter
numSibpairs
\family default
 will be set to indicate the total number of affected sibpairs in the population.
 Subpopulation structure will be kept in the samples so you will know how
 many individuals are drawn from each subpopulation.
 (This info is also saved in variable 
\family typewriter
numSibpairs
\family default
 of each sample.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Statistics Calculation
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
stat
\begin_inset LatexCommand index
name "operator!stat"

\end_inset

,
\family default
 function 
\family typewriter
Stat
\begin_inset LatexCommand index
name "function!Stat"

\end_inset

 
\end_layout

\begin_layout Standard
Operator stat calculate various basic statistics for the population and
 set variables in local namespace.
 Other operators/functions can refer to the results from the namespace after
 
\family typewriter
stat
\family default
 is applied.
 
\family typewriter
Stat
\family default
 is the function form of the operator.
\end_layout

\begin_layout Standard
For each statistics, I will list corresponding parameter (of 
\family typewriter
stat
\family default
), variables and mathematics formula if applicable.
 Note that these statistics are dependent to each other.
 For example, heterotype and allele frequency of related loci will be automatica
lly calculated if linkage diseqilibrium is requested.
\end_layout

\begin_layout Subsubsection*
Population size
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
popSize=True/False
\end_layout

\begin_layout Itemize
variable:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
numSubPop
\begin_inset LatexCommand index
name "stat!numSubPop"

\end_inset


\family default
\series default
 number of subpopulation
\end_layout

\begin_layout Itemize
\noindent

\family typewriter
\series bold
popSize
\begin_inset LatexCommand index
name "stat!popSize"

\end_inset

, subPop[sp]['popSize']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
subPopSize
\begin_inset LatexCommand index
name "stat!subPopSize"

\end_inset

,
\family default
\series default
 an array of subpopulation size.
 Not available for subpopulations.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Number of male/female
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
numOfMale=True/False
\end_layout

\begin_layout Itemize
\noindent
variable:
\end_layout

\begin_deeper
\begin_layout Itemize
\noindent

\family typewriter
\series bold
numOfMale
\begin_inset LatexCommand index
name "stat!numOfMale"

\end_inset

, subPop[sp]['numOfMale']
\end_layout

\begin_layout Itemize
\noindent

\family typewriter
\series bold
numOfFemale
\begin_inset LatexCommand index
name "stat!numOfFemale"

\end_inset

, subPop[sp]['numOfFemale']
\end_layout

\end_deeper
\begin_layout Subsubsection*
Number/proportion of affected/unaffected individuals
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
numOfAffected=True/False
\end_layout

\begin_layout Itemize
variable:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
numOfAffected, subPop[sp]['numOfAffected']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
numOfUnaffected, subPop[sp]['numOfUnAffected']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
propOfAffected, subPop[sp]['propOfAffected']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
propOfUnaffected, subPop[sp]['propOfUnAffected']
\end_layout

\end_deeper
\begin_layout Subsubsection*
Number of distinct alleles at a locus
\end_layout

\begin_layout Standard
This is done through the calculation of allele frequency.
 Therefore, allele frequency will also be calculated if this statistics
 is requested.
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
\series bold
numOfAlleles=[loc1, loc2, ...]
\family default
\series default
 where 
\family typewriter
\series bold
loc1
\family default
\series default
 etc are absolute locus indices.
 
\end_layout

\begin_layout Itemize
variable: a carray of number of alleles for 
\series bold
all loci
\series default
.
 Unrequested loci will have 0 distinct alleles.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
numOfAlleles
\begin_inset LatexCommand index
name "stat!numOfAlleles"

\end_inset

, subPop[sp]['numOfAlleles']
\family default
\series default
, number of distinct alles at each loci.
 (Calculated only at requested loci.)
\end_layout

\end_deeper
\begin_layout Subsubsection*
Allele frequency/count
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
\series bold
alleleFreq=[loc1, loc2, ...]
\family default
\series default
 where 
\family typewriter
\series bold
loc1
\family default
\series default
 etc are loci where allele frequencies will be counted.
\end_layout

\begin_layout Itemize
variable: the following 
\family typewriter
carray
\family default
 objects will be set.
 For example 
\family typewriter
\series bold
alleleNum[1][2]
\family default
\series default
 will be the number of allele 2 at locus 1.
 
\end_layout

\begin_deeper
\begin_layout Itemize
\noindent

\family typewriter
\series bold
alleleNum[a]
\begin_inset LatexCommand index
name "stat!alleleNum"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['alleleNum'][a]
\end_layout

\begin_layout Itemize
\noindent

\family typewriter
\series bold
alleleFreq[a]
\begin_inset LatexCommand index
name "stat!alleleFreq"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['alleleFreq'][a]
\end_layout

\end_deeper
\begin_layout Subsubsection*
heterozygote frequency/count
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
\series bold
heteroFreq=[loc1,loc2,...]
\series default
:
\family default
 
\end_layout

\begin_deeper
\begin_layout Standard
an array of loci to calaulate observed heterozygosity and expected heterozygosit
y.
\end_layout

\end_deeper
\begin_layout Itemize
variables: array of observed heterozygosity
\begin_inset LatexCommand index
name "observed heterozygosity"

\end_inset

.
 
\family typewriter
\series bold
heteroNum[
\series default
loc
\series bold
][1]
\family default
\series default
 is the number of heterozygote 1x, 
\series bold

\begin_inset Formula $x\ne1$
\end_inset

.

\series default
 Number and frequency (proportion) of heterozygotes are calculated for each
 allele.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\series bold
HeteroNum[loc]
\family default
\series default
 and 
\family typewriter
\series bold
HeterFreq[loc]
\family default
\series default
 is the overall heterozygosity number and frequency.
 I.e., number/frequency of genotype 
\begin_inset Formula $xy$
\end_inset

 
\begin_inset Formula $x\ne y$
\end_inset

.
 From this number, we can easily derive number of homozygosity.
 
\end_layout

\begin_layout Standard
Variables are:
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
HeteroNum[loc], subPop[sp]['HeteroNum'][loc]
\family default
\series default
, overall heterozygote number
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
HeteroFreq[loc], subPop[sp]['HeteroFreq'][loc]
\family default
\series default
, overall heterozygote frequency
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
heteroNum[loc][allele]
\begin_inset LatexCommand index
name "stat!heteroNum"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['heteroNum'][loc][allele]
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
heteroFreq[loc][allele]
\begin_inset LatexCommand index
name "stat!heteroFreq"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['heteroFreq'][loc][allele]
\end_layout

\end_deeper
\begin_layout Subsubsection*
expected heterozygosity
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
\series bold
expHetero=[loc1, loc2,...]
\end_layout

\begin_layout Itemize
Expected heterozygosity
\begin_inset LatexCommand index
name "expected heterozygosity"

\end_inset

 
\begin_inset Formula \[
h_{exp}=1-p_{i}^{2}\]

\end_inset


\end_layout

\begin_layout Itemize
variable: 
\family typewriter
\series bold
expHetero[loc], subPop[sp]['expHetero'][loc]
\end_layout

\begin_layout Subsubsection*
homozygosity frequency/count
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
\series bold
homoFreq=[loc1, loc2, ...]
\end_layout

\begin_layout Itemize
Number and frequency of homozygotes 
\begin_inset Formula $xx$
\end_inset

.
 
\end_layout

\begin_layout Itemize
variable: 
\family typewriter
\series bold
homoNum[loc
\family default
\series default
], 
\family typewriter
\series bold
homoFreq[loc], subPop[sp]['homoNum'][loc]
\family default
\series default
, 
\family typewriter
\series bold
subPop[sp]['homoFreq'][loc]
\end_layout

\begin_layout Subsubsection*
genotype frequency/count
\end_layout

\begin_layout Itemize
parameter: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
genoFreq=[loc1,loc2,...]
\series default
:
\family default
 an array of loci to calculate genotype frequency.
 All genotypes in the population will be counted.
\end_layout

\begin_layout Itemize

\family typewriter
hasPhase
\family default
: if a/b and b/a are the same genotype.
 default is True.
\end_layout

\end_deeper
\begin_layout Itemize
variables: Dictionary variables 
\family typewriter
genoNum, genoFreq, subPop[sp]['genoNum'], subPop[sp]['genoFreq']
\family default
 will be set.
 Note that the index 
\family typewriter
a, b
\family default
 of 
\family typewriter
genoFreq[a][b]
\family default
 are dictionary keys (unlike list used for alleleFreq etc) so you will get
 KeyError when you use a wrong key.
 
\family typewriter
genoNum.setDefault(a,{})
\family default
 is preferred.
 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
genoNum[a][geno]
\begin_inset LatexCommand index
name "stat!genoNum"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['genoNum'][a][geno]
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
genoFreq
\begin_inset LatexCommand index
name "stat!genoFreq"

\end_inset

[a][geno]
\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['genoFreq'][a][geno]
\family default
\series default
, number/frequency of genotype 
\family typewriter
geno
\family default
 at allele 
\family typewriter
a
\family default
.
 
\family typewriter
geno
\family default
 has the form 
\family typewriter
x-y.
\end_layout

\end_deeper
\begin_layout Subsubsection*
haplotype frequency
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
haploFreq:
\family default
 a matrix of haplotypes (allele sequence on the different loci) to count.
 For example:
\end_layout

\begin_deeper
\begin_layout LyX-Code
haploFreq = [ [ 0,1,2 ], [1,2] ]
\end_layout

\begin_layout Standard
will count all haplotypes on loci 0,1 and 2; and all haplotypes on loci
 1, 2.
 
\end_layout

\end_deeper
\begin_layout Itemize
variable: Dictionary ariables 
\family typewriter
haploNum, haploFreq,
\family default
 will be set with keys 
\family typewriter
0-1-2
\family default
 etc
\family typewriter
.

\family default
 For example 
\family typewriter
haploNum['1-2']['5-6']
\family default
 is the number of allele pair 
\family typewriter
5,6
\family default
 (on loci 1 and 2 respectively) in the population.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
haploNum[haplo]
\begin_inset LatexCommand index
name "stat!haploNum"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['haploNum'][haplo]
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
haploFreq
\begin_inset LatexCommand index
name "stat!haploFreq"

\end_inset

[haplo]
\family default
,
\series default
 
\family typewriter
\series bold
subPop[sp]['haploFreq'][haplo]
\family default
\series default
, number/frequency of allele sequencies on loci 
\family typewriter
haplo
\family default
.
 
\end_layout

\end_deeper
\begin_layout Subsubsection*
Linkage disequilibrium 
\end_layout

\begin_layout Itemize
parameter:
\end_layout

\begin_deeper
\begin_layout LyX-Code
LD: LD = [ [1,2], [ 0,1,1,2],[1,2,1,2]] 
\end_layout

\begin_layout Standard
For each item 
\family typewriter
[loc1, loc2, allele1, allele2]
\family default
, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 will be calculated based on allele1 at loc1 and allele2 at loc2.
 If only two loci are given, the LD values are averaged over all allele
 pairs.
 For example, for allele 
\begin_inset Formula $A$
\end_inset

 at locus 1 and allele 
\begin_inset Formula $B$
\end_inset

 at locus 2, with allele frequency 
\begin_inset Formula $P_{A}$
\end_inset

 and 
\begin_inset Formula $P_{B}$
\end_inset

 respectively, and haplotype frequency 
\begin_inset Formula $P_{AB}$
\end_inset

, 
\begin_inset Formula \begin{eqnarray*}
D & = & P_{AB}-P_{A}P_{B}\\
D' & = & D/D_{max}\\
D_{max} & = & \begin{cases}
\min\left(P_{A}\left(1-P_{B}\right),\left(1-P_{A}\right)P_{B}\right) & \textrm{if }D\geq0\\
\min\left(P_{A}P_{B},\left(1-P_{A}\right)\left(1-P_{B}\right)\right) & \textrm{if }D<0\end{cases}\\
r^{2} & = & \frac{D^{2}}{P_{A}\left(1-P_{A}\right)P_{B}\left(1-P_{B}\right)}\end{eqnarray*}

\end_inset


\begin_inset Formula $D'$
\end_inset

 is defined in 
\begin_inset LatexCommand citet
key "Lewontin1964"

\end_inset

, 
\begin_inset Formula $r^{2}$
\end_inset

 is defined in 
\begin_inset LatexCommand citet
key "Weir1979"

\end_inset

.
 If 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are not specified, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 will be the averaged value: (basically 
\begin_inset Formula $\sum\sum P_{A}P_{B}\left|\right|$
\end_inset

 )
\begin_inset Formula \begin{eqnarray*}
D & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D_{ij}\right|\\
D' & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D'_{ij}\right|\\
r^{2} & = & \sum_{i}\sum_{j}P_{i}P_{j}r_{ij}^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{\left(1-P_{i}\right)\left(1-P_{j}\right)}\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $p_{i}$
\end_inset

 and 
\begin_inset Formula $q_{j}$
\end_inset

 are the population allele frequencies of the 
\begin_inset Formula $i$
\end_inset

th allele on loc1 and the 
\begin_inset Formula $j$
\end_inset

th allele on loc2.
 Please note that some other authors use
\begin_inset Formula \[
r^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{P_{i}P_{j}}\]

\end_inset

If you are sure that the later is correct, please send me an email (with
 reference).
\end_layout

\end_deeper
\begin_layout Itemize
variables:
\end_layout

\begin_deeper
\begin_layout Standard
if loc1 and loc2 are specified.
 The values are LD measures averaged over all possible allele pairs.
 If al1 and al2 are specified, these values are calculated using these two
 alleles.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
ld['loc1-loc2']['al1-al2'], subPop[sp]['ld']['loc1-loc2']['al1-al2']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
ld_prime['loc1-loc2']['al1-al2'], subPop[sp]['ld_prime']['loc1-loc2']['al1-al2']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
r2['loc1-loc2']['al1-al2'], subPop[sp]['r2']['loc1-loc2']['al1-al2']
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
LD[loc1][loc2], subPop[sp]['LD'][loc1][loc2]
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
LD_prime[loc1][loc2], subPop[sp]['LD_prime'][loc1][loc2]
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
R2[loc1][loc2], subPop[sp]['R2'][loc1][loc2]
\end_layout

\begin_layout Standard
Please note the difference between the datastructure used for 
\family typewriter
ld
\family default
 and 
\family typewriter
LD
\family default
.
 The names are potentially very confusing but I have no better idea.
 
\end_layout

\end_deeper
\begin_layout Subsubsection*
\begin_inset Formula $F_{st}$
\end_inset

 
\end_layout

\begin_layout Itemize
parameter: 
\family typewriter
Fst: Fst = [0,1,2]
\family default
, calculate 
\begin_inset Formula $F_{st},$
\end_inset

 
\begin_inset Formula $F_{is}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 based on alleles at locu 0, 1, 2 respectively.
 The locus-specific values will be used to calculate 
\family typewriter
AvgFst
\family default
 etc.
 Terms and values that match 
\begin_inset LatexCommand citeauthor
key "Weir1984"

\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F$
\end_inset

 (
\begin_inset Formula $F_{IT}$
\end_inset

): the correlation of genes within individuals (inbreeding)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\theta$
\end_inset

 (
\begin_inset Formula $F_{ST}$
\end_inset

): the correlation of genes of difference individuals in the same population
 (will evaluate for each subpopulation and the population as a whole)
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 (
\begin_inset Formula $F_{IS}$
\end_inset

): the correlation of genes within individuals within populations.
 Populations refers to subpopulations in simuPOP term.
\end_layout

\end_deeper
\begin_layout Itemize
variables:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\series bold
Fst[loc]
\begin_inset LatexCommand index
name "stat!Fst"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
Fis[loc]
\begin_inset LatexCommand index
name "stat!Fis"

\end_inset


\family default
,
\series default
 
\family typewriter
\series bold
Fit[loc]
\begin_inset LatexCommand index
name "stat!Fit"

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
\series bold
AvgFst, AvgFis, AvgFit
\end_layout

\end_deeper
\begin_layout Subsubsection*
Relatedness 
\end_layout

\begin_layout Standard
The relatedness values between two individuals, or two groups of individuals
 are calculated according to 
\begin_inset LatexCommand citet
key "Quller1989"

\end_inset

 and 
\begin_inset LatexCommand citet
key "Lynch1999"

\end_inset

.
 The first one is referred to as 
\family typewriter
method=REL_Queller
\family default
 and the second one is 
\family typewriter
method=REL_Lynch
\family default
.
 The paramters are
\end_layout

\begin_layout Itemize

\family typewriter
relGroups:
\family default
 can be in the form of either 
\family typewriter
[[1,2,3],[5,6,7],[8,9]]
\family default
 or 
\family typewriter
[2,3,4]
\family default
.
 The first form specifies groups of individuals, the second form specifies
 subpopulations.
 By default, relatedness between subpopulations are calculated.
\end_layout

\begin_layout Itemize

\family typewriter
relLoci:
\family default
 calculate relativeness values based on 
\family typewriter
relLoci
\family default
 loci.
 
\end_layout

\begin_layout Itemize

\family typewriter
relMethod
\family default
: either 
\family typewriter
REL_Queller
\family default
 or 
\family typewriter
REL_Lynch
\end_layout

\begin_layout Standard
The results are pairwise relatedness values, in the form of a matrix.
 Original group or subpopulations numbers are discarded.
 
\end_layout

\begin_layout Itemize

\family typewriter
relatedness[grp1][grp2]
\family default
 is the relatedness value between grp1 and grp2.
 There is no subpop level relatedness values.
\end_layout

\begin_layout Section
Expression and Statements
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
output
\begin_inset LatexCommand index
name "operator!output"

\end_inset


\end_layout

\begin_layout Standard
This operator output a simple string.
 For example, 
\end_layout

\begin_layout LyX-Code
output(r'
\backslash
n', rep=REP_LAST)
\end_layout

\begin_layout Standard
output a newline at the last replicate.
 
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
tab
\begin_inset LatexCommand index
name "operator!tab"

\end_inset

 (defined in simuUtli.py)
\end_layout

\begin_layout Standard
Outpur a tab.
 (Wrapper of output operator)
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
endl
\begin_inset LatexCommand index
name "operator!endl"

\end_inset

 (defined in simuUtli.py)
\end_layout

\begin_layout Standard
Outpur a new line.
 (Wrapper of output operator)
\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyEval
\begin_inset LatexCommand index
name "operator!pyEval"

\end_inset

,
\family default
 function 
\family typewriter
PyEval
\begin_inset LatexCommand index
name "function!PyEval"

\end_inset


\end_layout

\begin_layout Standard
We have seen the 
\family typewriter
expr
\family default
 and 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
.
 These are python expression/statements that will be executed when 
\family typewriter
pyEval
\family default
 is applied to a population.
 Statements can also been executed when 
\family typewriter
pyEval
\family default
 is created and destroyed.
 The corresponding parameters are 
\family typewriter
preStmts
\family default
 and 
\family typewriter
postStmts
\family default
.
 For example, operator 
\family typewriter
varPlotter
\family default
 uses this feature to initialize R plot and save plot to a file when finished.
\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyExec
\begin_inset LatexCommand index
name "operator!pyEval"

\end_inset


\family default
, function 
\family typewriter
PyExec
\begin_inset LatexCommand index
name "function!PyExec"

\end_inset


\end_layout

\begin_layout Standard
This operator takes a list of statements and execute them.
 No value will be returned or outputed.
\end_layout

\begin_layout Subsection
Function (Python) 
\family typewriter
ListVars (defined in simuUtil.py)
\end_layout

\begin_layout Standard

\family typewriter
ListVars
\begin_inset LatexCommand index
name "function!listVars"

\end_inset

(variable)
\end_layout

\begin_layout Standard
This function list any variable in an indented text format.
 You can use 
\family typewriter
listVar(simuVars)
\family default
 to have a look at all replicates or 
\family typewriter
listVar(simuVars[0]['subPop'][0])
\family default
 to see variables for the first subpoulation in replicate one.
\end_layout

\begin_layout Section
Visualization
\end_layout

\begin_layout Standard
There is no special visualizer (there was indeed a matlabPlotter before
 ver 0.5.9 but I decide to remove it since matlab is not universally available.)
 Since everything is exposed dynamically, all you need to do is plotting
 variables in whatever way you prefer.
 The basic steps are:
\end_layout

\begin_layout Itemize
find an appropriate tool.
 I prefer R/Rpy to any other tools since I am familiar with R.
 You can make your own choice.
\end_layout

\begin_layout Itemize
write a function to plot variable.
 If you would like to plot history of a variable, you can use the 
\family typewriter
Aggregator
\family default
 object defined in 
\family typewriter
simuUtil.py
\family default
.
 
\end_layout

\begin_layout Itemize
wrap this function as an operator.
\end_layout

\begin_layout Standard

\family typewriter
simuRPy.py
\family default
 provides a pure Python operator 
\family typewriter
varPlotter.

\family default
 It is defined in 
\family typewriter
simuSciPy
\family default
 and 
\family typewriter
simuMatPlt.py
\family default
 as well but they are lack of subplot capacity (so the usages are different)
 due to the limit of SciPy/gplt and MatPlotLib's plotting capacity.
 Also note as of Apr, 2006, the development of gplt in scipy is stopped
 so support of simuPOP/simuSciPy is stopped as well.
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
varPlotter (simuRPy.py)
\end_layout

\begin_layout Standard
The use of 
\family typewriter
varPlotter
\family default
 is easy, if you would like to 
\end_layout

\begin_layout Subsubsection*
Plotting with history
\end_layout

\begin_layout Itemize
plot a number in the form of a varaible or expression, use
\end_layout

\begin_deeper
\begin_layout LyX-Code
varPlotter(var='expr')
\end_layout

\end_deeper
\begin_layout Itemize
plot a vector in the same window and there is only one replicate in the
 simulator, use
\end_layout

\begin_deeper
\begin_layout LyX-Code
varPlotter(var='expr', varDim=len)
\end_layout

\begin_layout Standard
where 
\family typewriter
len
\family default
 is the dimension of your variable or expression.
 Each line in the figure represents the history of an item of the array.
\end_layout

\end_deeper
\begin_layout Itemize
plot a vector in the same window and there are several replicates, use 
\end_layout

\begin_deeper
\begin_layout LyX-Code
varPlotter(var='expr', varDim=len, numRep=nr, byRep=1)
\end_layout

\begin_layout Standard
varPlotter will try to use an appropriate layout for your subplots (for
 example, use 3x4 if numRep=10).
 You can also specify paramter 
\family typewriter
mfrow
\family default
 to change the layout.
\end_layout

\end_deeper
\begin_layout Itemize
if you would like to plot each item of your array variable in a subplot,
 use
\end_layout

\begin_deeper
\begin_layout LyX-Code
varPlotter(var='expr', varDim=len, byVal=1)
\end_layout

\begin_layout Standard
in case of a single replicate or
\end_layout

\begin_layout LyX-Code
varPlotter(var='expr', varDim=len, byVal=1, numRep=nr)
\end_layout

\begin_layout Standard
There will be 
\family typewriter
numRep
\family default
 lines in each subplot
\end_layout

\end_deeper
\begin_layout Subsubsection*
Plotting without history
\end_layout

\begin_layout Itemize
use option 
\family typewriter
history=False.

\family default
 Parameters 
\family typewriter
byVal, varDim
\family default
 etc will be ignored.
 
\end_layout

\begin_layout Standard
Other options are
\end_layout

\begin_layout Enumerate

\family typewriter
title, xtitle, ytitle:
\family default
 title of your figure(s).
 title is defauled to your expression, xtitle is defaulted to 
\family typewriter
generation
\family default
.
\end_layout

\begin_layout Enumerate

\family typewriter
win:
\family default
 window of generations.
 I.e., how many generations to keep in a figure.
 This is useful when you want to keep track of only recent changes.
\end_layout

\begin_layout Enumerate

\family typewriter
update:
\family default
 update figure after 
\family typewriter
update
\family default
 calls.
 This is used when you do not want to update the figure too often, maybe
 for efficiency purpose.
\end_layout

\begin_layout Enumerate

\family typewriter
saveAs:
\family default
 save figures in files 
\family typewriter
saveAs#gen.eps.

\family default
 For example, if 
\family typewriter
saveAs='demo
\family default
', you will get files 
\family typewriter
demo1.eps
\family default
, 
\family typewriter
demo2.eps
\family default
 etc.
\end_layout

\begin_layout Enumerate

\family typewriter
separate:
\family default
 plot data lines in separate panel.
 
\end_layout

\begin_layout Enumerate

\family typewriter
image:
\family default
 use R image function to plot image, instead of lines.
\end_layout

\begin_layout Enumerate

\family typewriter
level:
\family default
 level of image colors.
 default to 20
\end_layout

\begin_layout Enumerate

\family typewriter
leaveOpen:
\family default
 whether or not leave the plot open when plotting is done.
 Default to true.
\end_layout

\begin_layout Standard
Here is an example:
\end_layout

\begin_layout LyX-Code
\begin_inset Include \verbatiminput{log/simuPlotter.log}
preview false

\end_inset


\end_layout

\begin_layout Standard
\align center

\end_layout

\begin_layout Subsection
plot through 
\family typewriter
python/SciPy/MatPltLib
\end_layout

\begin_layout Standard

\family typewriter
varPlotter
\family default
 is also available for SciPy/MatPltLib but there is no subplots (so no byVal
 etc) and the usage is different.
 The 
\family typewriter
__init__
\family default
 function of 
\family typewriter
varPlotter
\family default
 takes the following parameters:
\end_layout

\begin_layout Itemize

\family typewriter
win
\family default
 window size.
 Actually the number of generations to display.
 default to 0 (no limit).
 If this is set to be a positive number, only the last 
\family typewriter
win
\family default
 data will be displayed.
\end_layout

\begin_layout Itemize

\family typewriter
update
\family default
 generations between successive re-draw of figure.
 We can not use '
\family typewriter
step
\family default
' parameter of 
\family typewriter
pyEval
\family default
 operator since we need to collect data at each generation.
 
\end_layout

\begin_layout Itemize

\family typewriter
title, xtitle, ytitle
\family default
 titles/labels to be displayed
\end_layout

\begin_layout Itemize

\family typewriter
legend
\family default
 an array of strings, legend of the lines.
 If ignored, 
\begin_inset Quotes eld
\end_inset

var0
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

var1
\begin_inset Quotes erd
\end_inset

 etc will be used.
 If gives only one string (e,g, str), 
\begin_inset Quotes eld
\end_inset

str
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

str1
\begin_inset Quotes erd
\end_inset

,...
 etc will be used.
 Otherwise, the length of legend has to be the same as data size.
\end_layout

\begin_layout Subsection
Object (Python) 
\family typewriter
freqPlotter (defined in simuRPy.py)
\end_layout

\begin_layout Standard
The plotting function used for Reich's simulation, using R as plotting engine.
 It is put in simuRPy.py mainly for demonstration purposes.
\end_layout

\begin_layout Section
Tagging (used for pedigree tracking) 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
inheritTagger,
\family default
 duringMating
\end_layout

\begin_layout Standard
This during-mating operator will copy the tag info from his/her parents.
 Depending on 
\end_layout

\begin_layout Itemize

\family typewriter
mode = TAG_Paternal
\end_layout

\begin_layout Itemize

\family typewriter
mode = TAG_Maternal
\end_layout

\begin_layout Itemize

\family typewriter
mode = TAG_Both
\end_layout

\begin_layout Standard
this tagger will obtain tag from his/her father (two tag fields), monther
 (two tag fields) or both (first tag field from both).
 You can check the tagger test under 
\family typewriter
test
\family default
 directory for an example.
\end_layout

\begin_layout Standard
An example may be tagging one or a few parents and see, at the last generation,
 how many offspring they have.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
parentsTagger
\family default
, duringMating
\end_layout

\begin_layout Standard
This during-mating operator set 
\family typewriter
tag()
\family default
, currently a pair of numbers, of each individual with indices of his/her
 parents in the parent population.
 This info will be used by pedigree-related operators like 
\family typewriter
affectedSibpairSample
\family default
 to track pedigree information.
 Since parental population will be discarded or stored after mating, and
 tagging info will be passed with individuals, mating/population change
 etc will not interfere with this simple tagging system.
\end_layout

\begin_layout Section
Data collector
\end_layout

\begin_layout Standard
Sometimes, instead of output data directly, we may want to collect history
 data on some expression.
 Data collector is designed for this purpose.
 
\end_layout

\begin_layout Subsection
operator (Python) 
\family typewriter
collector
\begin_inset LatexCommand index
name "operator!collector"

\end_inset


\family default
, in 
\family typewriter
simuUtil.py
\end_layout

\begin_layout Standard
This operator accepts the following parameters:
\end_layout

\begin_layout Itemize

\family typewriter
name:
\family default
 name by which the collected data will be displayed.
 Variable name will be list of stored values.
 (generation is not stored.
 You can always put it in expr though.)
\end_layout

\begin_layout Itemize

\family typewriter
expr:
\family default
 an expression that will be evaluated.
 The result will be converted to a list (if needed) and stored in 
\family typewriter
name[gen]
\family default
.
\end_layout

\begin_layout Standard
When this operator is called, it will evaluate 
\family typewriter
expr
\family default
 and store its result in 
\family typewriter
name[gen]
\family default
.
 After evolution, you will get a dictionary of values indexed by generation
 number.
\end_layout

\begin_layout Section
Output 
\end_layout

\begin_layout Subsection
operator (C++) 
\family typewriter
savePopulation
\begin_inset LatexCommand index
name "operator!savePopulation"

\end_inset


\end_layout

\begin_layout Subsection
function (Python) 
\family typewriter
SaveFstat
\begin_inset LatexCommand index
name "function!SaveFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Subsection
operator (Python) 
\family typewriter
saveFstat
\begin_inset LatexCommand index
name "operator!saveFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Subsection
function (Python) 
\family typewriter
loadFstat
\begin_inset LatexCommand index
name "function!loadFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Section
Terminator
\end_layout

\begin_layout Standard
These operators are used to see if an evolution is running as expected,
 and terminate the evolution if a condition fails.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
terminateIf
\begin_inset LatexCommand index
name "operator!terminateIf"

\end_inset


\end_layout

\begin_layout Standard
This operator terminates the evolution under certain conditions.
 For example,
\end_layout

\begin_layout LyX-Code
terminateIf(condition='alleleFreq[0][1]<0.05', begin=100)
\end_layout

\begin_layout Standard
terminate the evolution if the allele frequency of allele 1 at locus 0 is
 less than 0.05.
 Of course, to make this opertor work, you will need to use an 
\family typewriter
stat
\family default
 operator before it so that variable 
\family typewriter
alleleFreq
\family default
 exists in the local namespace.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
continueIf
\begin_inset LatexCommand index
name "operator!terminateIf"

\end_inset


\end_layout

\begin_layout Standard
The same as 
\family typewriter
terminateIf
\family default
 but continue if the condition if true.
\end_layout

\begin_layout Section
Conditional operator 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
ifElse
\begin_inset LatexCommand index
name "operator!ifelse"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ifElse
\family default
 is an interesting operator.
 It accepts:
\end_layout

\begin_layout Itemize
an expression that will be evaluated when 
\family typewriter
ifelse
\family default
 is called.
\end_layout

\begin_layout Itemize
an operator that will be applied if the expression is true.
 (defult to null)
\end_layout

\begin_layout Itemize
an operator that will be applied if the expression if false.
 (default to null)
\end_layout

\begin_layout Standard
When this operator is applied to a population, it will evaluate the expression
 and depend on its value, apply the supplied operators.
 Note that the 
\family typewriter
begin, at, step, at
\family default
 parameters of if/else operators will be ignored.
 For example, you can mimic the 
\family typewriter
at
\family default
 parameter of an operator by
\end_layout

\begin_layout LyX-Code
ifElse('rep in [2,5,9]', operator)
\end_layout

\begin_layout Standard
Anyway, the real use of this machanism is minitoring the population statistics
 and act accordingly.
 The following example uses some advanced operators of simuPOP:
\end_layout

\begin_layout Itemize
set affected status using 
\family typewriter
maPenetrance
\family default
 as a 
\family typewriter
DuringMating
\family default
 operator.
 (penetrance can be used at other stages)
\end_layout

\begin_layout Itemize
count the number of affected individuals.
 Note that this has to be done after the penetrance operator is applied.
 
\end_layout

\begin_layout Itemize
If no one is effected, inject some mutations into the population.
 Note the use of 
\family typewriter
ifElse
\family default
 operator.
\end_layout

\begin_layout Itemize
expose individual affectedness to local namespaces.
 Note the use of 
\family typewriter
exposePop
\family default
 option.
 With this, you can call any population member function.
\end_layout

\begin_layout Itemize
plot affectedness, use image.
 
\end_layout

\begin_layout Itemize
Use dryrun to exam simulator first.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Conditional operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/ifElse.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Miscellaneous
\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
noneOp
\begin_inset LatexCommand index
name "operator!noneOp"

\end_inset


\end_layout

\begin_layout Standard
This operator does nothing.
 It is used like follows:
\end_layout

\begin_layout LyX-Code
if savePop :
\end_layout

\begin_layout LyX-Code
  saveOp = savePopulation(output='a.txt')
\end_layout

\begin_layout LyX-Code
else:
\end_layout

\begin_layout LyX-Code
  saveOp = noneOp()
\end_layout

\begin_layout LyX-Code
simu.evolve( [ ...
 saveOp ])
\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
pause
\begin_inset LatexCommand index
name "operator!pause"

\end_inset


\end_layout

\begin_layout Standard
This operator will pause the simulation and wait for user response.
 User can use 'q' to stop evolution, 's' to escape to a python shell, or
 any other key to continue.
 
\end_layout

\begin_layout Standard
There are two ways to use this operator, the first one is to pause the simulatio
n at specified generations, using the usual operator parameters like 
\family typewriter
at
\family default
.
 Another way is to pause a simulation with any key stroke, using the 
\family typewriter
stopOnKeyStroke
\family default
 parameter.
 This feature is useful for presentation and interative simulation.
 
\end_layout

\begin_layout Standard
When 's' is pressed, this operator expose the current population to the
 main python dictionary as variable 'pop' and enter an interactive python
 session.
 The way current population is exposed can be controled by parameter 
\family typewriter
exposePop
\family default
 and 
\family typewriter
popName
\family default
.
 This feature is useful when you want to examine the properties of a population
 during evolution.
\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
ticToc
\begin_inset LatexCommand index
name "operator!ticToc"

\end_inset


\family default
, function 
\family typewriter
TicToc
\begin_inset LatexCommand index
name "function!TicToc"

\end_inset


\end_layout

\begin_layout Standard
This operator, when called, output the difference between current and last
 called clock time.
 This can be used to estimate execution time of each generation.
 Similar information can also be obtained from 
\end_layout

\begin_layout LyX-Code
turnOnDebug(DBG_PROFILE)
\end_layout

\begin_layout Standard
but this operator has the advantage of measuing duration between several
 generations (set 
\family typewriter
step
\family default
 parameter.)
\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
setAncestralDepth
\family default
, function 
\family typewriter
pop.setAncestralDepth
\end_layout

\begin_layout Standard

\family typewriter
setAncestralDepth
\family default
 set the number of ancestral generations to keep in a population.
 This is useful when constructing pedigree trees from a population.
 
\end_layout

\begin_layout Section
Random Number Generator
\end_layout

\begin_layout Standard
Random number generator is a tricky business.
 Reliable and fast RNGs are hard to find and everyone seems to trust/distrust
 certain RNGs.
 To avoid such arguments, I have included all RNGs from GSL (
\begin_inset LatexCommand url
name "The GNU Scientific Library"
target "http://sources.redhat.com/gsl/"

\end_inset

) and you can choose any of the 61 RNGs, if you really know what the differences
 between them.
 (I do not, except that some of them are really bad but fast.) Note that
 RNG that can not generate a full range of integers are removed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Random number generator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/rng.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you need to use a random number generator in your 
\family typewriter
pyEval
\family default
 operator, you can either use python random module (
\family typewriter
import random
\family default
) or use 
\family typewriter
rng
\begin_inset LatexCommand index
name "function!rng"

\end_inset

()
\family default
 function to get the random number generator of simuPOP.
 Note that 
\family typewriter
rng()
\family default
 does not have many member functions and it might be tricky to use them
 correctly.
 (This object is not designed to be used at the Python level.
 For a full list of member functions, check 
\family typewriter
src/utility.h
\family default
)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Random number generator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/rngrand.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since simuPOP 0.7.1, RNGs are seeded in the following order:
\end_layout

\begin_layout Itemize
use random number from /dev/urandom if it is available
\end_layout

\begin_layout Itemize
use random number from /dev/random if it is available
\end_layout

\begin_layout Itemize
use python expression (random.randint(0, sys.maxint) + int(time.time())) %
 sys.maxint .
 This method is used only when simuPOP is first loaded so if you are going
 to set random number generator by youself, the relevant code in simuPOP.py
 is recommended.
\end_layout

\begin_layout Standard
The seed can also be retrieved using rng().seed() function, which should
 be saved for serious simulations.
\end_layout

\begin_layout Section
Debug-related operators/functions
\end_layout

\begin_layout Standard
Standard 
\family typewriter
simuPOP
\family default
 library can print out lots of debug information upon request.
 These are mostly for internal debuging use but you can also use them when
 error happens.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout LyX-Code
>>> population(1).individual(0).arrAllele()
\end_layout

\begin_layout Standard
It is not clear why this simple line will cause us trouble, instead of outputtin
g the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug info:
\end_layout

\begin_layout LyX-Code
>>> TurnOnDebug(DBG_ALL)
\end_layout

\begin_layout LyX-Code
Debug code DBG_ALL is turned on.
 cf.
 listDebugCode(), turnOffDebug() 
\end_layout

\begin_layout LyX-Code
>>> population(1).individual(0).arrAlleles()
\end_layout

\begin_layout LyX-Code
Constructor of Population is called
\end_layout

\begin_layout LyX-Code
Population size 1
\end_layout

\begin_layout LyX-Code
Destructor of Population is called 
\end_layout

\begin_layout LyX-Code
Segmentation fault (core dumped) 
\end_layout

\begin_layout Standard

\family typewriter
population(1)
\family default
 creates a temporary object that is destroyed right after the execution
 of the input.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is create a persistent population object: 
\end_layout

\begin_layout LyX-Code
>>> pop = population(1)
\end_layout

\begin_layout LyX-Code
>>> pop.individual(0).arrAllele()
\end_layout

\begin_layout Standard
If the output is overwhelming after you turn on all debug info, you can
 turn on certain part of the info by using the following functions:
\end_layout

\begin_layout Itemize

\family typewriter
ListDebugCode
\begin_inset LatexCommand index
name "listDebugCode"

\end_inset

()
\family default
 list all debug code.
\end_layout

\begin_layout Itemize

\family typewriter
turnOnDebug()
\begin_inset LatexCommand index
name "operator!turnOnDebug"

\end_inset

, TurnOnDebug
\begin_inset LatexCommand index
name "Function!TurnOnDebug"

\end_inset

(code)
\family default
 turn on a debug code
\end_layout

\begin_layout Itemize

\family typewriter
turnOffDebug()
\begin_inset LatexCommand index
name "operator!turnOffDebug"

\end_inset

, TurnOffDebug
\begin_inset LatexCommand index
name "Function!turnOffDebug"

\end_inset

(code)
\family default
 turn off debug code
\end_layout

\begin_layout Standard

\family typewriter
turnOnDebug()
\family default
 and 
\family typewriter
turnOffDebug()
\family default
 are operators and accept all operator parameters 
\family typewriter
begin, step
\family default
 etc.
 Usually, you can 
\family typewriter
turnOndebug
\family default
 before simuPOP starts to misbehave to output more info about a potential
 bug.
 
\end_layout

\begin_layout Standard
Another useful debug code is 
\family typewriter
DBG_PROFILE.

\family default
 When turned on, it will display running time of each operator.
 This will give you a good sense of which operator runs slowly (or simply
 the order of operator execution if you are not sure).
 If most of the excution time is spent on a pure-python operator, you may
 want to rewrite it in C++.
 Note that when 
\family typewriter
DBG_PROFILE
\family default
 is suitable for measuing individual operator performance.
 If you would like to measure execution time of all operators in several
 generations, 
\family typewriter
ticToc
\family default
 operator is better.
  
\end_layout

\begin_layout Chapter
Extending simuPOP
\end_layout

\begin_layout Standard
simuPOP can be extended easily using Python programming language.
 Because almost all data are exposed to the python interface, your ability
 of extending simuPOP is unlimited.
 However, because Python is slower than C++ and the exchange of data between
 internal C++ data structure and python interface may be costly, it is not
 recommended to write frequently used operators in python.
 Appropriate pure python operators are visualizers, statistics calculator,
 file outputers etc.
\end_layout

\begin_layout Standard
To write smuPOP extension, you will have to know more data structure and
 member functions of population.
 Note that for efficiency and implementation reasons, many of the following
 functions do not provide keyword parameters.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Genotypic-structure"

\end_inset

Genotypic structure
\end_layout

\begin_layout Standard
The genotypes of an individual are organized as a single array.
 For example, if you have an diploid individual with two chromosomes, having
 2 and 3 loci respectively.
 The genotypes should be in the order of
\end_layout

\begin_layout LyX-Code
0-0-0, 1-0-0, 0-1-0, 1-1-0, 2-1-0,0-0-1, 1-0-1, 0-1-1, 1-1-1,2-1-1
\end_layout

\begin_layout Standard
where X-X-X are locus-chromosome-ploidy indices.
 An important consequence of this arrangement is that 'locus location' +
 'total number of loci' is the location of the locus on the other set of
 chromosomes.
 
\end_layout

\begin_layout Standard
Several functions are provided to retrieve genotypic info:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\begin_inset LatexCommand index
name "function!ploidy"

\end_inset

()
\end_layout

\begin_layout Itemize

\family typewriter
numChrom
\begin_inset LatexCommand index
name "function!numChrom"

\end_inset

()
\end_layout

\begin_layout Itemize

\family typewriter
numLoci
\begin_inset LatexCommand index
name "function!numLoci"

\end_inset

(chrom)
\family default
, number of loci on chromosome chrom
\end_layout

\begin_layout Itemize

\family typewriter
totNumLoci
\begin_inset LatexCommand index
name "function!totNumLoci"

\end_inset

()
\end_layout

\begin_layout Itemize

\family typewriter
genoSize
\begin_inset LatexCommand index
name "function!genoSize"

\end_inset

()
\family default
, size of genotype.
 Equals to 
\family typewriter
totNumLoci()*ploidy()
\end_layout

\begin_layout Itemize

\family typewriter
alleleName
\begin_inset LatexCommand index
name "function!alleleName"

\end_inset

()
\family default
, if not specified by 
\family typewriter
alleleNames
\family default
 parameter when creating a population, return allele number
\end_layout

\begin_layout Itemize

\family typewriter
locusPos
\begin_inset LatexCommand index
name "function!locusPos"

\end_inset

(loc)
\family default
, locus position on chromosome (Distance to the beginning of chromosome)
\end_layout

\begin_layout Itemize

\family typewriter
arrlociPos
\begin_inset LatexCommand index
name "function!arrLociPos"

\end_inset

()
\family default
, return an 
\family typewriter
carray
\family default
 of the loci distance.
\end_layout

\begin_layout Standard
The last function is very interesting.
 It actually return the reference of the internal loci distance array.
 If you change the value of the returned array, the internal loci distance
 will be changed! All functions with this property will be named 
\family typewriter
arrFunc()
\family default
.
\end_layout

\begin_layout Standard
The following example shows how to change locus distance through this function.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
geno stru
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/extgenostru.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Accessing-genotype-and"

\end_inset

Accessing genotype and other info
\end_layout

\begin_layout Standard
Genotype of an individual can be retrieved through the following functions
\end_layout

\begin_layout Itemize

\family typewriter
ind.allele
\begin_inset LatexCommand index
name "function!allele"

\end_inset

(index, p=0)
\end_layout

\begin_layout Itemize

\family typewriter
ind.setAllele
\begin_inset LatexCommand index
name "function!setAllele"

\end_inset

(value, index, p=0)
\end_layout

\begin_layout Itemize

\family typewriter
ind.arrGenotype
\begin_inset LatexCommand index
name "function!arrAlleles"

\end_inset

(p=0, ch=0)
\end_layout

\begin_layout Standard

\family typewriter
p
\family default
 means ploidy.
 I.e., the index of copies of chromosomes.
 
\family typewriter
ch
\family default
 means chromosome.
 For example
\end_layout

\begin_layout LyX-Code
pop.individual(1).arrGenotype(1, 2)
\end_layout

\begin_layout Standard
returns an array of alleles on the third chromosome of the second copy of
 chromosomes, of the second individual in the population 
\family typewriter
pop
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
genotype
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/extgenotype.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sex, affected status can be accessed through 
\family typewriter
sex, setSex, affected, setAffected
\family default
 functions.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
genotype
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/extother.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Direct-populaiton-manipulation"

\end_inset

Direct populaiton manipulation
\end_layout

\begin_layout Standard
FIXME
\end_layout

\begin_layout Section
Writing Pure Python Operator 
\end_layout

\begin_layout Standard
Now we know how to access information for individuals in a population, but
 how can we use them in reality? Namely, how can you write an pure Python
 operator?
\end_layout

\begin_layout Subsection
Use 
\family typewriter
pyOperator
\end_layout

\begin_layout Standard
There are two kinds of pure python operators.
 The first one is easy: define a function and wrap it with a pyOperator
 operator.
 This method is highly recommended because of its simplicity.
 Many user scripts will use this kind of pure python operator.
 You can find such examples in scripts directory.
 A good one may be simuCDCV.py where a pure python operator is used to calculate
 and visualize special statistics.
 
\end_layout

\begin_layout Standard
For example, if you would like to record a silly statistics, namely the
 genotype of the 
\begin_inset Formula $m$
\end_inset

 individual at locu 
\begin_inset Formula $n$
\end_inset

, you can do:
\end_layout

\begin_layout LyX-Code
def sillyStat(pop, para):
\end_layout

\begin_layout LyX-Code
  # para can be used to pass any number of parameters
\end_layout

\begin_layout LyX-Code
  (filename, m, n) = para # unpack parameter
\end_layout

\begin_layout LyX-Code
  f = open(filename)
\end_layout

\begin_layout LyX-Code
  f.write('%d ' % pop.individual(m).allele(n) )
\end_layout

\begin_layout LyX-Code
  f.close()
\end_layout

\begin_layout LyX-Code
# then in the evole function
\end_layout

\begin_layout LyX-Code
evolve(...
\end_layout

\begin_layout LyX-Code
  ops=[ # other operators
\end_layout

\begin_layout LyX-Code
    pyOperator(func=sillyStat, param=('file.txt', 2, 1) )
\end_layout

\begin_layout LyX-Code
  ]
\end_layout

\begin_layout LyX-Code
)
\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is by default a post-mating operator, you can redefine its stage by 
\family typewriter
stage
\family default
 parameter.
 
\end_layout

\begin_layout Subsection
Use Python eval function
\end_layout

\begin_layout Standard
This kind of pure python operator acts more like an ordinary operator.
 They are usually pyEval or pyExec operators returned by a wrapper function.
 For example, the following function defines a 
\family typewriter
tab
\family default
 operator:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Tab operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/tab.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function actually returns an operator
\end_layout

\begin_layout LyX-Code
output(r"
\backslash
t", rep=REP_LAST, begin=500)
\end_layout

\begin_layout Standard
This kind of operators have some advantages, namely
\end_layout

\begin_layout Itemize
it acts more like ordinary operator.
 
\end_layout

\begin_layout Itemize
it is more efficient since it is handled (at least the first layer) by a
 C/C++ operator.
\end_layout

\begin_layout Standard
However, because of its complexity, such operators can only be found in
 system libraries.
 You can ignore the rest of this section if 
\family typewriter
pyOperator
\family default
 is enough to you.
 
\end_layout

\begin_layout Standard
To define a pure python operator, here is what you will generally do:
\end_layout

\begin_layout Itemize
Write a function that act on a population.
 This function should be able to be called like 
\family typewriter
func(simu.population(0)) .
 
\end_layout

\begin_layout Itemize
Wrap this function as an operator.
 
\end_layout

\begin_layout Standard
For example, function 
\family typewriter
saveInFstatFormat(pop, output, outputExpr, dict)
\family default
 saves a population in FSTAT format.
 Its defnition is (first 15 lines)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
genotype
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/extother.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
You can use this function independently like
\end_layout

\begin_layout LyX-Code
saveInFstatFormat(simu.population(1),'a.txt')
\end_layout

\begin_layout Itemize

\family typewriter
pop.vars()
\family default
 is used to evaluate 
\family typewriter
outputExpr
\family default
 
\end_layout

\begin_layout Standard
Then you can wrap this function by an operator, actually a function that
 returns a 
\family typewriter
pyEval
\family default
 operator:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
save fstat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{log/saveFstat.log}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function takes all parameters of an ordinary operator:
\end_layout

\begin_layout LyX-Code
saveFstat(at=[-1], outputExpr=r
\begin_inset Quotes erd
\end_inset

'a'+str(rep)+'.txt'
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
and generate a 
\family typewriter
pyEval
\family default
 operator (use above example)
\end_layout

\begin_layout LyX-Code
pyEval(exposePop=1, at=[-1], 
\end_layout

\begin_layout LyX-Code
  stmts=r"""saveInFSTATFormat(pop,
\end_layout

\begin_layout LyX-Code
    output='''''', outputExpr=r''' 'a'+str(rep)+'.txt' """ 
\end_layout

\begin_layout LyX-Code
  )
\end_layout

\begin_layout Standard
In this example,
\end_layout

\begin_layout Itemize

\family typewriter
pyEval
\family default
 works in the local namespace of each replicate.
 To access that replicate of population, you should use the magic paramter
 
\family typewriter
exposePop
\family default
 of 
\family typewriter
pyEval
\family default
.
 When set true, 
\family typewriter
pyEval
\family default
 will automatically set a variable 
\family typewriter
pop
\family default
 in the current local namespace before any statement is executed.
 This is why we can call 
\family typewriter
saveInFSTATFormat(
\series bold
pop
\series default
...)
\end_layout

\begin_layout Itemize

\family typewriter
'''a'''
\family default
 quotes are used to avoid conflict with quotes in 
\family typewriter
outputExpr
\family default
 etc.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
 
\end_layout

\begin_layout Section
Ultimate extension: working in C++
\end_layout

\begin_layout Standard
It is sometimes desired to write simuPOP extension in C++.
 For example,
\end_layout

\begin_layout Itemize
when you need some other mating scheme
\end_layout

\begin_layout Itemize
when you need certain operator that a pure Python implementation would be
 too slow.
\end_layout

\begin_layout Itemize
If some aspect of simuPOP is too limited (like the number of maximum alleles)
\end_layout

\begin_layout Standard
It is not difficult to write simuPOP extension in C++, once you know how
 simuPOP is organized.
 The general procedure is
\end_layout

\begin_layout Itemize
install the latest version of SWIG (>1.3.28)
\end_layout

\begin_layout Itemize
check out simuPOP source using subversion
\end_layout

\begin_layout Itemize
build from source and see if your programming environment works well
\end_layout

\begin_layout Itemize
to add an operator, make changes in appropriate 
\family typewriter
.h
\family default
 file, check 
\family typewriter
simuPOP_common.i
\family default
 if your operator can not be used.
\end_layout

\begin_layout Standard
The source code is reasonably well commented with full doxygen based documentati
on.
 Please post to the simuPOP forum if you encounter any problem while writing
 operators in C++.
\end_layout

\begin_layout Section
Debugging
\end_layout

\begin_layout Subsection
test scripts
\end_layout

\begin_layout Standard
There are many test scripts under the 
\family typewriter
test
\family default
 directory.
 It is recommended that you run the test scripts after you install simuPOP.
 This will make sure that your system is working correctly.
 To run all tests, run
\end_layout

\begin_layout LyX-Code
sh run_tests.sh
\end_layout

\begin_layout Standard
Or, if you do not install rpy and r, run
\end_layout

\begin_layout LyX-Code
sh run_tests.sh norpy
\end_layout

\begin_layout Standard
Please report any failed test.
\end_layout

\begin_layout Subsection
Memory leak detection
\end_layout

\begin_layout Standard
Python extensions tend to have memory leak problem, caused by the refcount
 mechanism.
 If your simuPOP script uses more and more RAM without population size increase,
 you may have this problem.
 You may try to disable individual operators and see find out the offending
 operator if the problem persist.
 
\end_layout

\begin_layout Standard
Potential simuPOP developers can make use of simuPOP's built-in refcount
 detection mechanism.
 To use it,
\end_layout

\begin_layout Itemize
Compile python with configure option --with-pydebug .
 This will enable sys.totalrefcount() etc
\end_layout

\begin_layout Itemize
Compile simuPOP with -DPy_REF_DEBUG.
 This can be done in setup.py, or better in SConstruct.
\end_layout

\begin_layout Standard
simulator.evolve will check reference count at the end of each generation
 and report any increased reference count.
 Some operators may create python object (like ascertainment operators)
 but if you see repeated warning at each generation, there is definitely
 a memory leak.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "bibtotoc,plainnat"
bibfiles "bib/all"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
