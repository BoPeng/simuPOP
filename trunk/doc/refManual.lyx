#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass manual
\begin_preamble
\usepackage{underscore}
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.6.10 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Statistics, Rice University}\\
{\bf Email: }{\textsf bpeng@rice.edu}\\
{\bf URL: }{\textsf http://simupop.sourceforge.net} \\
{\bf Mailing List: }{\textsf simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\float_placement H
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 1
\use_natbib 1
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

simuPOP Reference Manual
\layout Standard


\begin_inset Minipage
position 1
inner_position 0
height "1pt"
width "100col%"
collapsed false

\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1cm}
\layout Standard

\backslash 
vspace{5in}
\layout Standard
{
\backslash 
large
\backslash 
textsf Acknowledgements: }
\layout Standard

\backslash 
vspace{.2cm}
\layout Standard

\backslash 
hspace{.3cm} Dr. Marek Kimmel
\layout Standard

\backslash 
hspace{.3cm} Dr. Fran
\backslash 
c cious Balloux
\layout Standard

\backslash 
hspace{.3cm} Dr. William Amos
\layout Standard

\backslash 
hspace{.3cm} SWIG user community
\layout Standard

\backslash 
hspace{.3cm} Python user community 
\layout Standard

\backslash 
hspace{.3cm} Keck Center for Computational and Structural Biology
\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{.7in} 
\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard
 
\backslash 
copyright{} 
\end_inset 

 2004-2005 Bo Peng 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{.3cm} 
\backslash 
hrule 
\backslash 
vspace{0.1cm} 
\end_inset 

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_inset 


\layout Abstract

simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\layout Abstract

The core of simuPOP is a scripting language (Python) that provides a large
 number of building blocks (populations, mating schemes, various genetic
 forces in the form of operators, simulators and gene mapping methods) to
 construct a simulation.
 This provides a R/Splus or Matlab-like environment where users can interactivel
y create, manipulate and evolve populations, monitor and visualize population
 statistics and apply gene mapping methods.
 The full power of simuPOP and Python (even R) can be utilized to simulate
 arbitrarily complex evolutionary scenarios.
\layout Abstract

simuPOP is written in C++ and is provided as Python libraries.
 Besides a front-end providing an interactive shell and a scripting language,
 Python is used extensively to pass dynamic parameters, calculate complex
 statistics and write operators.
 Because of the openness of simuPOP and Python, users can make use of a
 wide variety of tools (Splus/R, Python/SciPy, MatPlotLib etc.) to perform
 tasks like statistical analysis, gene mapping and visualization.
 Depend on machine configuration, simuPOP can simulate large (think in millions)
 populations at reasonable speed.
\layout Abstract

Binary libraries of simuPOP are provided for linux, windows, solaris and
 mac systems.
 Source code and development documentations are also available for easy
 porting to other platforms.
 Both source code and binaries can be distributed free-of-charge under GPL
 license.
 All resources, including a pdf version of this manual and a discussion
 forum can be found at the simuPOP homepage 
\family typewriter 
http://simupop.sourceforge.net 
\family default 
.
\layout Abstract


\series bold 
How to cite simuPOP: 
\begin_deeper 
\layout Quote

Bo Peng and Marek Kimmel (2005) simuPOP: a forward-time population genetics
 simulation environment.

\emph on 
 bioinformatics
\emph default 
, 
\series bold 
21
\series default 
(18): 3686-3687
\end_deeper 
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Section

Design
\layout Standard

simuPOP is written in C++ and uses 
\begin_inset LatexCommand \htmlurl[python]{http://www.python.org}

\end_inset 

 as its user interface and extension language.
 Users can develop/debug simulations using Python shell interactively and
 run them as python scripts.
 Python expressions, statements can be used to pass dynamic variables, calculate
 population statistics, call hybrid operators (will explain later) or write
 operators from scratch.
 This flexibility gives simuPOP the power to simulate almost all evolutionary
 scenarios.
\layout Section

simuPOP Features
\layout Standard

Currently, simuPOP provides the following features:
\layout Itemize

Population with one-level subpopulation structure.
 (no explicit family structure) There is no limit on ploidy, number of chromosom
es, number of loci and population size.
 (depends on available RAM).
 Sex chromosomes can be modeled.
\layout Itemize

A population can hold arbitrary number of ancestral generations (default
 to none) for easy pedigree analysis.
 
\layout Itemize

Population/subpopulation sizes can be changed during mating.
 Subpopulations can be created/changed as a result of migration.
 
\layout Itemize

Several replicates of populations can be evolved simultaneously.
 
\layout Itemize

Mating schemes include random mating, binomial selection etc.
 Number of offsprings per mating can be constant, or follow a random distributio
n.
\layout Itemize

Populations can be saved and loaded in text, binary, XML, Fstat, GC formats.
 Methods to deal with other formats are provided.
 
\layout Itemize

Simulation can be paused, saved and resumed easily.
\layout Itemize

Easy developing/debugging using Python interactive shell, or run in batch
 as python scripts.
\layout Itemize

A wide variety of operators are provided.
 They can act on the populations at selected generations, at different stages
 of a life-cycle, on different replicate or replicate group.
 
\layout Itemize

Built-in operators for arbitrary migration model.
 
\layout Itemize

Operators for 
\begin_inset Formula $k$
\end_inset 

-allele, stepwise and generalized stepwise mutation models.
 Hybrid operators can be used for more complicated mutation models.
\layout Itemize

Support uniform or non-uniform (differ-by-loci) recombinations.
 Male/female individuals can have different recombination rates/intensities.
 
\layout Itemize

Support many single-locus selection model and multiplicative/additive multi-loci
 selection models.
 Hybrid operator is provided for arbitrary selection model.
\layout Itemize

Built-in support for allele, genotype, heterozygote, haplotype number/frequency
 calculation.
 As well as some more complicated statistics like 
\begin_inset Formula $F_{st}$
\end_inset 

.
 Other statistics can be calculated from these basic statistics.
\layout Itemize

Has support for plotting through Python/SciPY, Python/MatPlotLib or RPy
 (use R through Python).
 R/Rpy is recommended.
 
\layout Itemize

Operators to calculate quantitative trait, penetrance and draw samples from
 current population.
\layout Itemize

Built-in ascertainment methods
\layout Itemize

Maybe most importantly: 
\emph on 
a complete and detailed reference manual!
\layout Section

Starting simuPOP
\layout Standard

After installation, you should have the following files and directories
\layout Description


\begin_inset ERT
status Open

\layout Standard
simuPOP.py
\end_inset 

 The wrapper library of real simuPOP libraries.
 It loads appropriate library according to
\family typewriter 
 
\family default 
command line, environment variable or 
\family typewriter 
simuOpt 
\family default 
options.
\layout Description


\begin_inset ERT
status Open

\layout Standard
simuOpt.py
\end_inset 

 simuPOP options.
 Allow simuPOP to load standard/optimized, short/long allele version of
 the library.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
simuPOP_std.py, 
\backslash 
_simuPOP_std.so
\end_inset 

 The python/C++ portion of the standard library, file extension is platform
 dependent.
 Usually installed under site-packages.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
simuPOP
\backslash 
_op.py, 
\backslash 
_simuPOP
\backslash 
_op.so
\end_inset 

 Optimized version of the library.
 This library does not have any parameter check, boundary check, debugging
 info and can be 50% faster than the standard library.
 It is highly recommended that you use this library after you make sure
 the simulation runs correctly with the standard library.
 Usually installed under site-packages.
\layout Description


\begin_inset ERT
status Open

\layout Standard
simuPOP
\backslash 
_la.py, 
\backslash 
_simuPOP
\backslash 
_la.so, simuPOP
\backslash 
_laop.py, 
\backslash 
_simuPOP
\backslash 
_laop.so
\end_inset 

 Long-allele (standard/optimized) version of the library.
 simuPOP's locus, by default, has at most 255 alleles.
 If this imposes a restriction to your application, you can use 
\family typewriter 
simuPOP_la
\family default 
 instead of the standard library.
 This library uses 4 bytes to store an allele so the memory usage is roughly
 four times of the standard library.
 Note that many currently available population programs have their own max
 allele limits.
 For example, current version of 
\family typewriter 
fstat
\family default 
 can handle at most 999 alleles.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
simuUtil.py, simuSciPy.py, simuMatPlt.py, simuRPy.py 
\end_inset 

 
\family typewriter 
simuUtil.py
\family default 
 includes some (and will have more) frequently used operators and functions
 to calculate popular population statistics.
 
\family typewriter 
simuSciPy.py 
\family default 
including a 
\family typewriter 
varPlotter 
\family default 
to plot variables using the 
\family typewriter 
gplt 
\family default 
package of
\family typewriter 
 SciPy
\family default 
.
 
\family typewriter 
simuMatPlt 
\family default 
is the same 
\family typewriter 
varPlotter 
\family default 
but uses
\family typewriter 
 matplotlib
\family default 
 package.
 These are usually installed under site-packages.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
README, ChangeLog, etc.
\end_inset 

 Standard readme, installation, license notification files, etc.
 Installed under 
\family typewriter 
share/simuPOP
\family default 
 of 
\family typewriter 
/usr
\family default 
 or Python root.
\layout Description

doc this file in PDF format and 
\family typewriter 
userGuide.py
\family default 
.
 Installed under share/simuPOP.
\layout Description

test test scripts.
 
\layout Description

misc some utilities to help you use simuPOP.
 See 
\family typewriter 
README
\family default 
 under this directory for details.
 Installed under share/simuPOP.
\layout Standard

You should be able to load simuPOP library by running command 
\layout Standard


\begin_inset Include \verbatiminput{log/importSimuPOP.log}
preview false

\end_inset 

from python interactive shell.
 If simuPOP is located but python reports an error, please see simuPOP FAQ
 and/or post to simuPOP forum.
\layout Standard


\family typewriter 
from simuPOP import * 
\family default 
will load the standard short-allele version of the library.
 If you would like to use another library, do either
\layout Itemize

set environmental variable 
\family typewriter 
SIMUOPTIMIZED
\family default 
 and/or 
\family typewriter 
SIMULONGALLELE
\family default 
 accordingly
\layout Itemize

use 
\family typewriter 
simuOpt
\family default 
 module to set the option before 
\family typewriter 
simuPOP 
\family default 
is loaded
\begin_deeper 
\layout Standard


\begin_inset Include \verbatiminput{log/importSimuPOPOpt.log}
preview false

\end_inset 


\end_deeper 
\layout Standard

Several python GUI are available including ActivePython IDE, IDLE but the
 most convenient one is emacs (not surprisingly!).
 Through the time of developing simuPOP, I have written several emacs extensions
 to simplify the use of python within emacs.
 You can find them under the 
\family typewriter 
misc 
\family default 
directory if you are interested.
 
\layout Section

Naming Conventions
\layout Standard


\family typewriter 
simuPOP
\family default 
 follows the following naming conventions.
\layout Itemize

Classes (objects), member functions and parameter names start with small
 character and use capital character for the first character of each word
 afterwards.
 For example
\layout LyX-Code

population, population::subPopSize(), individual::setInfo()
\layout Itemize

Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter 
initByFreq
\family default 
 is an operator and
\family typewriter 
 InitByFreq(pop, vars)
\family default 
 is its function version (equivalent to 
\family typewriter 
initByFreq(vars).apply(pop)
\family default 
.
\layout Itemize

Constants start with Capital characters.
 For example
\layout LyX-Code

MigrByProportion, StatNumOfFemale
\layout Itemize

The following words in function names are abbreviated:
\layout LyX-Code

dist (distance),  info (information), migr (migration), subPop (subpopulation),
 
\newline 
(rep) replicate, gen (generation), grp (group(s)), ops (operators), 
\newline 
expr (expression), stmts (statements) 
\layout Chapter

simuPOP Components
\layout Section

Important Concepts
\layout Standard

simuPOP consists of the following components.
 It is important that you know what they are and how they are related.
 In this chapter, I will briefly explain each component and explain each
 of them in detail.
\layout Description

individual
\begin_inset LatexCommand \index{individual}

\end_inset 

 individuals are building blocks of populations.
 Each individual has its own genotype (chromosomes and loci), sex, disease
 status and some other auxiliary information.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
genotypic structure
\end_inset 


\begin_inset LatexCommand \index{genotype structure}

\end_inset 

 refers to the number of chromosomes, number and location of loci on each
 chromosome, name of alleles, maximum number of alleles.
 Individuals in the same population must have the same genotypic structure.
\layout Description

population
\begin_inset LatexCommand \index{population}

\end_inset 

 collection of individuals of the same type (genotypic structure) with subpopula
tion structure.
 A population object is associated with some variables that store population
 statistics calculated by operators.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
Mating scheme 
\end_inset 

 how individuals are chosen and mated during evolution.
 
\layout Description

operator
\begin_inset LatexCommand \index{operator}

\end_inset 

 operators are objects that manipulate populations.
 They can apply genetic forces like mutation, recombination, migration to
 populations, calculate population statistics, plot dynamics of variables,
 save populations or terminate simulation conditionally.
 Operators can be
\layout Itemize


\family typewriter 
built-in: 
\family default 
written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\layout Itemize


\family typewriter 
hybrid
\begin_inset LatexCommand \index{hybrid}

\end_inset 

:
\family default 
 written in C++ but calls python functions during execution.
 For example, a hybrid mutator 
\family typewriter 
pyMutator 
\family default 
will determine if an allele will be mutated and call a user-defined Python
 function to mutate it.
\layout Itemize


\family typewriter 
pure python:
\family default 
 written in python.
 For example, a 
\family typewriter 
varPlotter
\family default 
 can plot python variables that are set by other operators.
\layout Description

simulator
\begin_inset LatexCommand \index{simulator}

\end_inset 

 simulator manage several replicates of 
\emph on 
populations
\emph default 
 and evolve them in a way specified by a
\emph on 
 mating scheme
\emph default 
 generation by generation, subject to arbitrary number/kinds of 
\emph on 
operators
\emph default 
.
 There is nothing stops you from evolving an population manually but simulator
 simplifies this process a lot.
\layout Description

variables are associated with populations.
 They are dynamically generated by operators and can be accessed from Python
 namespace.
 This is how users obtain population statistics during evolution.
\layout Description


\begin_inset ERT
status Collapsed

\layout Standard
expression and statement
\end_inset 

 are python expression
\begin_inset LatexCommand \index{expression}

\end_inset 

 and statement
\begin_inset LatexCommand \index{statement}

\end_inset 

.
 They are widely used in 
\family typewriter 
simuPOP
\family default 
 to specify dynamic parameters, calculate statistics etc.
 
\layout Standard

You can refer to the 
\emph on 
simuPOP user's guide
\emph default 
 for a simple example.
\layout Section

Genotypic structure 
\begin_inset LatexCommand \index{genotypic structure}

\end_inset 


\layout Standard

Genotypic structure refers to 
\layout Itemize

ploidy, the number of copies of basic number of chromosomes (c.f.
 
\family typewriter 
ploidy
\begin_inset LatexCommand \index{GenoStruTrait!ploidy}

\end_inset 

(), ploidyName
\begin_inset LatexCommand \index{GenoStruTrait!ploidyName}

\end_inset 

() 
\family default 
)
\layout Itemize

number of chromosomes (c.f.

\family typewriter 
 numChrom
\begin_inset LatexCommand \index{GenoStruTrait!numChrom}

\end_inset 

() 
\family default 
)
\layout Itemize

existence of sex chromosome (c.f.
 
\family typewriter 
sexChrom
\begin_inset LatexCommand \index{GenoStruTrait!sexChrom}

\end_inset 

() 
\family default 
)
\layout Itemize

number of loci on each chromosome (c.f.
 
\family typewriter 
numLoci
\begin_inset LatexCommand \index{GenoStruTrait!numLoci}

\end_inset 

(ch), totNumLoci
\begin_inset LatexCommand \index{GenoStruTrait!totNumLoci}

\end_inset 

() 
\family default 
)
\layout Itemize

locus location on chromosome (c.f.
 
\family typewriter 
locusPos
\begin_inset LatexCommand \index{GenoStruTrait!locusPos}

\end_inset 

(loc), arrlociPos
\begin_inset LatexCommand \index{GenoStruTrait!arrLociPos}

\end_inset 

() 
\family default 
)
\layout Itemize

allele names, default to allele number (c.f.
 
\family typewriter 
alleleName
\begin_inset LatexCommand \index{GenoStruTrait!alleleName}

\end_inset 

(allele) 
\family default 
)
\layout Itemize

maximum allele state (c.f.
 
\family typewriter 
maxAllele
\begin_inset LatexCommand \index{GenoStruTrait!maxAllele}

\end_inset 

() 
\family default 
)
\layout Standard

The following example creates a population and displays some of genotypic
 information
\layout Standard


\begin_inset Include \verbatiminput{log/genoStru.log}
preview false

\end_inset 


\layout Standard

Individuals in the same population share the same genotypic structure.
 Consequently, 
\emph on 
genotypic information can be retrieved from individual, population and simulator
\emph default 
 (consists of populations with the same genotypic structure)
\emph on 
 level
\emph default 
.
 
\layout Standard


\begin_inset Include \verbatiminput{log/indGenoStru.log}
preview false

\end_inset 


\layout Standard

You may have noticed that locus Indices start from 0.
 
\series bold 
As a matter of fact, all arrays in simuPOP start at index 0
\series default 
.
 To avoid confusion, I will refer the first locus as locus zero, second
 locus as locus one; first individual in a population as individual zero,
 and so on.
 The reason why zero-based indices are used is because C++ and Python, using
 which simuPOP is built, are both zero-based.
\layout Standard

Another concern is how we should refer to loci on different chromosomes.
 The solution is that we almost always use
\emph on 
 absolute index
\begin_inset LatexCommand \index{index!absolute}

\end_inset 

 
\emph default 
and seldom 
\emph on 
use relative index
\begin_inset LatexCommand \index{index!relative}

\end_inset 

.
 
\emph default 
For example, if there are five and seven loci on the first two chromosomes,
 the absolute indices of loci will be (0,1,2,3,4), (5,6,7,8,9,10,11).
 It may feel confusing at first but this avoids the trouble of having to
 use two numbers (chrom, index) to refer to a locus.
 If relative index is needed, functions 
\family typewriter 
chromLocusPair(absIndex)
\family default 
 and 
\family typewriter 
absLocusIndex(chrom,index)
\family default 
 can be used.
 
\begin_inset Include \verbatiminput{log/absIndex.log}
preview false

\end_inset 


\layout Standard

A full list of genotypic structure related functions, please use 
\family typewriter 
help(population)
\family default 
 or 
\family typewriter 
help(individual) 
\family default 
or directly
\family typewriter 
 help(GenoStruTrait).

\family default 
 (You may notice that both 
\family typewriter 
population 
\family default 
and 
\family typewriter 
individual 
\family default 
classes are inherited from 
\family typewriter 
GenoStruTrait
\family default 
 class.
 )
\layout Standard


\begin_inset Float table
placement h
wide false
collapsed false

\layout Caption

Genotypic structure related functions
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="19" columns="2">
<features islongtable="true">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
function
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
ploidy()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

number of copies of chromosomes
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
ploidyName()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

haploid, diploid, triploid etc
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
numLoci(chrom)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

number of loci on a chromosome
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
sexChrom()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

whether or not the last chromosome is sex chromosome
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
totNumLoci()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

total number of loci on all chromosomes
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
genoSize()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

totNumLoci()*ploidy()
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
locusPos(loc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

the position of a locus
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
arrLociDist()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

return an (editable) array of loci positions
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
numChrom()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

number of chromosomes
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
chromBegin(chrom)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

index of the first locus on a chromosome
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
chromEnd(chrom)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

index of the last locus on a chromosome + 1 
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
absLocusIndex(chrom, loc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

absolute index of a locus on a chromosome
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
chromLocusPair(loc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

(chrom, loc) pair of an absolute index
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
alleleName(allele)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

name of an allele (if previously specified)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
alleleNames()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

array of names of alleles, the first one is for missing value
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
locusName(loc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

name of a locus
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
maxAllele()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

maximum allele state for all loci
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
setMaxAllele(max)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

set maximum allele state for all loci
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Subsection

Sex chromosome
\layout Standard

If 
\family typewriter 
sexChrom() 
\family default 
is false, all chromosomes are assumed to be autosomes.
 You can also create population/individuals with a sex chromosome.
 Please note that we currently only model the XY chromosomes in diploid
 population.
 Consequently,
\layout Itemize

Sex chromosome is always the last chromosome.
 
\layout Itemize

Sex chromosome can only be specified for diploid population.
 (
\family typewriter 
ploidy()
\family default 
=2)
\layout Itemize

Sex chromosomes (XY) may differ in length.
 You should specify the length of the longer one as the chromosome length.
 If there are more loci on X than Y, the rest of the Y chromosome is unused.
 Mutation, recombination may still occur at this unused part of chromosome
 to simplify implementation and usage.
 
\layout Itemize

It is assumed that male has XY and female has XX chromosomes.
 The sex chromosomes of male individuals will be arranged in the order of
 XY.
 
\layout Section

Population
\layout Standard


\family typewriter 
population
\begin_inset LatexCommand \index{population}

\end_inset 


\family default 
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals,
 all have the same genotypic structure.
 A population can store arbitrary number of ancestral populations to facilitate
 pedigree analysis.
\layout Standard

simuPOP uses one-level population structure.
 That is to say, there is no sub-subpopulation or families in subpopulations.
 Mating is within subpopulations only.
 Exchange of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
 More specifically
\layout Itemize

Migration can change subpopulation size; create or remove subpopulations.
 Since migration can not generate new individuals, total population size
 will not be changed.
\layout Itemize

Mating can fill any population/subpopulation structure with offsprings.
 Both population and subpopulation sizes can be changed.
 Since mating is within subpopulation, you can not create new subpopulation
 through mating.
\layout Itemize

A special operator 
\family typewriter 
pySubset 
\family default 
can shrink population size.
 It removes individuals according to their 
\family typewriter 
info() 
\family default 
status.
 (Will explain later.) This can be used to model sudden population decrease
 due to natural disaster.
 
\layout Itemize

Subpopulations can be split or merged.
\layout Standard

Note that migration will most likely change subpopulation size.
 To keep subpopulation sizes constant, you can set subpopulation sizes during
 mating so that the next generation will have desired subpopulation sizes.
\layout Standard

Every population has its own variable space, or 
\emph on 
local namespaces
\begin_inset LatexCommand \index{local namespace}

\end_inset 

 
\emph default 
in simuPOP term.
 This namespace is a Python dictionary that is attached to each population
 and can be exposed to the users through 
\family typewriter 
vars()
\family default 
 or 
\family typewriter 
dvars()
\family default 
 function.
 Many functions and operators work in these namespaces and store their results
 in them.
 For example, function 
\family typewriter 
Stat
\family default 
 set variables like 
\family typewriter 
alleleFreq[loc] 
\family default 
and you can access them like 
\family typewriter 
pop.dvars().alleleFreq[loc][allele]
\family default 
.
 
\layout Standard

Population has a large number of member functions, ranging from reviewing
 simple property to generating new population from the current one.
 However, you do not have to know all the member functions to use a population.
 As a matter of fact, you will only use a small portion of these functions
 unless you need to write pure python functions/operators that involves
 complicated manipulation of populations.
\layout Standard
\added_space_top medskip \align center 

\series bold 
Member functions of the population object
\layout Standard
\added_space_bottom smallskip \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="47" columns="3">
<features islongtable="true" firstHeadBottomDL="true" headBottomDL="true">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0" special="|p{2in}|">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0" special="p{4in}|">
<row topline="true" bottomline="true" endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ref
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

function
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
population()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Create a population.
 Note that this is techniquely the
\family typewriter 
 __init__ 
\family default 
function of the population object.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
numSubPop()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Number of subpopulations in a population
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
subPopSize(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Size of a subpopulation
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
subPopSizes()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return an array of subpopulation sizes
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
popSize()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Total population size
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
absIndIndex(idx, sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return the absolute index of an individual in a subpopulation
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
subPopIndPair(ind)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return the (sp,idx) pair from an absolute index of an individual
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
subPopBegin(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Index of the first individual of a subpopulation
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
subPopEnd(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Index of the last individual of a subpopulation + 1
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
individual(ind)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return an individual
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
individual(ind, sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return an individual from a subpopulation
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
arrGenotype()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return an editable array of all genotype of the population.
 You need to know how these genotype are organized to safely read/write
 genotype directly.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
arrGenotype(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return an editable array of all genotype of a subpopulation.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
exposeInfo( name='info')
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Expose (not editable) the info field of all individuals
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
exposeAffectedness( name='affected')
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Expose (not editable) the effectedness field of all individuals
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
setIndInfo(info)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Set info field of all individuals using an array of size
\family typewriter 
 popSize()
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
setIndInfoWithSubPopID()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Fill info field of all individuals using their respective subpopulation
 ID.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
setSubPopByIndInfo( info=[])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Rearrange individual and set subpopulation structure, using the info value
 of each individual as subpopulation ID.
 Individuals with negative info value will be removed.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
splitSubPop( which, sizes, subPopID=[])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Split a subpopulation into subpopulations of gives sizes.
 (The sum of sizes should equal the size of 
\family typewriter 
which
\family default 
 subpopulation.) Subpopulation IDs can be specified.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
splitSubPopByProportion( which, proportions, subPopID=[])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Split a subpopulation info subpopulations of given proportions.
 (The sum of proportions should add up to one).
 Subpopulation IDs can be specifed.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
removeEmptySubPops()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Remove empty subpopulations by adjusting subpopulation IDs.
 
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
removeSubPops( subPops=[], removeEmptySubPops=False)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Remove some subpopulations (and all individuals within).
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
removeIndividuals( inds, subPop=-1)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Remove individuals.
 If a valid subPop is given, remove individuals from this subpopulation.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
mergeSubPops( subPops, removeEmptySubPops=False)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Merge subpopulations, using the first subpopulation ID.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
reorderSubPops( order, rank, removeEmptySubPops=False)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Reorder subpopulations by order or by rank.
 FIXME: details.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
newPopByIndInfo( keepAncestralPops=True, removeEmptySubPops=False)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

FIXME: details.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
removeLoci( remove=[], keep=[])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Remove some loci from the current population.
 One of remove or keep can be specified.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
newPopWithPartialLoci( remove=[], keep=[])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Copy current population to a new one and remove its loci.
 (Current population untouched)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
pushAndDiscard(pop)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

(Almost) Internal use only.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
ancestralDepth()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Ancestral depth of current population.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
setAncestralDepth(depth)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Set ancestral depth.
 0 for none, -1 for unlimited.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
ancestralPop()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Current ancestral population selected.
 (0 for latest generation)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
useAncestralPop(idx)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Use an ancestral population.
 0 for latest generation.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
equalTo(pop)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Compare two populations.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
savePopulation( filename, format)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Save a population.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
loadPopulation( filename, format)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Load a population and replace the current one.
 (Use 
\family typewriter 
LoadPopulation
\family default 
 instead)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
rep()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Current replicate in a simulator
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
grp()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Current group ID in a simulator
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
gen()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Current generation during evolution.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
vars()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return a dictionary of attached Python namespace.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
vars(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return the namespace for a subpopulation
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
dvars()
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return the dictionary 
\family typewriter 
vars()
\family default 
 with keys mapped to attributes.
 I.e., you can access 
\family typewriter 
pop.vars()['LD']
\family default 
 as 
\family typewriter 
pop.dvars().LD.
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
dvars(sp)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Return the attribute version of 
\family typewriter 
vars(sp)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
hasVar(name)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Whether or not a variable exists in the local namespace
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
evaluate(expr, stmts='')
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Evaluate an expression and return its result.
 Optionally run statement first.
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
execute(stmts)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Evaluate a statement (can be multi-line string).
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Subsection

Creating a population
\layout Standard

A population can be created through
\layout Itemize

call 
\family typewriter 
population 
\family default 
function to create an instance of population from 
\family typewriter 
population 
\family default 
class.
\layout Itemize

call 
\family typewriter 
loadPopulation
\family default 
, 
\family typewriter 
loadFstat
\family default 
 etc to load a population from saved image file.
 
\layout Itemize

generated as a subset of an existing population by operators like 
\family typewriter 
randomSample, caseControlSample 
\family default 
or equivalent functions 
\family typewriter 
RandomSample, CaseControlSample
\family default 
.
 
\layout Itemize

Obtained from an existing simulator through
\family typewriter 
 simulator::getPopulation()
\layout Standard

Help contents of all functions of population class can be displayed by 
\family typewriter 
help
\begin_inset LatexCommand \index{help}

\end_inset 

(population)
\family default 
.
 Help on a memeber function can be viewed by 
\family typewriter 
help(population.func)
\family default 
.
 In Python, constructor is named 
\family typewriter 
__init__
\family default 
 and you can use class name to create an instance of the class.
 Therefore, to display parameters of 
\family typewriter 
population
\begin_inset LatexCommand \index{population}

\end_inset 


\family default 
 function, you need to run 
\family typewriter 
help(population.__init__)
\family default 
:
\layout Standard


\begin_inset Include \verbatiminput{log/helpPopInit.log}
preview false

\end_inset 


\layout Standard

Some notes about the parameters:
\layout Itemize


\family typewriter 
size, subPop: 
\family default 
size can be ignored if subPop is specified.
 If both parameters are provided, 
\family typewriter 
subPop 
\family default 
should add up to 
\family typewriter 
size
\family default 
.
\layout Itemize


\family typewriter 
loci:
\family default 
 number of loci on each chromosomes.
 The length of parameter 
\family typewriter 
loci 
\family default 
determines number of chromosomes.
 The last chromosome can be sex chromosome.
 In this case, please specify the maximum number of loci on X or Y.
 I.e., if there are 1 loci on Y chromosme and 0 on X chromosome, use 1.
 
\layout Itemize


\family typewriter 
sexChrom: 
\family default 
true or false.
 Diploid population only.
 If true, the last homologous chromosomes will be treated as sex chromosomes.
 (XY for male and XX for female.) If X and Y have different number of loci,
 you should use the longer one as loci number of the last (sex) chromosome.
\layout Itemize


\family typewriter 
lociPos:
\family default 
 a 1-d or 2-d array specifying positions of loci on each chromosome.
 For example, you can use 
\family typewriter 
lociPos=[1,2,3]
\family default 
 when
\family typewriter 
 loci=[3]
\family default 
 or
\family typewriter 
 lociPos=[[1,2],[1.5,3,5]]
\family default 
 for 
\family typewriter 
loci=[2,3]
\family default 
.
 simuPOP does not assume a unit for these locations, although they are usually
 intepreted as base pairs or centiMorgans, depending on types of simulation
 being performed.
 Currently, loci distance (actually loci location) is used only for specifying
 recombination intensity.
 The actual recombination rate is intensity times loci distance between
 adjacent loci.
\layout Itemize


\family typewriter 
ancestralDepth: 
\family default 
number of most recent ancestral generations to keep during evolution.
 Default to 0.
 You can set it to a positive number
\family typewriter 
 m 
\family default 
to keep the latest 
\family typewriter 
m
\family default 
 generations in the population, or -1 to keep all ancestral populations.
 Note that keeping track of all ancestral populations may quickly exhaust
 your computer RAM.
 If you really need to do that, use 
\family typewriter 
savePopulation
\family default 
 operator to save each generation to a file is a much better choice.
 
\layout Itemize


\family typewriter 
alleleNames:
\family default 
 Note that allele 0 is reserved for 'missing values'.
\layout Itemize


\family typewriter 
maxAllele
\family default 
: maximum allele state for the whole population.
 This will set a cap for all loci.
 For individual locus, you can specify 
\family typewriter 
maxAllele
\family default 
 in mutation models, which can be smaller than global 
\family typewriter 
maxAllele 
\family default 
but not larger.
 Please note that there are two set of simuPOP libraries: one standard and
 one long-allele.
 On most platforms, standard library has max allele state 127 and long-allele
 library has max allele state 
\begin_inset Formula $2^{32}-1$
\end_inset 

.
 
\layout Subsection

Copying a population
\layout Standard

Like many other python operations,
\layout LyX-Code

pop = population(...)
\layout LyX-Code

pop1 = pop
\layout Standard

will create a reference 
\family typewriter 
pop1
\family default 
 to population 
\family typewriter 
pop
\family default 
.
 Modifying 
\family typewriter 
pop1
\family default 
 will modify 
\family typewriter 
pop
\family default 
 as well.
 If you would like to have an independent copy, use
\layout LyX-Code

pop1 = pop.clone()
\layout Standard

This scenario also apply to simulator (see later sections), if 
\family typewriter 
simu
\family default 
 is a simulator with several replicates,
\layout LyX-Code

pop = simu.population(idx)
\layout Standard

will get a reference to one of the replicates.
 You can, although not recomended, modify simulator through this 
\family typewriter 
pop
\family default 
 reference.
 If you would like to get a real copy, use
\layout LyX-Code

pop = simu.getPopulation(idx)
\layout Subsection

Interaction with Operators and Functions
\layout Standard

Operators are objects that can be applied to populations.
 They have special attributes like at which generations to be active, at
 what stage of a evolutionary life cycle to be applied.
 Usually, an operator is created and passed as a parameter to a simulator.
 When 
\family typewriter 
simulator::evolve 
\family default 
(or
\family typewriter 
 step, apply
\family default 
) is called, the simulator will call the 
\family typewriter 
apply() 
\family default 
function of these operators at appropriate times.
 For example
\layout LyX-Code

simu.evolve(
\layout LyX-Code

  preOps = [initByFreq([.8, .2])],
\layout LyX-Code

  ops=[
\layout LyX-Code

    stat( alleleFreq=[0,1], Fst=[1], step = 10),
\layout LyX-Code

    kamMutator( rate = .0001, rep = 1),
\layout LyX-Code

    kamMutator( rate = .001, rep = 2)
\layout LyX-Code

  ], 
\layout LyX-Code

  end = 100
\layout LyX-Code

)
\layout Standard

will create operators 
\family typewriter 
initByFreq, stat 
\family default 
and two copies of 
\family typewriter 
kamMutator
\family default 
.
 During evolution, 
\family typewriter 
simu
\family default 
 will apply 
\family typewriter 
initByFreq
\family default 
 once to each replicate of the simulator; apply the first 
\family typewriter 
kamMutator
\family default 
 to the first replicate and the second 
\family typewriter 
kamMutator 
\family default 
on the second replicate at every generation; apply 
\family typewriter 
stat 
\family default 
to count allele frequency and calculate 
\begin_inset Formula $F_{st}$
\end_inset 

 every 10 generations.
 More details about operators will be introduced later.
\layout Standard

You can ignore the specialties of an opertor and call its 
\family typewriter 
apply() 
\family default 
function directly.
 For example, you can initialize a population outside a simulator by 
\layout LyX-Code

initByFreq( [0.3, .2, .5] ).apply(pop)
\layout Standard

or dump the content of a population by
\layout LyX-Code

dumper().apply(pop)
\layout Standard

This style of calling is used so often that it deserves some simplification.
 Equivalent functions are defined for most of the operators.
 For example, function 
\family typewriter 
InitByFreq 
\family default 
is defined for operator 
\family typewriter 
initByFreq 
\family default 
as follows
\begin_inset Include \verbatiminput{log/InitByFreq.log}
preview false

\end_inset 

 so you can use apply operator 
\family typewriter 
initByFreq 
\family default 
to 
\family typewriter 
pop
\family default 
 as follows:
\layout LyX-Code

InitByFreq(pop, [.3, .2, .5] )
\layout Standard

Note that 
\layout Enumerate

The following two calling sequences have different consequences:
\begin_deeper 
\layout LyX-Code

pop = population(10)
\layout LyX-Code

simu = simulator(pop, randomMating(), rep=3)
\layout LyX-Code

simu.evolve( preOps = [initByFreq([.8,.2]) ] )
\layout Standard

initialize three replicates of the population independently, (
\family typewriter 
initByFreq
\family default 
 object is applied to three populations.) but
\layout LyX-Code

pop = population(10)
\layout LyX-Code

InitByFreq(pop, [.8, .2])
\layout LyX-Code

simu = simulator(pop, randomMating(), rep=3)
\layout Standard

initialize a population once and create a simulator with three copies of
 the initialized population.
 
\end_deeper 
\layout Enumerate

If you are going to call such a function many times, it is more efficient
 to do
\begin_deeper 
\layout LyX-Code

init = initByFreq([.8,.2])
\layout LyX-Code

for i in range(0,1000):
\layout LyX-Code

  init.apply(pop[i])
\layout Standard

than 
\layout LyX-Code

for i in range(0,1000):
\layout LyX-Code

  InitByFreq(pop[i], [.8,.2])
\layout Standard

The difference is that the second method creates and destroys an 
\family typewriter 
initByFreq
\family default 
 object each time it calls the function.
\end_deeper 
\layout Subsubsection

Operator 
\family typewriter 
initByFreq
\family default 
 and
\family typewriter 
 dumper
\layout Standard

These two operators (and their associated functions) will be used frequently
 in this manual.
\layout Itemize


\family typewriter 
initByFreq
\begin_inset LatexCommand \index{initByFreq}

\end_inset 


\family default 
 takes an array of probabilities (must add up to one).
 When applying to a population, each allele will be assigned 
\family typewriter 
1,2,3,...

\family default 
 etc according to the provided probabilities.
 
\family typewriter 
InitByFreq
\begin_inset LatexCommand \index{function!InitByFreq}

\end_inset 

(pop,...)
\family default 
 is its function form.
\layout Itemize


\family typewriter 
dumper
\begin_inset LatexCommand \index{dumper}

\end_inset 


\family default 
 will simply display the population.
 The output format for each individual is: individual index, tag, sex, affected
 status, alleles on copy 
\family typewriter 
1,2,...

\family default 
 of all chromosomes, separated by 
\family typewriter 
|
\family default 
.
 Its function form is named 
\family typewriter 
Dump
\begin_inset LatexCommand \index{function!Dump}

\end_inset 

(pop).
\layout Standard

The following example demonstrate the use of these two operators:
\layout Standard


\begin_inset Include \verbatiminput{log/dumpPop.log}
preview false

\end_inset 


\layout Subsection

Population Structure
\layout Standard

subpopulation structure can be accessed through the following functions:
 
\family typewriter 
popSize
\begin_inset LatexCommand \index{population!popSize}

\end_inset 

(), numSubPop
\begin_inset LatexCommand \index{population!numSubPop}

\end_inset 

(), subPopSize
\begin_inset LatexCommand \index{population!subPopSize}

\end_inset 

(sp), subPopBegin
\begin_inset LatexCommand \index{population!dubPopBegin}

\end_inset 

(sp), subPopEnd
\begin_inset LatexCommand \index{population!subPopEnd}

\end_inset 

(sp), subPopIndPair
\begin_inset LatexCommand \index{population!subPopIndPair}

\end_inset 

(), absIndIndex
\begin_inset LatexCommand \index{population!absIndIndex}

\end_inset 

().
 
\layout Standard


\begin_inset Include \verbatiminput{log/popStru.log}
preview false

\end_inset 


\layout Standard

There are another set of functions that deal with population/subpopulation
 size changes.
 Some of them depend on a special field of 
\family typewriter 
individual
\family default 
: 
\family typewriter 
info.

\family default 
 For example, function 
\family typewriter 
rearrangeByIndInfo
\begin_inset LatexCommand \index{population!rearrangeByIndInfo}

\end_inset 

() 
\family default 
rearrange individuals in the order of their info values.
 Similar functions are:
\layout Itemize


\family typewriter 
pop.setIndInfo
\begin_inset LatexCommand \index{population!setIndInfo}

\end_inset 

(), 
\family default 
set individual info to be used by other functions.
\layout Itemize


\family typewriter 
pop.setIndInfoWithSubPopID
\begin_inset LatexCommand \index{population!setIndInfoWithSubPopID}

\end_inset 

(), 
\family default 
assume ordered info and redivide population according to info values.
\layout Itemize


\family typewriter 
pop.setSubPopByIndInfo
\begin_inset LatexCommand \index{population!setSubPopByIndInfo}

\end_inset 

(),
\family default 
 set info with subpopulation ID
\layout Itemize


\family typewriter 
pop.spliSubPopByProportion
\begin_inset LatexCommand \index{population!spliSubPopByProportion}

\end_inset 

()
\family default 
, split a subpopulation by proporitons
\layout Itemize


\family typewriter 
pop.removeEmptySubPops
\begin_inset LatexCommand \index{population!removeEmptySubPops}

\end_inset 

()
\family default 
, remove empty subpops
\layout Itemize


\family typewriter 
pop.removeSubPops
\begin_inset LatexCommand \index{population!removeSubPops}

\end_inset 

()
\family default 
, remove specified subpopulations.
 Subpop id will be shifted.
\layout Itemize


\family typewriter 
pop.reorderSubPops
\begin_inset LatexCommand \index{population!reorderSubPops}

\end_inset 

()
\family default 
, reorder subpop with given order or rank.
\layout Itemize


\family typewriter 
pop.newPopByIndInfo
\begin_inset LatexCommand \index{population!newPopByIndInfo}

\end_inset 

(),
\family default 
 return a population consists of individuals of non-negative info values.
\layout Itemize


\family typewriter 
pop.removeLoci
\begin_inset LatexCommand \index{population!removeLoci}

\end_inset 

()
\family default 
, remove loci.
 This result in a populaition with different genotypic structure.
\layout Itemize


\family typewriter 
pop.newPopWithPartialLoci
\begin_inset LatexCommand \index{population!newPopWithPartialLoci}

\end_inset 

()
\family default 
, new population with a subset of the loci
\layout Itemize


\family typewriter 
pop.splitSubPop
\begin_inset LatexCommand \index{population!splitSubPop}

\end_inset 

(which, subPopSizes, subPopID),
\family default 
 split subpop 
\family typewriter 
which 
\family default 
into sizes
\family typewriter 
 subPopSizes
\family default 
, optionally given new subpopulations 
\family typewriter 
subPopID
\layout Itemize


\family typewriter 
pop.mergeSubPop
\begin_inset LatexCommand \index{population!mergeSubPop}

\end_inset 

(subPops)
\family default 
, merge subpopulations 
\family typewriter 
subPops
\family default 
.
 New subpopulation has the same ID as
\family typewriter 
 subPops[0]
\family default 
.
\layout Standard

These functions may look useful and appealing but you will almost never
 use them directly.
 All these operations will be performed by various operators, in a more
 user-friendly way.
 Only when you begin to write your own operators will you have to read about
 the details of these functions.
\layout Subsection

Individuals
\layout Standard

You can access individuals of a population through 
\family typewriter 
individual
\begin_inset LatexCommand \index{population!individual}

\end_inset 

()
\family default 
 function.
 There are two forms of this function, one with and one without parameter
 
\family typewriter 
subPop,
\layout Itemize


\family typewriter 
individual(ind) 
\family default 
returns the
\family typewriter 
 ind
\family default 
'th individual (absolute index) of the whole population
\layout Itemize


\family typewriter 
individual(ind, subPop) 
\family default 
returns the 
\family typewriter 
ind
\family default 
'th (relative index) individual in the 
\family typewriter 
subPop
\family default 
'th subpopulation.
\layout Standard

The returned 
\family typewriter 
individual 
\family default 
object also has its own member functions.
 You can retrieve genotypic information of an individual through the same
 set of functions.
 You can also get/set genotype of an individual.
 
\layout Standard


\begin_inset Include \verbatiminput{log/ind.log}
preview false

\end_inset 


\layout Standard

Again, you will very seldom have to use these functions directly.
 Everything should be handled by operators.
 
\layout Subsection

Population Variables
\layout Standard

Populations are associated with python variables.
 These variables are usually set by various operators.
 For example, 
\family typewriter 
stat
\begin_inset LatexCommand \index{operator!stat}

\end_inset 


\family default 
 calculates many population statistics and store results in population namespace.
 The following example demonstrates how 
\family typewriter 
stat 
\family default 
set variables 
\family typewriter 
popSize
\family default 
, 
\family typewriter 
alleleFreq
\family default 
 etc.
 
\layout Standard

You can refer to these variables using 
\family typewriter 
population::vars
\begin_inset LatexCommand \index{population!vars}

\end_inset 

() 
\family default 
or 
\family typewriter 
population::
\begin_inset LatexCommand \index{population!population}

\end_inset 

dvars() 
\family default 
function.
 The returned value of 
\family typewriter 
vars() 
\family default 
and 
\family typewriter 
dvars()
\family default 
 reflects the same dictionary.
 However, 
\family typewriter 
dvars()
\family default 
 uses a little Python magic so that you can use attribute syntax to access
 dictionary keys.
 Since 
\family typewriter 
a.allaleFreq[0]
\family default 
 is a lot easier to handle than 
\family typewriter 
a['alleleFre'][0]
\family default 
, 
\family typewriter 
dvars()
\family default 
 is always preferred to 
\family typewriter 
vars()
\family default 
.
 A function 
\family typewriter 
ListVars 
\family default 
defined in 
\family typewriter 
simuUtil 
\family default 
is used to display the variables.
\layout Standard


\begin_inset Include \verbatiminput{log/popVars.log}
preview false

\end_inset 

If you have 
\family typewriter 
wxPython 
\family default 
installed, this function will opens a dialog showing all variables with
 a nice tree structure.
 This is among many reasons why you should install wxPython packages (and
 why wxPython should be the default GUI toolkit for Python.)
\layout Standard

These variables form a Python dictionary, and furthermore a local namespace
 for
\family typewriter 
 
\family default 
functions like
\family typewriter 
 population::evaluate
\family default 

\begin_inset LatexCommand \index{population!evaluate}

\end_inset 

.
 
\emph on 
Local namespace 
\emph default 
means that you can use dictionary items as variables duing evaluation.
 For example: 
\begin_inset Include \verbatiminput{log/localNamespace.log}
preview false

\end_inset 


\layout Standard

As you can see, these variables are 
\emph on 
local 
\emph default 
to the population and is not directly accessible from the main namespace.
 
\family typewriter 
vars(subPop) 
\family default 
and 
\family typewriter 
dvars(subPop) 
\family default 
function can be used.
 Both functions takes an optional 
\family typewriter 
subPop 
\family default 
option.
 If ignored, they will return population dictionary; otherwise, they will
 return dictionary for subpopulation 
\family typewriter 
subPop
\family default 
.
 This is a very convenient feature, because subpopulations and populations
 have similar keys, you can calculate the same statistics for the whole
 population and individual subpopulations, just by specifying different
 namespaces!
\layout Subsection

Sample from a Population
\layout Standard

Sampling (or ascertainment) is a complicated issue.
 simuPOP provides several methods to generate samples from an existing populatio
n.
 Details please refer to the 'ascertainment section' of Chapter 5.
\layout Subsection

Ancestral populations
\layout Standard

By default, a population object only hold current generation.
 All ancestral populations (generations) will be discarded.
 You can, however, keep as many ancestral generations as you wish, provided
 that you have enough RAM to store all these extra information.
\layout Standard

Parameter 
\family typewriter 
ancestralDepth
\family default 
 is used to specify number of generations to keep.
 This parameter is default to zero, meaning keeping no ancestral population.
 You can specify a positive number to store most recent 
\family typewriter 
ancestry
\family default 
 generations; or -
\family typewriter 
1 
\family default 
to store all populations.
 
\layout Standard

Several important usage of ancestral populations:
\layout Itemize


\family typewriter 
dumper() 
\family default 
operator and 
\family typewriter 
Dump()
\family default 
 function has a parameter 
\family typewriter 
ancestralPops
\family default 
.
 If set to true, they will dump all ancestral generations.
\layout Itemize

function 
\family typewriter 
population.setAncestralDepth()
\family default 
 and operator 
\family typewriter 
setAncestralDepth()
\family default 
 set the number of ancestral generations to keep for a population.
 A typical use of 
\family typewriter 
setAncestralDepth() 
\family default 
is
\begin_deeper 
\layout LyX-Code

simu.evolve(...
\layout LyX-Code

  setAncestralDepth(3, at=[-3])
\layout LyX-Code

)
\layout Standard

which save the last three generations in populations so that pedigree based
 sampling schemes can sample from the population.
\end_deeper 
\layout Itemize


\family typewriter 
pop.useAncestralPop(idx) 
\family default 
set current generation of population 
\family typewriter 
pop
\family default 
 to 
\family typewriter 
idx
\family default 
 generation.
 
\family typewriter 
idx
\family default 
 = 1 for the first ancestral generation, 2 for second ancestral ..., and 0
 for current generation.
 After this function, all functions, operators will be applied to this ancestral
 population.
 You should always call 
\family typewriter 
setAncestralPop(0)
\family default 
 after you examed the ancestral populations.
 A typical use of this function is
\begin_deeper 
\layout LyX-Code

ancDep = pop.ancestralDepth()
\layout LyX-Code

fst = [0]*(ancDep+1);
\layout LyX-Code

for i in range(0, ancDep+1):
\layout LyX-Code

  pop.useAncestralPop(i)
\layout LyX-Code

  Stat(pop, Fst=[0])
\layout LyX-Code

  fst[i] = pop.dvars().Fst
\layout LyX-Code

# set current population back.
\layout LyX-Code

pop.useAncestralPop(0) 
\end_deeper 
\layout LyX-Code

 
\layout LyX-Code

\layout LyX-Code

\layout Subsection

Save and Load a Population
\layout Standard

Internally, population can be saved/loaded in 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
txt
\family default 

\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
xml
\family default 

\begin_inset Quotes erd
\end_inset 

 or 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
bin
\family default 

\begin_inset Quotes erd
\end_inset 

 formats using 
\family typewriter 
savePopulation
\begin_inset LatexCommand \index{savePopulation}

\end_inset 

(file, format)
\family default 
 member function, global 
\family typewriter 
SavePopulation
\begin_inset LatexCommand \index{Function!SavePopulation}

\end_inset 

(pop, file, format) 
\family default 
(in 
\family typewriter 
simuUtil.py
\family default 
) and 
\family typewriter 
LoadPopulation
\family default 

\begin_inset LatexCommand \index{function!LoadPopulation}

\end_inset 

.
 (Yes, it is 
\family typewriter 
Load..

\family default 
 not 
\family typewriter 
load..
 
\family default 
since 
\family typewriter 
savePopulation 
\family default 
is a member function and 
\family typewriter 
LoadPopulation 
\family default 
is a global function.) These formats have their own advantages and disadvantages:
\layout Itemize


\family typewriter 
xml
\begin_inset LatexCommand \index{xml format}

\end_inset 

:
\family default 
 most human readable, easy transformation to other formats, largest file
 size
\layout Itemize


\family typewriter 
bin
\begin_inset LatexCommand \index{bin format}

\end_inset 

:
\family default 
 not readable, small file size.
 May not be portable.
\layout Itemize


\family typewriter 
txt
\begin_inset LatexCommand \index{text format}

\end_inset 

:
\family default 
 human readable with no structure, median file size.
\layout Standard


\begin_inset Include \verbatiminput{log/popSaveLoad.log}
preview false

\end_inset 


\layout Standard

Populations can also be saved in other formats such as FSTAT so that they
 can be directly analyzed by other programs.
 These formats are not supported internally.
 They are handled in Python in the form of Python function or pure-Python
 operator.
 If you would like to save/load simuPOP population in your own format, you
 can do it by mimicing these functions in 
\family typewriter 
simuUtil.py
\family default 
.
 Note that these formats may not keep full information of simuPOP population
 so loaded population may not reflect the original population.
\layout Standard

The following example demonstrates how to use 
\family typewriter 
SaveFstat
\begin_inset LatexCommand \index{function!SaveFstat}

\end_inset 

 
\family default 
and 
\family typewriter 
LoadFstat
\begin_inset LatexCommand \index{function!LoadFstat}

\end_inset 


\family default 
 functions.
 There is also an operator version of 
\family typewriter 
SaveFstat
\family default 
: 
\family typewriter 
saveFstat
\family default 

\begin_inset LatexCommand \index{operator!saveFstat}

\end_inset 

.
 The source code can be find in 
\family typewriter 
simuUtil.py
\family default 
 which provides a good example when you export to other formats.
\layout Standard

It is also possible to save a bunch of populations in a single file, provided
 that they have the same genotypic structure.
 The functions are
\layout Itemize


\family typewriter 
SavePopulations
\begin_inset LatexCommand \index{function!SavePopulations}

\end_inset 

([pop1,pop2,...,], filename, format='auto')
\layout Itemize


\family typewriter 
LoadPopulations
\begin_inset LatexCommand \index{functions!LoadPopulations}

\end_inset 

(filename, format='auto')
\layout Standard

Shared variables will also be saved (except for big objects like samples).
 Since the number of shared variables can be big, it maybe a good idea to
 clear these variables before you save a population.
 On the other hand, you may want to save key parameters used to generate
 this population in the local namespace so that you will know these parameters
 after the population is loaded.
 For example, you can
\layout LyX-Code

pop.vars().clear()
\layout LyX-Code

pop.dvars().migrationRate = 0.002
\layout LyX-Code

pop.dvars().diseaseLoci = [4, 30]
\layout LyX-Code

SavePopulation(pop, 'pop.bin')
\layout Subsection

View a population (GUI, wxPython required)
\layout Standard

Introduced in ver 0.6.9, 
\family typewriter 
simuViewPop.py
\family default 
 can be used to view a population.
 It can be used as a standalone application, or in an interactive session.
 First, you can use this script as a standalone application, simply run
\layout LyX-Code

simuViewPop.py mypop.bin
\layout Standard

will fire a GUI (Figure 
\begin_inset LatexCommand \ref{viewpop}

\end_inset 

) and allow you to exam population property, genotype and calculate statistics.
 
\layout Standard


\begin_inset Graphics
	filename viewPop.png
	lyxscale 30
	width 6in
	height 5in

\end_inset 


\layout Standard

In a Python session, import this module will provide a function 
\family typewriter 
viewPop
\family default 
, apply it on a in-memory population or a filename will have the same effect.
 For example,
\layout LyX-Code

import simuViewPop
\layout LyX-Code

simuViewPop.viewPop(myPop)
\layout LyX-Code

simuViewPop.viewPop(filename='mypop.bin') 
\layout Section

Mating Scheme
\begin_inset LatexCommand \index{mating scheme}

\end_inset 


\layout Standard

Mating schemes specify how to generate offspring from the current population.
 It must be provided when a simulator is created.
 Mating can perform the following tasks:
\layout Itemize

change population/subpopulation sizes.
 
\layout Itemize

Randomly choose parent(s) to generate offsprings to fill the next generation.
 
\layout Itemize

During-mating operators are applied to all offsprings.
\layout Itemize

Apply selection if applicable.
 
\layout Subsection

Create a Mating Scheme
\layout Standard

Most mating schemes take the following parameters:
\layout Itemize


\family typewriter 
numOffsprings
\begin_inset LatexCommand \index{simulator!numOffsprings}

\end_inset 

 
\family default 
number of offsprings or 
\begin_inset Formula $p$
\end_inset 

 for a random distribution.
 default to 1.
 This parameter determines number of offsprings a mating will produce so
 it determines family size.
\layout Itemize


\family typewriter 
numOffspringsFunc
\begin_inset LatexCommand \index{simulator!numOffspringsFunc}

\end_inset 

 
\family default 
a python function that return number of offspring or 
\begin_inset Formula $p$
\end_inset 

.
\layout Itemize


\family typewriter 
maxNumOffsprings
\begin_inset LatexCommand \index{simulator!maxNumOffsprings}

\end_inset 

 
\family default 
used when numOffsprings is generated from a poisson or binomial distribution.
\layout Itemize


\family typewriter 
mode
\family default 
 
\family typewriter 

\begin_inset LatexCommand \index{simulator!mode}

\end_inset 

 
\family default 
One of 
\family typewriter 
MATE_NumOffsprings, MATE_NumOffspringsEachFamily, MATE_GeometricDistribution,
 MATE_PoissonDistribution, MATE_BinomialDistribution
\family default 
.
\layout Itemize


\family typewriter 
newSubPopSize
\begin_inset LatexCommand \index{simulator!newSubPopSize}

\end_inset 

 
\family default 
an array of sizes of subpopulaitons.
 
\layout Itemize


\family typewriter 
newSubPopSizeExpr
\begin_inset LatexCommand \index{simulator!newSubPopSizeExpr}

\end_inset 

 
\family default 
an expression that will return the new subpopulation size.
 Details about python expression will be discussed later.
\layout Itemize


\family typewriter 
newSubPopSizeFunc
\begin_inset LatexCommand \index{simulator!newSubPopSizeFunc}

\end_inset 


\family default 
 Added for more convenience.
 This should be a function that accept a int parameter (generation), an
 array of current population size and return an array of subpopulation sizes.
 This is sometimes easier to use than the expression version of this parameter.
\layout Subsection

Determine number of offsprings during mating
\layout Standard

The default values 
\family typewriter 
numOffsprings 
\family default 
parameters makes a mating scheme produce one offspring per mating.
 This is the real random mating and should be used whenever possible.
 However, various situations requires larger family size or even changing
 family size.
 simuPOP provides a comprehensive way to deal with this problem.
\layout Standard

The method to determine the number of offsprings are set by 
\family typewriter 
mode
\family default 
 parameter:
\layout Itemize


\family typewriter 
MATE_NumOffsprings:
\family default 
 if 
\family typewriter 
numOffspringsFunc 
\family default 
is not given, number of offsprings will be constant 
\family typewriter 
numOffsprings
\family default 
 all the time.
 Otherwise, 
\family typewriter 
numOffspringsFunc(gen)
\family default 
 will be called 
\series bold 
once 
\series default 
for each generation to get the number of offsprings for the matings happen
 in this generation.
 
\layout Itemize


\family typewriter 
MATE_NumOffspringsEachFamily:
\family default 
 
\family typewriter 
numOffspringsFunc 
\family default 
has to be given and will be called whenever a mating happens.
 Since 
\family typewriter 
numOffspringsFunc
\family default 
 can be 
\series bold 
any
\series default 
 python function, this mode allows arbitrary model of assigning number of
 offsprings during mating.
 The mode can be slow though.
\layout Itemize


\family typewriter 
MATE_GeometricDistribution: numOffsprings 
\family default 
or result of 
\family typewriter 
numOffspringsFunc
\family default 
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset 

 for a geometric distribution.
 The number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset 


\layout Itemize


\family typewriter 
MATE_PoissonDistribution: numOffsprings 
\family default 
or result of 
\family typewriter 
numOffspringsFunc
\family default 
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset 

 for a Poission distribution.
 The number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{p^{k-1}}{\left(k-1\right)!}e^{-p}\quad\textrm{ for }k\geq1\]

\end_inset 


\layout Itemize


\family typewriter 
MATE_BinomialDistribution: numOffsprings 
\family default 
or result of 
\family typewriter 
numOffspringsFunc
\family default 
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset 

 for a Binomial distribution.
 Let 
\begin_inset Formula $N$
\end_inset 

=
\family typewriter 
maxNumOffsprings
\family default 
, the number of offsprings for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}\;\textrm{ for }N\geq k\geq1\]

\end_inset 


\layout Standard

Note that all these distributions are adjusted to produce at least one offspring.
 
\layout Subsection

Determine subpopulation sizes of next generation
\layout Standard

The default behavior of simuPOP is to use the same population/subpopulation
 sizes as the parent generation.
 You can change this behavior by setting one of 
\family typewriter 
newSubPopSize,
\family default 
 
\family typewriter 
newSubPopSizeExpr
\family default 
 and 
\family typewriter 
newSubPopSizeFunc
\family default 
 parameters:
\layout Itemize

If you would like to have fixed subpopulation sizes, use 
\family typewriter 
newSubPopSize=some_fixed_values
\family default 
 .
 This is useful when subpopulation sizes are changed by migration and you
 do want to keep constant subpopulation sizes.
\layout Itemize

If subpopulation size can be easily calculated through an expression, you
 can use 
\family typewriter 
newSubPopSizeExpr 
\family default 
to determine the new subpopulation sizes.
 For example 
\family typewriter 
newSubPopSizeExpr=`[gen+10]' 
\family default 
uses generation number + 10 as the new population size.
 More complicated expression can be used, maybe along with 
\family typewriter 
pyExec 
\family default 
operators, but in this case, a specialized function and 
\family typewriter 
newSubPopSizeFunc 
\family default 
is recommened.
 Note that the expression uses variables from local namespace.
\layout Itemize

A more organized (and thus recommended) way to set new population/subpopulation
 sizes is through parameter 
\family typewriter 
newSubPopSizeFunc
\family default 
.
 To use this paarmeter, you need to define a Python function that take two
 parameters: generation number and current subpopulation sizes and return
 an array of new subpoulation sizes.
 ( return 
\family typewriter 
[newsize] 
\family default 
instead of
\family typewriter 
 newsize 
\family default 
when you do not have any subpopulation structure).
 For example, the following function defines a linear expansion demographic
 scenario where a real example where a single population is splitted at
 200 generations (using a 
\family typewriter 
spliPopulation
\family default 
 operator).
\begin_deeper 
\layout LyX-Code

def lin_exp(gen, oldSize=[]):
\layout LyX-Code

  if gen < 200:   # burn in, constant population size
\layout LyX-Code

    return [1000]
\layout LyX-Code

  else:           # increase subpopulation sizes
\layout LyX-Code

    incSize = (10000-1000)/(500-200)/len(oldSize)
\layout LyX-Code

    return [oldSize[x]+incSize for x in range(0, len(oldSize))]
\layout Standard

you can then use this function as follows
\layout LyX-Code

...randomMating(newSubPopSizeFunc=lin_exp) ...
\end_deeper 
\layout Subsection

Demographic change functions
\layout Standard


\family typewriter 
newSubPopSizeFunc 
\family default 
can take a function with parameters 
\family typewriter 
gen 
\family default 
and 
\family typewriter 
oldSize.
 
\family default 
A few functions are defined in 
\family typewriter 
simuUtil.py 
\family default 
that will return such a function with given parameters.
 All these functions support burnin and split to equal sized subpopulations.
 For all these function, you can test them by
\layout LyX-Code

func = oneOfTheDemographicFunc(parameters)
\layout LyX-Code

gen = range(0, yourEndGen)
\layout LyX-Code

r.plot(gen, [func(x)[0] for x in gen])
\layout Standard

NumSubPop is default to 1.
 split is default to 0 or burnin.
 Population size change happens 
\series bold 
after
\series default 
 burnin (start at burn+1) and split happens at 
\family typewriter 
split.
\layout Subsubsection


\family typewriter 
constSize(size, split, numSubPop, bottleneckGen, bottleneckSize)
\layout Standard

The population size is constant, but will split into 
\family typewriter 
numSubPop
\family default 
 subpopulations at generation 
\family typewriter 
split
\family default 
.
 If 
\family typewriter 
bottleneckGen
\family default 
 is specified, population size will be 
\family typewriter 
bottleneckSize 
\family default 
at that generation.
 
\layout Subsubsection


\family typewriter 
linearExpansion(initSize, endSize, end, burnin, split, numSubPop, bottleneckGen,
 bottleneckSize)
\layout Standard

Linearly expand population size from intiSize to endSize after burnin, split
 the population at generation 
\family typewriter 
split.
\family default 
If 
\family typewriter 
bottleneckGen
\family default 
 is specified, population size will be 
\family typewriter 
bottleneckSize 
\family default 
at that generation.
 
\layout Subsubsection


\family typewriter 
exponentialExpansion
\family default 
(
\family typewriter 
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\layout Standard

Exponentially expand population size from intiSize to endSize after burnin,
 split the population at generation 
\family typewriter 
split.
\family default 
If 
\family typewriter 
bottleneckGen
\family default 
 is specified, population size will be 
\family typewriter 
bottleneckSize 
\family default 
at that generation.
 
\layout Subsubsection


\family typewriter 
instantExpansion
\family default 
(
\family typewriter 
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\layout Standard

Instaneously expand population size from intiSize to endSize after burnin,
 split the population at generation 
\family typewriter 
split.
\family default 
If 
\family typewriter 
bottleneckGen
\family default 
 is specified, population size will be 
\family typewriter 
bottleneckSize 
\family default 
at that generation.
 
\layout LyX-Code

\layout Subsection

Different Mating Schemes
\layout Standard

Currently, simuPOP provides the following mating schemes:
\layout Itemize


\family typewriter 
noMating
\begin_inset LatexCommand \index{noMating}

\end_inset 

() 
\family default 
parent generation will be considered as offspring genertion.
 subpopsizes will be ignored although some during-mating operators can be
 applied.
\layout Itemize


\family typewriter 
\emph on 
binomialSelection
\emph default 

\begin_inset LatexCommand \index{binomialSelection}

\end_inset 

() 
\family default 
no sex is involved.
 Offspring is chosen from parental generation by random or according to
 fitness values.
\layout Itemize


\family typewriter 
radomMating
\begin_inset LatexCommand \index{radomMating}

\end_inset 

() 
\family default 
sexed random mating.
 A prameter 
\family typewriter 
(contIfUniSex
\begin_inset LatexCommand \index{contIfUniSex}

\end_inset 

) 
\family default 
can be set to determine the behavior when only one sex exists in a subpopulation.
 Default is continue without warning.
\layout Itemize


\family typewriter 
pyMating
\begin_inset LatexCommand \index{pyMating}

\end_inset 

() 
\family default 
(
\series bold 
not usable right now) 
\series default 
Hybird mating scheme.
 This mating scheme takes two parameters: 
\family typewriter 
mateFunc
\family default 
 and 
\family typewriter 
keepSubPopStru
\family default 
.
 
\family typewriter 
mateFunc
\family default 
 should be a python function that accept a (parental) population and return
 parent indices for each offspring.
 If 
\family typewriter 
keepSubPopStru=True 
\family default 
(default), parents should come from the same subpopulation and the offspring
 population will have subpopulation strcture.
 Otherwise, mating can across subpopulation strcuture.
 
\layout Standard

Detailed information of each mating scheme can be found through 
\family typewriter 
help(...) 
\family default 
function.
 
\layout Subsection

Sex chromosomes
\layout Standard

Currently, only 
\family typewriter 
randomMating()
\family default 
 in diploid population supports sex chromosomes.
 When 
\family typewriter 
sexChrom()
\family default 
 is false, the sex of an offspring is determined randomly with prob 
\begin_inset Formula $1/2$
\end_inset 

.
 Otherwise, it is determined by the existence of Y chromosome.
 I.e., what sex chromosome an offspring get from his father.
 
\layout Standard

Recombinations on sex chromosomes of females (XX) is just like those on
 autosomes.
 However, this is not true in male.
 Currently, recombinations between male sex chromosomes (XY) are 
\emph on 
not
\emph default 
 allowed (a bug/feature of recombinators).
 This may change later if exchanges of genes between pseudoautosomal regions
 of XY need to be modeled.
\layout Section

Simulator
\begin_inset LatexCommand \index{Simulator}

\end_inset 


\layout Standard

Simulators combine three important components of simuPOP: population, mating
 scheme and operators together.
 A simulator is usually created with an instance of population, a replicate
 number and a mating scheme.
 It makes '
\family typewriter 
rep
\family default 
' replicates of this population and control the evolution process of these
 populations.
\layout Standard

The most important function of a simulator is 
\family typewriter 
evolve()
\family default 
.
 It accepts arrays of operators as its parameters, among which, '
\family typewriter 
preop
\family default 

\begin_inset LatexCommand \index{preop}

\end_inset 

' and '
\family typewriter 
postop
\family default 

\begin_inset LatexCommand \index{postop}

\end_inset 

' will be applied to the populations at the begining/end of evolution, whereas
 '
\family typewriter 
ops
\family default 
' will be applied at every generation.
 
\layout Subsection

Generation Number
\layout Standard

Several things about generation number may cause confusion:
\layout Itemize

generation starts from zero
\layout Itemize

a generation number presents a 'to-be-evolved' generation
\layout Itemize

ending generation specified in 
\family typewriter 
evolve() 
\family default 
will be executed
\layout Standard

That is to say, a new simulator will have generation 0 (at the beginning
 of generation 0).
 If you do
\family typewriter 
 evolve(..., end=0), evolve 
\family default 
will evolve one generation and stop at the beginning of generation 1.
\layout Standard

It may sound strange that 
\layout LyX-Code

evolve(end=2)
\layout Standard

evolve the population three times.
 Generation 0, generation 1, and generation 2.
 At the end of simulation, current generation number is 3! (If you are familiar
 with C, this is like a for loop index).
\layout Standard

When you use 
\family typewriter 
start=0, step=5
\family default 
 for your operator, it will be applied at generations 
\family typewriter 
0,5,10 
\family default 
etc.
 
\layout Subsection

Operator calling sequence
\layout Standard

Simulators separate operators into 
\family typewriter 
pre-
\family default 
,
\family typewriter 
 during-
\family default 
 and
\family typewriter 
 post-
\family default 
 mating operators.
 During evolution, simulator first apply all 
\family typewriter 
preMating
\family default 
 operators and then call the 
\family typewriter 
mate()
\family default 
 function of the given mating scheme, which will call 
\family typewriter 
duringMating 
\family default 
operators during the birth of each offspring.
 After the new generation is generated, 
\family typewriter 
postMating
\family default 
 operators are applied in the order they appear in the operator list.
\layout Standard

Since operators can apply to specific replicate or replicates group, and
 might not be active at all time, the 
\family typewriter 
isActive()
\family default 
 function of each operator is called before it is applied to a population.
\layout Standard

If you are not sure about the calling sequence of operaotrs, you can set
 the 
\family typewriter 
dryrun
\family default 

\begin_inset LatexCommand \index{simulator!dryun}

\end_inset 


\family typewriter 
 
\family default 
parameter of 
\family typewriter 
evolve() 
\family default 
function to true.
 
\family typewriter 
evolve 
\family default 
will then print out the order of operators to apply.
 Consider that operator can be 
\family typewriter 
PreMating
\begin_inset LatexCommand \index{constant!PreMating}

\end_inset 


\begin_inset LatexCommand \index{operator!PreMating}

\end_inset 

, PostMating
\begin_inset LatexCommand \index{constant!PostMating}

\end_inset 


\begin_inset LatexCommand \index{operator!PostMating}

\end_inset 

, PrePostMating
\begin_inset LatexCommand \index{constant!PrePostMating}

\end_inset 


\begin_inset LatexCommand \index{operator!PrePostMating}

\end_inset 

, DuringMating
\begin_inset LatexCommand \index{constant!DuringMating}

\end_inset 


\begin_inset LatexCommand \index{operator!DuringMating}

\end_inset 

 
\family default 
and the default value (parameter 
\family typewriter 
stage
\family default 
) may not be what you expect, having a look at the calling sequence before
 real evolution is always a good idea.
\layout Subsection

Evolution
\layout Standard

Simulators can evolve a given number of generations (the
\family typewriter 
 'end'
\family default 
 parameter of evolve), or evolve indefinitely using a certain type of operators
 called terminators.
 In this case, one or more terminators will check the status of evolution
 and determine if the simulation should be stopped.
 An obvious example of such a terminator is a fixation-checker.
 Useful simulator functions are
\layout Itemize


\family typewriter 
gen
\begin_inset LatexCommand \index{simulator!gen}

\end_inset 

() 
\family default 
return current generation number
\layout Itemize


\family typewriter 
setGen
\begin_inset LatexCommand \index{simulator!setGen}

\end_inset 

() 
\family default 
set current generation.
 Usually used to reset a simulator
\layout Itemize


\family typewriter 
population
\begin_inset LatexCommand \index{simulator!population}

\end_inset 

() 
\family default 
return temporary reference of one of the populations.
 'Reference' means that the changes to the referred population will reflect
 to the one in simulator.
 'Temporary' means that the referred population might be invalid after evolution.
\layout Itemize


\family typewriter 
evolve
\begin_inset LatexCommand \index{simulator!evolve}

\end_inset 

() 
\family default 
evolve all replicates of the population
\layout Itemize


\family typewriter 
apply
\begin_inset LatexCommand \index{simulator!apply}

\end_inset 

() 
\family default 
apply a list of operators to all populations.
\layout Itemize


\family typewriter 
step
\begin_inset LatexCommand \index{simulator!step}

\end_inset 

()
\family default 
 evolve one generation.
\layout Standard

The most useful function is of course 
\family typewriter 
evolve
\family default 
, which takes parameters
\layout Itemize


\family typewriter 
preOps:
\family default 
 operators that will be applied before evolution
\layout Itemize


\family typewriter 
ops: 
\family default 
opeartors that will be applied at each generation.
 
\layout Itemize


\family typewriter 
postOps: 
\family default 
operators that will be applied after evolution.
\layout Itemize


\family typewriter 
end:
\family default 
 ending generation.
 Default to -1.
 In this case, a simulator will only be ended by a terminator.
\layout Itemize


\family typewriter 
dryrun: 
\family default 
dryrun mode.
 see previous section
\layout Itemize


\family typewriter 
saveAs:
\family default 
 saveAt, format: see next section
\layout Subsection

Save and Load
\layout Standard

A simulator can be saved to a file in the format of
\family typewriter 
 'txt', 'bin'
\family default 
, or
\family typewriter 
 'xml'
\family default 
.
 This enables us to stop a simulation and resume it at another time or on
 another machine.
 It is also a good idea to save a snapshot of a simulation every several
 generations.
 Note that mating scheme can not be saved and has to be re-specified in
 
\family typewriter 
LoadSimulator
\begin_inset LatexCommand \index{loadSimulator}

\end_inset 

()
\family default 
.
 
\layout Standard


\begin_inset Include \verbatiminput{log/simulatorsaveload.log}
preview false

\end_inset 


\layout Standard

simulators can also be saved during evolution.
 Three relevant parameters of 
\family typewriter 
evolve()
\family default 
 function are:
\layout Itemize


\family typewriter 
saveAs:
\family default 
 filename to save the simulator.
 Default to 
\family typewriter 
simu
\family default 
.
\layout Itemize


\family typewriter 
saveAt: 
\family default 
generations at which to save the simulator.
 Generation can be negative, meaning counting backwards.
\layout Itemize


\family typewriter 
format: 
\family default 
format.
 Default to 'bin'.
\layout Standard

During evolution, simulator will be saved at 
\family typewriter 
saveAt
\family default 
 generations with filenames 
\family typewriter 
saveAs+gen+format 
\family default 
(for example 
\family typewriter 
simu1000.bin
\family default 
).
\layout Standard

It is also possible to build a simulator from a bunch of populations:
\layout Itemize


\family typewriter 
SimulatorFromPops(pops, mating)
\family default 
, build a simulator with given populations and mating scheme
\layout Itemize


\family typewriter 
SimulatorFromFiles(files, mating)
\family default 
, load populations from a given list of files (population images) and build
 a simulator with given mating scheme.
\layout Section

Operators
\layout Standard

Operators are objects that act on populations.
 They (there are exceptions) can be applied to populations directly using
 
\family typewriter 
apply
\family default 
() member function, but most of the time they are managed and applied by
 a simulator.
\layout Subsection

Type of operators
\layout Standard

There are three kinds of operators:
\layout Itemize


\emph on 
built-in:
\emph default 
 written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\layout Itemize


\emph on 
hybrid
\emph default 

\begin_inset LatexCommand \index{hybrid}

\end_inset 

: written in C++ but calls python function when execution.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter 
pyMutator 
\family default 
will determine if an allele will be mutated and call a user--defined Python
 function to mutate it.
\layout Itemize


\emph on 
pure python
\emph default 
: written in python.
 Same speed as python.
 For example, a 
\family typewriter 
varPlotter
\begin_inset LatexCommand \index{varPlotter}

\end_inset 


\family default 
 can plot python variables that are set by other operators.
\layout Standard

You do not have to know the type of an operator to use them.
 The interface of them are all the same.
 Note that although it is possible to write pure python operators to operate
 directly on populations, it might work very slowly compared to the built-in
 ones.
 If you believe some operators are important, please post to the simuPOP
 forum and I will see if I can implement it internally.
 It would be best if you have a working python version of the operator.
\layout Subsection

Applicable Stages
\begin_inset LatexCommand \index{applicable stage}

\end_inset 


\layout Standard

Operators can be applied at different stage(s) of a life cycle.
 More specifically, at pre-, during- or post mating stage(s).
 Note that it is possible for an operator to apply multiple times in a life
 cycle.
 For example, an save-to-file operator might be applied before and after
 mating to trace parental information.
 Applicable stages are usually set by default but you can change it by setting
 
\family typewriter 
stage=(PreMating|PostMating|DuringMating|PrePostMating) 
\family default 
parameter.
 Note that some operators ignore 
\family typewriter 
stage 
\family default 
parameter since they have to work at a certain stage.
\layout Standard


\begin_inset Include \verbatiminput{log/operatorstages.log}
preview false

\end_inset 


\layout Subsection

Active Generations
\layout Standard

Operators do not have to be applied at all generations.
 You can specify starting generation, ending generation, gaps between applicable
 generations, or even specific generations to apply.
 For example, you might want to start applying migrations after certain
 heat-up generation; or you want to calculate every 10 generations.
 Operators take the following parameters during initialization:
\layout Itemize


\family typewriter 
begin
\begin_inset LatexCommand \index{begin}

\end_inset 

 
\family default 
start generation.
 default to 1.
 negative number is interpreted as endGeneration + begin 
\layout Itemize


\family typewriter 
end
\begin_inset LatexCommand \index{end}

\end_inset 


\family default 
 stop applying after this generation.
 negative number is allowed
\layout Itemize


\family typewriter 
step
\begin_inset LatexCommand \index{step}

\end_inset 

 
\family default 
number of generations between active generations.
 default to 1 
\layout Itemize


\family typewriter 
at
\begin_inset LatexCommand \index{at}

\end_inset 


\family default 
 an array of active generations.
 If given, begin, end, step will be ignored.
\layout Standard

For example
\layout Standard


\begin_inset Include \verbatiminput{log/operatorgen.log}
preview false

\end_inset 


\layout Standard

The last example displays variable 
\family typewriter 
gen 
\family default 
for each replicate (actually all get from global namespace since 
\family typewriter 
gen 
\family default 
is shared by all replicates).
 Note that you can use negative generation number whenever you specifies
 the 
\family typewriter 
end
\family default 
 parameter of evolve.
 In this case, generation -1 is the last generation (end), -2 is end -1,
 and so on.
\layout Subsection

Replicates and Groups
\layout Standard

Most operators are applied to every replicate of a simulator during evolution.
 However, you can apply operators to one or a group of replicates only.
 For example, you can initialize different replicates with different initial
 values and then start evolution.
 c.f.

\family typewriter 
 simulator::setGroup 
\family default 
.
 
\layout Standard

The most useful example is 
\layout LyX-Code

output('
\backslash 
n',rep=REP_LAST)
\layout Standard

that will output 
\family typewriter 

\backslash 
n 
\family default 
at the end of each generation.
 It is so frequently used so I have wrapped it as a pure python operator
 in 
\family typewriter 
simuUtil.py.
\layout Standard

Here is an example of using replicate groups:
\layout Standard


\begin_inset Include \verbatiminput{log/operatorgrp.log}
preview false

\end_inset 


\layout Subsection

Output Specification
\layout Standard

Operators can have outputs.
 Output can be standard output (terminal) or a file, which can be constant,
 or change with generation or replicate.
 Different operators can append to the same file to form table-like outputs.
 
\layout Standard

Filename can have the following format:
\layout Itemize


\family typewriter 
'filename'
\family default 
 this file will be closed after each use.
 I.e., if several operators output to the same file, only the last one will
 succeed.
\layout Itemize


\family typewriter 
'>filename' 
\family default 
the same as 'filename'
\layout Itemize


\family typewriter 
'>>filename' 
\family default 
The file will be created at the beginning of evolution (
\family typewriter 
simulator::evolve
\family default 
) and close at the end.
 Several operators can output to this file to form a table.
\layout Itemize


\family typewriter 
'>>>filename' 
\family default 
The same as 
\family typewriter 
'>>filename'
\family default 
 except that the file will not be cleared at the beginning of evolution
 if it is not empty.
 
\layout Itemize


\family typewriter 
'>'
\family default 
 out put to standard output.
\layout Itemize


\family typewriter 
'' 
\family default 
suppress output.
\layout Standard

The following example shows the difference between 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

>
\begin_inset Quotes erd
\end_inset 


\family default 
 and 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

>>
\begin_inset Quotes erd
\end_inset 


\layout Standard


\begin_inset Include \verbatiminput{log/operatoroutput.log}
preview false

\end_inset 


\layout Standard

In the first simulator, all operators uses 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

a.txt
\begin_inset Quotes erd
\end_inset 


\family default 
 (the same as 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

>a.txt
\begin_inset Quotes erd
\end_inset 


\family default 
).
 This file is repeatedly covered by other operators so what we finally get
 is a newline written by 
\family typewriter 
output(
\begin_inset Quotes eld
\end_inset 


\backslash 
n
\begin_inset Quotes erd
\end_inset 

)
\family default 
.
 The second simulator works fine by using 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

>>a.txt
\begin_inset Quotes erd
\end_inset 


\family default 
.
\layout Standard

Output filename does not have to be fixed.
 If 
\family typewriter 
outputExpr 
\family default 
parameter is used (
\family typewriter 
output
\family default 
 will be ignored), it will be evaluated when a filename is needed.
 This is useful when you need to write to different files for different
 replicate/generations.
 
\layout Standard


\begin_inset Include \verbatiminput{log/operatoroutputexpr.log}
preview false

\end_inset 


\layout Section

Python expression and statistics calculation
\layout Subsection

Expressions and Statements
\layout Standard

Expressions are used extensively in operators so basic knowldege of python
 is required.
 If you know almost nothing about Python, please spend some time on the
 Python tutorial from python website.
\layout Standard

Unlikely C/C++, assignments in Python do not return values.
 This is the biggest difference between Python expression and statement:
\layout Itemize

expressions consist of constants, variables, operators, functions, but 
\emph on 
no 
\emph default 
assignments, condition, loop etc.
 Expression returns a value when executed.
 An example of expression is 
\family typewriter 
range(1,5)+10 
\family default 
.
\layout Itemize

statements consist of arbitrary valid python code.
 Statement does 
\emph on 
not
\emph default 
 return a value when executed.
 An example of statement is 
\family typewriter 
a=range(1,5)
\family default 
 .
\layout Subsection

simuPOP variables
\layout Standard

All populations have their own attached variables.
 We have seen the structure of a population dictionary: it starts empty
 and will have many variables created by various operators.
 You can access local namespace of each replicate through a simulator's
 
\family typewriter 
vars(rep) 
\family default 
function:
\layout LyX-Code

simu.vars(0)        simu.vars(1) ...
      // replicate
\layout LyX-Code

  popSize             popSize            // local namespace
\layout LyX-Code

  alleleFreq[0]       alleleFreq[0]      // allele frequency at locus 1
\layout LyX-Code

  alleleFreq[1]       alleleFreq[1]      // at locus 2
\layout LyX-Code

  ...
                 ....
\layout LyX-Code

  subPop[0]           subPop[0]          // subpop namespace
\layout LyX-Code

    popSize             popSize          // subpopulation 1 size
\layout LyX-Code

    allaleFreq[0]       allaleFreq[0]    // allele frequency at locus 1
\layout LyX-Code

    ...
                 ...
\layout LyX-Code

  subPop[1]           subPop[1]          // variables for subpop 2
\layout LyX-Code

    ...
                 ...
\layout Standard

It is important to know that
\layout Itemize


\family typewriter 
simulator::vars[0], vars[1] 
\family default 
etc are the 
\emph on 
local namespaces
\emph default 
 for each replicate.
\layout Itemize


\family typewriter 
subPop[0], subPop[1] 
\family default 
etc have almost the same set of keys as those for the whole population.
 This is because 
\family typewriter 
stat
\family default 
 operator calculate statistics of each replicate of population, and all
 subpopulations.
\layout Standard

To list these variables, you can use the 
\family typewriter 
ListVars() 
\family default 
function defined in 
\family typewriter 
simuUtil.py
\family default 
.
 For example
\layout LyX-Code

ListVars(simu.vars(0), level=2)
\layout Standard

list all variables for the first replicate.
 
\family typewriter 
Level=2
\family default 
 stops 
\family typewriter 
ListVars
\family default 
 from expanding lists and dictionaries after two levels.
 
\layout Standard

Two functions can be used to access simulator and population variables:
 
\family typewriter 
vars()
\family default 
 and
\family typewriter 
 dvars()
\family default 
.
 We have known 
\family typewriter 
population::vars() 
\family default 
and 
\family typewriter 
population::dvars()
\family default 
, 
\family typewriter 
simulator::vars() 
\family default 
and 
\family typewriter 
simulator::dvars()
\family default 
 work in almost the same way.
 
\layout Itemize


\family typewriter 
simulator::vars(rep
\family default 
),
\family typewriter 
 dvars(rep):
\family default 
 return replicate 
\family typewriter 
rep
\family default 
's local namespace
\layout Itemize


\family typewriter 
simulator::vars(rep, subPop
\family default 
),
\family typewriter 
 dvars(rep, subPop):
\family default 
 return the namespace of
\family typewriter 
 subPop
\family default 
 subpopulation of replicate 
\family typewriter 
rep.
\layout Standard

The return values of
\family typewriter 
 vars() 
\family default 
and 
\family typewriter 
dvars() 
\family default 
are different.
 
\family typewriter 
vars()
\family default 
 returns a Python dictionary.
 You should access their keys in the usual Python way.
 
\family typewriter 
dvars() 
\family default 
returns a 'wrapped' Python dictionary.
 You can access dictionary keys as attributes.
 
\family typewriter 
dvars() 
\family default 
is usually considered to be easier to use.
\layout Subsection


\family typewriter 
evaluate
\begin_inset LatexCommand \index{calculate}

\end_inset 

 
\family default 
function and 
\family typewriter 
pyEval
\begin_inset LatexCommand \index{calc}

\end_inset 

 
\family default 
and
\family typewriter 
 pyExec
\begin_inset LatexCommand \index{pyExec}

\end_inset 


\family default 
 operators
\layout Standard

Function 
\family typewriter 
population::evaluate 
\family default 
and operator 
\family typewriter 
pyEval/pyExec 
\family default 
will work in local namespaces.
 For example, if there are 
\family typewriter 
a
\family default 
 and 
\family typewriter 
b
\family default 
 in the main namespace and 
\family typewriter 
a
\family default 
 in 
\family typewriter 
pop
\family default 
, 
\family typewriter 
pop.evaluate('a')
\family default 
 will return 
\family typewriter 
pop.vars()['a']
\family default 
, 
\family typewriter 
pop.evaluate('b') 
\family default 
will return global 
\family typewriter 
b
\family default 
 since there is no 
\family typewriter 
b
\family default 
 in the local namespace.
 It this is still too abstract, here is a real example
\layout Standard


\begin_inset Include \verbatiminput{log/exprvarsrep.log}
preview false

\end_inset 


\layout Itemize


\family typewriter 
simulator 
\family default 
creates a simulator with two replicates 0 and 1.
 
\layout Itemize

We evaluate 
\family typewriter 
grp*2
\family default 
 in different replicates and get different results.
\layout Itemize


\family typewriter 
gen 
\family default 
is not in either replicate's namespace so the global one will be used.
\layout Itemize

Using statements can create variables in local namespaces.
 (You can use 
\family typewriter 
global 
\family default 
statement to create global variable if you are familiar with python.)
\layout Standard


\family typewriter 
pyEval/pyExec 
\family default 
operators execute python expression/statements, 
\emph on 
using local namespaces
\emph default 
.
\layout Itemize


\family typewriter 
pyEval 
\family default 
(operator) evaluate a Python expression and return its value, optional execute
 a list of statements beforehand.
\layout Itemize


\family typewriter 
pyExec 
\family default 
(operator) execute a list of statements in the form of a multi-line string.
 No return value or output.
\layout Standard

Here, 
\family typewriter 
expr
\family default 
 is a simple string containing an expression that will return a value when
 executed; 
\family typewriter 
stmts 
\family default 
is a string of statements, separated by 
\family typewriter 
'
\backslash 
n'
\family default 
.
 
\layout Standard

For example, you can return a string of 
\begin_inset Quotes eld
\end_inset 

gen:rep
\begin_inset Quotes erd
\end_inset 

 using the following function
\layout LyX-Code

pop.evaluate(r
\begin_inset Quotes eld
\end_inset 

'%d:%d' % (gen,rep)
\begin_inset Quotes erd
\end_inset 

)
\layout Standard

but if you would like to change/create variables, you have to use statements
 like
\layout LyX-Code

pop.evalulate(r
\begin_inset Quotes eld
\end_inset 

myval
\begin_inset Quotes erd
\end_inset 

, stmts=r
\begin_inset Quotes erd
\end_inset 

myval=rep+1
\begin_inset Quotes erd
\end_inset 

)
\layout Standard

Since you are executing Python statements, you can of course do it directly
 in python.
 For example, the above function does exactly the following
\layout LyX-Code

pop.vars()['myval'] = pop.vars()['rep'] + 1
\layout LyX-Code

pop.vars()['myvar']
\layout Standard

As a matter of fact, we seldom use 
\family typewriter 
evaluate
\family default 
 function directly (maybe for debuging), usually
\layout Itemize

we use expressions for dynamic parameters.
 For example:
\begin_deeper 
\layout LyX-Code

newSubPopSizeExpr=
\begin_inset Quotes erd
\end_inset 

range(10,20)*1.2
\begin_inset Quotes erd
\end_inset 


\layout LyX-Code

outputExpr= ' 
\begin_inset Quotes erd
\end_inset 

saveAt%s.txt
\begin_inset Quotes erd
\end_inset 

 % gen'
\layout Standard

These parameters will be evaluated whenever they are referred.
\end_deeper 
\layout Itemize

we use expression/statements in
\family typewriter 
 pyEval/pyExec 
\family default 
operators.
 These statements will work in local namespaces.
 For example:
\layout Standard


\begin_inset Include \verbatiminput{log/expreval.log}
preview false

\end_inset 


\layout Standard

Because of the interactive nature of python, it is very easy to write short
 programs, quote them in 
\family typewriter 
r'''program''' 
\family default 
and put them in to 
\family typewriter 
pyEval/pyExec 
\family default 
operators.
\layout Subsection

Calculate new statistics
\layout Standard

simuPOP provides many built-in or pure-Python operators that can calcualte
 various statistics.
 If you can not find the one you need, you can calculate them by yourself.
 Firstly, you need to 
\layout Subsubsection

Check if your statistics can be calcualted based on exisiting statistics
\layout Standard

Most statistics can be calcualted from basic quantities like allele frequencies.
 This chapter will only deal with this case.
 Please refer to chapter 'extending simuPOP' for methods to access arbitrary
 population information.
\layout Subsubsection

calculate them with existing operators
\layout Standard

Run a simple simulation and generate the statistics you need.
 For example: 
\layout Standard


\begin_inset Include \verbatiminput{log/calcStat.log}
preview false

\end_inset 


\layout LyX-Code

\layout Subsubsection

know how to acess these variables
\layout Standard

For example, use 
\layout LyX-Code

s = simu.dvars(1)
\layout LyX-Code

a.haploNum['1-2|1-2']
\layout Subsubsection

Write a function to calculate your statistics
\layout Standard

Once you know how to access the basic statistics, you can write a function
 to calculate your own statistics based on them.
 For example, the following function calculate 
\begin_inset Formula $F_{st}$
\end_inset 

, 
\begin_inset Formula $F_{is}$
\end_inset 

, 
\begin_inset Formula $F_{it}$
\end_inset 

 based on heterozygosities calculated by 
\family typewriter 
stat
\layout Standard


\begin_inset Include \verbatiminput{log/calcFstH.log}
preview false

\end_inset 


\layout Standard

This function calculate and set 
\family typewriter 
heter_obs
\family default 
.
 It is recommeneded that you always use 
\family typewriter 
rep
\family default 
 and 
\family typewriter 
subPop
\family default 
 parameters so that your function can be applied to any population/subpopulation
 at any replicate.
 
\layout Standard

You can use this function to calculate observed heterozygosity for any populatio
n/subpopulation like
\layout LyX-Code

calc_Fst_H(pop, 1)
\layout Standard

If you would like to calculate this statistics as an operator (set 
\family typewriter 
heter_obs 
\family default 
automatically), you need to 
\layout Subsubsection

Wrap this function as an operator (optional)
\layout Standard

The basic idea is that you use a function that return an appropriate 
\family typewriter 
pyExec 
\family default 
opertor.
 This part is a bit more involved.
 If you can not understand the following code, give up or read more at 'extendin
g simuPOP' chapter.
\layout Standard


\begin_inset Include \verbatiminput{log/wrapFstH.log}
preview false

\end_inset 


\layout Standard

Some notes:
\layout Itemize


\family typewriter 
kwargs 
\family default 
and 
\family typewriter 
parm 
\family default 
are used to pass additional parameters (at, begin, output etc) to pyExec
 operator.
\layout Itemize


\family typewriter 
cmd
\family default 
 is the 
\family typewriter 
pyExec 
\family default 
operator we would like to get.
 We use 
\family typewriter 
pyExec 
\family default 
since statistics calculators usually do not return values.
\layout Itemize

It is always a good idea to 
\family typewriter 
print cmd 
\family default 
and make sure you have the right syntax for your 
\family typewriter 
pyExec 
\family default 
operator.
\layout Itemize


\family typewriter 
exposePop=1 
\family default 
is used to set a variable 
\family typewriter 
pop
\family default 
 in local namespace.
 
\layout Itemize

Finally, use 
\family typewriter 
eval 
\family default 
to return the operator.
\layout Subsubsection

Use the opeator (optional)
\layout Standard

Use the operator 
\family typewriter 
hetero
\family default 
 just like any other operator:
\layout Standard


\begin_inset Include \verbatiminput{log/useFstH.log}
preview false

\end_inset 


\layout Chapter

Operator and Function References
\layout Standard

This chapter will list all functions, types and operators by category.
\layout Section


\family typewriter 
carray
\begin_inset LatexCommand \index{carray}

\end_inset 

 
\family default 
type
\layout Standard

simuPOP uses a special 
\family typewriter 
carray 
\family default 
instead of list to pass large amount data and more importantly, let you
 modify underlying C++ data structure directly.
 For any practical use of 
\family typewriter 
carray
\family default 
, it is identical to 
\begin_inset LatexCommand \url[Python array module]{http://docs.python.org/lib/module-array.html}

\end_inset 

.
 Just remember that if you get a
\family typewriter 
 carray 
\family default 
object as a return value of a simuPOP function, you actually get a reference
 to the underlying data.
 Therefore, you can modify the array elements (and thus modify underlying
 data) but can not resize the array.
 
\layout Section

Use of R (RPy) in Python
\layout Standard

Most of the info can be found in rpy manual.
 One function in simuRPy may help though:
\layout LyX-Code

def rmatrix(mat):
\layout LyX-Code

  ' convert a python 2d list to r.matrix object'
\layout LyX-Code

  return with_mode(NO_CONVERSION, r.do_call)('rbind',mat)
\layout Standard

with this function, you can easily handle matrices in R.
 (List and array has been easy enough to be handled).
\layout LyX-Code

>>> a = [[1,2],[4,5]]
\layout LyX-Code

>>> r.image( rmatrix(a))
\layout Standard

With the help of this function, you can call almost any R function directly,
 maybe except some R-only syntax like formula, expression etc.
 In this case, you can always do
\layout LyX-Code

>>> r('''whatever R expression''')
\layout Standard

Since Rpy is not always available, you may see the following scenario again
 and again in simuPOP scripts:
\layout LyX-Code

try:
\layout LyX-Code

  from simuRPy import *
\layout LyX-Code

except:
\layout LyX-Code

  hasRPy = False
\layout LyX-Code

else:
\layout LyX-Code

  hasRPy = True
\layout LyX-Code

...
\layout LyX-Code

if hasRPy:
\layout LyX-Code

  r.....
\layout Section

Operator (Hybrid) 
\family typewriter 
pyOperator
\begin_inset LatexCommand \index{operator!pyOperator}

\end_inset 


\layout Standard

This is the single most powerful hybrid operator.
 Whenever you think that something is too complicated to be done by standard
 operators, you can do it here in python.
 This operator accepts a Python function which can accept a population and
 optionally a parameter.
 To use this operator, you will need to 
\layout Itemize

define a function that handle a population as you wish.
\begin_deeper 
\layout LyX-Code

def myOperator(pop, para):
\layout LyX-Code

  ' do whatever you want'
\layout LyX-Code

  return True
\layout Standard

If you return 
\family typewriter 
False
\family default 
, this operator will work like a terminator.
\end_deeper 
\layout Itemize

use 
\family typewriter 
pyOperator
\family default 
 like
\begin_deeper 
\layout LyX-Code

pyOperator(myOperator,para)
\layout Standard

all parameters of an operator are supported except for 
\family typewriter 
output
\family default 
 and 
\family typewriter 
outputExpr
\family default 
 which are ignored for now.
\end_deeper 
\layout Standard

When 
\family typewriter 
pyOperator 
\family default 
is called, it will simply pass the accepted population to the function.
 If your function returns 
\family typewriter 
False
\family default 
, the simulation will be stopped.
\layout Standard

This operator allows implementation of arbitrarily complicated operators,
 at a cost of efficiency.
 Of course, to use this operator, you will have to know how to use population-re
lated functions.
 The following example shows how to implement a dynamic mutator which mutate
 loci according to their allele frequency.
\layout Standard


\begin_inset Include \verbatiminput{log/pyOperator.log}
preview false

\end_inset 


\layout Standard

Note that 
\layout Itemize

Currently, 
\family typewriter 
pyOperator 
\family default 
does not support parameter 
\family typewriter 
output
\family default 
 and 
\family typewriter 
outputExpr
\family default 
.
 This is because of the incompatibility between the Python way and underlying
 C++ way of handling file I/O stream.
 Consequently, you will have to handle file input/output by yourself through
 
\family typewriter 
param
\family default 
 parameter.
 Be careful that you 
\series bold 
can not
\series default 
 mix output of 
\family typewriter 
pyOperator
\family default 
 with those of other (normal) operators.
\layout Itemize

Since you can attach any information to a population, you can in practise
 use 
\family typewriter 
pop.dvars()
\family default 
 to pass parameters.
\layout Itemize


\family typewriter 
pyOperator
\family default 
 is a post-mating operator by default.
 Remember to use 
\family typewriter 
stage 
\family default 
parameter to change this when necessary.
\layout Section

Initialization
\begin_inset LatexCommand \index{initializer}

\end_inset 


\layout Standard

Initializers are used to initialize populations before evolution.
 They are set to be PreMating operators by default.
 simuPOP provides three initializers, one assigns alleles by random, one
 assigns a fixed set of genotype, and the last one calls a user-defined
 function.
\layout Subsection

Operator (C++) 
\family typewriter 
initByFreq
\begin_inset LatexCommand \index{operator!initByFreq}

\end_inset 

, 
\family default 
function
\family typewriter 
 InitByFreq
\begin_inset LatexCommand \index{function!InitByFreq}

\end_inset 


\layout Standard


\family typewriter 
initByFreq 
\family default 
operator accepts 
\family typewriter 
alleleFreq 
\family default 
or
\family typewriter 
 alleleFreqs
\family default 
.
 The first one ignores subpopulation structure while the second one gives
 different initial allele frequencies to different subpop or ranges.
 These parameters are
\layout Itemize


\family typewriter 
subPop:
\family default 
 specifies applicable subpopulations.
 If 
\family typewriter 
alleleFreqs
\family default 
 are given, 
\family typewriter 
alleleFreqs
\family default 
 should have the same length as subPop.
 (One freq each subPop)
\layout Itemize


\family typewriter 
indRange
\family default 
: range(s) of absolute index of individuals.
 I.e., one (
\family typewriter 
[1,2]
\family default 
) or more (
\family typewriter 
[[1,4],[5,6]]
\family default 
) ranges are acceptable.This is how you can initialize individuals differently
 within subpopulations.
 Note that ranges are in the form of
\family typewriter 
 [a,b]
\family default 
.
 I.e., range
\family typewriter 
 [4,6] 
\family default 
will intialize individual 4, 5 and not 6.
 As a shortcut for 
\family typewriter 
[4,4]
\family default 
, you can use 
\family typewriter 
[4]
\family default 
 to specify one individual.
\layout Itemize


\family typewriter 
atLoci: 
\family default 
loci at which initialization will be done.
\layout Itemize


\family typewriter 
maleFreq: 
\family default 
intialize sex with this male frequency.
\layout Itemize


\family typewriter 
identicalInds: 
\family default 
if true, copy the genotype of the first randomly initialized individual
 to other individuals in the subpop/range.
 
\layout Standard

Here is an example of using 
\family typewriter 
alleleFreq
\family default 
:
\begin_inset Include \verbatiminput{log/initByFreq.log}
preview false

\end_inset 


\layout Standard

Please refer to
\family typewriter 
 test/test_init.py 
\family default 
for more complicated examples.
\layout Subsection

Operator (C++)
\family typewriter 
 initByValue
\begin_inset LatexCommand \index{operator!initByValue}

\end_inset 

,
\family default 
 function 
\family typewriter 
InitByValue
\begin_inset LatexCommand \index{function!InitByValue}

\end_inset 


\layout Standard


\family typewriter 
initByValue 
\family default 
operator gets the one copy of chromosomes or the whole genotype (or of those
 corresponds to 
\family typewriter 
atLoci
\family default 
) of an individual and copy them to all or subset of individuals.
 
\layout Standard


\begin_inset Include \verbatiminput{log/initByValue.log}
preview false

\end_inset 


\layout Standard

Parameters
\family typewriter 
 subPop, indRange, atLoci, maleFreq 
\family default 
are also supported.
 Note that
\layout Itemize

If
\family typewriter 
 value 
\family default 
is an array of values, it should have the same length as 
\family typewriter 
subpop, indRange 
\family default 
or 
\family typewriter 
proportions
\family default 
.
 
\layout Itemize


\family typewriter 
proportions
\family default 
: if given, assign given genotypes randomly.
 
\layout Subsection

Operator (C++)
\family typewriter 
 spread
\begin_inset LatexCommand \index{operator!spread}

\end_inset 

,
\family default 
 function 
\family typewriter 
Spread
\begin_inset LatexCommand \index{function!Spread}

\end_inset 


\layout Standard


\family typewriter 
Spread(ind, subPop) 
\family default 
spread the genotype of ind to all individuals in an array of subpopulations.
 The default value of subPop is the subpopulation where ind resides.
\layout Subsection

Operator (hybrid)
\family typewriter 
 pyInit
\begin_inset LatexCommand \index{operator!pyInit}

\end_inset 

,
\family default 
 function 
\family typewriter 
PyInit
\begin_inset LatexCommand \index{function!PyInit}

\end_inset 


\layout Standard


\family typewriter 
pyInit
\family default 
 is a hybrid initializer.
 User should define a function with parameters allele, ploidy and subpop
 indices, and return an allele value.
 
\layout Standard


\begin_inset Include \verbatiminput{log/pyInit.log}
preview false

\end_inset 


\layout Section

Migration
\begin_inset LatexCommand \index{migrator}

\end_inset 


\layout Standard

Mating is strictly within subpopulations in simuPOP so migrator is the only
 way to mix genotypes of several subpopulations.
 Migrators are quite flexible in simuPOP in the sense that
\layout Itemize

Migration can happen from and to a subset of subpopulations.
\layout Itemize

Migration can be done by probability, proportion or by counts.
 In the case of probability, 
\begin_deeper 
\layout Itemize

if the migration rate from subpopulation 
\family typewriter 
a
\family default 
 to 
\family typewriter 
b
\family default 
 is 
\begin_inset Formula $r$
\end_inset 

, then everyone in subpopulation 
\family typewriter 
a
\family default 
 will have this probability to migrate to 
\family typewriter 
b
\family default 
.
 
\layout Itemize

In the case of proportion, exactly 
\family typewriter 
r*size_of_subPop_a 
\family default 
individuals (chosen by random) will migrate to subpop b.
 
\layout Itemize

In the last case, a given number of individuals will migrate.
\end_deeper 
\layout Itemize

New subpopulation can be generated through migration.
 You simply need to migrate to a new subpop number.
 
\layout Standard

Note that overall population size will not change.
 (Mating schemes can do that).
 If you would like to keep subpop size after migration, you can use the
\family typewriter 
 newSubPopSize
\family default 
 or 
\family typewriter 
newSubPopSizeExpr
\family default 
 parameter of a mating scheme.
\layout Subsection

Constants: 
\family typewriter 
MigrByProbability
\begin_inset LatexCommand \index{constant!MigrByProbability}

\end_inset 

, MigrByProportion
\begin_inset LatexCommand \index{constant!MigrByProportion}

\end_inset 

, MigrByCount
\begin_inset LatexCommand \index{constant!MigrByCount}

\end_inset 


\layout Standard

Possible values of parameter 
\family typewriter 
mode
\family default 
.
\layout Subsection

Opertor (C++) 
\family typewriter 
migrator
\begin_inset LatexCommand \index{operator!migrator}

\end_inset 


\layout Standard

Opertor 
\family typewriter 
migrator
\family default 
 is used to migrate from 
\family typewriter 
'fromSubPop'
\family default 
 to 
\family typewriter 
'toSubPop'.

\family default 
 From and to subpop can be a number or an array of subpopulations.
 The migration probability/rate/counts from 
\family typewriter 
i->j 
\family default 
is specified in the rate matrix.
 The 
\family typewriter 
'fromSubPop'
\family default 
 and 
\family typewriter 
'toSubPop' 
\family default 
are default to all subpopulations.
\layout Standard


\begin_inset Include \verbatiminput{log/migratorhelp.log}
preview false

\end_inset 


\layout Standard

An detailed example can be found in 'some real examples' -> 'complex Migration
 Scheme' section.
\layout Subsection

Functions (Python) 
\family typewriter 
migrIslandRates
\begin_inset LatexCommand \index{Function!migrIslandRates}

\end_inset 

, migrStepstoneRates
\begin_inset LatexCommand \index{Function!migrStepstoneRates}

\end_inset 

 
\family default 
(simuUtil.py)
\layout Standard

Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpops to
 any (even new) other subset of subpops.
 Several functions are defined in simuUtil.py, however, for easy use of popular
 migration models:
\layout Itemize


\family typewriter 
migrIslandRates(r, n)
\family default 
 returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset 


\layout Itemize


\family typewriter 
migrStepstoneRates(r,n,circular=False) 
\family default 
returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset 

and if 
\family typewriter 
circular=True
\family default 

\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset 


\layout Standard

A lot of such functions may be defined later.
 I guess 2-d stepstone will be the first one?
\layout Subsection

Operator (C++/Hybrid) 
\family typewriter 
pyMigrator
\begin_inset LatexCommand \index{operator!pyMigrator}

\end_inset 


\layout Standard

For evan more complicated migration schemes, you do DIY it using a 
\family typewriter 
pyMigrator
\family default 
.
 This operator is not strictly hybrid since it does not call python function.
 However, it takes a 
\family typewriter 
carray
\family default 
 as subPop id for each individual.
 
\family typewriter 
pyMigrator
\family default 
 then complete migration according its content.
 For example:
\begin_inset Include \verbatiminput{log/pyMigrator.log}
preview false

\end_inset 


\layout Standard

Note that 
\layout Itemize

the application sequence of the operators is 
\family typewriter 
initByFreq
\family default 
,
\family typewriter 
 dumper, pyMigrator 
\family default 
and then 
\family typewriter 
dumper 
\family default 
again since its stage is set to
\family typewriter 
 PrePostMating
\family default 
.
\layout Itemize

Usually you will use a 
\family typewriter 
pyEval 
\family default 
operator to re-assign 
\family typewriter 
spID
\family default 
 during evolution.
\layout Subsection

Operator (C++) 
\family typewriter 
splitSubPop
\family default 

\begin_inset LatexCommand \index{operator!splitSubPop}

\end_inset 

, function 
\family typewriter 
SplitSubPop
\begin_inset LatexCommand \index{function!SplitSubPop}

\end_inset 


\layout Standard

This operator takes parameters
\layout Itemize

which: which subpopulation to split.
 If there is no subpopulation structure, use 0 as the first (and only) subpopula
tion.
\layout Itemize

sizes: new subpopulation sizes.
 The sizes should add up to the original subpopulation (subpop which) size.
\layout Itemize

proportions: Optionally, you can specify proportions of new subpops.
 (easier to use) The proportions should add up to 1.
\layout Itemize

subPopID: the operator will automatically set new subpop ID to new subpops.
 You can also specify the IDs.
\layout Subsection

Operator (C++) 
\family typewriter 
mergeSubPops
\family default 

\begin_inset LatexCommand \index{operator!mergeSubPops}

\end_inset 

, function 
\family typewriter 
MergeSubPops
\begin_inset LatexCommand \index{function!MergeSubPops}

\end_inset 


\layout Standard

This operator merges subPopulations
\family typewriter 
 subPops 
\family default 
(the only parameter) to a single subpopulation.
 If 
\family typewriter 
subPops 
\family default 
are ignored, all subpopulations will be merged.
\layout Section

Mutation
\begin_inset LatexCommand \index{Mutation}

\end_inset 


\layout Standard

All mutators have the common interface as shown below: 
\begin_inset Include \verbatiminput{log/mutatorhelp.log}
preview false

\end_inset 


\family typewriter 
rate
\begin_inset LatexCommand \index{rate}

\end_inset 

 
\family default 
can be a number (uniform rate) or an array of mutation rates, 
\family typewriter 
atLoci
\begin_inset LatexCommand \index{atLoci}

\end_inset 

 
\family default 
is defaulted to all loci.
 The only differences between the following mutors are they way they actually
 mutate an allele, and corresponding input parameters.
\layout Standard

Mutators record the number of mutation events at each loci.
 You can retrieve this information using
\layout LyX-Code

mut.mutationCount(locus)
\layout LyX-Code

mut.mutationCounts()
\layout Standard

where 
\family typewriter 
mut
\family default 
 is any mutator and 
\family typewriter 
locus
\family default 
 is locus index.
\layout Subsection

Operator (C++) 
\family typewriter 
kamMutator
\begin_inset LatexCommand \index{operator!kamMutator}

\end_inset 

, 
\family default 
function
\family typewriter 
 KamMutate
\begin_inset LatexCommand \index{function!KamMutate}

\end_inset 


\layout Standard


\family typewriter 
kamMutator
\family default 
 (K-allele mutator
\begin_inset LatexCommand \index{mutation!K-allele model}

\end_inset 

) mutate an allele to another allelic state with equal probability.
 The specified mutation rate is actually 'probability to mutate' so the
 mutation rate to any other allelic state is actually 
\begin_inset Formula $\frac{r}{K-1}$
\end_inset 

, where 
\begin_inset Formula $K$
\end_inset 

 is specified by parameter 
\family typewriter 
maxAllele
\family default 

\begin_inset LatexCommand \index{maxAllele}

\end_inset 

.
 Here is an example of mutation:
\layout Standard


\begin_inset Include \verbatiminput{log/kamMutator.log}
preview false

\end_inset 


\layout Standard

You can also specify states for this mutator.
 If 
\family typewriter 
states
\begin_inset LatexCommand \index{kamMutator!states}

\end_inset 


\family default 
 parameter is given, all alleles must be one of the state and mutation will
 happen among them.
 
\family typewriter 
states 
\family default 
is defaulted to 
\family typewriter 
1-maxAllele
\family default 
.
 
\layout Subsection

Operator (C++) 
\family typewriter 
smmMutator
\begin_inset LatexCommand \index{operator!smmMutator}

\end_inset 

, 
\family default 
function
\family typewriter 
 SmmMutate
\begin_inset LatexCommand \index{function!SmmMutate}

\end_inset 


\layout Standard

Stepwise mutation model
\begin_inset LatexCommand \index{mutation!stepwise mutation model}

\end_inset 

 (SMM) Mutation model assumes that alleles are represented by integer values
 and that a mutation either increases or decreases the allele value by one.
 For variable number tandem repeats loci (VNTR), the allele value is generally
 taken as the number of tandem repeats in the DNA sequence.
 
\layout Standard

The following example demonstrate the use of
\family typewriter 
 smmMutator
\family default 
.
 Note that although the mutation rate is 1, some allele 1 is not mutated
 since they can not be mutated to 0.
 The same will hold for the upper bound 
\family typewriter 
maxAllele 
\family default 
which is defaulted to 99 in this case.
\begin_inset Include \verbatiminput{log/smmMutator.log}
preview false

\end_inset 


\layout Subsection

Operator (C++/Hybrid) 
\family typewriter 
gsmMutator
\begin_inset LatexCommand \index{operator!gsmMutator}

\end_inset 

, 
\family default 
function
\family typewriter 
 GsmMutate
\begin_inset LatexCommand \index{function!GsmMutate}

\end_inset 


\layout Standard


\emph on 
Generalized stepwise model
\begin_inset LatexCommand \index{mutation!generalized stepwise model}

\end_inset 

 
\emph default 
is an extension to stepwise mutation model.
 In this model, the change in the allelic state is draw from a random distributi
on.
 A 
\emph on 
geometric generalized stepwise model 
\begin_inset LatexCommand \index{geometric generalized stepwise model}

\end_inset 


\emph default 
uses a geometric distribution with parameter 
\begin_inset Formula $p$
\end_inset 

, which has mean 
\begin_inset Formula $\frac{p}{1-p}$
\end_inset 

 and variance 
\begin_inset Formula $\frac{p}{\left(1-p\right)^{2}}$
\end_inset 

.
 
\layout Standard

Operator 
\family typewriter 
gsmMutator 
\family default 
implements both models.
 If you specify a python function without parameter, the operator will use
 its return value each time a mutation occur; otherwise, a parameter 
\begin_inset Formula $p$
\end_inset 

 should be provided and the operator will act as a geometric generalized
 stepwise model.
\begin_inset Include \verbatiminput{log/gsmMutator.log}
preview false

\end_inset 


\layout Subsection

Operator (Hybrid) 
\family typewriter 
pyMutator
\begin_inset LatexCommand \index{operator!pyMutator}

\end_inset 

, 
\family default 
function
\family typewriter 
 PyMutate
\begin_inset LatexCommand \index{function!PyMutate}

\end_inset 


\layout Standard

If you can not accomplish your task with the above normal mutator, you can
 always use this hybrid mutator.
 Mutation rate etc are set just like others and you are supposed to provide
 a python function to return a new allele state given an old state.
 
\family typewriter 
pyMutator 
\family default 
will choose an allele as usual and call your function to mutate it to another
 allele.
 Here is an example:
\layout Standard


\begin_inset Include \verbatiminput{log/pyMutator.log}
preview false

\end_inset 


\layout Subsection

Operator (C++) 
\family typewriter 
pointMutator
\begin_inset LatexCommand \index{operator!pointMutator}

\end_inset 

, 
\family default 
function
\family typewriter 
 PointMutate
\begin_inset LatexCommand \index{function!PointMutate}

\end_inset 


\layout Standard

If you can not accomplish your task with the above normal mutator, you can
 always use this hybrid mutator.
 Mutation rate etc are set just like others and you are supposed to provide
 a python function to return a new allele state given an old state.
 
\family typewriter 
pyMutator 
\family default 
will choose an allele as usual and call your function to mutate it to another
 allele.
 Here is an example:
\layout Section

Recombination
\begin_inset LatexCommand \index{recombination}

\end_inset 


\layout Standard

Only one recombinator is provided.
 Recombination events between loci a/b and b/c are independent.
\layout Subsection

Operator (C++) 
\family typewriter 
recombinator
\begin_inset LatexCommand \index{operator!recombinator}

\end_inset 


\layout Standard

This operator takes similar parameters as a mutator.
 However, because of potentially uneven allelic distance, you should use
 one of the two parameters:
\layout Itemize


\family typewriter 
intensity:
\family default 
 intensity of recombination.
 The actually recombination rate is 
\family typewriter 
intensity*loci distance.
\layout Itemize


\family typewriter 
rate:
\family default 
 recombination rate after all 
\family typewriter 
afterLoci
\family default 
.
 It can also be an array of recombination rates.
 Should have length 
\family typewriter 
totNumLoci()
\family default 
 or length of 
\family typewriter 
afterLoci.

\family default 
 The recombination rates are independent of loci distance.
\layout Itemize


\family typewriter 
afterLoci: 
\family default 
recombine after loci 
\family typewriter 
afterLoci.
 
\layout Itemize


\family typewriter 
maleIntensity, maleRate, maleAfterLoci: 
\family default 
If you need to specify different recombination model for male and female,
 you can specify these parameters.
 In this case, 
\family typewriter 
intensity, rate 
\family default 
and
\family typewriter 
 afterLoci
\family default 
 will be treated as female parameters.
\layout Standard


\begin_inset Include \verbatiminput{log/recombinatorhelp.log}
preview false

\end_inset 


\layout Standard

The following example forces recombination (with rate 1, an unrealistic
 value since the maximum recombination rate should be .5) at loci 2,6 and
 10.
 Here I use a 
\family typewriter 
parentsTagger 
\family default 
to mark the parents of each individual so you can (if you have enough patience)
 see exactly how recombination works.
 
\begin_inset Include \verbatiminput{log/recombinator.log}
preview false

\end_inset 


\layout Standard

Note that if 
\family typewriter 
sexChrom() 
\family default 
is true, there is no recombination between the last chromosome (sex chromosomes
 XY) of male individuals.
 This may change later if the exchanges of genes between pseudoautosomal
 region of XY need to be modeled.
\layout Standard

Recombinations after each locus will be recorded.
 You can retrieve this information through functions
\layout LyX-Code

rec.recCount(locus)
\layout LyX-Code

rec.recCounts()
\layout Standard

where 
\family typewriter 
rec
\family default 
 is the recombinator, 
\family typewriter 
locus
\family default 
 is locus index.
 
\layout Section

Selection
\begin_inset LatexCommand \index{selection}

\end_inset 

 
\layout Subsection

Mechanism
\layout Standard

Genetic selection is tricky to simulate since there are many difference
 
\emph on 
fitness 
\emph default 
values and many different way to apply selection.
 
\family typewriter 
simuPOP
\family default 
 employees an '
\emph on 
ability-to-mate
\emph default 
' approach.
 Namely, the probability that an individual will be chosen for mating is
 proportional to its fitness value.
 More specifically,
\layout Itemize

PreMating selectors assign fitness values to each individual.
\layout Itemize

During sexless mating (e.g.
 
\family typewriter 
binomialSelection
\family default 
), individuals are chosen at probabilities that are proportional to their
 fitness values.
 If there are 
\begin_inset Formula $N$
\end_inset 

 individuals with fitness values 
\begin_inset Formula $f_{i},i=1,...,N$
\end_inset 

, individual 
\begin_inset Formula $i$
\end_inset 

 will have probability 
\begin_inset Formula $\frac{f_{i}}{\sum_{j}f_{j}}$
\end_inset 

 to be chosen to be passed to the next generation.
\layout Itemize

During 
\family typewriter 
randomMating
\family default 
, males and females are separated.
 Males and females are chosen from their respective groups in the same manner
 and mate.
 
\layout Standard

It is not very clear that our method agrees with the traditional 'average
 number of offsprings' definition of fitness.
 (Note that this concept is very difficult to simulate since we do not know
 who will determine the number of offsprings if two parents are involved.)
 We can, instead, look at the consequence of selection in a simpler case
 (as derived in any population genetics textbook):
\layout Quote

At generation 
\begin_inset Formula $t$
\end_inset 

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset 

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset 

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset 

 etc, should be
\layout Quote


\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset 


\layout Standard

Now, using the ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset 

 will be number of 
\begin_inset Formula $11$
\end_inset 

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset 

This is, however, is exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset 

The same argument applies to arbitrary number of genotypes and random mating.
 
\layout Standard

The following operators, when applied, will set a variable
\family typewriter 
 fitness
\family default 
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\layout Itemize

selector along can not do selection! Only mating schemes can actually select
 on individuals.
\layout Itemize

selector has to be 
\family typewriter 
PreMating 
\family default 
operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter 
PreMating
\family default 
.
 However, if you use the function form of these selectors in a
\family typewriter 
 pyOperator
\family default 
, make sure to set the stage of 
\family typewriter 
pyOperator
\family default 
 to
\family typewriter 
 PreMating
\family default 
.
 
\layout Subsection

Operator (C++) 
\family typewriter 
basicSelector
\begin_inset LatexCommand \index{operator!basicSelector}

\end_inset 

,
\family default 
function 
\family typewriter 
BasicSele
\begin_inset LatexCommand \index{function!BasicSelect}

\end_inset 

 
\layout Standard


\family typewriter 
basicSelector
\family default 
 implements selection at one locus.
 User should supply a dictionary of fitness values for each genotype and
 this selector will set each individual's fitness value according to its
 genotype.
\layout Standard


\begin_inset Include \verbatiminput{log/selectorhelp.log}
preview false

\end_inset 


\layout Standard

The following example is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset 

 the genotype frequency will go to an equilibrium state.
 Theoretically, if
\begin_inset Formula \begin{eqnarray*}
s_{1} & = & w_{12}-w_{11}\\
s_{2} & = & w_{12}-w_{22}\end{eqnarray*}

\end_inset 

the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset 

Which is 
\begin_inset Formula $.677$
\end_inset 

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset 

, 
\begin_inset Formula $s_{2}=.2$
\end_inset 

).
 
\begin_inset Include \verbatiminput{log/basicSelector.log}
preview false

\end_inset 


\layout Subsection

Operator (C++) 
\family typewriter 
maSelector
\begin_inset LatexCommand \index{operator!maSelector}

\end_inset 

, 
\family default 
function 
\family typewriter 
MaSelect
\begin_inset LatexCommand \index{function!MaSelect}

\end_inset 

 
\layout Standard


\family typewriter 
maSelector 
\family default 
is called 'multiple-alleles
\begin_inset LatexCommand \index{selection!multiple-alleles selection}

\end_inset 

' selector.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter 
wildtype 
\family default 
and any other alleles are considered as diseased allele.
 
\family typewriter 
maSelector 
\family default 
accepts an array of fitness for AA, Aa, aa while A stands for wildtype alleles.
 Fitness is then set for any given genotype.
 (Anyway, 
\family typewriter 
aa
\family default 
 does not have to have smaller fitness value than 
\family typewriter 
AA
\family default 
 or 
\family typewriter 
Aa
\family default 
.)
\layout Subsection

Operator (C++) 
\family typewriter 
mlSelector
\begin_inset LatexCommand \index{operator!mlSelector}

\end_inset 


\family default 
, function 
\family typewriter 
MlSelect
\begin_inset LatexCommand \index{function!MlSelect}

\end_inset 

 
\layout Standard


\family typewriter 
mlSelector 
\family default 
is a 'multiple-loci model
\begin_inset LatexCommand \index{selection!multiple-loci multiplicative model}

\end_inset 

' selector.
 The selector takes a vector of selectors (can not be another 
\family typewriter 
mlSelector
\family default 
) and evaluate the fitness of an individual as the the product or sum of
 individual fitness values.
 The mode is determined by parameter 
\family typewriter 
mode
\family default 
, which takes the value
\layout Subsubsection

SEL_Multiplicative
\begin_inset LatexCommand \index{constant!SEL_Multiplicative}

\end_inset 

: 
\layout Standard

The fitness is calculated as 
\begin_inset Formula $f=\prod_{i}f_{i}$
\end_inset 

.
 
\layout Subsubsection

SEL_Additive
\begin_inset LatexCommand \index{constant!SEL_Additive}

\end_inset 

:
\layout Standard

The fitness is calculated as 
\begin_inset Formula $f=\max\left(0,1-\sum_{i}(1-f_{i})\right)=\max\left(0,1-\sum_{i}s_{i}\right)$
\end_inset 

.
 
\begin_inset Formula $f$
\end_inset 

 is set to 0 when 
\begin_inset Formula $f<0$
\end_inset 

.
 What is added are 
\begin_inset Formula $s_{i}$
\end_inset 

, not 
\begin_inset Formula $f_{i}$
\end_inset 

 directly.
\layout Subsection

Operator (Hybrid) 
\family typewriter 
pySelector
\begin_inset LatexCommand \index{operator!pySelector}

\end_inset 


\family default 
, function 
\family typewriter 
PySelect
\begin_inset LatexCommand \index{function!PySelect}

\end_inset 

 
\layout Standard


\family typewriter 
pySelector 
\family default 
accept a list of susceptibility loci and a Python function.
 For each individual, this operator will pass the genotypes at these loci
 (in the form of 
\family typewriter 
0-0,0-1,1-0,1-1
\family default 
 etc where X-Y is locus X - ploidy Y, in case of diploid population) and
 expect a returned fitness value.
 This, at least in theory, can accommodate all selection scenarios.
 
\layout Standard

The following example simulate the same scenario as above, with 
\begin_inset Formula $s_{1}=.2,s_{2}=.3$
\end_inset 

 (so
\begin_inset Formula $p=.6$
\end_inset 

) and a 
\family typewriter 
pySelector
\family default 
.
 Note that although alleles at two loci are passed, the 
\family typewriter 
sel
\family default 
 function only uses the first one.
\begin_inset Include \verbatiminput{log/pySelector.log}
preview false

\end_inset 


\layout Section

Penetrance
\begin_inset LatexCommand \index{penetrance}

\end_inset 


\layout Standard

Penetrance is the probability that one will have the disease when he has
 certain genotype(s).
 Calculation of penetrance is similar to that of fitness.
 The parameter set is also similar.
 An individual will be randomly marked as affected/unaffected according
 to his penetrance value.
 For example, an individual will have .8 probability to be affected if the
 penetrance is .8.
 
\layout Standard

Penetrance can be applied at any stage.
 The default stage is 
\family typewriter 
DuringMating
\family default 
.
 The penetrance will be calculated and affected status is set for each offspring
 during mating.
 You can also use penetrance as 
\family typewriter 
PreMating, PostMating 
\family default 
or even 
\family typewriter 
PrePostMating 
\family default 
operator.
 In these cases, affected status will be set to all individuals according
 to their penetrance value.
 It is also possible to use 
\family typewriter 
exposePenetrance
\family default 
 parameter to set an carray 
\family typewriter 
penetrance 
\family default 
in these cases.
 This is useful to actaully have a look at penetrance values and see if
 the values are as expected.
\layout Standard

Affected status will be used for statistical purpose, and most importantly,
 ascertainment.
 They will be calculated along with fitness although they might not be used
 at every generation.
 You can use two operators: one for fitness/selection, active at every generatio
n; one for affected status, active only at ascertainment, to avoid unnecessary
 calculation of affected status.
\layout Standard

One important note about penetrance functions is that they only apply to
 the current generation of a population.
 This is usually not a problem for operators, but if you need to set affected
 status for a population with ancestral populations, you should do
\layout LyX-Code

for i in range(0, pop.ancetralDepath()+1):
\layout LyX-Code

  pop.useAncestralPop(i)
\layout LyX-Code

  PyPenetrance(pop, ...)
\layout LyX-Code

pop.useAncestralPop(0)
\layout LyX-Code

\layout Subsection

Operator (C++)
\family typewriter 
 basicPenetrance
\family default 

\begin_inset LatexCommand \index{operator!basicPenetrance}

\end_inset 

 (post, during-Mating), function 
\family typewriter 
BasicPenetrance
\begin_inset LatexCommand \index{function!BasicPenetrance}

\end_inset 

 
\layout Standard

Assign penetrance using a table with keys 'X-Y' where X and Y are allele
 numbers.
 For example,
\layout LyX-Code

basicPenetrance(locus=1, penetrance={'1-1':0, '1-2':0.5, '2-2':1})
\layout Standard

Note that this dictionary can be more than three elements to accommendate
 more than one disease alleles.
 
\layout Subsection

Operator (C++) 
\family typewriter 
maPenetrance
\family default 

\begin_inset LatexCommand \index{operator!maPenetrance}

\end_inset 

 (post, during-Mating), function 
\family typewriter 
MaPenetrance
\begin_inset LatexCommand \index{function!MaPenetrance}

\end_inset 


\layout Standard


\family typewriter 
maPenetrance 
\family default 
is called 'multiple-alleles
\begin_inset LatexCommand \index{selection!multiple-alleles penetrance}

\end_inset 

' penetrance.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter 
wildtype 
\family default 
and any other alleles are considered as diseased allele.
 
\family typewriter 
maSelector 
\family default 
accepts an array of fitness for AA, Aa, aa while A stands for wildtype alleles.
 Penetrance is then set for any given genotype.
 For example
\layout LyX-Code

maPenetrance(locus=1, wildtype=[1], penetrance={0,0.5,1})
\layout Standard

this operator behave the same as the 
\family typewriter 
basicPenetrance 
\family default 
example but will work if there are more than one disease alleles.
 
\layout Subsection

Operator (C++)
\family typewriter 
 mlPenetrance
\family default 

\begin_inset LatexCommand \index{operator!mlPenetrance}

\end_inset 

(post, during-Mating), function 
\family typewriter 
MlPenetrance
\begin_inset LatexCommand \index{function!MlPenetrance}

\end_inset 


\layout Standard


\family typewriter 
mlPentrance
\family default 
 is the 'multiple-loci' penetrnace calculator.
 It accepts a list of penetrances and combine them according to the 
\family typewriter 
mode 
\family default 
parameter which can take the values:
\layout Subsubsection

PEN_Multiplicative
\begin_inset LatexCommand \index{constant!PEN_Multiplicative}

\end_inset 

: 
\layout Standard

The penetrance is calculated as 
\begin_inset Formula $f=\prod f_{i}$
\end_inset 

.
 
\layout Subsubsection

PEN_Additive
\begin_inset LatexCommand \index{constant!PEN_Additive}

\end_inset 


\layout Standard

The penetrance is calculated as 
\begin_inset Formula $f=\min\left(1,\sum f_{i}\right)$
\end_inset 

.
 
\begin_inset Formula $f$
\end_inset 

 is set to 1 when 
\begin_inset Formula $f<0$
\end_inset 

.
 What is added are 
\begin_inset Formula $s_{i}$
\end_inset 

, not 
\begin_inset Formula $f_{i}$
\end_inset 

 directly.
\layout Subsubsection

PEN_Heterogeneity
\begin_inset LatexCommand \index{constant!PEN_Multiplicative}

\end_inset 

: 
\layout Standard

The penetrance is calculated as 
\begin_inset Formula $f=1-\prod\left(1-f_{i}\right)$
\end_inset 

.
 
\layout Standard

Please refer to 
\begin_inset LatexCommand \citet{Risch1990}

\end_inset 

 for detailed information about these models.
\layout Standard

For example, if each locus follows an additive penetrance model, we can
 have
\layout LyX-Code

pen = []
\layout LyX-Code

for loc in loci:
\layout LyX-Code

  pen.append( maPenetrance(locus=loc, wildtype=[1],
\layout LyX-Code

    penetrance=[0.0.3,0.6] ) )
\layout LyX-Code

# the multi-loci penetrance
\layout LyX-Code

penMulti = mlPenetrance(mode=PEN_Multiplicative, peneOps=pen)
\layout Subsection

Operator (Hybrid) 
\family typewriter 
pyPenetrance
\family default 

\begin_inset LatexCommand \index{operator!pyPenetrance}

\end_inset 

(post, during-Mating), function 
\family typewriter 
PyPenetrance
\begin_inset LatexCommand \index{function!PyPenetrance}

\end_inset 


\layout Standard

For each individual, user provide a function to calculate penetrance.
 This method is very flexible but will be slower than previous operators
 since a function will be called for each individual.
 This operator accept the following parameters:
\layout Itemize


\family typewriter 
loci: 
\family default 
disease susceptibility loci.
 The genotype 
\emph on 
at these loci 
\emph default 
will be passed to the provided python function in the form of 
\family typewriter 
loc1_1, loc1_2, loc2_1, loc2_2, ...
 
\family default 
if the individuals are diploid.
\layout Itemize


\family typewriter 
func:
\family default 
 a user-defined function that takes a array of genotype and return a penetrance
 value.
 The returned value should be between 0 and 1.
\layout Standard

For example, for the same multi-locus model before, we can define is using
 
\family typewriter 
pyPenetrance
\family default 
 as
\layout LyX-Code

def peneFunc(geno):
\layout LyX-Code

  p = 1
\layout LyX-Code

  for l in range(len(geno)/2):
\layout LyX-Code

    p *= (geno[l*2]+geno[l*2+1]-2)*0.3
\layout LyX-Code

  return p
\layout LyX-Code

penMulti = pyPenetrance(loci=loci, func=peneFunc)
\layout Standard

As you can see, using this operator, you can define arbitrarily complex
 penetrance functions.
 Typical such penetrance functions are interaction between loci (using a
 multi-locus penetrance table), even random ones.
\layout Standard

It would be useful to let peneFunc take parameters.
 This can be done by defining a python function that return a penetrance
 function.
 This may sound intimidating but it is really easy:
\layout LyX-Code

def peneFunc(table):
\layout LyX-Code

  def func(geno):
\layout LyX-Code

    return table[geno[0]-1][geno[1]-1]
\layout LyX-Code

  return func
\layout LyX-Code

# then, given a table, you can do
\layout LyX-Code

pen = pyPenetrance(loci=loci, func=peneFunc( ((0,0.5),(0.3,0.8)) ) )
\layout Standard

Now, for any table, you can use 
\family typewriter 
peneFunc 
\family default 
to return a penetrance function that uses this table.
\layout LyX-Code

    
\layout Section

Quantitative Trait
\begin_inset LatexCommand \index{quantitative trait}

\end_inset 


\layout Standard

Quantitative trait is the measure of certain phenotype for given genotype.
 Quantitative trait is similar to penetrance in that the consequence of
 penetrance is binary: affected or unaffected; while it is continuous for
 quantitative trait.
 
\layout Standard

The following operators/functions calculate quantitative traits for each
 individual and store the values in an array 
\family typewriter 
QT.

\family default 
 Because migration, mating etc will change individual order, the values
 in QT should be used soon after they are calculated.
\layout Subsection

Operator (C++)
\family typewriter 
 basicQuanTrait
\family default 

\begin_inset LatexCommand \index{operator!basicQuanTrait}

\end_inset 

, function 
\family typewriter 
BasicQuanTrait
\begin_inset LatexCommand \index{function!BasicQuanTrait}

\end_inset 


\layout Standard

Assign quantitative trait using a table with keys 'X-Y' where X and Y are
 allele numbers.
 If 
\family typewriter 
sigma
\family default 
 is not zero, the returned value is the sum of trait plus 
\begin_inset Formula $N\left(0,\sigma^{2}\right)$
\end_inset 

.
 This random part is usually considered as environmental factor of the trait.
 
\layout Subsection

Operator (C++) 
\family typewriter 
maQuanTrait
\family default 

\begin_inset LatexCommand \index{operator!maQuanTrait}

\end_inset 

, function 
\family typewriter 
MaQuanTrait
\begin_inset LatexCommand \index{function!MaQuanTrait}

\end_inset 


\layout Standard


\family typewriter 
maQuanTrait 
\family default 
is called 'multiple-alleles
\begin_inset LatexCommand \index{selection!multiple-alleles penetrance}

\end_inset 

' quantitative trait.
 It separate alleles into two groups: wildtype and disease alleles.
 wildtype alleles are specified by parameter 
\family typewriter 
wildtype 
\family default 
and any other alleles are considered as diseased allele.
 
\family typewriter 
maQuanTrait 
\family default 
accepts an array of fitness for AA, Aa, aa while A stands for wildtype alleles.
 Quantitative trait is then set for any given genotype.
 
\begin_inset Formula $N\left(0,\sigma^{2}\right)$
\end_inset 

 will be added to returned trait value.
\layout Subsection

Operator (C++) 
\family typewriter 
mlQuanTrait
\family default 

\begin_inset LatexCommand \index{operator!mlQuanTrait}

\end_inset 

, function 
\family typewriter 
MlQuanTrait
\begin_inset LatexCommand \index{function!MlQuanTrait}

\end_inset 


\layout Standard


\family typewriter 
mlQuanTrait
\family default 
 is the 'multiple-loci' QT calculator.
 It accepts a list of QuanTraits and combine them according to the 
\family typewriter 
mode 
\family default 
parameter which can take the values:
\layout Subsubsection

QT_Multiplicative
\begin_inset LatexCommand \index{constant!QT_Multiplicative}

\end_inset 

: 
\layout Standard

The mean of quantitative trait is calculated as 
\begin_inset Formula $f=\prod f_{i}$
\end_inset 

.
 
\layout Subsubsection

QT_Additive
\begin_inset LatexCommand \index{constant!QT_Additive}

\end_inset 

:
\layout Standard

The mean of quantitative trait is calculated as 
\begin_inset Formula $f=\sum f_{i}$
\end_inset 

.
 
\layout Standard

Note that all 
\begin_inset Formula $\sigma_{i}$
\end_inset 

 (for 
\begin_inset Formula $f_{i}$
\end_inset 

) and 
\begin_inset Formula $\sigma$
\end_inset 

 (for 
\begin_inset Formula $f$
\end_inset 

 ) will all be considerd.
 I.e, the trait value should be 
\begin_inset Formula \[
f=\sum_{i}\left(f_{i}+N\left(0,\sigma_{i}^{2}\right)\right)+\sigma^{2}\]

\end_inset 

for QT_Additive case.
 If this is not desired, you can set some of the 
\begin_inset Formula $\sigma$
\end_inset 

 to zero.
\layout Subsection

Operator (Hybrid)
\family typewriter 
 pyQuanTrait
\family default 

\begin_inset LatexCommand \index{operator!pyQuanTrait}

\end_inset 

, function 
\family typewriter 
PyQuanTrait
\begin_inset LatexCommand \index{function!PyQuanTrait}

\end_inset 


\layout Standard

For each individual, user provide a function to calculate quantitative trait.
\layout Section

Ascertainment
\begin_inset LatexCommand \index{ascertainment}

\end_inset 

 (subset of population)
\layout Standard

Ascertainment/sampling refers to ways to select individuals from a population.
 In simuPOP, ascerntainment operators forms separate populations in a population
's namespace.
 All the following operators work like this except for 
\family typewriter 
pySubset
\family default 
 which thrink the population itself.
 
\layout Standard

Individuals in sampled populations may or may not keep their original order.
 Please check each sampling scheme for details.
\layout Standard

Most of the ascertainment operators support the following options:
\layout Itemize


\family typewriter 
times: 
\family default 
how many times to sample from the population.
\layout Itemize


\family typewriter 
name
\family default 
: name of samples in local namespace.
 This variable is an array of populations of size 
\family typewriter 
times
\family default 
.
 Default to 
\family typewriter 
sample
\family default 
.
 If 
\family typewriter 
name=''
\family default 
 is set, samples will not be saved in local namespace.
 
\layout Itemize


\family typewriter 
saveAs, format:
\family default 
 filename and format to save the samples.
 
\layout Itemize


\family typewriter 
nameExpr, saveAsExpr: 
\family default 
expression version of parameter 
\family typewriter 
name
\family default 
 and 
\family typewriter 
saveAs
\family default 
.
 They will be dynamically evaluated in population's local namespace.
 
\layout Standard

Two forms of sample size specifications are supported: with/without subpopulatio
n structure.
 For example, the 
\family typewriter 
size 
\family default 
parameter of 
\family typewriter 
randomSample
\family default 
 can be a number or an array (of the length of number of subpopulations).
 If a number is given, sample will be drawn from the whole population, regardles
s of population structure.
 If an array is given, individuals will be draw from each subpopulation
 
\family typewriter 
sp
\family default 
 according to 
\family typewriter 
size[sp]
\family default 
.
\layout Standard

An important special case of sample size specification is when 
\family typewriter 
size=[]
\family default 
 (default).
 In this case, usually all qualified individuals will be returned.
\layout Standard

The function form of these operators are a bit different from others.
 They do return a value: an array of samples.
 
\layout Subsection

function 
\family typewriter 
population::shrinkByIndInfo
\begin_inset LatexCommand \index{thrinkByIndInfo}

\end_inset 

()
\layout Standard

This function look at the 
\family typewriter 
info() 
\family default 
field of each individual and remove anyone with value 0.
 
\layout Subsection

Operator (C++) 
\family typewriter 
pySubset
\family default 

\begin_inset LatexCommand \index{operator!pySubset}

\end_inset 

, function 
\family typewriter 
PySubset
\family default 

\begin_inset LatexCommand \index{function!PySubset}

\end_inset 


\layout Standard

This operator shrink a population according to a given array or the 
\family typewriter 
info()
\family default 
 value of each indvidual.
 Subpopulations are kept intact.
 
\layout Subsection

Operator (C++/hybrid) 
\family typewriter 
pySample
\begin_inset LatexCommand \index{operator!pySample}

\end_inset 

, 
\family default 
function
\family typewriter 
 PySample
\begin_inset LatexCommand \index{function!PySample}

\end_inset 


\layout Standard


\family typewriter 
PySample
\begin_inset LatexCommand \index{function!PySample}

\end_inset 

(pop, info, name, saveAs, format) 
\family default 
or 
\family typewriter 
Sample
\begin_inset LatexCommand \index{function!Sample}

\end_inset 

(pop)
\family default 
 if you already set info for each individual using 
\family typewriter 
setInfo
\begin_inset LatexCommand \index{population!setInfo}

\end_inset 

() 
\family default 
function.
 The operator version of these functions are 
\family typewriter 
pySample
\begin_inset LatexCommand \index{operator!pySample}

\end_inset 

(info, times, name, nameExpr, saveAs, saveAsExpr, format).
 
\layout Subsection

Operator (C++) 
\family typewriter 
randomSample
\begin_inset LatexCommand \index{operator!randomSample}

\end_inset 

, 
\family default 
function
\family typewriter 
 RandomSample
\begin_inset LatexCommand \index{function!RandomSample}

\end_inset 


\layout Standard


\family typewriter 
RandomSample
\begin_inset LatexCommand \index{function!RandomSample}

\end_inset 

(pop, size, times, name, saveAs, format)
\family default 
 will randomly choose size individuals (or 
\family typewriter 
sizes
\family default 
 from subpopulations) and return a new population.
 The operator version is 
\family typewriter 
randomSample
\family default 

\begin_inset LatexCommand \index{operator!randomSample}

\end_inset 

(
\family typewriter 
size, times, name, nameExpr, saveAs, saveAsExpr, format
\family default 
).
 
\layout Standard

The function form returns the samples directly.
 The operator keeps samples in an array 
\family typewriter 
name 
\family default 
in local namespace.
 You can acess them through 
\family typewriter 
dvars()
\family default 
 or 
\family typewriter 
vars() 
\family default 
functions.
 
\layout Standard

The orginal subpopulation structure/boundary is kept in the samples.
\layout Subsection

Opeartor (C++) 
\family typewriter 
caseControlSample
\begin_inset LatexCommand \index{operator!caseControlSample}

\end_inset 

, 
\family default 
function
\family typewriter 
 CaseControlSample
\begin_inset LatexCommand \index{function!CaseControlSample}

\end_inset 


\layout Standard


\family typewriter 
CaseControlSample(pop, cases, controls, times, name, saveAs, format)
\family default 
 will randomly choose cases affected individuals and controls unaffected
 individuals.
 The operator version of this function is 
\family typewriter 
caseControlSample(case, cases, control, controls, times, name, nameExpr,
 saveAs, saveAsExpr, format)
\family default 
.
 The affected status is usually set by penetrance function/operators.
 The sample populations will have two subpopulations: cases and controls.
 
\layout Standard

You can specify number of cases and controls from each subpop using the
 array form of the parameters.
 The sample population will still have only two subpoulations (case/control)
 though.
\layout Standard

A special case of this sampling scheme is when one or both 
\family typewriter 
cases
\family default 
 and 
\family typewriter 
controls
\family default 
 are omitted (zeros).
 In this cases, all cases and/or controls are chosen.
 If both parameters are omitted, the sample is effectively the same population
 with affected and unaffected separated into two subpopulaitons.
\layout Standard

The following example shows how to draw a random sample (without replacement
 of course) from an existing population.
 
\begin_inset Include \verbatiminput{log/randomSample.log}
preview false

\end_inset 


\layout Subsection

Operator (C++) 
\family typewriter 
affectedSibpairSample
\family default 

\begin_inset LatexCommand \index{operator!affectedSibpairsSample}

\end_inset 

, function 
\family typewriter 
AffectedSibpairSample
\family default 

\begin_inset LatexCommand \index{function!AffectedSibpairsSample}

\end_inset 


\layout Standard

The use of this operator needs special preparation for the population.
 Obviously, to obtain affected sibpairs, we need to know the parents and
 the affectedness tatus of each individual.
 Furthermore, to get parental genotype, the population should have ancestralDept
h at least 1.
 The biggest problem, however, comes from the mating scheme we are using.
\layout Standard


\family typewriter 
randomMating()
\family default 
 is usually used for diploid populations.
 The 
\emph on 
real random
\emph default 
 mating requires that a mating will generate only one offspring.
 Since parents are chosen with replacement, a parent can have multiple offspring
s with different parents.
 On the otherhand, it is very unlikely that two offsprings will have the
 same parents.
 The probability of having a sibling for an offspring is 
\begin_inset Formula $\frac{1}{N^{2}}$
\end_inset 

 (do not consider selection).
 Therefore, we will have to allow multiple offsprings per mating at the
 cost of smaller effective population size.
\layout Standard

All these requirements come at a cost: multiple ancestral populations, judge
 affectedness status and tagging will slow down evolution; multiple offsprings
 will reduce effective population size.
 Fortunately, simuPOP is flexible enough to let all these happen only at
 the last several generations.
 For example, you can do
\layout LyX-Code

endGen = 1000
\layout LyX-Code

# having two offsprings only at the last three generations
\layout LyX-Code

def numOffsprings(gen):
\layout LyX-Code

  if gen >= endGen - 3:
\layout LyX-Code

    return 2
\layout LyX-Code

  else 
\layout LyX-Code

    return 1
\layout LyX-Code

# evolve ...
\layout LyX-Code

simu = simulator(pop, randomMating(numOffspringsFunc = numOffsprings))
\layout LyX-Code

simu.evolve( ...
\layout LyX-Code

  parentsTagger(begin = endGen - 3),
\layout LyX-Code

  basicPenetrance(...., begin = endGen - 2),
\layout LyX-Code

  setAncestralDepth(1, at = endGen -2 )
\layout LyX-Code

...)
\layout Standard

to let your population evolve 
\emph on 
normally
\emph default 
 and start to store ancestral generations and allow multiple offsprings
 at the last several generations.
\layout Standard

Briefly, you should
\layout Itemize

set ancestral depth to at least 1 to allow analyzing of parental generation,
\layout Itemize

use parentsTagger to track parents for each individual, with the usual limit
 of no post-mating migration, and 
\layout Itemize

allow multiple offsprings at least at the last generation.
 (You do not have to use fixed number of offsprings.
 Other mating mode like 
\family typewriter 
MATE_GeometricDistribution
\family default 
 can also be used.)
\layout Itemize

use a penetrance operator to set affected status of each individual
\layout Standard

and finally use this operator (or function)
\layout LyX-Code

affectedSibpairSample(size
\family typewriter 
, 
\family default 
 
\family typewriter 
times, name, saveAs, format
\family default 
)
\layout Standard

to get samples accessible from
\family typewriter 
 dvars().name[i].
 
\family default 
Each sample will
\layout Itemize

have 2*size of paired individuals.
 (e.g.
 
\family typewriter 
individual(2n)
\family default 
 and 
\family typewriter 
individual(2n+1), n=0,1,..., size-1 
\family default 
are siblings.
\layout Itemize

have an ancestral generation of the same size, with parents to the sibpairs.
\layout Itemize

if 
\family typewriter 
size 
\family default 
is an array, get 
\family typewriter 
size[sp] 
\family default 
sibpairs from subpop
\family typewriter 
 sp 
\family default 
.
\layout Standard

Other than samples 
\family typewriter 
name
\family default 
, variable 
\family typewriter 
numSibpairs
\family default 
 will be set to indicate the total number of affected sibpairs in the population.
 Subpopulation structure will be kept in the samples so you will know how
 many individuals are drawn from each subpopulation.
 (This info is also saved in variable 
\family typewriter 
numSibpairs
\family default 
 of each sample.
\layout LyX-Code

\layout Section

Statistics Calculation
\layout Subsection

Operator (C++) 
\family typewriter 
stat
\begin_inset LatexCommand \index{operator!stat}

\end_inset 

, 
\family default 
function 
\family typewriter 
Stat
\begin_inset LatexCommand \index{function!Stat}

\end_inset 

 
\layout Standard

Operator stat calculate various basic statistics for the population and
 set variables in local namespace.
 Other operators/functions can refer to the results from the namespace after
 
\family typewriter 
stat
\family default 
 is applied.
 
\family typewriter 
Stat
\family default 
 is the function form of the operator.
\layout Standard

For each statistics, I will list corresponding parameter (of 
\family typewriter 
stat
\family default 
), variables and mathematics formula if applicable.
 Note that these statistics are dependent to each other.
 For example, heterotype and allele frequency of related loci will be automatica
lly calculated if linkage diseqilibrium is requested.
\layout Subsubsection

Population size
\layout Itemize

parameter: 
\family typewriter 
popSize=True/False
\layout Itemize

variable:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
numSubPop
\begin_inset LatexCommand \index{stat!numSubPop}

\end_inset 

 
\family default 
\series default 
number of subpopulation
\layout Itemize
\noindent 

\family typewriter 
\series bold 
popSize
\begin_inset LatexCommand \index{stat!popSize}

\end_inset 

, subPop[sp]['popSize']
\layout Itemize


\family typewriter 
\series bold 
subPopSize
\begin_inset LatexCommand \index{stat!subPopSize}

\end_inset 

, 
\family default 
\series default 
an array of subpopulation size.
 Not available for subpopulations.
\end_deeper 
\layout Subsubsection

Number of male/female
\layout Itemize

parameter: 
\family typewriter 
numOfMale=True/False
\layout Itemize
\noindent 
variable:
\begin_deeper 
\layout Itemize
\noindent 

\family typewriter 
\series bold 
numOfMale
\begin_inset LatexCommand \index{stat!numOfMale}

\end_inset 

, subPop[sp]['numOfMale']
\layout Itemize
\noindent 

\family typewriter 
\series bold 
numOfFemale
\begin_inset LatexCommand \index{stat!numOfFemale}

\end_inset 

, subPop[sp]['numOfFemale']
\end_deeper 
\layout Subsubsection

Number/proportion of affected/unaffected individuals
\layout Itemize

parameter: 
\family typewriter 
numOfAffected=True/False
\layout Itemize

variable:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
numOfAffected, subPop[sp]['numOfAffected']
\layout Itemize


\family typewriter 
\series bold 
numOfUnaffected, subPop[sp]['numOfUnAffected']
\layout Itemize


\family typewriter 
\series bold 
propOfAffected, subPop[sp]['propOfAffected']
\layout Itemize


\family typewriter 
\series bold 
propOfUnaffected, subPop[sp]['propOfUnAffected']
\end_deeper 
\layout Subsubsection

Number of distinct alleles at a locus
\layout Standard

This is done through the calculation of allele frequency.
 Therefore, allele frequency will also be calculated if this statistics
 is requested.
\layout Itemize

parameter: 
\family typewriter 
\series bold 
numOfAlleles=[loc1, loc2, ...]
\family default 
\series default 
 where 
\family typewriter 
\series bold 
loc1 
\family default 
\series default 
etc are absolute locus indices.
 
\layout Itemize

variable: a carray of number of alleles for 
\series bold 
all loci
\series default 
.
 Unrequested loci will have 0 distinct alleles.
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
numOfAlleles
\begin_inset LatexCommand \index{stat!numOfAlleles}

\end_inset 

, subPop[sp]['numOfAlleles']
\family default 
\series default 
, number of distinct alles at each loci.
 (Calculated only at requested loci.)
\end_deeper 
\layout Subsubsection

Allele frequency/count
\layout Itemize

parameter: 
\family typewriter 
\series bold 
alleleFreq=[loc1, loc2, ...] 
\family default 
\series default 
where 
\family typewriter 
\series bold 
loc1 
\family default 
\series default 
etc are loci where allele frequencies will be counted.
\layout Itemize

variable: the following 
\family typewriter 
carray
\family default 
 objects will be set.
 For example
\family typewriter 
\series bold 
 alleleNum[1][2] 
\family default 
\series default 
will be the number of allele 2 at locus 1.
 
\begin_deeper 
\layout Itemize
\noindent 

\family typewriter 
\series bold 
alleleNum[a]
\begin_inset LatexCommand \index{stat!alleleNum}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['alleleNum'][a]
\layout Itemize
\noindent 

\family typewriter 
\series bold 
alleleFreq[a]
\begin_inset LatexCommand \index{stat!alleleFreq}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['alleleFreq'][a]
\end_deeper 
\layout Subsubsection

heterozygote frequency/count
\layout Itemize

parameter:
\family typewriter 
 
\series bold 
heteroFreq=[loc1,loc2,...]
\series default 
:
\family default 
 
\begin_deeper 
\layout Standard

an array of loci to calaulate observed heterozygosity and expected heterozygosit
y.
\end_deeper 
\layout Itemize

variables: array of observed heterozygosity
\begin_inset LatexCommand \index{observed heterozygosity}

\end_inset 

.
 
\family typewriter 
\series bold 
heteroNum[0][1]
\series default 
 
\family default 
is the number of heterozygote 1x,
\series bold 
 
\begin_inset Formula $x\ne1$
\end_inset 

.
 
\series default 
Number and frequency (proportion) of heterozygotes are calculated for each
 allele.
 
\begin_deeper 
\layout Standard


\family typewriter 
heteroNum[loc][0] 
\family default 
and
\family typewriter 
 heterFreq[loc][0] 
\family default 
is the overall heterozygosity number and frequency.
 I.e., number/frequency of genotype 
\begin_inset Formula $xy$
\end_inset 

 
\begin_inset Formula $x\ne y$
\end_inset 

.
 From this number, we can easily derive number of homozygosity.
\layout Itemize


\family typewriter 
\series bold 
heteroNum[loc][allele]
\begin_inset LatexCommand \index{stat!heteroNum}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['heteroNum'][loc][allele]
\layout Itemize


\family typewriter 
\series bold 
heteroFreq[loc][allele]
\begin_inset LatexCommand \index{stat!heteroFreq}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['heteroFreq'][loc][allele]
\end_deeper 
\layout Subsubsection

expected heterozygosity
\layout Itemize

parameter: 
\family typewriter 
\series bold 
expHetero=[loc1, loc2,...]
\layout Itemize

Expected heterozygosity
\begin_inset LatexCommand \index{expected heterozygosity}

\end_inset 

 
\begin_inset Formula \[
h_{exp}=1-p_{i}^{2}\]

\end_inset 


\layout Itemize

variable: 
\family typewriter 
\series bold 
expHetero[loc], subPop[sp]['expHetero'][loc]
\layout Subsubsection

homozygosity frequency/count
\layout Itemize

parameter:
\family typewriter 
\series bold 
 homoFreq=[loc1, loc2, ...]
\layout Itemize

Number and frequency of homozygotes 
\begin_inset Formula $xx$
\end_inset 

.
 
\layout Itemize

variable: 
\family typewriter 
\series bold 
homoNum[loc
\family default 
\series default 
], 
\family typewriter 
\series bold 
homoFreq[loc], subPop[sp]['homoNum'][loc]
\family default 
\series default 
,
\family typewriter 
\series bold 
 subPop[sp]['homoFreq'][loc]
\layout Subsubsection

genotype frequency/count
\layout Itemize

parameter:
\series bold 
 
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
genoFreq=[loc1,loc2,...]
\series default 
:
\family default 
 an array of loci to calculate genotype frequency.
 All genotypes in the population will be counted.
\layout Itemize


\family typewriter 
hasPhase
\family default 
: if a/b and b/a are the same genotype.
 default is false.
\end_deeper 
\layout Itemize

variables: Dictionary variables 
\family typewriter 
genoNum, genoFreq, subPop[sp]['genoNum'], subPop[sp]['genoFreq'] 
\family default 
will be set.
 Note that the index
\family typewriter 
 a, b 
\family default 
of 
\family typewriter 
genoFreq[a][b] 
\family default 
are dictionary keys (unlike list used for alleleFreq etc) so you will get
 KeyError when you use a wrong key.
 
\family typewriter 
genoNum.setDefault(a,{})
\family default 
 is preferred.
 
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
genoNum[a][geno]
\begin_inset LatexCommand \index{stat!genoNum}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['genoNum'][a][geno]
\layout Itemize


\family typewriter 
\series bold 
genoFreq
\begin_inset LatexCommand \index{stat!genoFreq}

\end_inset 

[a][geno]
\family default 
, 
\family typewriter 
subPop[sp]['genoFreq'][a][geno]
\family default 
\series default 
, number/frequency of genotype 
\family typewriter 
geno
\family default 
 at allele 
\family typewriter 
a
\family default 
.
 
\family typewriter 
geno
\family default 
 has the form 
\family typewriter 
x-y.
\end_deeper 
\layout Subsubsection

haplotype frequency
\layout Itemize

parameter: 
\family typewriter 
haploFreq:
\family default 
 a matrix of haplotypes (allele sequence on the different loci) to count.
 For example:
\begin_deeper 
\layout LyX-Code

haploFreq = [ [ 0,1,2 ], [1,2] ]
\layout Standard

will count all haplotypes on loci 0,1 and 2; and all haplotypes on loci
 1, 2.
 
\end_deeper 
\layout Itemize

variable: Dictionary ariables 
\family typewriter 
haploNum, haploFreq,
\family default 
 will be set with keys 
\family typewriter 
0-1-2 
\family default 
etc
\family typewriter 
.
 
\family default 
For example 
\family typewriter 
haploNum['1-2']['5-6'] 
\family default 
is the number of allele pair 
\family typewriter 
5,6
\family default 
 (on loci 1 and 2 respectively) in the population.
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
haploNum[haplo]
\begin_inset LatexCommand \index{stat!haploNum}

\end_inset 


\family default 
, 
\family typewriter 
subPop[sp]['haploNum'][haplo]
\layout Itemize


\family typewriter 
\series bold 
haploFreq
\begin_inset LatexCommand \index{stat!haploFreq}

\end_inset 

[haplo]
\family default 
, 
\family typewriter 
subPop[sp]['haploFreq'][haplo]
\family default 
\series default 
, number/frequency of allele sequencies on loci 
\family typewriter 
haplo
\family default 
.
 
\end_deeper 
\layout Subsubsection

Linkage disequilibrium 
\layout Itemize

parameter:
\begin_deeper 
\layout LyX-Code

LD: LD = [ [1,2], [ 0,1,1,2],[1,2,1,2]] 
\layout Standard

For each item
\family typewriter 
 [loc1, loc2, allele1, allele2]
\family default 
, 
\begin_inset Formula $D$
\end_inset 

, 
\begin_inset Formula $D'$
\end_inset 

 and 
\begin_inset Formula $r^{2}$
\end_inset 

 will be calculated based on allele1 at loc1 and allele2 at loc2.
 If only two loci are given, the LD values are averaged over all allele
 pairs.
 For example, for allele 
\begin_inset Formula $A$
\end_inset 

 at locus 1 and allele 
\begin_inset Formula $B$
\end_inset 

 at locus 2, 
\begin_inset Formula \begin{eqnarray*}
D & = & P_{AB}-P_{A}P_{B}\\
D' & = & D/D_{max}\\
D_{max} & = & \begin{cases}
\min\left(P_{A}\left(1-P_{B}\right),\left(1-P_{A}\right)P_{B}\right) & \textrm{if }D>0\\
\min\left(P_{A}P_{B},\left(1-P_{A}\right)\left(1-P_{B}\right)\right) & \textrm{if }D<0\end{cases}\\
r^{2} & = & \frac{D^{2}}{P_{A}\left(1-P_{A}\right)P_{B}\left(1-P_{B}\right)}\end{eqnarray*}

\end_inset 

If 
\begin_inset Formula $A$
\end_inset 

 and 
\begin_inset Formula $B$
\end_inset 

 are not specified, 
\begin_inset Formula $D$
\end_inset 

, 
\begin_inset Formula $D'$
\end_inset 

 and 
\begin_inset Formula $r^{2}$
\end_inset 

 will be the averaged value: (basically 
\begin_inset Formula $\sum\sum P_{A}P_{B}\left|\right|$
\end_inset 

 )
\begin_inset Formula \begin{eqnarray*}
D & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D_{ij}\right|\\
D' & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D'_{ij}\right|\\
r^{2} & = & \sum_{i}\sum_{j}P_{i}P_{j}r_{ij}^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{\left(1-P_{i}\right)\left(1-P_{j}\right)}\end{eqnarray*}

\end_inset 

where 
\begin_inset Formula $p_{i}$
\end_inset 

 and 
\begin_inset Formula $q_{j}$
\end_inset 

 are the population allele frequencies of the 
\begin_inset Formula $i$
\end_inset 

th allele on loc1 and the 
\begin_inset Formula $j$
\end_inset 

th allele on loc2.
 Please note that some other authors uses
\begin_inset Formula \[
r^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{P_{i}P_{j}}\]

\end_inset 

If you are sure the later is correct, please send me an email (with reference).
\end_deeper 
\layout Itemize

variables:
\begin_deeper 
\layout Standard

if loc1 and loc2 are specified.
 The values are LD measures averaged over all possible allele pairs.
 If al1 and al2 are specified, these values are calculated using these two
 alleles.
\layout Itemize


\family typewriter 
\series bold 
ld['loc1-loc2']['al1-al2'], subPop[sp]['ld']['loc1-loc2']['al1-al2']
\layout Itemize


\family typewriter 
\series bold 
ld_prime['loc1-loc2']['al1-al2'], subPop[sp]['ld_prime']['loc1-loc2']['al1-al2']
\layout Itemize


\family typewriter 
\series bold 
r2['loc1-loc2']['al1-al2'], subPop[sp]['r2']['loc1-loc2']['al1-al2']
\layout Itemize


\family typewriter 
\series bold 
LD[loc1][loc2], subPop[sp]['LD'][loc1][loc2]
\layout Itemize


\family typewriter 
\series bold 
LD_prime[loc1][loc2], subPop[sp]['LD_prime'][loc1][loc2]
\layout Itemize


\family typewriter 
\series bold 
R2[loc1][loc2], subPop[sp]['R2'][loc1][loc2]
\layout Standard

Please note the difference between the datastructure used for 
\family typewriter 
ld
\family default 
 and 
\family typewriter 
LD
\family default 
.
 The names are potentially very confusing but I have no better idea.
 
\end_deeper 
\layout Subsubsection


\begin_inset Formula $F_{st}$
\end_inset 

 
\layout Itemize

parameter:
\family typewriter 
 Fst: Fst = [0,1,2]
\family default 
, calculate 
\begin_inset Formula $F_{st},$
\end_inset 

 
\begin_inset Formula $F_{is}$
\end_inset 

, 
\begin_inset Formula $F_{it}$
\end_inset 

 based on alleles at locu 0, 1, 2 respectively.
 The locus-specific values will be used to calculate 
\family typewriter 
AvgFst 
\family default 
etc.
 Terms and values that match 
\begin_inset LatexCommand \citeauthor{Weir1984}

\end_inset 

.
 
\begin_deeper 
\layout Itemize


\begin_inset Formula $F$
\end_inset 

 (
\begin_inset Formula $F_{IT}$
\end_inset 

): the correlation of genes within individuals (inbreeding)
\layout Itemize


\begin_inset Formula $\theta$
\end_inset 

 (
\begin_inset Formula $F_{ST}$
\end_inset 

): the correlation of genes of difference individuals in the same population
 (will evaluate for each subpopulation and the population as a whole)
\layout Itemize


\begin_inset Formula $f$
\end_inset 

 (
\begin_inset Formula $F_{IS}$
\end_inset 

): the correlation of genes within individuals within populations.
 Populations refers to subpopulations in simuPOP term.
\end_deeper 
\layout Itemize

variables:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
Fst[loc]
\begin_inset LatexCommand \index{stat!Fst}

\end_inset 


\family default 
, 
\family typewriter 
Fis[loc]
\begin_inset LatexCommand \index{stat!Fis}

\end_inset 


\family default 
, 
\family typewriter 
Fit[loc]
\begin_inset LatexCommand \index{stat!Fit}

\end_inset 


\layout Itemize


\family typewriter 
\series bold 
AvgFst, AvgFis, AvgFit
\end_deeper 
\layout Subsubsection

Relatedness 
\layout Standard

The relatedness values between two individuals, or two groups of individuals
 are calculated according to 
\begin_inset LatexCommand \citet{Quller1989}

\end_inset 

 and 
\begin_inset LatexCommand \citet{Lynch1999}

\end_inset 

.
 The first one is referred to as 
\family typewriter 
method=REL_Queller
\family default 
 and the second one is 
\family typewriter 
method=REL_Lynch
\family default 
.
 The paramters are
\layout Itemize


\family typewriter 
relGroups:
\family default 
 can be in the form of either 
\family typewriter 
[[1,2,3],[5,6,7],[8,9]]
\family default 
 or 
\family typewriter 
[2,3,4]
\family default 
.
 The first form specifies groups of individuals, the second form specifies
 subpopulations.
 By default, relatedness between subpopulations are calculated.
\layout Itemize


\family typewriter 
relLoci: 
\family default 
calculate relativeness values based on 
\family typewriter 
relLoci
\family default 
 loci.
 
\layout Itemize


\family typewriter 
relMethod
\family default 
: either 
\family typewriter 
REL_Queller
\family default 
 or 
\family typewriter 
REL_Lynch
\layout Standard

The results are pairwise relatedness values, in the form of a matrix.
 Original group or subpopulations numbers are discarded.
 
\layout Itemize


\family typewriter 
relatedness[grp1][grp2]
\family default 
 is the relatedness value between grp1 and grp2.
 There is no subpop level relatedness values.
\layout Section

Expression and Statements
\layout Subsection

Operator (C++)
\family typewriter 
 output
\begin_inset LatexCommand \index{operator!output}

\end_inset 


\layout Standard

This operator output a simple string.
 For example, 
\layout LyX-Code

output(r'
\backslash 
n', rep=REP_LAST)
\layout Standard

output a newline at the last replicate.
 
\layout Subsection

Operator (Python) 
\family typewriter 
tab
\begin_inset LatexCommand \index{operator!tab}

\end_inset 

 (defined in simuUtli.py)
\layout Standard

Outpur a tab.
 (Wrapper of output operator)
\layout Subsection

Operator (Python) 
\family typewriter 
endl
\begin_inset LatexCommand \index{operator!endl}

\end_inset 

 (defined in simuUtli.py)
\layout Standard

Outpur a new line.
 (Wrapper of output operator)
\layout Subsection

Operator (hybrid) 
\family typewriter 
pyEval
\begin_inset LatexCommand \index{operator!pyEval}

\end_inset 

, 
\family default 
function 
\family typewriter 
PyEval
\begin_inset LatexCommand \index{function!PyEval}

\end_inset 


\layout Standard

We have seen the 
\family typewriter 
expr
\family default 
 and
\family typewriter 
 stmts
\family default 
 parameter of 
\family typewriter 
pyEval
\family default 
.
 These are python expression/statements that will be executed when 
\family typewriter 
pyEval
\family default 
 is applied to a population.
 Statements can also been executed when 
\family typewriter 
pyEval
\family default 
 is created and destroyed.
 The corresponding parameters are 
\family typewriter 
preStmts
\family default 
 and 
\family typewriter 
postStmts
\family default 
.
 For example, operator 
\family typewriter 
varPlotter
\family default 
 uses this feature to initialize R plot and save plot to a file when finished.
\layout Standard


\begin_inset Include \verbatiminput{log/expressionhelp.log}
preview false

\end_inset 


\layout Subsection

Operator (hybrid) 
\family typewriter 
pyExec
\begin_inset LatexCommand \index{operator!pyEval}

\end_inset 


\family default 
, function
\family typewriter 
 PyExec
\begin_inset LatexCommand \index{function!PyExec}

\end_inset 


\layout Standard

This operator takes a list of statements and execute them.
 No value will be returned or outputed.
\layout Subsection

Function (Python) 
\family typewriter 
ListVars (defined in simuUtil.py)
\layout Standard


\family typewriter 
ListVars
\begin_inset LatexCommand \index{function!listVars}

\end_inset 

(variable)
\layout Standard

This function list any variable in an indented text format.
 You can use 
\family typewriter 
listVar(simuVars) 
\family default 
to have a look at all replicates or 
\family typewriter 
listVar(simuVars[0]['subPop'][0]) 
\family default 
to see variables for the first subpoulation in replicate one.
\layout Section

Visualization
\layout Standard

There is no special visualizer (there was indeed a matlabPlotter before
 ver 0.5.9 but I decide to remove it since matlab is not universally available.)
 Since everything is exposed dynamically, all you need to do is plotting
 variables in whatever way you prefer.
 The basic steps are:
\layout Itemize

find an appropriate tool.
 I prefer R/Rpy to any other tools since I am familiar with R.
 You can make your own choice.
\layout Itemize

write a function to plot variable.
 If you would like to plot history of a variable, you can use the 
\family typewriter 
Aggregator 
\family default 
object defined in 
\family typewriter 
simuUtil.py
\family default 
.
 
\layout Itemize

wrap this function as an operator.
\layout Standard


\family typewriter 
simuRPy.py 
\family default 
provides a pure Python operator 
\family typewriter 
varPlotter.
 
\family default 
It is defined in 
\family typewriter 
simuSciPy
\family default 
 and 
\family typewriter 
simuMatPlt.py 
\family default 
as well but they are lack of subplot capacity (so the usages are different)
 due to the limit of SciPy/gplt and MatPlotLib's plotting capacity.
\layout Subsection

Operator (Python) 
\family typewriter 
varPlotter (simuRPy.py)
\layout Standard

The use of 
\family typewriter 
varPlotter 
\family default 
is easy, if you would like to 
\layout Subsubsection

Plotting with history
\layout Itemize

plot a number in the form of a varaible or expression, use
\begin_deeper 
\layout LyX-Code

varPlotter(var='expr')
\end_deeper 
\layout Itemize

plot a vector in the same window and there is only one replicate in the
 simulator, use
\begin_deeper 
\layout LyX-Code

varPlotter(var='expr', varDim=len)
\layout Standard

where 
\family typewriter 
len 
\family default 
is the dimension of your variable or expression.
 Each line in the figure represents the history of an item of the array.
\end_deeper 
\layout Itemize

plot a vector in the same window and there are several replicates, use 
\begin_deeper 
\layout LyX-Code

varPlotter(var='expr', varDim=len, numRep=nr, byRep=1)
\layout Standard

varPlotter will try to use an appropriate layout for your subplots (for
 example, use 3x4 if numRep=10).
 You can also specify paramter 
\family typewriter 
mfrow 
\family default 
to change the layout.
\end_deeper 
\layout Itemize

if you would like to plot each item of your array variable in a subplot,
 use
\begin_deeper 
\layout LyX-Code

varPlotter(var='expr', varDim=len, byVal=1)
\layout Standard

in case of a single replicate or
\layout LyX-Code

varPlotter(var='expr', varDim=len, byVal=1, numRep=nr)
\layout Standard

There will be 
\family typewriter 
numRep 
\family default 
lines in each subplot
\end_deeper 
\layout Subsubsection

Plotting without history
\layout Itemize

use option 
\family typewriter 
history=False.

\family default 
 Parameters
\family typewriter 
 byVal, varDim 
\family default 
etc will be ignored.
 
\layout Standard

Other options are
\layout Enumerate


\family typewriter 
title, xtitle, ytitle:
\family default 
 title of your figure(s).
 title is defauled to your expression, xtitle is defaulted to 
\family typewriter 
generation
\family default 
.
\layout Enumerate


\family typewriter 
win: 
\family default 
window of generations.
 I.e., how many generations to keep in a figure.
 This is useful when you want to keep track of only recent changes.
\layout Enumerate


\family typewriter 
update: 
\family default 
update figure after 
\family typewriter 
update
\family default 
 calls.
 This is used when you do not want to update the figure too often, maybe
 for efficiency purpose.
\layout Enumerate


\family typewriter 
saveAs: 
\family default 
save figures in files 
\family typewriter 
saveAs#gen.eps.
 
\family default 
For example, if 
\family typewriter 
saveAs='demo
\family default 
', you will get files 
\family typewriter 
demo1.eps
\family default 
,
\family typewriter 
 demo2.eps
\family default 
 etc.
\layout Enumerate


\family typewriter 
separate:
\family default 
 plot data lines in separate panel.
 
\layout Enumerate


\family typewriter 
image: 
\family default 
use R image function to plot image, instead of lines.
\layout Enumerate


\family typewriter 
level: 
\family default 
level of image colors.
 default to 20
\layout Enumerate


\family typewriter 
leaveOpen:
\family default 
 whether or not leave the plot open when plotting is done.
 Default to true.
\layout Standard

Here is an example:
\layout LyX-Code


\begin_inset Include \verbatiminput{log/simuPlotter.log}
preview false

\end_inset 


\layout Standard

and one of its output figure:
\layout Standard
\align center 

\begin_inset Graphics
	filename log/simuDemo16
	lyxscale 40
	width 5in
	height 4in
	clip

\end_inset 


\layout Subsection

plot through 
\family typewriter 
python/SciPy/MatPltLib
\layout Standard


\family typewriter 
varPlotter 
\family default 
is also available for SciPy/MatPltLib but there is no subplots (so no byVal
 etc) and the usage is different.
 The
\family typewriter 
 __init__
\family default 
 function of
\family typewriter 
 varPlotter 
\family default 
takes the following parameters:
\layout Itemize


\family typewriter 
win 
\family default 
window size.
 Actually the number of generations to display.
 default to 0 (no limit).
 If this is set to be a positive number, only the last 
\family typewriter 
win 
\family default 
data will be displayed.
\layout Itemize


\family typewriter 
update 
\family default 
generations between successive re-draw of figure.
 We can not use '
\family typewriter 
step
\family default 
' parameter of 
\family typewriter 
pyEval 
\family default 
operator since we need to collect data at each generation.
 
\layout Itemize


\family typewriter 
title, xtitle, ytitle 
\family default 
titles/labels to be displayed
\layout Itemize


\family typewriter 
legend
\family default 
 an array of strings, legend of the lines.
 If ignored, 
\begin_inset Quotes eld
\end_inset 

var0
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

var1
\begin_inset Quotes erd
\end_inset 

 etc will be used.
 If gives only one string (e,g, str), 
\begin_inset Quotes eld
\end_inset 

str
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

str1
\begin_inset Quotes erd
\end_inset 

,...
 etc will be used.
 Otherwise, the length of legend has to be the same as data size.
\layout Standard

The difference between 
\family typewriter 
simuSci.Py 
\family default 
and 
\family typewriter 
simuMatPlt.py
\family default 
 is that they use different plotting engine.
 The following example shows an example:
\layout Standard


\begin_inset Include \verbatiminput{log/scipy.log}
preview false

\end_inset 


\layout Standard

The resulting plot is:
\layout Standard
\align center 

\begin_inset Graphics
	filename subpop
	lyxscale 40
	width 5in
	height 4in
	clip

\end_inset 


\layout Subsection

Object (Python) 
\family typewriter 
freqPlotter (defined in simuRPy.py)
\layout Standard

The plotting function used for Reich's simulation, using R as plotting engine.
 It is put in simuRPy.py mainly for demonstration purposes.
\layout Section

Tagging (used for pedigree tracking) 
\layout Subsection

Operator (C++) 
\family typewriter 
inheritTagger, 
\family default 
duringMating
\layout Standard

This during-mating operator will copy the tag info from his father.
 This can be used to tracking offsprings of an ancester.
 More options may be introduced later.
\layout Subsection

Operator (C++) 
\family typewriter 
parentsTagger
\family default 
, duringMating
\layout Standard

This during-mating operator set
\family typewriter 
 tag()
\family default 
, currently a pair of numbers, of each individual with indices of his/her
 parents in the parent population.
 This info will be used by pedigree-related operators like 
\family typewriter 
affectedSibpairSample 
\family default 
to track pedigree information.
 Since parental population will be discarded or stored after mating, and
 tagging info will be passed with individuals, mating/population change
 etc will not interfere with this simple tagging system.
\layout Section

Data collector
\layout Standard

Sometimes, instead of output data directly, we may want to collect history
 data on some expression.
 Data collector is designed for this purpose.
 
\layout Subsection

operator (Python) 
\family typewriter 
collector
\begin_inset LatexCommand \index{operator!collector}

\end_inset 


\family default 
, in
\family typewriter 
 simuUtil.py
\layout Standard

This operator accepts the following parameters:
\layout Itemize


\family typewriter 
name:
\family default 
 name by which the collected data will be displayed.
 Variable name will be list of stored values.
 (generation is not stored.
 You can always put it in expr though.)
\layout Itemize


\family typewriter 
expr: 
\family default 
an expression that will be evaluated.
 The result will be converted to a list (if needed) and stored in
\family typewriter 
 name[gen]
\family default 
.
\layout Standard

When this operator is called, it will evaluate 
\family typewriter 
expr
\family default 
 and store its result in 
\family typewriter 
name[gen]
\family default 
.
 After evolution, you will get a dictionary of values indexed by generation
 number.
\layout Section

Parameter and user input
\layout Standard

Although simuPOP scripts, simply Python scripts, can be in any valid Python
 style, it is highly recommended that all simuPOP scripts follow the same
 writing style and provide a uniform interface to users.
 From a user's point of view, a simuPOP script 
\family typewriter 
cmd.py 
\family default 
should
\layout Enumerate

Start a Tk/wxPython dialog to accept user input when 
\family typewriter 
--noDialog 
\family default 
is not specified.
\layout Enumerate

List all commandline/config file options through 
\family typewriter 
-h
\family default 
 or 
\family typewriter 
--help 
\family default 
option.
 
\layout Enumerate

Accept 
\family typewriter 
-c 
\family default 
or 
\family typewriter 
--config 
\family default 
parameter to read a configuration file and set parameters.
\layout Enumerate

Be able to use command line arguments to set parameters as well.
\layout Enumerate

Accept 
\family typewriter 
--saveconfig file 
\family default 
to save current configuration (input my commandline argument) into 
\family typewriter 
file
\family default 
.
\layout Enumerate

Be able to make use of optimized libraries through the use of command line
 parameter ( 
\family typewriter 
--optimized
\family default 
), config file entry (
\family typewriter 
optimized=True
\family default 
) or environment variable (
\family typewriter 
SIMUOPTIMIZED
\family default 
).
 
\layout Enumerate

Be able to make use of longallele libraries through the use of command line
 parameter (
\family typewriter 
--longallele
\family default 
), config file entry (
\family typewriter 
longallele=True
\family default 
) or environment variable (
\family typewriter 
SIMULONGALLELE
\family default 
).
 
\layout Standard

To alleviate throuble of doing all these, 
\family typewriter 
simuPOP
\family default 
 has provided a set of functions.
 Here is how parameters should be handled.
 The first step is decribe each parameter in details.
 This includes (not all is necessary) short and long argument name, entry
 on a configuration file, prompt when asking for user input, default value,
 description that will be shown in usage, allowed types of parameter, function
 to validate the input value.
 All these should be put in a list of dictionaries like follows:
\layout LyX-Code

options = [
\layout LyX-Code

  { 'arg':'h', 'longarg':'help', 'default':False,
\layout LyX-Code

    'allowedTypes':[IntType],
\layout LyX-Code

    'description':'print this message'},
\layout LyX-Code

  { 'longarg':'saveconfig=', 'default':'', 'allowedTypes':[StringType],
\layout LyX-Code

    'description':'Save current configuration in a file.'},
\layout LyX-Code

  { 'arg':'m', 'longarg':'mu', 'configName'='mutationRate', 
\layout LyX-Code

    'default':0.005,
\layout LyX-Code

    'prompt':'Please enter mutation rate (default 0.005): ',
\layout LyX-Code

    'validate': simuOpt.valueBetween(0,1),
\layout LyX-Code

    'description':'mutation rate (a number or an array of numbers) at each
 loci'
\layout LyX-Code

  } ]
\layout Standard

The entries:
\layout Itemize


\family typewriter 
arg
\family default 
 and 
\family typewriter 
longarg
\family default 
 are command line argument format.
 For example,
\begin_deeper 
\layout Itemize


\family typewriter 
arg:'h' 
\family default 
checks the presence of argument 
\family typewriter 
-h
\family default 
, return 
\family typewriter 
True
\family default 
 if succeeds
\layout Itemize


\family typewriter 
arg:'f:'
\family default 
 checks the presence of argument pair
\family typewriter 
 -f something
\family default 
, return 
\family typewriter 
something
\family default 
 if succeeds
\layout Itemize


\family typewriter 
longarg:'help' 
\family default 
cheks the prescence of argument 
\family typewriter 
--longarg
\family default 
, return 
\family typewriter 
True 
\family default 
if succeeds
\layout Itemize


\family typewriter 
longarg:'mu=' 
\family default 
checks the presence of argument pair
\family typewriter 
 --mu number
\family default 
, return
\family typewriter 
 number
\family default 
 if succeeds.
\end_deeper 
\layout Itemize


\family typewriter 
configName 
\family default 
is the entry of the parameter in config file.
 This will also be used as the label of input field in a parameter dialog.
 Blanks are allowed.
 Since you will seldom write a config file manually, using a longer name
 will do no harm.
\layout Itemize


\family typewriter 
prompt
\family default 
 is prompted when user input is required.
 This is when
\begin_deeper 
\layout Itemize


\family typewriter 
--noDialog
\family default 
 is used to avoid parameter dialog
\layout Itemize

No command line argument is found, 
\layout Itemize

no config file is specified, 
\layout Itemize


\family typewriter 
prompt
\family default 
 is not empty
\end_deeper 
\layout Itemize


\family typewriter 
default
\family default 
 is used when prompt is empty, or when user press enter directly.
\layout Itemize


\family typewriter 
description 
\family default 
is the description of this parameter, will be put into usage information.
 ( 
\family typewriter 
-h 
\family default 
or help button in parameter dialog).
\layout Itemize


\family typewriter 
allowedTypes
\family default 
 is the accepted types.
 If 
\family typewriter 
allowedTypes 
\family default 
is 
\family typewriter 
types.ListType
\family default 
 or 
\family typewriter 
types.TupleType
\family default 
 and user input is a scalar, the input will be converted to a list automatically.
\layout Itemize


\family typewriter 
validate
\family default 
 is a function to validate the parameter.
 You can define your own functions or use the following from 
\family typewriter 
simuOpt
\begin_deeper 
\layout Itemize


\family typewriter 
valueGT(a), valueLT(a), valueGE(a), valueLE(a)
\family default 
: check greater than, less than, greater equal, less equal to a value 
\family typewriter 
a.
\layout Itemize


\family typewriter 
valueBetween(a,b), valueOneOf(list):
\family default 
 check if the value is between 
\family typewriter 
a 
\family default 
and 
\family typewriter 
b 
\family default 
or is one of 
\family typewriter 
list
\layout Itemize


\family typewriter 
valueValidFile(), valueValidDir():
\family default 
 check if the parameter is a valid file/directory name.
\layout Itemize


\family typewriter 
valueListOf():
\family default 
 check if parameter is a list of given type, in a list of types, or pass
 a validator.
 For example, you can use 
\family typewriter 
valueListOf(types.IntType)
\family default 
, 
\family typewriter 
valueListOf([types.IntType, types.LongType])
\family default 
 or 
\family typewriter 
valueListOf( valueValidFile()).
 
\family default 
As you can see, validators can be nested.
\end_deeper 
\layout Itemize


\family typewriter 
chooseOneOf: 
\family default 
If specified, 
\family typewriter 
simuOpt
\family default 
 will choose one from a list of values using a listbox (tk) or a combo box
 (wxPython) .
\layout Itemize


\family typewriter 
chooseFrom:
\family default 
 If specified, 
\family typewriter 
simuOpt 
\family default 
will choose one or more items from a list of values using a listbox (tk)
 or a combo box (wxPython) .
 
\layout Itemize


\family typewriter 
jump:
\family default 
 jump is used to skip some parameter when doing interative user input.
 For example, 
\family typewriter 
getParam
\family default 
 will skip the rest of the parameters if
\family typewriter 
 -h
\family default 
 is specified since parameter 
\family typewriter 
-h
\family default 
 has item 
\family typewriter 
'jump':-1
\family default 
 which means jump to the end.
 Another use of this value is when you have a hierarchical parameter sets.
 For example, if mutation is on, specify mutation rate, otherwise proceed....
 
\layout Itemize


\family typewriter 
jumpIfFalse: 
\family default 
The same as 
\family typewriter 
jump
\family default 
 but jump if current parameter is false.
\layout Standard

With all these information at hand, the rest is routine.
 You should almost always do something like:
\layout LyX-Code

import simuOpt, os, sys, types
\layout LyX-Code

options = [
\layout LyX-Code

 .....
 the parameter definitions ....
\layout LyX-Code

]
\layout LyX-Code

# get all parameters.
 a dialog may or may not be used depending
\layout LyX-Code

# on --noDialog option.
 
\layout LyX-Code

allParam = simuOpt.getParam(options, __doc__)
\layout LyX-Code

#
\layout LyX-Code

if len(allParam) > 0:  
\layout LyX-Code

  # successfully get the params, unpack the parameters
\layout LyX-Code

  (help, popSize, endGen, recRate, numRep, saveConfig, verbose) = allParam
\layout LyX-Code

else:
\layout LyX-Code

  sys.exit(0)
\layout LyX-Code

# if --saveConfig is used
\layout LyX-Code

if saveConfig != '':
\layout LyX-Code

  simuOpt.saveConfig(options, saveConfig, allParam)
\layout LyX-Code

# if -h or --help is used
\layout LyX-Code

if help:
\layout LyX-Code

  print simuOpt.usage(options, __doc__)
\layout LyX-Code

  sys.exit(1)
\layout LyX-Code

# print out info if in verbose mode
\layout LyX-Code

if verbose:
\layout LyX-Code

  print "Pop size: ", popSize
\layout LyX-Code

  print "End gen: ", endGen
\layout LyX-Code

  print "Recombination rate: ", recRate
\layout LyX-Code

  print "Number of replicates: ", numRep
\layout LyX-Code

#
\layout LyX-Code

# continue the real stuff  
\layout Standard

As you can see, 
\family typewriter 
getParam
\family default 
 does all the work for you.
 All you need to do is writing a correct (and user-friendly) parameter specifica
tion.
\layout LyX-Code

  
\layout LyX-Code

\layout Section

Output 
\layout Subsection

operator (C++)
\family typewriter 
 savePopulation
\begin_inset LatexCommand \index{operator!savePopulation}

\end_inset 


\layout Subsection

function (Python) 
\family typewriter 
SaveFstat
\begin_inset LatexCommand \index{function!SaveFstat}

\end_inset 

 
\family default 
(in 
\family typewriter 
simuUtil.py
\family default 
)
\layout Subsection

operator (Python) 
\family typewriter 
saveFstat
\begin_inset LatexCommand \index{operator!saveFstat}

\end_inset 

 
\family default 
(in 
\family typewriter 
simuUtil.py
\family default 
)
\layout Subsection

function (Python) 
\family typewriter 
loadFstat
\begin_inset LatexCommand \index{function!loadFstat}

\end_inset 

 
\family default 
(in 
\family typewriter 
simuUtil.py
\family default 
)
\layout Section

Terminator
\layout Standard

These operators are used to see if an evolution is running as expected,
 and terminate the evolution if a condition fails.
\layout Subsection

Operator (C++) 
\family typewriter 
terminateIf
\begin_inset LatexCommand \index{operator!terminateIf}

\end_inset 


\layout Standard

This operator terminates the evolution under certain conditions.
 For example,
\layout LyX-Code

terminateIf(condition='alleleFreq[0][1]<0.05', begin=100)
\layout Standard

terminate the evolution if the allele frequency of allele 1 at locus 0 is
 less than 0.05.
 Of course, to make this opertor work, you will need to use an 
\family typewriter 
stat
\family default 
 operator before it so that variable 
\family typewriter 
alleleFreq
\family default 
 exists in the local namespace.
\layout Subsection

Operator (C++) 
\family typewriter 
continueIf
\begin_inset LatexCommand \index{operator!terminateIf}

\end_inset 


\layout Standard

The same as 
\family typewriter 
terminateIf 
\family default 
but continue if the condition if true.
\layout Section

Conditional operator 
\layout Subsection

Operator (C++) 
\family typewriter 
ifElse
\begin_inset LatexCommand \index{operator!ifelse}

\end_inset 


\layout Standard


\family typewriter 
ifElse 
\family default 
is an interesting operator.
 It accepts:
\layout Itemize

an expression that will be evaluated when 
\family typewriter 
ifelse 
\family default 
is called.
\layout Itemize

an operator that will be applied if the expression is true.
 (defult to null)
\layout Itemize

an operator that will be applied if the expression if false.
 (default to null)
\layout Standard

When this operator is applied to a population, it will evaluate the expression
 and depend on its value, apply the supplied operators.
 Note that the 
\family typewriter 
begin, at, step, at 
\family default 
parameters of if/else operators will be ignored.
 For example, you can mimic the 
\family typewriter 
at
\family default 
 parameter of an operator by
\layout LyX-Code

ifElse('rep in [2,5,9]', operator)
\layout Standard

Anyway, the real use of this machanism is minitoring the population statistics
 and act accordingly.
 The following example uses some advanced operators of simuPOP:
\layout Itemize

set affected status using 
\family typewriter 
maPenetrance 
\family default 
as a 
\family typewriter 
DuringMating
\family default 
 operator.
 (penetrance can be used at other stages)
\layout Itemize

count the number of affected individuals.
 Note that this has to be done after the penetrance operator is applied.
 
\layout Itemize

If no one is effected, inject some mutations into the population.
 Note the use of 
\family typewriter 
ifElse 
\family default 
operator.
\layout Itemize

expose individual affectedness to local namespaces.
 Note the use of 
\family typewriter 
exposePop 
\family default 
option.
 With this, you can call any population member function.
\layout Itemize

plot affectedness, use image.
 
\layout Itemize

Use dryrun to exam simulator first.
\layout Standard


\begin_inset Include \verbatiminput{log/ifElse.log}
preview false

\end_inset 


\layout Standard
\align center 

\begin_inset Graphics
	filename ifElse50
	lyxscale 40
	width 5in
	height 4in
	clip

\end_inset 


\layout Section

Miscellaneous
\layout Subsection

Operator: (C++) 
\family typewriter 
noneOp
\begin_inset LatexCommand \index{operator!noneOp}

\end_inset 


\layout Standard

This operator does nothing.
 It is used like follows:
\layout LyX-Code

if savePop :
\layout LyX-Code

  saveOp = savePopulation(output='a.txt')
\layout LyX-Code

else:
\layout LyX-Code

  saveOp = noneOp()
\layout LyX-Code

simu.evolve( [ ...
 saveOp ])
\layout Subsection

Operator: (C++) 
\family typewriter 
pause
\begin_inset LatexCommand \index{operator!pause}

\end_inset 


\layout Standard

This operator will pause the simulation and wait for user response.
 User can use 'q' to stop evolution, 's' to escape to a python shell, or
 any other key to continue.
 Another way to use it is through its 
\family typewriter 
stopOnKeyStroke
\family default 
 parameter.
 If set to true, 
\family typewriter 
pause
\family default 
 will continue until you press any key.
 It is useful for presentation and interative simulation.
 
\layout Standard

When 's' is pressed, this operator expose the current population to the
 main python dictionary as variable 'pop', and enter an interactive python
 session.
 The way current population is exposed can be controled by parameter 
\family typewriter 
exposePop
\family default 
 and 
\family typewriter 
popName
\family default 
.
 This feature is useful when you want to examine the properties of a population
 during evolution.
\layout Subsection

Operator: (C++) 
\family typewriter 
ticToc
\begin_inset LatexCommand \index{operator!ticToc}

\end_inset 


\family default 
, function
\family typewriter 
 TicToc
\begin_inset LatexCommand \index{function!TicToc}

\end_inset 


\layout Standard

This operator, when called, output the difference between current and last
 called clock time.
 This can be used to estimate execution time of each generation.
 Similar information can also be obtained from 
\layout LyX-Code

turnOnDebug(DBG_PROFILE)
\layout Standard

but this operator has the advantage of measuing duration between several
 generations (set 
\family typewriter 
step 
\family default 
parameter.)
\layout Subsection

Operator: (C++) 
\family typewriter 
setAncestralDepth
\family default 
, function 
\family typewriter 
pop.setAncestralDepth
\layout Standard


\family typewriter 
setAncestralDepth 
\family default 
set the number of ancestral generations to keep in a population.
 This is useful when constructing pedigree trees from a population.
 
\layout Section

Random Number Generator
\layout Standard

Random number generator is a tricky business.
 Reliable and fast RNGs are hard to find and everyone seems to trust/distrust
 certain RNGs.
 To avoid such arguments, I have included all RNGs from GSL (
\begin_inset LatexCommand \url[The GNU Scientific Library]{http://sources.redhat.com/gsl/}

\end_inset 

) and you can choose any of the 61 RNGs, if you really know what the differences
 between them.
 (I do not, except that some of them are really bad but fast.) 
\layout Standard


\begin_inset Include \verbatiminput{log/rng.log}
preview false

\end_inset 


\layout Standard

If you need to use a random number generator in your 
\family typewriter 
pyEval 
\family default 
operator, you can either use python random module (
\family typewriter 
import random
\family default 
) or use 
\family typewriter 
rng
\begin_inset LatexCommand \index{function!rng}

\end_inset 

() 
\family default 
function to get the random number generator of simuPOP.
 Note that 
\family typewriter 
rng() 
\family default 
does not have many member functions and it might be tricky to use them correctly.
 (This object is not designed to be used at the Python level.)
\layout Standard


\begin_inset Include \verbatiminput{log/rngrand.log}
preview false

\end_inset 


\layout Section

Debug-related operators/functions
\layout Standard

Standard 
\family typewriter 
simuPOP 
\family default 
library can print out lots of debug information upon request.
 These are mostly for internal debuging use but you can also use them when
 error happens.
 For example, the following code will crash simuPOP:
\layout LyX-Code

>>> population(1).individual(0).arrAllele()
\layout Standard

It is not clear why this simple line will cause us trouble, instead of outputtin
g the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug info:
\layout LyX-Code

>>> TurnOnDebug(DBG_ALL)
\layout LyX-Code

Debug code DBG_ALL is turned on.
 cf.
 listDebugCode(), turnOffDebug() 
\layout LyX-Code

>>> population(1).individual(0).arrAlleles()
\layout LyX-Code

Constructor of Population is called
\layout LyX-Code

Population size 1
\layout LyX-Code

Destructor of Population is called 
\layout LyX-Code

Segmentation fault (core dumped) 
\layout Standard


\family typewriter 
population(1)
\family default 
 creates a temporary object that is destroyed right after the execution
 of the input.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is create a persistent population object: 
\layout LyX-Code

>>> pop = population(1)
\layout LyX-Code

>>> pop.individual(0).arrAllele()
\layout Standard

If the output is overwhelming after you turn on all debug info, you can
 turn on certain part of the info by using the following functions:
\layout Itemize


\family typewriter 
ListDebugCode
\begin_inset LatexCommand \index{listDebugCode}

\end_inset 

()
\family default 
 list all debug code.
\layout Itemize


\family typewriter 
turnOnDebug()
\begin_inset LatexCommand \index{operator!turnOnDebug}

\end_inset 

, TurnOnDebug
\begin_inset LatexCommand \index{Function!TurnOnDebug}

\end_inset 

(code) 
\family default 
turn on a debug code
\layout Itemize


\family typewriter 
turnOffDebug()
\begin_inset LatexCommand \index{operator!turnOffDebug}

\end_inset 

, TurnOffDebug
\begin_inset LatexCommand \index{Function!turnOffDebug}

\end_inset 

(code) 
\family default 
turn off debug code
\layout Standard


\family typewriter 
turnOnDebug()
\family default 
 and 
\family typewriter 
turnOffDebug() 
\family default 
are operators and accept all operator parameters 
\family typewriter 
begin, step
\family default 
 etc.
 Usually, you can 
\family typewriter 
turnOndebug
\family default 
 before simuPOP starts to misbehave to output more info about a potential
 bug.
 
\layout Standard

Another useful debug code is 
\family typewriter 
DBG_PROFILE.
 
\family default 
When turned on, it will display running time of each operator.
 This will give you a good sense of which operator runs slowly (or simply
 the order of operator execution if you are not sure).
 If most of the excution time is spent on a pure-python operator, you may
 want to rewrite it in C++.
 Note that when 
\family typewriter 
DBG_PROFILE
\family default 
 is suitable for measuing individual operator performance.
 If you would like to measure execution time of all operators in several
 generations, 
\family typewriter 
ticToc
\family default 
 operator is better.
  
\layout Chapter

Extending simuPOP
\layout Standard

simuPOP can be extended easily using Python programming language.
 Because almost all data are exposed to the python interface, your ability
 of extending simuPOP is unlimited.
 However, because Python is slower than C++ and the exchange of data between
 internal C++ data structure and python interface may be costly, it is not
 recommended to write frequently used operators in python.
 Appropriate pure python operators are visualizers, statistics calculator,
 file outputers etc.
\layout Standard

To write smuPOP extension, you will have to know more data structure and
 member functions of population.
 Note that for efficiency and implementation reasons, many of the following
 functions do not provide keyword parameters.
\layout Section

Genotypic structure
\layout Standard

The genotypes of an individual are organized as a single array.
 For example, if you have an diploid individual with two chromosomes, having
 2 and 3 loci respectively.
 The genotypes should be in the order of
\layout LyX-Code

0-0-0, 1-0-0, 0-1-0, 1-1-0, 2-1-0,0-0-1, 1-0-1, 0-1-1, 1-1-1,2-1-1
\layout Standard

where X-X-X are locus-chromosome-ploidy indices.
 An important consequence of this arrangement is that 'locus location' +
 'total number of loci' is the location of the locus on the other set of
 chromosomes.
 
\layout Standard

Several functions are provided to retrieve genotypic info:
\layout Itemize


\family typewriter 
ploidy
\begin_inset LatexCommand \index{function!ploidy}

\end_inset 

()
\layout Itemize


\family typewriter 
numChrom
\begin_inset LatexCommand \index{function!numChrom}

\end_inset 

()
\layout Itemize


\family typewriter 
numLoci
\begin_inset LatexCommand \index{function!numLoci}

\end_inset 

(chrom)
\family default 
, number of loci on chromosome chrom
\layout Itemize


\family typewriter 
totNumLoci
\begin_inset LatexCommand \index{function!totNumLoci}

\end_inset 

()
\layout Itemize


\family typewriter 
genoSize
\begin_inset LatexCommand \index{function!genoSize}

\end_inset 

()
\family default 
, size of genotype.
 Equals to
\family typewriter 
 totNumLoci()*ploidy()
\layout Itemize


\family typewriter 
alleleName
\begin_inset LatexCommand \index{function!alleleName}

\end_inset 

()
\family default 
, if not specified by 
\family typewriter 
alleleNames 
\family default 
parameter when creating a population, return allele number
\layout Itemize


\family typewriter 
locusPos
\begin_inset LatexCommand \index{function!locusPos}

\end_inset 

(loc)
\family default 
, locus position on chromosome (Distance to the beginning of chromosome)
\layout Itemize


\family typewriter 
arrlociPos
\begin_inset LatexCommand \index{function!arrLociPos}

\end_inset 

()
\family default 
, return an
\family typewriter 
 carray
\family default 
 of the loci distance.
\layout Standard

The last function is very interesting.
 It actually return the reference of the internal loci distance array.
 If you change the value of the returned array, the internal loci distance
 will be changed! All functions with this property will be named 
\family typewriter 
arrFunc()
\family default 
.
\layout Standard

The following example shows how to change locus distance through this function.
\layout Standard


\begin_inset Include \verbatiminput{log/extgenostru.log}
preview false

\end_inset 


\layout Section

Accessing genotype and other info
\layout Standard

Genotype of an individual can be retrieved through the following functions
\layout Itemize


\family typewriter 
ind.allele
\begin_inset LatexCommand \index{function!allele}

\end_inset 

(index, p=0)
\layout Itemize


\family typewriter 
ind.setAllele
\begin_inset LatexCommand \index{function!setAllele}

\end_inset 

(value, index, p=0)
\layout Itemize


\family typewriter 
ind.arrGenotype
\begin_inset LatexCommand \index{function!arrAlleles}

\end_inset 

(p=0, ch=0)
\layout Standard


\family typewriter 
p 
\family default 
means ploidy.
 I.e., the index of copies of chromosomes.
 
\family typewriter 
ch 
\family default 
means chromosome.
 For example
\layout LyX-Code

pop.individual(1).arrGenotype(1, 2)
\layout Standard

returns an array of alleles on the third chromosome of the second copy of
 chromosomes, of the second individual in the population 
\family typewriter 
pop
\family default 
.
 
\layout Standard


\begin_inset Include \verbatiminput{log/extgenotype.log}
preview false

\end_inset 


\layout Standard

Sex, affected status can be accessed through 
\family typewriter 
sex, setSex, affected, setAffected 
\family default 
functions.
\begin_inset Include \verbatiminput{log/extother.log}
preview false

\end_inset 


\layout Section

Writing Pure Python Operator 
\layout Standard

Now we know how to access information for individuals in a population, but
 how can we use them in reality? Namely, how can you write an pure Python
 operator?
\layout Subsection

Use 
\family typewriter 
pyOperator
\layout Standard

There are two kinds of pure python operators.
 The first one is easy: define a function and wrap it with a pyOperator
 operator.
 This method is highly recommended because of its simplicity.
 Many user scripts will use this kind of pure python operator.
 You can find such examples in scripts directory.
 A good one may be simuCDCV.py where a pure python operator is used to calculate
 and visualize special statistics.
 
\layout Standard

For example, if you would like to record a silly statistics, namely the
 genotype of the 
\begin_inset Formula $m$
\end_inset 

 individual at locu 
\begin_inset Formula $n$
\end_inset 

, you can do:
\layout LyX-Code

def sillyStat(pop, para):
\layout LyX-Code

  # para can be used to pass any number of parameters
\layout LyX-Code

  (filename, m, n) = para # unpack parameter
\layout LyX-Code

  f = open(filename)
\layout LyX-Code

  f.write('%d ' % pop.individual(m).allele(n) )
\layout LyX-Code

  f.close()
\layout LyX-Code

# then in the evole function
\layout LyX-Code

evolve(...
\layout LyX-Code

  ops=[ # other operators
\layout LyX-Code

    pyOperator(func=sillyStat, param=('file.txt', 2, 1) )
\layout LyX-Code

  ]
\layout LyX-Code

)
\layout Standard


\family typewriter 
pyOperator 
\family default 
is by default a post-mating operator, you can redefine its stage by 
\family typewriter 
stage
\family default 
 parameter.
 
\layout Subsection

Use Python eval function
\layout Standard

This kind of pure python operator acts more like an ordinary operator.
 They are usually pyEval or pyExec operators returned by a wrapper function.
 For example, the following function defines a 
\family typewriter 
tab
\family default 
 operator:
\layout Standard


\begin_inset Include \verbatiminput{log/tab.log}
preview false

\end_inset 


\layout Standard

This function actually returns an operator
\layout LyX-Code

output(r"
\backslash 
t", rep=REP_LAST, begin=500)
\layout Standard

This kind of operators have some advantages, namely
\layout Itemize

it acts more like ordinary operator.
 
\layout Itemize

it is more efficient since it is handled (at least the first layer) by a
 C/C++ operator.
\layout Standard

However, because of its complexity, such operators can only be found in
 system libraries.
 You can ignore the rest of this section if 
\family typewriter 
pyOperator
\family default 
 is enough to you.
 
\layout Standard

To define a pure python operator, here is what you will generally do:
\layout Itemize

Write a function that act on a population.
 This function should be able to be called like 
\family typewriter 
func(simu.population(0)) .
 
\layout Itemize

Wrap this function as an operator.
 
\layout Standard

For example, function 
\family typewriter 
saveInFstatFormat(pop, output, outputExpr, dict) 
\family default 
saves a population in FSTAT format.
 Its defnition is (first 15 lines)
\layout Standard


\begin_inset Include \verbatiminput{log/saveInFstatFormat.log}
preview false

\end_inset 


\layout Standard

Note that
\layout Itemize

You can use this function independently like
\layout LyX-Code

saveInFstatFormat(simu.population(1),'a.txt')
\layout Itemize


\family typewriter 
pop.vars() 
\family default 
is used to evaluate 
\family typewriter 
outputExpr
\family default 
 
\layout Standard

Then you can wrap this function by an operator, actually a function that
 returns a 
\family typewriter 
pyEval 
\family default 
operator:
\layout Standard


\begin_inset Include \verbatiminput{log/saveFstat.log}
preview false

\end_inset 


\layout Standard

This function takes all parameters of an ordinary operator:
\layout LyX-Code

saveFstat(at=[-1], outputExpr=r
\begin_inset Quotes erd
\end_inset 

'a'+str(rep)+'.txt'
\begin_inset Quotes erd
\end_inset 

)
\layout Standard

and generate a 
\family typewriter 
pyEval 
\family default 
operator (use above example)
\layout LyX-Code

pyEval(exposePop=1, at=[-1], 
\layout LyX-Code

  stmts=r"""saveInFSTATFormat(pop,
\layout LyX-Code

    output='''''', outputExpr=r''' 'a'+str(rep)+'.txt' """ 
\layout LyX-Code

  )
\layout Standard

In this example,
\layout Itemize


\family typewriter 
pyEval
\family default 
 works in the local namespace of each replicate.
 To access that replicate of population, you should use the magic paramter
 
\family typewriter 
exposePop 
\family default 
of 
\family typewriter 
pyEval
\family default 
.
 When set true, 
\family typewriter 
pyEval 
\family default 
will automatically set a variable 
\family typewriter 
pop 
\family default 
in the current local namespace before any statement is executed.
 This is why we can call 
\family typewriter 
saveInFSTATFormat(
\series bold 
pop
\series default 
...)
\layout Itemize


\family typewriter 
'''a'''
\family default 
 quotes are used to avoid conflict with quotes in 
\family typewriter 
outputExpr
\family default 
 etc.
 
\layout Standard

.
 
\layout Section

Ultimate extension: working in C++
\layout Standard

It is sometimes desired to write simuPOP extension in C++.
 For example,
\layout Itemize

when a pure Python operator is too slow.
\layout Itemize

when you would like to change individual structure
\layout Itemize

If some aspect of simuPOP is too limited (like the number of maximum alleles)
\layout Standard

It is not difficult to write simuPOP extension in C++, once you know how
 simuPOP is organized.
 The general procedure is
\layout Itemize

install the latest version of SWIG (>1,3,24), download simuPOP source 
\layout Itemize

build from source and see if your programming environment works well
\layout Itemize

to add an operator, make changes in appropriate 
\family typewriter 
.h 
\family default 
file and add an entry in 
\family typewriter 
simuPOP.i (simuPOP_common.i)
\layout Itemize

to change individual, create or derive an individual type and instantiate
 templates in 
\family typewriter 
simuPOP.i 
\family default 
using your own individual type.
 
\layout Standard

The source code is reasonably well commented with full doxygen based documentati
on.
 Please post to the simuPOP forum if you encounter any problem while writing
 operators in C++.
\layout Chapter

Some Real Examples
\layout Section

Decay of Linkage Disequilibrium
\layout Standard


\begin_inset Include \verbatiminput{log/expLD.log}
preview false

\end_inset 


\layout Standard

Hopefully, the program is not too difficult to understand.
 
\layout Section

Recombinator, Mutator, Migrator ...
\layout Standard

Here is an example when all genetic forces are in effect:
\layout Standard


\begin_inset Include \verbatiminput{log/expcomplex.log}
preview false

\end_inset 


\layout Section

Complex Migration Scheme
\layout Standard

The following is a demonstration of dynamic population number/size change.
 Based on the same idea, we can simulate very complicated models like the
 'out of africa' model.
 Here is what this model does:
\layout Itemize

There are 6 cities along a line.
\layout Itemize

Migration happens only between adjacent cities at a rate of 0.1 (0.05 each
 if there are two adjacent cities).
\layout Itemize

Population size at each city will grow by a factor of 1.2 each time.
 But when the subpopulation size exceeds 1000, starvation :-) will cut the
 subpop size by half.
\layout Itemize

Initially, everyone is in the 3th city.
\layout Standard

The following script describe the rules almost literally:
\layout Standard


\begin_inset Include \verbatiminput{log/expmigration.log}
preview false

\end_inset 

and you can see the change of population number/sizes clearly.
\layout Standard

It should not be difficult to add recombinator, selectors to this model.
 Tracing the spreading of genetic diseases should also be possible, but
 this is out of the scope of this user's guide.
\layout Section

Association Mapping with Genomic Control
\layout Standard

This example demonstrates how to generate SNP datasets and analyze them
 using genomic control method.
 
\begin_inset LatexCommand \citep{Devlin1999,Devlin2001}

\end_inset 


\layout Standard

There are several other applications that can generate SNP datasets (e.g.
 SNPsim 
\begin_inset LatexCommand \citet{Posada2003}

\end_inset 

).
 These methods are coalescent based and can simulate datasets under certain
 mutation and recombination models.
 It would be easy to generate datasets using these applications but simuPOP
 has the following advantages:
\layout Itemize

simuPOP can keep track of details of ancestral generations so it is possible
 to perform various analysis multiple times.
 For example, you can trace the formation of haplotype blocks or test the
 power of association method as a function of generation.
\layout Itemize

simuPOP can simulate selection and many other complicated scenarios.
 It is easy to add more genetic forces and observe their impact on your
 study.
\layout Subsection

Genotypic structure and Initial Population (incomplete)
\layout Standard

For SNP datasets, we can simulate loci with two (1/2) or four (A/C/T/G)
 allelic states.
 Since we will have at most 2 alleleic states at each locus and it does
 not matter exactly what two states a lcous has, the first one makes more
 sense.
 If you would like to simulate four allelic states, you will have to use
 the 
\family typewriter 
states 
\family default 
option of mutators so that alleles will mutate back and force in these states.
 
\layout Standard

This example will initialize the population with genotype of a single individual.
 Linkage disequlibrium is at its highest at first and will break down with
 time.
 Note that we need to make sure initial individuals are heterozygous at
 disease susceptibility locus so LD will exist between this locus and others.
\layout Subsection

Mutation model
\layout Standard

Coalescent based applications usually use 'infiite-site model
\begin_inset LatexCommand \index{mutation!infinite site model'}

\end_inset 

' to perform mutation.
 In such simulations, once a mutation happens on the coalescent tree, it
 will definitely be passed to the final generation.
 This makes infinite-site model very appealing both in theory and in practics.
 However, in a forward-based simulation, a mutation may get lost very quickly
 so what is 'infinite-site' becomes unclear.
 There is also no sensible choice how to implement this model: 'mutation
 will not happen at a site that has been mutated before' does not make sense
 in biolody!
\layout Standard

To avoid these troubles, I choose a Juke-Cantor model 
\begin_inset LatexCommand \citet{Jukes1969}

\end_inset 

 (essentially a K-allele model) with two allelic states.
 I.e., allele 1 and 2 will mutate to each other with equal probability.
 
\layout Subsection

Recombination
\layout Standard

Uniform recombination with rate 0.0001 will be used.
 Although non-uniform recombination can be applied easily.
 (Use the array form of parameter 
\family typewriter 
rate
\family default 
.)
\layout Section

Does rapid population growth lead to common disease/common variant in human
 population?
\layout Standard

Reich and Lander's 2001 paper ``On the allelic spectrum of human disease''
 ( Trends in Genetics, 17(0):502-510) proposed a population genetics framework
 to model the evolution of allelic spectra.
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\layout Standard

I will use simuPOP to simulate this evolution process and observe the allelic
 spectra of both diseases.
\layout Subsection

Population expansion
\layout Standard

The initial population size is set to 10,000, as suggested in the paper.
 The simulation will evolve 500 generations with constant population size
 to reach mutation-selection equilibrium.
 Then, the population size will increase by around 20,000 every 10 generations
 and reach 1,000,000 at generation 1000.
 The population growth takes around 12,500 years if we assume 25 years per
 generation.
 Other growth patterns are also simulated.
\layout Standard

Actually human population took 720 ~ 6000 generations to reach a population
 of size 6 billion.
 There is no way to simulate such a huge population -- the biggest population
 my workstation (equipped with 2G RAM) can handle is around 50 million.
 However, mating of really human population is far from random which implies
 a much smaller effected population size.
 As it turns out, a final population size of 1 million is enough to demonstrate
 the model.
\layout Subsection

Mutation model
\layout Standard

The maximum number of alleles at each locus is set to be 255, a number that
 is hopefully big enough to mimic the infinite allele model.
 Allele 1 is the wild type (
\begin_inset Formula $A$
\end_inset 

) and all others are disease alleles (
\begin_inset Formula $a$
\end_inset 

).
 The 
\begin_inset Formula $k-$
\end_inset 

allele mutation model is used.
 That is to say, an allele can mutate to any other allele with equal probability.
 An immediate implication of this model is that 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset 

 since there are many more 
\begin_inset Formula $a$
\end_inset 

 than 
\begin_inset Formula $A$
\end_inset 

.
 
\layout Standard

The mutation rate is set to 
\begin_inset Formula $\mu=3.2\times10^{-5}$
\end_inset 

 per locus per generation, the same for common and complex disease, and
 regardless of current allelic state.
 This rate is not 
\begin_inset Formula $P\left(A\rightarrow a\right)$
\end_inset 

.
 Instead, it is `probability to mutate' regardless of current allelic state.
 Consequently, 
\begin_inset Formula \[
P\left(A\rightarrow a\right)=P\left(A\rightarrow a\mid A\right)P\left(A\right)P\left(\textrm{mutate}\right)=\mu p\]

\end_inset 

since 
\begin_inset Formula $P\left(A\rightarrow a\right)=1$
\end_inset 

 and 
\begin_inset Formula $P\left(A\right)$
\end_inset 

 is the allele frequency of allele 
\begin_inset Formula $A$
\end_inset 

.
 For rare disease, 
\begin_inset Formula $p\sim1$
\end_inset 

 so 
\begin_inset Formula $\mu\sim P\left(A\rightarrow a\right)$
\end_inset 

.
 
\layout Standard

Note that I can also use 
\begin_inset Formula $\mu=3.2\times10^{-6}$
\end_inset 

 as suggested in the paper, at a cost of longer simulation time.
\layout Subsection

Selection on a common and a rare disease 
\layout Standard

Two diseases are simulated: a common disease with initial allele frequency
 of 
\begin_inset Formula $f_{0}=0.2$
\end_inset 

; and a rare disease with initial allele frequency of 
\begin_inset Formula $f_{0}=0.001$
\end_inset 

.
 The diseases are unlinked in the sense that their corresponding loci reside
 on separated chromosomes.
 The allelic spectra of both diseases are set to be 
\begin_inset Formula $\left[.9,.02,.02,.02,.02,.02\right]$
\end_inset 

.
 I.e., one allele accounts for 90% of the disease cases.
 
\layout Standard

Both diseases are recessive in that their fitness values are 
\begin_inset Formula $\left[1,1,1-s\right]$
\end_inset 

 for genotype 
\begin_inset Formula $AA$
\end_inset 

, 
\begin_inset Formula $Aa$
\end_inset 

 and 
\begin_inset Formula $aa$
\end_inset 

 respectively.
 
\begin_inset Formula $s_{c}=0.1$
\end_inset 

 , 
\begin_inset Formula $s_{r}=0.9$
\end_inset 

 are used in the simulation which imply weak selection on the common disease
 and strong selection on the rare disease.
 If an individual has both diseases, his fitness value follows a multiplicative
 model, i.e., 
\begin_inset Formula $\left(1-s_{c}\right)\times\left(1-s_{r}\right)=0.09$
\end_inset 

.
 
\layout Standard

The choice of 
\begin_inset Formula $s_{c}$
\end_inset 

 and 
\begin_inset Formula $s_{r}$
\end_inset 

 seems to be appropriate because allele frequencies of disease alleles for
 both diseases remain largely unchanged during the first 500 generations.
 This suggests that both diseases are in mutation-selection equilibrium.
\layout Subsection

Implementation
\layout Standard

The python script is short and well commented.
 It translates the above specifications word by word into Python/simuPOP.
 The plots are drawn by R.
 All I did was assign variables to R workspace by 
\family typewriter 
r.assign
\family default 
 function and execute a big trunk of 
\family typewriter 
R 
\family default 
code through 
\family typewriter 
r(`')
\family default 
 function.
 This part of source code is omited since it is irrelevant to simuPOP.
 
\layout Standard


\begin_inset Include \verbatiminput{log/reich.py}
preview false

\end_inset 


\layout Subsection

Results
\layout Standard

The simulation results match Reich's paper well.
 The allelic spectra of common disease remain largely unchanged during simulatio
n while rare disease spectra become complex over time.
 
\layout Chapter

Quick How-to References
\layout Standard


\begin_inset LatexCommand \label{cha:howto}

\end_inset 

Here is a quick how-to like references of how to do certain things.
 This is useful when you have some simulations in mind but no sure if simuPOP
 can handle it.
 (
\family typewriter 
class::function
\family default 
 means member function of object of class type.)
\newline 

\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="96" columns="2">
<features islongtable="true">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

How to ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Solution
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

general
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

help on a class
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
help(classname)
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

help on a member function
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
help(classname.function)
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

I get core dump...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

please report the bug to simuPOP forum
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

something smells wrong...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

post to simuPOP forum
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

can I help (writing code, donate money)?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Sure!!!
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

Can I include my extension to ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Most likely yes.
\end_inset 
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

help!
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

write to me or post to simuPOP forum (no need to register)
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

population
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

create population 
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
population
\series bold 
 
\family default 
\series default 
function
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

have a look at the population
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
dumper().apply(your_population)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

set subpopulations
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

create populations with 
\family typewriter 
subPop
\family default 
 parameter
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

sub-subpopulations, like families
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

not available 
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

display ACTG instead of 1,2,3,4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
alleleNames
\family default 
 parameter of 
\family typewriter 
population()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

save population to a file and load it later
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
population::savePopulation(), loadPopulation()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

save to other formats
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

convert from xml format, write a python function or write an operator
\end_inset 
</cell>
</row>
<row topline="true">
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

simulator
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

run several replicates at the same time
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
rep
\family default 
 parameter of 
\family typewriter 
simulator
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

evolve step by step
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
simulator::step()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

apply operators without evolution
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
simulator::apply()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

reset generation count
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
simulator::setGen(0)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

terminate the simulation when ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use a terminator like 
\family typewriter 
terminateIf(
\begin_inset Quotes eld
\end_inset 

min(alleleNum)==0
\begin_inset Quotes erd
\end_inset 

)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

know when a replicate stops
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

turn on output of a terminator using 
\family typewriter 
output=
\begin_inset Quotes erd
\end_inset 

>
\begin_inset Quotes erd
\end_inset 

 
\family default 
or to a file
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

change mating scheme ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

really need it?? 
\family typewriter 
simulator::setMatingScheme()
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Operator - General 
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

act on populations every 5 generations
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
step=5 
\family default 
parameter of any operator
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

last five generations?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
begin=-5, end=-1 
\family default 
or 
\family typewriter 
at=[-5,-4,-3,-2,-1]
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

turn off output
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
output=''
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

output to screen
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
output='>'
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

output to a file 
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
output='file'
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

several opertors output to the same file
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
output='>>file'
\family default 
 for all of them
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

act only on replicate 3 (the last replicate)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
rep=3 
\family default 
or better
\family typewriter 
 rep=REP_LAST
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

act on a group of replicates
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
simulator::setGroup() 
\family default 
and 
\family typewriter 
grp
\family default 
 parameter of any operator
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row bottomline="true">
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Mating
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

no mating?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use mating scheme 
\family typewriter 
noMating()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

binomial selection, no sex involved
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
binomialSelection()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

random mating
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
randomMating()
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

change to a new (sub)population size
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
newSubPopSize=[] 
\family default 
parameter
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

new pop size at every generation?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use an expression in 
\family typewriter 
newSubPopSizeExpr='' 
\family default 
parameter
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

change to random (sub)population sizes?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use a random number generator in your expression
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

create new subpopulation!
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

only migrators can do that
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Migration
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

migrate in a probabilistic way
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

You mean 
\family typewriter 
mode=MigrByProbability
\family default 
 for a migrator?
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

migrate proportion of individuals
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
mode=MigrByProportion
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

migrate a fixed numbers of individuals
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
mode=MigrByCounts
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

migrate from a subpop to another
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
from=[f], to=[t], rate=[[r]]
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

migrate from one group to another
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
from=[f1,f2], to=[t1,t2,t3]
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

..
 then the rate matrix is not square?!
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

element 
\family typewriter 
(i,j) 
\family default 
means means from
\family typewriter 
 i
\family default 
 to
\family typewriter 
 j
\family default 
.
 That is all.
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

create new subpopulations
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

columns of 
\family typewriter 
rate
\family default 
 > subpop number or through 
\family typewriter 
to=[new]
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I want more flexibility
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

see example of 
\family typewriter 
pyMigrator
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Mutation
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

mutate regardless of current allele
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

that is 
\family typewriter 
kamMutator
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

what about that add one something?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

You mean
\family typewriter 
 smmMutator
\family default 
?
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

the generalized one?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
gsmMutator
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

the geometric gsm model?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

use 
\family typewriter 
p=
\family default 
 parameter of a 
\family typewriter 
gsmMutator
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I need another mutator!
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

have tried 
\family typewriter 
pyMutator
\family default 
? 
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

...
 but I do not know C++
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

write in Python, not C++
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

...
 that is too advanced
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

not at all, and there are examples! 
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Recombination
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

how can I specify recombination hotspots?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

just specify different recombination rates at differnt loci
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

recombination rate prop.
 to loci distance?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

If you give rate, that is what will happen.
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Selection
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

relative fitness or absolute fitness?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

my method is close to relative fitness.
 read the manual
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

selection at a locus
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
simpleSelector
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I need a more complex selection scheme
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

try 
\family typewriter 
pySelector
\family default 
 first
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
pySelector 
\family default 
is slow
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

write to me or learn to use python extension in C++
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Visualization
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

What can visualizer plot?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

any variables under
\family typewriter 
 simuVars
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Can I plot in ???
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

As long as you can find Python extension for it.
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row bottomline="true">
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Statistics Calculator
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I want to calculate ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

check the manual
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

...
 no, you do not have it
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

write an expression to evaluate it
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Where does the results go?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
listVar(simuVars)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Can I output the statistics?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

turn on 
\family typewriter 
output='' 
\family default 
option
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

terminate simulation when my statistics ...
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
terminateIf(
\begin_inset Quotes eld
\end_inset 

youStatistics>3.5
\begin_inset Quotes erd
\end_inset 

)
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Save/load
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

save to linkage/XXX format?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

write a function or an operator (read
\family typewriter 
 simuUtil.py 
\family default 
first)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

...
 I like XML format
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

simuPOP can export to XML format.
\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\layout Standard

Misc
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I do not trust your RNG.
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Will you trust one of the 61 kinds from GSL?
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

What is GSL?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

GNU Scientific Library.
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

How to switch RNG?
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
listRNGs(), setRNG()
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard


\begin_inset LatexCommand \BibTeX[bibtotoc,plainnat]{all}

\end_inset 


\layout Standard


\begin_inset LatexCommand \printindex{}

\end_inset 


\the_end
