#LyX 1.5.0rc2 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.8.0 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. MD Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand\lstlistlistingname{List of Examples}
\renewcommand\lstlistingname{Example}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement h
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},language=Python,showspaces=false,showtabs=false,xleftmargin=15pt"
\tracking_changes false
\output_changes false
\author "Anonymous" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP Reference Manual
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
hspace{1cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{5in}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

{
\backslash
large
\backslash
textsf Acknowledgements: }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{.2cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Marek Kimmel
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Fran
\backslash
c cois Balloux
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 William Amos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} SWIG user community
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Python user community 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Keck Center for Computational and Structural Biology
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} UT M.D.
 Anderson Cancer Center
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
vspace{.7in} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2007 Bo Peng 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
The core of simuPOP is a scripting language (Python) that provides a large
 number of building blocks (populations, mating schemes, various genetic
 forces in the form of operators, simulators and gene mapping methods) to
 construct a simulation.
 This provides a R/Splus or Matlab-like environment where users can interactivel
y create, manipulate and evolve populations, monitor and visualize population
 statistics and apply gene mapping methods.
 The full power of simuPOP and Python (even R) can be utilized to simulate
 arbitrarily complex evolutionary scenarios.
\end_layout

\begin_layout Abstract
simuPOP is written in C++ and is provided as Python modules.
 Besides a front-end providing an interactive shell and a scripting language,
 Python is used extensively to pass dynamic parameters, calculate complex
 statistics and write operators.
 Because of the openness of simuPOP and Python, users can make use of external
 programs, such as R, to perform statistical analysis, gene mapping and
 visualization.
 Depending on machine configuration, simuPOP can simulate large (think of
 millions) populations at reasonable speed.
\end_layout

\begin_layout Abstract
This is a reference manual to all variables, functions, and objects of simuPOP.
 To learn different components of simuPOP and how to write simuPOP scripts,
 please refer to the 
\emph on
simuPOP user's guide.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP: 
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmel (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
(18): 3686-3687
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 and simuPOP_ref.tex generated by 'doxygen; cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \include{simuPOP_ref.tex}
preview false

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Itemize
How to access the main page (an example) from the command line? help( _,
 _ )
\end_layout

\begin_layout Itemize
Online reference (URL).
\end_layout

\begin_layout Itemize
Concept of base classes and how to refer to base classes for parameters.
\end_layout

\begin_layout Itemize
What is the function form, global functions, and member functions?
\end_layout

\begin_layout Itemize
arr_function and carray type
\end_layout

\begin_layout Itemize
Library-dependent functions/constants
\end_layout

\begin_layout Chapter
Genotypic structure 
\begin_inset LatexCommand index
name "genotypic structure"

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Genotypic structure refers to 
\end_layout

\begin_layout Itemize
ploidy, the number of copies of basic number of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset LatexCommand index
name "GenoStruTrait!ploidy"

\end_inset

(), ploidyName
\begin_inset LatexCommand index
name "GenoStruTrait!ploidyName"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
the number of chromosomes (c.f.
 
\family typewriter
numChrom
\begin_inset LatexCommand index
name "GenoStruTrait!numChrom"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
the existence of sex chromosome (c.f.
 
\family typewriter
sexChrom
\begin_inset LatexCommand index
name "GenoStruTrait!sexChrom"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
the number of loci on each chromosome (c.f.
 
\family typewriter
numLoci
\begin_inset LatexCommand index
name "GenoStruTrait!numLoci"

\end_inset

(ch), totNumLoci
\begin_inset LatexCommand index
name "GenoStruTrait!totNumLoci"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
the locus position on its chromosome (c.f.
 
\family typewriter
locusPos
\begin_inset LatexCommand index
name "GenoStruTrait!locusPos"

\end_inset

(loc), arrLociPos
\begin_inset LatexCommand index
name "GenoStruTrait!arrLociPos"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
allele name(s), default to allele number (c.f.
 
\family typewriter
alleleName
\begin_inset LatexCommand index
name "GenoStruTrait!alleleName"

\end_inset

(allele)
\family default
 , 
\family typewriter
alleleNames()
\family default
)
\end_layout

\begin_layout Itemize
the maximum allele state (c.f.
 
\family typewriter
maxAllele
\begin_inset LatexCommand index
name "GenoStruTrait!maxAllele"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Itemize
the names of the information fields (c.f.
 
\family typewriter
infoField
\begin_inset LatexCommand index
name "GenoStruTrait!infoField"

\end_inset

(idx), infoFields
\begin_inset LatexCommand index
name "GenoStruTrait!infoFields"

\end_inset

()
\family default
 )
\end_layout

\begin_layout Standard

\emph on
Information fields
\emph default
 refer to the numbers attached to each individual, such as fitness value,
 parent index, age.
 They are used to store auxiliary information of individuals, and are essential
 to the operations of some simuPOP components.
 For example, 
\family typewriter
'fitness'
\family default
 field is required by all selectors.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:Genotype-structure-functions"

\end_inset

 creates a population and displays some of its genotypic information.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/genoStru.log}[caption={Genotype structure functions},label={alg:Genotype-structure-functions}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Individuals in the same population share the same genotypic structure.
 Consequently, 
\emph on
the genotypic information can be accessed from individual, population and
 simulator
\emph default
 (consists of populations with the same genotypic structure) 
\emph on
levels
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/indGenoStru.log}[caption={Calling genotype structure functions from individual or simulator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
You may have noticed that locus indexes start from 0.
 As a matter of fact,
\series bold
 all arrays in simuPOP start at index 0
\series default
.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the
\emph on
 absolute index
\begin_inset LatexCommand index
name "index!absolute"

\end_inset


\emph default
 and
\emph on
 
\emph default
the
\emph on
 relative index
\begin_inset LatexCommand index
name "index!relative"

\end_inset

 
\emph default
of a locus.
 The former index ignores chromosome structure.

\emph on
 
\emph default
For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two loci are (0, 1, 2, 3, 4), (5, 6, 7, 8, 9, 10,
 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3, 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(absIndex)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/absIndex.log}[caption={Conversion between absolute and relative indices},label={absIndex}]
preview false

\end_inset


\end_layout

\begin_layout Section
Sex chromosome
\end_layout

\begin_layout Standard
If 
\family typewriter
sexChrom()
\family default
 is false, all chromosomes are assumed to be autosomes.
 You can also create populations with a sex chromosome.
 Currently, simuPOP only models the XY chromosomes in diploid population.
 This is to say,
\end_layout

\begin_layout Itemize
sex chromosome is always the last chromosome.
 
\end_layout

\begin_layout Itemize
sex chromosome can only be specified for diploid population (
\family typewriter
ploidy()=2
\family default
).
\end_layout

\begin_layout Itemize
sex chromosomes (XY) may differ in length.
 You should specify the length of the longer one as the chromosome length.
 If there are more loci on X than Y, the rest of the Y chromosome is unused.
 Mutation may still occur at this unused part of chromosome to simplify
 implementation and usage.
 
\end_layout

\begin_layout Itemize
it is assumed that males have XY and females have XX chromosomes.
 The sex chromosomes of male individuals are in the order of XY.
 
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
An individual will by default have genotype, sex and affection status informatio
n, but other information is needed for some operations.
 For example, the fitness value of an individual is needed for selection,
 one or more trait values may be needed to calculate quantitative traits,
 and age may be needed if age-dependent mating schemes are used.
 Because the need for information fields varies from simulation to simulation,
 simuPOP does not fix the amount of information fields, and allow users
 to specify these fields during the construction of populations.
\end_layout

\begin_layout Standard
Operators may require certain information fields to work properly.
 For example, all selectors require field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 
\family typewriter
parentTagger
\family default
 needs 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 to store indices of the parents of each individual in the parental generation.
 These information fields can be added by the 
\family typewriter
infoFields
\family default
 parameter of the population constructor or be added later using relevant
 function.
 If a required information field is unavailable, an error message will appear
 and tell you which fields are needed.
\end_layout

\begin_layout Standard
The information fields can be accessed from each individual (c.f.
 
\family typewriter
info(idx), info(name), setInfo(value, idx), setInfo(value, name), arrInfo()
\family default
 of the individual), or from the population level (c.f.
 
\family typewriter
setIndInfo(value), arrIndInfo(subPop)
\family default
).
 Some operators allow you to specify which information field(s) to use.
 For example, quantitative trait operator can work on specified fields so
 an individual can have several quantitative traits.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
GenoStruTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Population
\end_layout

\begin_layout Standard

\family typewriter
population
\begin_inset LatexCommand index
name "population"

\end_inset


\family default
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals,
 all have the same genotypic structure.
 A population can store arbitrary number of ancestral populations to facilitate
 pedigree analysis.
\end_layout

\begin_layout Section
Population overview
\end_layout

\begin_layout Standard
simuPOP uses one-level population structure.
 That is to say, there is no sub-subpopulation or family in subpopulations.
 Mating is within subpopulations only.
 Exchanges of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
 More specifically,
\end_layout

\begin_layout Itemize
migration can change subpopulation size; create or remove subpopulations.
 Since migration can not generate new individuals, the total population
 size will not be changed.
\end_layout

\begin_layout Itemize
mating can fill any population/subpopulation structure with offspring.
 Both population and subpopulation sizes can be changed.
 Since mating is within subpopulations, you can not create a new subpopulation
 through mating.
\end_layout

\begin_layout Itemize
a special operator 
\family typewriter
pySubset
\family default
 can shrink the population size.
 It removes individuals according to their 
\family typewriter
subPopID()
\family default
 status.
 (Will explain later.) This can be used to model a sudden population decrease
 due to some natural disaster.
 
\end_layout

\begin_layout Itemize
subpopulations can be split or merged.
\end_layout

\begin_layout Standard
Note that migration will most likely change the subpopulation sizes.
 To keep the subpopulation sizes constant, you can set the subpopulation
 sizes during mating so that the next generation will have desired subpopulation
 sizes.
\end_layout

\begin_layout Standard

\family typewriter
population
\family default
 has a large number of member functions, ranging from reviewing simple propertie
s to generating a new population from the current one.
 However, you do not have to know all the member functions to use a population.
 As a matter of fact, you will only use a small portion of these functions
 unless you need to write pure Python functions/operators that involves
 complicated manipulation of populations.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Creating-a-population"

\end_inset

Creating a population
\end_layout

\begin_layout Standard
A population can be created by the following methods:
\end_layout

\begin_layout Itemize
call 
\family typewriter
population
\family default
 function to create an instance of population from 
\family typewriter
population
\family default
 class.
\end_layout

\begin_layout Itemize
call 
\family typewriter
LoadPopulation
\family default
, 
\family typewriter
LoadFstat
\family default
 etc.
 to load a population from a saved file.
 
\end_layout

\begin_layout Itemize
be generated as a subset of an existing population by operators such as
 
\family typewriter
randomSample, caseControlSample
\family default
 or equivalent functions 
\family typewriter
RandomSample, CaseControlSample
\family default
.
 
\end_layout

\begin_layout Itemize
be obtained from an existing simulator through 
\family typewriter
simulator::getPopulation()
\family default
.
\end_layout

\begin_layout Standard
Help contents of all functions of 
\family typewriter
population
\family default
 class can be displayed by 
\family typewriter
help
\begin_inset LatexCommand index
name "help"

\end_inset

(population)
\family default
.
 Help on a member function can be viewed by 
\family typewriter
help(population.func)
\family default
.
 In Python, constructors are named 
\family typewriter
__init__
\family default
 and you can use the class name to create an instance of this class.
 Therefore, to display parameters of 
\family typewriter
population
\begin_inset LatexCommand index
name "population"

\end_inset


\family default
 function, you need to run 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

help(population.__init__)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to 
\family typewriter
population
\family default
 class reference for detailed information of parameters.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "popInit"

\end_inset

 shows a few examples of using the population function to create populations.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popInit.log}[caption={Use of population function},label={popInit}]
preview false

\end_inset


\end_layout

\begin_layout Section
Copying a population
\end_layout

\begin_layout Standard
Like many other Python operations,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = population(...)
\end_layout

\begin_layout Standard

pop1 = pop
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well.
 If you would like to have an independent copy, use
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop1 = pop.clone()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This scenario also applies to simulator (see later sections).
 If 
\family typewriter
simu
\family default
 is a simulator with several replicates
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = simu.population(idx)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will get a reference to one of the replicates.
 You can, although not recommended, modify simulator through this 
\family typewriter
pop
\family default
 reference.
 Note that this pop reference will become invalid when the simulator is
 destroyed so the following calling sequence will crash Python:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = simu.population(idx)
\end_layout

\begin_layout Standard

simu = simulator(....)
\end_layout

\begin_layout Standard

pop.savePopulation(....)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to get a real copy, use
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = simu.getPopulation(idx)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Interaction with operators and functions
\end_layout

\begin_layout Standard
Operators are objects that can be applied to populations.
 They have special attributes like at which generations to be active, at
 what stage of a evolutionary life cycle to be applied.
 Usually, an operator is created and passed as a parameter to a simulator.
 When 
\family typewriter
simulator::evolve
\family default
 (or 
\family typewriter
step, apply
\family default
) is called, the simulator will call the 
\family typewriter
apply()
\family default
 function of these operators at appropriate times.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popAndOperator.log}[caption={Population and operators},label={popAndOperator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
For example, operators 
\family typewriter
initByFreq, stat
\family default
 and two copies of 
\family typewriter
kamMutator
\family default
 are created in example 
\begin_inset LatexCommand ref
reference "popAndOperator"

\end_inset

.
 During evolution, 
\family typewriter
simu
\family default
 will apply 
\family typewriter
initByFreq
\family default
 once to each replicate of the simulator; apply the first 
\family typewriter
kamMutator
\family default
 to the first replicate and the second 
\family typewriter
kamMutator
\family default
 to the second replicate at every generation; apply 
\family typewriter
stat
\family default
 to count allele frequency and calculate 
\begin_inset Formula $F_{st}$
\end_inset

 every 10 generations.
 More details about operators will be described later.
\end_layout

\begin_layout Standard
You can ignore the specialties of an operator and call its 
\family typewriter
apply()
\family default
 function directly.
 For example, you can initialize a population outside a simulator by 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

initByFreq( [0.3, .2, .5] ).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or dump the content of a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

dumper().apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This style of calling is used so often that it deserves some simplification.
 Equivalent functions are defined for most of the operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/InitByFreq.log}[caption={Function InitByFreq},label={InitByFreq}]
preview false

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Note that 
\end_layout

\begin_layout Enumerate
The following two calling sequences have different consequences:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = population(10)
\end_layout

\begin_layout Standard

simu = simulator(pop, randomMating(), rep=3)
\end_layout

\begin_layout Standard

simu.evolve( preOps = [initByFreq([.8,.2]) ] )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
initialize three replicates of the population independently, (
\family typewriter
initByFreq
\family default
 object is applied to three populations.) but
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop = population(10)
\end_layout

\begin_layout Standard

InitByFreq(pop, [.8, .2])
\end_layout

\begin_layout Standard

simu = simulator(pop, randomMating(), rep=3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
initialize a population once and create a simulator with three copies of
 the initialized population.
 
\end_layout

\end_deeper
\begin_layout Enumerate
If you are going to call such a function many times, it is more efficient
 to do
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

init = initByFreq([.8,.2])
\end_layout

\begin_layout Standard

for i in range(0,1000):
\end_layout

\begin_layout Standard

  init.apply(pop[i])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
than 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

for i in range(0,1000):
\end_layout

\begin_layout Standard

  InitByFreq(pop[i], [.8,.2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The difference is that the second method creates and destroys an 
\family typewriter
initByFreq
\family default
 object each time it calls the function.
\end_layout

\end_deeper
\begin_layout Standard
Because 
\family typewriter
initByFreq
\family default
 and 
\family typewriter
dumper
\family default
 will be frequently used in this manual, I will briefly describe them here.
 
\end_layout

\begin_layout Itemize

\family typewriter
initByFreq
\begin_inset LatexCommand index
name "initByFreq"

\end_inset


\family default
 takes an array of probabilities (must be added up to one).
 When applied to a population, each allele will be assigned 
\family typewriter
0,1,2,3,...

\family default
 etc.
 according to the provided probabilities.
 
\family typewriter
InitByFreq
\begin_inset LatexCommand index
name "function!InitByFreq"

\end_inset

(pop,...)
\family default
 is its function form.
\end_layout

\begin_layout Itemize

\family typewriter
dumper
\begin_inset LatexCommand index
name "dumper"

\end_inset


\family default
 will simply display the population.
 The output format for each individual is: individual index, tag, sex, affected
 status, alleles on copy 
\family typewriter
1,2,...

\family default
 of all chromosomes, separated by 
\family typewriter
|
\family default
.
 Its function form is named 
\family typewriter
Dump
\begin_inset LatexCommand index
name "function!Dump"

\end_inset

(pop)
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "dumpPop"

\end_inset

 demonstrates the use of these two operators:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/dumpPop.log}[caption={Operator dumper and initByFreq},label={dumpPop}]
preview false

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Population-Structure"

\end_inset

Population structure
\end_layout

\begin_layout Standard
Please refer to the class reference of population for detailed information
 of its member functions.
 Here is an example of population structure.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popStru.log}[caption={population structure functions},label={popStru}]
preview false

\end_inset


\end_layout

\begin_layout Standard
There is another set of functions that deal with population/subpopulation
 size changes.
 In these functions, the 
\family typewriter
info
\family default
 field of each individual plays an important role.
 This field represents an individual's (new) subpopulation ID most of the
 times.
 For example, function 
\family typewriter
rearrangeByIndID
\begin_inset LatexCommand index
name "population!rearrangeByIndInfo"

\end_inset

()
\family default
 rearranges individuals in the order of their 
\family typewriter
info
\family default
 values.
\end_layout

\begin_layout Standard
These functions may look useful and appealing but you will almost never
 use them directly.
 All these operations will be performed by various operators, in a more
 user-friendly way.
 Only when you begin to write your own operators will you have to read about
 the details of these functions.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "popStruManip"

\end_inset

 demonstrates the use of functions 
\family typewriter
setIndSubPopID, setSubPopByIndID
\family default
 and 
\family typewriter
removeLoci
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popStruManip.log}[caption={population structure functions},label={popStruManip}]
preview false

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Individuals"

\end_inset

Individuals
\end_layout

\begin_layout Standard
You can access individuals of a population through 
\family typewriter
individual
\begin_inset LatexCommand index
name "population!individual"

\end_inset

()
\family default
 function.
 There are four forms of this function, two with and two without parameter
 
\family typewriter
subPop
\family default
,
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind)
\family default
 returns the 
\family typewriter
ind
\family default
'th individual (absolute index) of the whole population.
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind, subPop)
\family default
 returns the 
\family typewriter
ind
\family default
'th (relative index) individual in the 
\family typewriter
subPop
\family default
'th subpopulation.
\end_layout

\begin_layout Itemize

\family typewriter
individuals(), individuals(subPop)
\family default
 return an iterator that can be used to iterate through all individuals.
\end_layout

\begin_layout Standard
The iterator can simplify the access of individuals, by using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

for ind in pop.individuals(2):
\end_layout

\begin_layout Standard

  # do something to ind
\end_layout

\begin_layout Standard

  print ind.affected()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
instead of the older
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

for i in range(pop.popSize()):
\end_layout

\begin_layout Standard

  ind = pop.individual(i)
\end_layout

\begin_layout Standard

  print ind.affected()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The returned 
\family typewriter
individual
\family default
 object also has its own member functions.
 You can retrieve genotypic information of an individual through the same
 set of functions.
 You can also get/set genotypes of an individual.
 Note that you can not create an individual object directly.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/ind.log}[caption={Individual member functions},label={ind}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Again, you will very seldom have to use these functions directly unless
 when you write pure Python operators.
 
\end_layout

\begin_layout Section
Reference of class 
\family typewriter
individual
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
individualRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Population-Variables"

\end_inset

Population variables
\end_layout

\begin_layout Standard
Populations are associated with Python variables.
 These variables are usually set by various operators.
 For example, 
\family typewriter
stat
\begin_inset LatexCommand index
name "operator!stat"

\end_inset


\family default
 operator calculates many population statistics and store results in population
 namespace.
 Example 
\begin_inset LatexCommand ref
reference "sub:Population-Variables"

\end_inset

 demonstrates how 
\family typewriter
stat
\family default
 set variables 
\family typewriter
popSize
\family default
, 
\family typewriter
alleleFreq
\family default
 etc.
 
\end_layout

\begin_layout Standard
You can refer to these variables using 
\family typewriter
population::vars
\begin_inset LatexCommand index
name "population!vars"

\end_inset

()
\family default
 or 
\family typewriter
population::
\begin_inset LatexCommand index
name "population!population"

\end_inset

dvars()
\family default
 function.
 The returned values of 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
 reflect the same dictionary.
 However, 
\family typewriter
dvars()
\family default
 uses a little Python magic so that you can use attribute syntax to access
 dictionary keys.
 Since 
\family typewriter
a.allaleFreq[0]
\family default
 is much easier to read than 
\family typewriter
a['alleleFre'][0]
\family default
, 
\family typewriter
dvars()
\family default
 is always preferred to 
\family typewriter
vars()
\family default
.
 A function 
\family typewriter
ListVars
\family default
 defined in 
\family typewriter
simuUtil
\family default
 can be used to display the variables.
 With wxPython installed, this function will open a nice window with a tree
 representing the variables.
 Without wxPython (or use parameter 
\family typewriter
useWxPython=False
\family default
), variables will be displayed in a indented form.
 Several parameters can be used to limit your display.
 They are
\end_layout

\begin_layout Itemize

\family typewriter
level
\family default
: the level of the tree, further nested variables will not be displayed
\end_layout

\begin_layout Itemize

\family typewriter
name
\family default
: the name of the variable to display
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: whether or not display variables for each subpopulation.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popVars.log}[caption={Population variables},label={popVars}]
preview false

\end_inset


\end_layout

\begin_layout Standard
These variables form a Python dictionary, and furthermore a local namespace
 for functions like 
\family typewriter
population::evaluate
\family default

\begin_inset LatexCommand index
name "population!evaluate"

\end_inset

.
 
\emph on
Local namespace
\emph default
 means that you can use dictionary items as variables during evaluation.
 For example: 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/localNamespace.log}[caption={Local namespaces of populations},label={localNamespace}]
preview false

\end_inset


\end_layout

\begin_layout Standard
As you can see, these variables are 
\emph on
local
\emph default
 to the population and is not directly accessible from the main namespace.
 
\family typewriter
vars(subPop)
\family default
 and 
\family typewriter
dvars(subPop)
\family default
 function can be used.
 Both functions take an optional 
\family typewriter
subPop
\family default
 option.
 If ignored, they will return the population dictionary; otherwise, they
 will return the dictionary for subpopulation 
\family typewriter
subPop
\family default
.
 This is a very convenient feature, because subpopulations and populations
 have similar keys, you can calculate the same statistics for the whole
 population and individual subpopulations, just by specifying different
 namespaces.
\end_layout

\begin_layout Section
Sample from a Population
\end_layout

\begin_layout Standard
Sampling (or ascertainment) is a complicated issue.
 simuPOP provides several methods to generate samples from an existing populatio
n.
 For more details please refer to Chapter 
\begin_inset LatexCommand ref
reference "sec:Ascertainment"

\end_inset

.
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
The information fields are information that is attached to each individual.
 For example, an individual may need 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 to track pedigree information, may need 
\family typewriter
penetrance
\family default
 to set affectedness.
\end_layout

\begin_layout Standard
The information fields is usually set during population creation, in preparation
 for all the operators, using the 
\family typewriter
infoFields
\family default
 option of population constructor.
 It can also be set or added by functions
\end_layout

\begin_layout Itemize

\family typewriter
pop.setInfoFields(fields)
\end_layout

\begin_layout Itemize

\family typewriter
pop.addIndField(field)
\end_layout

\begin_layout Standard
Note that changing information fields for a simulator is dangerous since
 all populations in a simulator share the same genotypic structure.
 You should use 
\family typewriter
addIndField
\family default
 to all populations to avoid potential problems.
\end_layout

\begin_layout Standard
One can set/retrieve information at individual level:
\end_layout

\begin_layout Itemize

\family typewriter
ind.info(idx or field)
\end_layout

\begin_layout Itemize

\family typewriter
ind.setInfo(idx or field)
\end_layout

\begin_layout Itemize

\family typewriter
ind.arrInfo()
\end_layout

\begin_layout Standard
or set at the population level
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx or field, order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx or field, subPop, order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.setIndInfo(idx or field, [subPop])
\end_layout

\begin_layout Itemize

\family typewriter
pop.arrIndInfo(order)
\end_layout

\begin_layout Itemize

\family typewriter
pop.arrIndInfo(subPop, order)
\end_layout

\begin_layout Standard

\family typewriter
idx
\family default
 or 
\family typewriter
field
\family default
 means that you can use field index obtained from 
\family typewriter
infoIdx(field)
\family default
, or use field name directly.
 
\family typewriter
field
\family default
 is easier to use but 
\family typewriter
idx
\family default
 is faster.
 Although population information is kept in a population object linearly,
 there is no guarantee that they are ordered.
 If you would like to access 
\family typewriter
info
\family default
 individual by individual, passing 
\family typewriter
order=True
\family default
 will ensure that the returned information fields are ordered by individual
 order.
 If you only need to get a summary of some information fields, passing 
\family typewriter
order=False
\family default
 will speed up the process.
 
\end_layout

\begin_layout Standard
For each individual, 
\family typewriter
ind.arrInfo()
\family default
 will return 
\family typewriter
f1, f2, f3, ...

\family default
 etc.
 for that individual.
 From a population point of view, 
\family typewriter
pop.arrIndInfo([subPop])
\family default
 will return a list of 
\family typewriter
f1, f2, f3, ..., f1, f2, f3, ...
\family default
.
 Note that the order of individuals may not be kept in this (sub)population-wise
 array.
 That is to say, 
\family typewriter
pop.arrIndInfo()[0]
\family default
 does not have to be the first field of the first individual.
 This property is also true for 
\family typewriter
setIndInfo(values, idx or name)
\family default
.
 That is to say, if you want to set information field for individuals in
 a population unordered, you can use 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

setIndInfo(values, idx)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otherwise, you will have to use the less efficient way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

for i in range(pop.popSize()):
\end_layout

\begin_layout Standard

    pop.individual(i).setInfo(values[i], idx)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\family typewriter
indInfo
\family default
 is more convenient but it is less efficient (fields must be copied out)
 than 
\family typewriter
arrIndInfo
\family default
.
 To handle the returned value of 
\family typewriter
arrIndInfo
\family default
, you would usually do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

idx = pop.infoIdx('trait2')
\end_layout

\begin_layout Standard

step = pop.infoSize()
\end_layout

\begin_layout Standard

arr = pop.arrIndInfo(subPop=2)
\end_layout

\begin_layout Standard

for i in range(pop.subPopSize(2)):
\end_layout

\begin_layout Standard

  # note again that arr is writable.
\end_layout

\begin_layout Standard

  arr[idx + step*i] = something
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
By default, a population object only holds the current generation.
 All ancestral populations (generations) will be discarded.
 You can, however, keep as many ancestral generations as you wish, provided
 that you have enough RAM to store all these extra information.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
ancestralDepth
\family default
 is used to specify the number of generations to keep.
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number to store most recent 
\family typewriter
ancestry
\family default
 generations; or -
\family typewriter
1
\family default
 to store all populations.
 
\end_layout

\begin_layout Standard
Several important usage of ancestral populations:
\end_layout

\begin_layout Itemize

\family typewriter
dumper()
\family default
 operator and 
\family typewriter
Dump()
\family default
 function has a parameter 
\family typewriter
ancestralPops
\family default
.
 If set to 
\family typewriter
True
\family default
, they will dump all ancestral generations.
\end_layout

\begin_layout Itemize
function 
\family typewriter
population::setAncestralDepth()
\family default
 and operator 
\family typewriter
setAncestralDepth()
\family default
 set the number of ancestral generations to keep for a population.
 A typical use of 
\family typewriter
setAncestralDepth()
\family default
 is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

simu.evolve(...
\end_layout

\begin_layout Standard

  setAncestralDepth(3, at=[-3])
\end_layout

\begin_layout Standard

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which saves the last three generations in populations so that pedigree based
 sampling schemes can sample from the population.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
pop.useAncestralPop(idx)
\family default
 set the current generation of population 
\family typewriter
pop
\family default
 to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the first ancestral generation, 
\family typewriter
2
\family default
 for second ancestral ..., and 
\family typewriter
0
\family default
 for the current generation.
 After this function, all functions, operators will be applied to this ancestral
 population.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral populations.
 
\end_layout

\begin_layout Standard
A typical use of this function is demonstrated in example 
\begin_inset LatexCommand ref
reference "ancestralPop"

\end_inset

.
 In this example, a population with two loci is created and with initial
 genotype 0.
 Two 
\family typewriter
kamMutator
\family default
 with different mutation rates are applied to these two loci.
 Five most recent populations are kept.
 The allele frequencies at these generations are calculated afterward.
 (Note that this is not the best way to exam the changes of allele frequencies,
 a 
\family typewriter
stat
\family default
 operator should be used.)
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/ancestralPop.log}[caption={Ancestral populations},label={ancestralPop}]
preview false

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and Load a Population
\end_layout

\begin_layout Standard
Internally, population can be saved/loaded in 
\begin_inset Quotes eld
\end_inset


\family typewriter
txt
\family default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
xml
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
bin
\family default

\begin_inset Quotes erd
\end_inset

 formats using 
\family typewriter
savePopulation
\begin_inset LatexCommand index
name "savePopulation"

\end_inset

(file, format, compress=True)
\family default
 member function, global 
\family typewriter
SavePopulation
\begin_inset LatexCommand index
name "Function!SavePopulation"

\end_inset

(pop, file, format)
\family default
 and 
\family typewriter
LoadPopulation
\family default

\begin_inset LatexCommand index
name "function!LoadPopulation"

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 since 
\family typewriter
savePopulation
\family default
 is a member function and 
\family typewriter
LoadPopulation
\family default
 is a global function.) These formats have their own advantages and disadvantages
:
\end_layout

\begin_layout Itemize

\family typewriter
xml
\begin_inset LatexCommand index
name "xml format"

\end_inset

:
\family default
 most readable, easy transformation to other formats, largest file size
\end_layout

\begin_layout Itemize

\family typewriter
bin
\begin_inset LatexCommand index
name "bin format"

\end_inset

:
\family default
 not readable, small file size.
 May not be portable.
\end_layout

\begin_layout Itemize

\family typewriter
txt
\begin_inset LatexCommand index
name "text format"

\end_inset

:
\family default
 human readable with no structure, portable, median file size.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/popSaveLoad.log}[caption={Save and load population},label={popSaveLoad}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Populations are by default compressed in gzip format.
 If you are interested in viewing the content of the file, you can use 
\family typewriter
compress=False
\family default
 when saving a population, or decompress the saved files using 
\family typewriter
gzip -d
\family default
 command.
\end_layout

\begin_layout Standard
Populations can also be saved in other formats such as FSTAT so that they
 can be directly analyzed by other programs.
 These formats are not supported internally.
 They are handled in Python in the form of Python function or pure-Python
 operator.
 If you would like to save/load simuPOP population in your own format, you
 can do it by mimicking these functions in 
\family typewriter
simuUtil.py
\family default
.
 
\end_layout

\begin_layout Standard
It is also possible to save a bunch of populations in a single file, provided
 that they have the same genotypic structure.
 The functions are
\end_layout

\begin_layout Itemize

\family typewriter
SavePopulations
\begin_inset LatexCommand index
name "function!SavePopulations"

\end_inset

([pop1,pop2,...,], filename, format='auto', compress=True)
\end_layout

\begin_layout Itemize

\family typewriter
LoadPopulations
\begin_inset LatexCommand index
name "functions!LoadPopulations"

\end_inset

(filename)
\end_layout

\begin_layout Standard
Shared variables will also be saved (except for big objects like samples).
 Since the number of shared variables can be very large, it maybe a good
 idea to clear these variables before you save a population.
 On the other hand, you may want to save key parameters used to generate
 this population in the local namespace so that you will know these parameters
 after the population is loaded.
 For example, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop.vars().clear()
\end_layout

\begin_layout Standard

pop.dvars().migrationRate = 0.002
\end_layout

\begin_layout Standard

pop.dvars().diseaseLoci = [4, 30]
\end_layout

\begin_layout Standard

SavePopulation(pop, 'pop.bin')
\end_layout

\end_inset


\end_layout

\begin_layout Section
View a population (GUI, wxPython required)
\end_layout

\begin_layout Standard
Introduced in version 0.6.9, 
\family typewriter
simuViewPop.py
\family default
 can be used to view a population.
 It can be used as a standalone application, or in an interactive session.
 First, you can use this script as a standalone application, simply run
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

simuViewPop.py mypop.bin
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will fire a GUI and allow you to exam population property, genotype and
 calculate statistics.
 
\end_layout

\begin_layout Standard
In a Python session, import this module will provide a function 
\family typewriter
viewPop
\family default
, apply it on a in-memory population or a filename will have the same effect.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

import simuViewPop
\end_layout

\begin_layout Standard

simuViewPop.viewPop(myPop)
\end_layout

\begin_layout Standard

simuViewPop.viewPop(filename='mypop.bin')
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
populationRef
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Mating Scheme
\begin_inset LatexCommand index
name "mating scheme"

\end_inset


\end_layout

\begin_layout Standard
Mating schemes define the rules of offspring generating.
 A mating scheme is required when a simulator is created.
\end_layout

\begin_layout Section
Determine the number of offspring during mating
\end_layout

\begin_layout Standard
The default value of 
\family typewriter
numOffspring
\family default
 parameter makes a mating scheme produce one offspring per mating.
 This is the real random mating and should be used whenever possible.
 However, various situations require a larger family size or even changing
 the family size.
 simuPOP provides a comprehensive way to deal with this problem.
\end_layout

\begin_layout Standard
As described in the class reference, the method to determine the number
 of offspring is to set the 
\family typewriter
mode
\family default
 parameter:
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffspring:
\family default
 if 
\family typewriter
numOffspringFunc
\family default
 is not given, the number of offspring will be the constant 
\family typewriter
numOffspring
\family default
 all the time.
 Otherwise, 
\family typewriter
numOffspringFunc(gen)
\family default
 will be called 
\series bold
once
\series default
 for each generation to get the number of offspring for the matings happen
 in this generation.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffspringEachFamily:
\family default
 
\family typewriter
numOffspringFunc
\family default
 has to be given and will be called whenever a mating happens.
 Since 
\family typewriter
numOffspringFunc
\family default
 can be 
\series bold
any
\series default
 Python function, this mode allows arbitrary model of assigning the number
 of offspring during mating.
 The mode can be slow though.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_GeometricDistribution: numOffspring
\family default
 or the result of 
\family typewriter
numOffspringFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a geometric distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_PoissonDistribution: numOffspring
\family default
 or result of 
\family typewriter
numOffspringFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a Poission distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{p^{k-1}}{\left(k-1\right)!}e^{-p}\;\textrm{ for}k\geq1\]

\end_inset

Since the mean of this shifted Poisson distribution is 
\begin_inset Formula $p+1$
\end_inset

, you need to specify, for example, 2, if you want a mean family size 3.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_BinomialDistribution: numOffspring
\family default
 or the result of 
\family typewriter
numOffspringFunc
\family default
 (evaluated at each generation) will be considered as 
\begin_inset Formula $p$
\end_inset

 for a Binomial distribution.
 Let 
\begin_inset Formula $N$
\end_inset

=
\family typewriter
maxNumOffspring
\family default
, the number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}\;\textrm{ for }N\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_UniformDistribution:
\family default
 
\family typewriter
numOffspring
\family default
 or the result of 
\family typewriter
numOffspringFunc
\family default
 (evaluated at each generation), and 
\family typewriter
maxNumOffspring
\family default
 will be considered as 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 for a Uniform distribution, respectively.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{1}{b-a}\;\textrm{ for }b\geq k\geq a\]

\end_inset


\end_layout

\begin_layout Standard
Note that all these distributions are adjusted to produce at least one offspring.
 
\end_layout

\begin_layout Section
Determine subpopulation sizes of the next generation
\end_layout

\begin_layout Standard
The default behavior of simuPOP is to use the same population/subpopulation
 sizes as those of the parent generation.
 You can change this behavior by setting one of 
\family typewriter
newSubPopSize
\family default
, 
\family typewriter
newSubPopSizeExpr
\family default
, and 
\family typewriter
newSubPopSizeFunc
\family default
 parameters:
\end_layout

\begin_layout Itemize
If you would like to have fixed subpopulation sizes, use 
\family typewriter
newSubPopSize=some_fixed_values
\family default
.
 This is useful when subpopulation sizes are changed by migration and you
 do want to keep constant subpopulation sizes.
\end_layout

\begin_layout Itemize
If subpopulation sizes can be easily calculated through an expression, you
 can use 
\family typewriter
newSubPopSizeExpr
\family default
 to determine the new subpopulation sizes.
 For example, 
\family typewriter
newSubPopSizeExpr='[gen+10]'
\family default
 uses the generation number + 10 as the new population size.
 More complicated expressions can be used, maybe along with 
\family typewriter
pyExec
\family default
 operators, but in these cases, a specialized function and 
\family typewriter
newSubPopSizeFunc
\family default
 are recommended.
 Note that the expression uses variables from the local namespace.
\end_layout

\begin_layout Itemize
A more organized (and thus recommended) way to set new population/subpopulation
 sizes is through parameter 
\family typewriter
newSubPopSizeFunc
\family default
.
 To use this parameter, you need to define a Python function that takes
 two parameters: the generation number and the current subpopulation sizes,
 and return an array of new subpopulation sizes (return 
\family typewriter
[newsize]
\family default
 instead of 
\family typewriter
newsize
\family default
 when you do not have any subpopulation structure).
 For example, the following function defines a linear expansion demographic
 scenario where a population splits at generation 200 and starts expanding
 .
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def lin_exp(gen, oldSize=[]):
\end_layout

\begin_layout Standard

  if gen < 200:   # burn in, constant population size
\end_layout

\begin_layout Standard

    return [1000]
\end_layout

\begin_layout Standard

  else:           # increase subpopulation sizes
\end_layout

\begin_layout Standard

    incSize = (10000-1000)/(500-200)/len(oldSize)
\end_layout

\begin_layout Standard

    return [oldSize[x]+incSize for x in range(0, len(oldSize))]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
you can then use this function as follows
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

...randomMating(newSubPopSizeFunc=lin_exp) ...
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Demographic change functions
\end_layout

\begin_layout Standard

\family typewriter
newSubPopSizeFunc
\family default
 can take a function with parameters 
\family typewriter
gen
\family default
 and 
\family typewriter
oldSize.

\family default
 A few functions are defined in 
\family typewriter
simuUtil.py
\family default
 that will return such a function with given parameters.
 All these functions support a burnin stage and then split to equal sized
 subpopulations.
 For all these functions, you can test them by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

func = oneOfTheDemographicFunc(parameters)
\end_layout

\begin_layout Standard

gen = range(0, yourEndGen)
\end_layout

\begin_layout Standard

r.plot(gen, [func(x)[0] for x in gen])
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
numSubPop
\family default
 is default to 
\family typewriter
1
\family default
.
 
\family typewriter
split
\family default
 is default to 
\family typewriter
0
\family default
 or given 
\family typewriter
burnin
\family default
 value.
 Population size change happens 
\series bold
after
\series default
 burnin (start at 
\family typewriter
burnin+1
\family default
) and split happens at 
\family typewriter
split
\family default
.
\end_layout

\begin_layout Subsubsection*

\family typewriter
ConstSize(size, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
The population size is constant, but will split into 
\family typewriter
numSubPop
\family default
 subpopulations at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
LinearExpansion(initSize, endSize, end, burnin, split, numSubPop, bottleneckGen,
 bottleneckSize)
\end_layout

\begin_layout Standard
Linearly expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
ExponentialExpansion
\family default
(
\family typewriter
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
Exponentially expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Subsubsection*

\family typewriter
InstantExpansion
\family default
(
\family typewriter
initSize, endSize, end, burnin, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\begin_layout Standard
Instaneously expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Section
References of different mating schemes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
noMatingRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
binomialSelectionRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
randomMatingRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyMatingRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sex chromosomes
\end_layout

\begin_layout Standard
Currently, only 
\family typewriter
randomMating()
\family default
 in diploid population supports sex chromosomes.
 When 
\family typewriter
sexChrom()
\family default
 is 
\family typewriter
False
\family default
, the sex of an offspring is determined randomly with probability 
\begin_inset Formula $1/2$
\end_inset

.
 Otherwise, it is determined by the existence of Y chromosome, I.e., what
 kind of sex chromosome an offspring get from his father.
 
\end_layout

\begin_layout Standard
Recombinations on sex chromosomes of females (XX) are just like those on
 autosomes.
 However, this is not true in males.
 Currently, recombinations between male sex chromosomes (XY) are 
\emph on
not
\emph default
 allowed (a bug/feature of recombinators).
 This may change later if exchanges of genes between pseudoautosomal regions
 of XY need to be modeled.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
matingRef
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They define manipulations on populations.
 Operators are basic and important components in simuPOP.
\end_layout

\begin_layout Section
Types of operators
\end_layout

\begin_layout Standard
There are three kinds of operators:
\end_layout

\begin_layout Itemize

\emph on
built-in:
\emph default
 written in C++, the fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\end_layout

\begin_layout Itemize

\emph on
hybrid
\emph default

\begin_inset LatexCommand index
name "hybrid"

\end_inset

: written in C++ but calls a Python function during simulation.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter
pyMutator
\family default
 will determine if an allele will be mutated and call a user-defined Python
 function to mutate it.
\end_layout

\begin_layout Itemize

\emph on
pure Python
\emph default
: written in Python.
 The same speed as Python.
 For example, a 
\family typewriter
varPlotter
\begin_inset LatexCommand index
name "varPlotter"

\end_inset


\family default
 can plot Python variables that are set by other operators.
\end_layout

\begin_layout Standard
You do not have to know the type of an operator to use them.
 The interfaces of them are all the same.
 Note that although it is possible to write pure Python operators to operate
 directly on populations, it might work very slowly compared to the built-in
 ones.
\end_layout

\begin_layout Subsection
Applicable stages
\begin_inset LatexCommand index
name "applicable stage"

\end_inset


\end_layout

\begin_layout Standard
Operators can be applied at 
\emph on
pre-
\emph default
, 
\emph on
during-
\emph default
 or 
\emph on
post-mating
\emph default
, or a combination of these stages.
 Note that it is possible for an operator to apply multiple times in a life
 cycle.
 For example, a save-to-file operator might be applied before and after
 mating to trace parental information.
 Also please refer to the class reference for setting the 
\family typewriter
stage
\family default
 parameter.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/operatorstages.log}[caption={Operator stage},label={operatorstages}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Active generations
\end_layout

\begin_layout Standard
You can specify 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, and 
\family typewriter
at
\family default
 parameters of an operator during initialization.
 For example,
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/operatorgen.log}[caption={Set active generations of an operator},label={operatorgen}]
preview false

\end_inset


\end_layout

\begin_layout Standard
The last example displays variable 
\family typewriter
gen
\family default
 for each replicate.
 Note that you can use negative generation number whenever you specify the
 
\family typewriter
end
\family default
 parameter of the evolution.
 In this case, generation -1 is the last generation (
\family typewriter
end
\family default
), -2 is 
\family typewriter
end-1
\family default
, and so on.
\end_layout

\begin_layout Subsection
Replicates and groups
\end_layout

\begin_layout Standard
Most operators are applied to every replicate of a simulator during evolution.
 However, you can apply operators to one or a group of replicates only.
 For example, you can initialize different replicates with different initial
 values and then start evolution.
 c.f.
 
\family typewriter
simulator::setGroup
\family default
 .
 
\end_layout

\begin_layout Standard
The most useful example is 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

output('
\backslash
n',rep=REP_LAST)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which will output 
\family typewriter

\backslash
n
\family default
 at the end of each generation.
 Here is an example of using replicate groups:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/operatorgrp.log}[caption={Replicate group},label={operatorgrp}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Output Specification
\end_layout

\begin_layout Standard
The following example shows the difference between 
\family typewriter

\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset


\family default
 and 
\family typewriter

\begin_inset Quotes eld
\end_inset

>>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/operatoroutput.log}[caption={log/operatoroutput},label={operatoroutput}]
preview false

\end_inset


\end_layout

\begin_layout Standard
In the first simulator, all operators use 
\family typewriter

\begin_inset Quotes eld
\end_inset

a.txt
\begin_inset Quotes erd
\end_inset


\family default
 (the same as 
\family typewriter

\begin_inset Quotes eld
\end_inset

>a.txt
\begin_inset Quotes erd
\end_inset


\family default
).
 This file is repeatedly covered by other operators, so what we finally
 get is a new line written by 
\family typewriter
output(
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

)
\family default
.
 The second simulator works fine by using 
\family typewriter

\begin_inset Quotes eld
\end_inset

>>a.txt
\begin_inset Quotes erd
\end_inset


\family default
.
\end_layout

\begin_layout Standard
The output filename does not have to be fixed.
 If 
\family typewriter
outputExpr
\family default
 parameter is used (
\family typewriter
output
\family default
 will be ignored), it will be evaluated when a filename is needed.
 This is useful when you need to write different files for different replicates/
generations.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/operatoroutputexpr.log}[caption={log/operatoroutputexpr},label={operatoroutputexpr}]
preview false

\end_inset


\end_layout

\begin_layout Section
Python expression and statistics calculation
\end_layout

\begin_layout Subsection
Expressions and statements
\end_layout

\begin_layout Standard
Expressions are used extensively in operators so some basic knowledge of
 Python is required.
 If you know almost nothing about Python, please spend some time on the
 Python tutorial from Python website.
\end_layout

\begin_layout Standard
Unlike C/C++, assignments in Python do not return values.
 This is the most notable difference between Python expressions and statements:
\end_layout

\begin_layout Itemize
expressions consist of constants, variables, operators, functions, but 
\emph on
no
\emph default
 assignment, condition, loop etc.
 An expression returns a value when executed.
 An example of expression is 
\family typewriter
range(1,5)+10
\family default
 .
\end_layout

\begin_layout Itemize
statements consist of arbitrary valid Python codes.
 A statement does 
\emph on
not
\emph default
 return a value when executed.
 An example of statement is 
\family typewriter
a=range(1,5)
\family default
 .
\end_layout

\begin_layout Subsection
simuPOP variables
\end_layout

\begin_layout Standard
All populations have their own attached variables.
 We have seen the structure of a population dictionary: it is empty at the
 beginning and will have many variables created by various operators later.
 You can access the local namespace of each replicate through a simulator's
 
\family typewriter
vars(rep)
\family default
 function:
\end_layout

\begin_layout LyX-Code
simu.vars(0)        simu.vars(1) ...
     // replicate
\end_layout

\begin_layout LyX-Code
  popSize             popSize            // local namespace
\end_layout

\begin_layout LyX-Code
  alleleFreq[0]       alleleFreq[0]      // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
  alleleFreq[1]       alleleFreq[1]      // at locus 2
\end_layout

\begin_layout LyX-Code
  ...
                 ....
\end_layout

\begin_layout LyX-Code
  subPop[0]           subPop[0]          // subpop namespace
\end_layout

\begin_layout LyX-Code
    popSize             popSize          // subpopulation 1 size
\end_layout

\begin_layout LyX-Code
    allaleFreq[0]       allaleFreq[0]    // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout LyX-Code
  subPop[1]           subPop[1]          // variables for subpop 2
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout Standard
It is important to know that
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(0), vars(1)
\family default
 etc.
 are the 
\emph on
local namespaces
\emph default
 for each replicate.
\end_layout

\begin_layout Itemize

\family typewriter
subPop[0]
\family default
, 
\family typewriter
subPop[1]
\family default
 etc.
 have almost the same set of keys as those for the whole population.
 This is because 
\family typewriter
stat
\family default
 operator calculates statistics of each replicate of population, and all
 subpopulations.
\end_layout

\begin_layout Standard
To list these variables, you can use the 
\family typewriter
ListVars()
\family default
 function defined in 
\family typewriter
simuUtil.py
\family default
.
 For example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

ListVars(simu.vars(0), level=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
list all variables for the first replicate.
 
\family typewriter
level=2
\family default
 stops 
\family typewriter
ListVars
\family default
 from expanding lists and dictionaries after two levels.
 
\end_layout

\begin_layout Standard
Two functions can be used to access simulator and population variables:
 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
.
 We have known 
\family typewriter
population::vars()
\family default
 and 
\family typewriter
population::dvars()
\family default
, 
\family typewriter
simulator::vars()
\family default
 and 
\family typewriter
simulator::dvars()
\family default
 work in almost the same way.
 
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(rep
\family default
), 
\family typewriter
dvars(rep)
\family default
: return replicate 
\family typewriter
rep
\family default
's local namespace.
\end_layout

\begin_layout Itemize

\family typewriter
simulator::vars(rep, subPop
\family default
), 
\family typewriter
dvars(rep, subPop)
\family default
: return the namespace of 
\family typewriter
subPop
\family default
 subpopulation of replicate 
\family typewriter
rep
\family default
.
\end_layout

\begin_layout Standard
The return values of 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
 are different.
 
\family typewriter
vars()
\family default
 returns a Python dictionary.
 You should access their keys in the usual Python way.
 
\family typewriter
dvars()
\family default
 returns a 'wrapped' Python dictionary.
 You can access their dictionary keys as attributes.
 
\family typewriter
dvars()
\family default
 is usually considered to be easier to use than 
\family typewriter
vars()
\family default
.
\end_layout

\begin_layout Subsection

\family typewriter
evaluate
\begin_inset LatexCommand index
name "calculate"

\end_inset


\family default
 function and 
\family typewriter
pyEval
\begin_inset LatexCommand index
name "calc"

\end_inset


\family default
 and 
\family typewriter
pyExec
\begin_inset LatexCommand index
name "pyExec"

\end_inset


\family default
 operators
\end_layout

\begin_layout Standard
Function 
\family typewriter
population::evaluate
\family default
 and operator 
\family typewriter
pyEval/pyExec
\family default
 will work in local namespaces.
 For example, if there are 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 in the main namespace and 
\family typewriter
a
\family default
 in 
\family typewriter
pop
\family default
, 
\family typewriter
pop.evaluate('a')
\family default
 will return 
\family typewriter
pop.vars()['a']
\family default
, 
\family typewriter
pop.evaluate('b')
\family default
 will return global 
\family typewriter
b
\family default
 since there is no 
\family typewriter
b
\family default
 in the local namespace.
 If this is still too abstract, here is a real example
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/expr.log}[caption={python expression},label={expr}]
preview false

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
simulator
\family default
 creates a simulator with two replicates 0 and 1.
 
\end_layout

\begin_layout Itemize
We evaluate 
\family typewriter
grp*2
\family default
 in different replicates and get different results.
\end_layout

\begin_layout Itemize

\family typewriter
gen
\family default
 is not in either replicate's namespace so the global one will be used.
\end_layout

\begin_layout Itemize
Using statements can create variables in the local namespaces.
 (You can use 
\family typewriter
global
\family default
 statement to create global variables if you are familiar with Python.)
\end_layout

\begin_layout Standard

\family typewriter
pyEval 
\family default
and
\family typewriter
 pyExec
\family default
 operators execute Python expressions/statements, 
\emph on
using the local namespaces
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
pyEval
\family default
 (operator) evaluates a Python expression and returns its value, optionally
 executes a list of statements beforehand.
\end_layout

\begin_layout Itemize

\family typewriter
pyExec
\family default
 (operator) executes a list of statements in the form of a multi-line string.
 No return value or output.
\end_layout

\begin_layout Standard
Here, 
\family typewriter
expr
\family default
 is a simple string containing an expression that will return a value when
 executed; 
\family typewriter
stmts
\family default
 is a string of statements, separated by 
\family typewriter
'
\backslash
n'
\family default
.
 
\end_layout

\begin_layout Standard
For example, you can return a string of 
\family typewriter

\begin_inset Quotes eld
\end_inset

gen:rep
\begin_inset Quotes erd
\end_inset


\family default
 using the following function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop.evaluate(r'%d:%d' % (gen,rep))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but if you would like to change/create variables, you have to use statements
 like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop.evalulate(rmyval, stmts=rmyval=rep+1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since you are executing Python statements, you can of course do it directly
 in Python.
 For example, the above function does exactly the following
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop.vars()['myval'] = pop.vars()['rep'] + 1
\end_layout

\begin_layout Standard

pop.vars()['myvar']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a matter of fact, we seldom use 
\family typewriter
evaluate
\family default
 function directly (maybe for debugging), usually
\end_layout

\begin_layout Itemize
we use expressions for dynamic parameters.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

newSubPopSizeExpr=range(10,20)*1.2
\end_layout

\begin_layout Standard

outputExpr= ' saveAt%s.txt % gen'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be evaluated whenever they are referred.
\end_layout

\end_deeper
\begin_layout Itemize
we use expressions/statements in 
\family typewriter
pyEval/pyExec
\family default
 operators.
 These statements will work in local namespaces.
 For example:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/expreval.log}[caption={Expression evaluation},label={expreval}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Because of the interactive nature of Python, it is very easy to write short
 programs, quote them in 
\family typewriter
r'''program'''
\family default
 and put them into 
\family typewriter
pyEval/pyExec
\family default
 operators.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
OperatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Simulator
\begin_inset LatexCommand index
name "Simulator"

\end_inset


\end_layout

\begin_layout Standard
The population evolution is implemented in simulator, which manages and
 manipulates other components of simuPOP.
 Simulator is the basic and important simulation function or environment
 in simuPOP.
 Without it, we may only call the simuPOP 'POP'.
\end_layout

\begin_layout Section
Generation number
\end_layout

\begin_layout Standard
Several aspects of the generation number may cause confusion:
\end_layout

\begin_layout Itemize
generation starts from zero
\end_layout

\begin_layout Itemize
a generation number presents a 'to-be-evolved' generation
\end_layout

\begin_layout Itemize
the ending generation specified in 
\family typewriter
evolve()
\family default
 will be executed
\end_layout

\begin_layout Standard
That is to say, a new simulator will have generation 0 (at the beginning
 of generation 0).
 If you do 
\family typewriter
evolve(..., end=0), evolve
\family default
 will evolve one generation and stop at the beginning of generation 1.
\end_layout

\begin_layout Standard
It may sound strange that 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

evolve(end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
evolve the population three times.
 Generation 0, generation 1, and generation 2.
 At the end of the simulation, current generation number is 3! (If you are
 familiar with C, this is like a 
\family typewriter
for
\family default
 loop index).
 This is why you should test if a simulation is finished correctly by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

if(simu.gen() == endGen+1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
instead of 
\family typewriter
simu.gen() == endGen.

\family default
 (endGen is the value for parameter 
\family typewriter
end
\family default
).
\end_layout

\begin_layout Standard
When you use 
\family typewriter
start=0, step=5, end=10
\family default
 for your operator, it will be applied at generations 
\family typewriter
0,5,10
\family default
 etc.
 
\end_layout

\begin_layout Section
Operator calling sequence
\end_layout

\begin_layout Standard
In a simulation, operators are applied at different stages, pre-, during-,
 and post-mating.
 However, operators are not always active.
 They can be applied to certain generations or certain replicate(s) of a
 population.
 A simulator will always apply 
\family typewriter
preOps
\family default
 and 
\family typewriter
postOps
\family default
 operators, but will ask if an operator is active (by providing 
\family typewriter
rep, grp, gen
\family default
 information) before it is called.
\end_layout

\begin_layout Standard
The order of applying operators usually does not matter but errors may occur
 if you are not careful.
 For example, 
\family typewriter
stat(...)
\family default
 calculates the statistics of the current population.
 It is a pre-mating operator so you should set 
\family typewriter
stage=PostMating
\family default
 and put it after all operators if you would like to measure a post-mating
 population.
 However, it should be put before any operator (such as an terminator) that
 uses the shared variable set by 
\family typewriter
stat(...).
\end_layout

\begin_layout Standard
If you are not sure about the calling sequence of operators, you can set
 the 
\family typewriter
dryrun
\family default

\begin_inset LatexCommand index
name "simulator!dryun"

\end_inset

 parameter of 
\family typewriter
evolve()
\family default
 function to 
\family typewriter
True
\family default
.
 
\family typewriter
evolve
\family default
 will then print out the order of operators to apply.
 Consider that operators can be 
\family typewriter
PreMating
\begin_inset LatexCommand index
name "constant!PreMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PreMating"

\end_inset

, PostMating
\begin_inset LatexCommand index
name "constant!PostMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PostMating"

\end_inset

, PrePostMating
\begin_inset LatexCommand index
name "constant!PrePostMating"

\end_inset


\begin_inset LatexCommand index
name "operator!PrePostMating"

\end_inset

, DuringMating
\begin_inset LatexCommand index
name "constant!DuringMating"

\end_inset


\begin_inset LatexCommand index
name "operator!DuringMating"

\end_inset


\family default
 and the default value (parameter 
\family typewriter
stage
\family default
) may not be what you expect.
 Having a look at the calling sequence before the real evolution is always
 a good idea.
\end_layout

\begin_layout Section
Save and Load
\end_layout

\begin_layout Standard
Using function 
\family typewriter
saveSimulator
\family default
, we can save a simulator to a file in the format of 
\family typewriter
'txt'
\family default
,
\family typewriter
 'bin'
\family default
, or 
\family typewriter
'xml'
\family default
.
 However, a mating scheme can not be saved and has to be re-specified in
 
\family typewriter
LoadSimulator
\begin_inset LatexCommand index
name "loadSimulator"

\end_inset

()
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/simulatorsaveload.log}[caption={save and load a simulator},label={simulatorsaveload}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
simulatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Option Handling
\end_layout

\begin_layout Section
Conventions of simuPOP scripts
\end_layout

\begin_layout Standard
A simuPOP script is usually composed of the following parts:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

#!/usr/bin/env Python
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Introduction to the whole script:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

'''
\end_layout

\begin_layout Standard

This script simulates ....
\end_layout

\begin_layout Standard

'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Options: (see the next section)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

options = [ 
\end_layout

\begin_layout Standard

...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout Standard

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
\end_layout

\end_deeper
\begin_layout Enumerate
Auxiliary functions
\end_layout

\begin_layout Enumerate
Evolution function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def simulation(....)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Executable part:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

if __name__ == '__main__':  
\end_layout

\begin_layout Standard

  allParam = simuOpt.getParam(options,
\end_layout

\begin_layout Standard

    ''' A short description ''', __doc__)
\end_layout

\begin_layout Standard

  # if user press cancel,
\end_layout

\begin_layout Standard

  if len(allParam) == 0:
\end_layout

\begin_layout Standard

    sys.exit(1)
\end_layout

\begin_layout Standard

  # -h or --help
\end_layout

\begin_layout Standard

  if allParam[0]:  
\end_layout

\begin_layout Standard

    print simuOpt.usage(options, __doc__)
\end_layout

\begin_layout Standard

    sys.exit(0)
\end_layout

\begin_layout Standard

  # sace configuration, something like
\end_layout

\begin_layout Standard

  if allParam[-2] != None:
\end_layout

\begin_layout Standard

     simuOpt.saveConfig(options, allParam[-2]+'.cfg', allParam)  
\end_layout

\begin_layout Standard

  # get the parameters, something like
\end_layout

\begin_layout Standard

  N = allParam[1]
\end_layout

\begin_layout Standard

  # run the simulation
\end_layout

\begin_layout Standard

  simulation(N) 
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
  
\end_layout

\end_deeper
\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, printing usage, saving the configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
\end_layout

\begin_layout Standard
Note that these scripts, if proper written, can also be imported.
 Other scripts (or interactive session) can import a script and call its
 simulation function directly.
\end_layout

\begin_layout Section
Parameter handling and user input 
\end_layout

\begin_layout Standard
Although simuPOP scripts, simply Python scripts, can be in any valid Python
 style, it is highly recommended that all simuPOP scripts follow the same
 writing style and provide a uniform interface to users.
 From a user's point of view, a simuPOP script 
\family typewriter
cmd.py
\family default
 should
\end_layout

\begin_layout Enumerate
Start a Tk/wxPython dialog to accept a user's input when 
\family typewriter
--noDialog
\family default
 is not specified.
\end_layout

\begin_layout Enumerate
List all command-line/config file options through 
\family typewriter
-h
\family default
 or 
\family typewriter
--help
\family default
 option.
 
\end_layout

\begin_layout Enumerate
Accept 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
 parameter to read a configuration file and set parameters.
\end_layout

\begin_layout Enumerate
Be able to use command line arguments to set parameters if 
\family typewriter
--useDefault
\family default
 is not specified.
\end_layout

\begin_layout Enumerate
When 
\family typewriter
--noDialog
\family default
 and 
\family typewriter
--useDefault
\family default
 is specified, use default values for all parameters, if they can not be
 obtained from command-line parameters, configuration file, and have default
 values.
\end_layout

\begin_layout Enumerate
Accept 
\family typewriter
--saveconfig file
\family default
 to save current configuration  into 
\family typewriter
file
\family default
.
\end_layout

\begin_layout Enumerate
Be able to make use of optimized libraries through the use of command line
 parameter ( 
\family typewriter
--optimized
\family default
), config file entry (
\family typewriter
optimized=True
\family default
) or environment variable (
\family typewriter
SIMUOPTIMIZED
\family default
).
 
\end_layout

\begin_layout Enumerate
Be able to make use of long-allele libraries through the use of command
 line parameter (
\family typewriter
--longallele
\family default
), config file entry (
\family typewriter
longallele=True
\family default
) or environment variable (
\family typewriter
SIMULONGALLELE
\family default
).
 
\end_layout

\begin_layout Standard
To alleviate the trouble of doing all these, 
\family typewriter
simuPOP
\family default
 has provided a set of functions.
 Here is how parameters should be handled.
 The first step is describing each parameter in details.
 This includes (but not all of these are necessary) short and long argument
 names, entries in a configuration file, prompting when asking for user's
 input, default values, the description that will be shown in usage, allowed
 types of parameters, the function to validate the inputted values.
 All these should be put in a list of dictionaries like follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

options = [
\end_layout

\begin_layout Standard

  { 'arg':'h', 'longarg':'help', 'default':False,
\end_layout

\begin_layout Standard

    'allowedTypes':[IntType],
\end_layout

\begin_layout Standard

    'description':'print this message',
\end_layout

\begin_layout Standard

    'jump':-1 },
\end_layout

\begin_layout Standard

  { 'longarg':'saveconfig=', 'default':'', 'allowedTypes':[StringType],
\end_layout

\begin_layout Standard

    'description':'Save current configuration in a file.'},
\end_layout

\begin_layout Standard

  { 'arg':'m', 'longarg':'mu', 'label'='mutationRate', 
\end_layout

\begin_layout Standard

    'default':0.005,
\end_layout

\begin_layout Standard

    'validate': simuOpt.valueBetween(0,1),
\end_layout

\begin_layout Standard

    'description':'mutation rate (a number or an array of numbers) at each
 loci'
\end_layout

\begin_layout Standard

  } ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The entries:
\end_layout

\begin_layout Itemize

\family typewriter
arg
\family default
 and 
\family typewriter
longarg
\family default
 are in command line argument format.
 For example,
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
arg:'h'
\family default
 checks the presence of argument 
\family typewriter
-h
\family default
, returns 
\family typewriter
True
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
arg:'f:'
\family default
 checks the presence of argument pair 
\family typewriter
-f something
\family default
, returns 
\family typewriter
something
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
longarg:'help'
\family default
 checks the presence of argument 
\family typewriter
--longarg
\family default
, returns 
\family typewriter
True
\family default
 if succeeds
\end_layout

\begin_layout Itemize

\family typewriter
longarg:'mu='
\family default
 checks the presence of argument pair 
\family typewriter
--mu number
\family default
, returns 
\family typewriter
number
\family default
 if succeeds.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
label
\family default
 will be used as the label of the input field in a parameter dialog, and
 as the prompt for user input.
\end_layout

\begin_layout Itemize

\family typewriter
default
\family default
 is used when prompt is empty, or when user press 'Enter' directly.
\end_layout

\begin_layout Itemize

\family typewriter
useDefault
\family default
 use default value without asking, if the value can not be determined from
 GUI, command line option or config file.
 This is useful for options that rarely need to be changed.
 Setting them to 
\family typewriter
useDfault
\family default
 allows short command lines, and easy user input.
 
\end_layout

\begin_layout Itemize

\family typewriter
description
\family default
 is the description of this parameter, will be put into the usage information.
 ( 
\family typewriter
-h
\family default
 or help button in parameter dialog).
\end_layout

\begin_layout Itemize

\family typewriter
allowedTypes
\family default
 is the accepted types.
 If 
\family typewriter
allowedTypes
\family default
 is 
\family typewriter
types.ListType
\family default
 or 
\family typewriter
types.TupleType
\family default
 and the user's input is a scalar, the input will be converted to a list
 automatically.
\end_layout

\begin_layout Itemize

\family typewriter
validate
\family default
 is a function to validate the parameter.
 You can define your own functions or use the following from 
\family typewriter
simuOpt
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
valueGT(a), valueLT(a), valueGE(a), valueLE(a)
\family default
: check if the value is greater than, less than, greater than or equal to,
 less than or equal to a value 
\family typewriter
a
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
valueBetween(a,b), valueOneOf(list)
\family default
: check if the value is between 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 or is one from 
\family typewriter
list
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
valueValidFile(), valueValidDir()
\family default
: check if the parameter is a valid file/directory name.
\end_layout

\begin_layout Itemize

\family typewriter
valueIsNum()
\family default
: check if the parameter is a number.
\end_layout

\begin_layout Itemize

\family typewriter
valueListOf()
\family default
: check if the parameter is a list of a given type, in a list of types,
 or just pass a validator.
 For example, you can use 
\family typewriter
valueListOf(types.IntType)
\family default
, 
\family typewriter
valueListOf([types.IntType, types.LongType])
\family default
 or 
\family typewriter
valueListOf( valueValidFile())
\family default
.
 As you can see, validators can be nested.
\end_layout

\begin_layout Itemize

\family typewriter
valueOr(validator), valueAnd(val1, val2), valueOr(val1,val2)
\family default
: accept other validators and perform respective logical calculations.
 For example
\end_layout

\begin_deeper
\begin_layout LyX-Code
valueOr( valueGT(0), valueListOf( valueGT(0) ))
\end_layout

\begin_layout Standard
accepts a positive number, or a list of positive numbers.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family typewriter
chooseOneOf
\family default
: if specified, 
\family typewriter
simuOpt
\family default
 will choose one from a list of values using a listbox (Tk) or a combo box
 (wxPython) .
\end_layout

\begin_layout Itemize

\family typewriter
chooseFrom
\family default
: if specified, 
\family typewriter
simuOpt
\family default
 will choose one or more items from a list of values using a listbox (tk)
 or a combo box (wxPython) .
 
\end_layout

\begin_layout Itemize

\family typewriter
separator
\family default
: if specified, a blue label will be used to separate groups of parameters.
\end_layout

\begin_layout Itemize

\family typewriter
jump
\family default
: it is used to skip some parameters when doing the interactive user input.
 For example, 
\family typewriter
getParam
\family default
 will skip the rest of the parameters if 
\family typewriter
-h
\family default
 is specified since parameter 
\family typewriter
-h
\family default
 has item 
\family typewriter
'jump':-1
\family default
 which means that jump to the end.
 Another situation of using this value is when you have a hierarchical parameter
 set.
 For example, if mutation is on, specify mutation rate, otherwise proceed.
\end_layout

\begin_layout Itemize

\family typewriter
jumpIfFalse:
\family default
 The same as 
\family typewriter
jump
\family default
 but jump if current parameter is 
\family typewriter
False
\family default
.
\end_layout

\begin_layout Standard
With all these information at hand, the rest is routine, if you follow the
 coding conventions.
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
Operator and Function References
\end_layout

\begin_layout Standard
This chapter will list all functions, types and operators by category.
\end_layout

\begin_layout Section
Library-dependent functions/constants
\end_layout

\begin_layout Standard
Several functions and constants are defined for each library:
\end_layout

\begin_layout Itemize

\family typewriter
alleleType()
\family default
: return 
\family typewriter
'binary'
\family default
, 
\family typewriter
'short'
\family default
, or 
\family typewriter
'long'
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
MaxAllele
\family default
: 
\family typewriter
1
\family default
 for binary libraries, usually 
\family typewriter
255
\family default
 for short libraries and 
\begin_inset Formula $2^{32}-1$
\end_inset

 for long libraries.
 Note that these numbers for short and long libraries might be changed on
 different platforms.
\end_layout

\begin_layout Itemize

\family typewriter
simuVer()
\family default
: return the version string
\end_layout

\begin_layout Itemize

\family typewriter
simuRev()
\family default
: simuPOP revision number.
 If your script needs a recent version of simuPOP, it is a good idea to
 test 
\family typewriter
simuRev()
\family default
 against the revision when the feature you need becomes available.
\end_layout

\begin_layout Section

\family typewriter
carray
\begin_inset LatexCommand index
name "carray"

\end_inset


\family default
 type
\end_layout

\begin_layout Standard
The return value of simuPOP functions with names start with 
\family typewriter
arr
\family default
 is of a special Python type 
\family typewriter
carray
\family default
.
 This object reflects the underlying C/C++ array and you can read/write
 array elements just as a regular list.
 Only a small subset of list member functions of Python, 
\family typewriter
count, index
\family default
 to be exact, is available.
 This is because you are not allowed to change the size of the underlying
 C/C++ vector.
 The following shows the operations allowed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

# obtain an object using one of the arrXXX functions
\end_layout

\begin_layout Standard

pop = population(loci=[3,4], lociPos=[1,2,3,4,5,6,7])
\end_layout

\begin_layout Standard

arr = pop.arrLociPos()
\end_layout

\begin_layout Standard

# print and expression (just like list)
\end_layout

\begin_layout Standard

print arr
\end_layout

\begin_layout Standard

str(arr)
\end_layout

\begin_layout Standard

# count
\end_layout

\begin_layout Standard

arr.count(2)
\end_layout

\begin_layout Standard

# index 
\end_layout

\begin_layout Standard

arr.index, 2)
\end_layout

\begin_layout Standard

# can read write
\end_layout

\begin_layout Standard

arr[0] = 0.5
\end_layout

\begin_layout Standard

# convert to list
\end_layout

\begin_layout Standard

arr.tolist()
\end_layout

\begin_layout Standard

# or simply
\end_layout

\begin_layout Standard

list(arr)
\end_layout

\begin_layout Standard

# compare to list directly
\end_layout

\begin_layout Standard

arr == [0.5, 1.0, 3.0, 3.5, 5.0, 6.0, 7.0]
\end_layout

\begin_layout Standard

# you can also convert and compare
\end_layout

\begin_layout Standard

list(arr) == [0.5, 1.0, 3.0, 3.5, 5.0, 6.0, 7.0])
\end_layout

\begin_layout Standard

# slice
\end_layout

\begin_layout Standard

arr[:] = [1,2,3,4,5,6,7]
\end_layout

\begin_layout Standard

# arr1 is 1,2,3
\end_layout

\begin_layout Standard

arr1 = arr[:3]
\end_layout

\begin_layout Standard

# assign slice from a number
\end_layout

\begin_layout Standard

# IMPORTANT NOTE that arr will also be affected
\end_layout

\begin_layout Standard

# since arr1 point to a part of arr
\end_layout

\begin_layout Standard

arr1[:] = 10
\end_layout

\begin_layout Standard

# assign vector of the same length
\end_layout

\begin_layout Standard

arr1[:] = [30,40]
\end_layout

\begin_layout Standard

# assign from another part
\end_layout

\begin_layout Standard

arr[1:3] = arr[3:5]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No other operation is allowed.
 
\end_layout

\begin_layout Standard

\series bold
Important note:
\series default
 Objects returned from 
\family typewriter
arrXXX
\family default
 functions should be considered temporary.
 There is no guarantee that the underlying array will still be valid after
 any population operation.
 
\end_layout

\begin_layout Section
Use of R (RPy) in Python
\end_layout

\begin_layout Standard
Most of the information can be found in RPy manual.
 One function in simuRPy may help though:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def rmatrix(mat):
\end_layout

\begin_layout Standard

  ' convert a Python 2d list to r.matrix object'
\end_layout

\begin_layout Standard

  return with_mode(NO_CONVERSION, r.do_call)('rbind',mat)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this function, you can easily handle matrices in R.
 (List and array have been easy enough to be handled).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

>>> a = [[1,2],[4,5]]
\end_layout

\begin_layout Standard

>>> r.image( rmatrix(a))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the help of this function, you can call almost any R function directly,
 maybe except some R-only syntax like formula, expression etc.
 In this case, you can always do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

>>> r('''whatever R expression''')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since RPy is not always available, you may see the following scenario again
 and again in simuPOP scripts:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

try:
\end_layout

\begin_layout Standard

  from simuRPy import *
\end_layout

\begin_layout Standard

except:
\end_layout

\begin_layout Standard

  hasRPy = False
\end_layout

\begin_layout Standard

else:
\end_layout

\begin_layout Standard

  hasRPy = True
\end_layout

\begin_layout Standard

...
\end_layout

\begin_layout Standard

if hasRPy:
\end_layout

\begin_layout Standard

  r.....
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operator (Hybrid) 
\family typewriter
pyOperator
\begin_inset LatexCommand index
name "operator!pyOperator"

\end_inset

, pyIndOperator
\begin_inset LatexCommand index
name "operator!pyIndOperator"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
pyOperator
\end_layout

\begin_layout Standard
This is the single most powerful hybrid operator.
 Whenever you think that something is too complicated to be done by standard
 operators, you can do it here in Python.
 This operator accepts a Python function which accepts a population and
 optionally a parameter.
 To use this operator, you will need to 
\end_layout

\begin_layout Itemize
define a function that handle a population as you wish.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def myOperator(pop, para):
\end_layout

\begin_layout Standard

  'do whatever you want'
\end_layout

\begin_layout Standard

  return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you return 
\family typewriter
False
\family default
, this operator will work like a terminator.
 
\family typewriter
para
\family default
 will be omitted.
\end_layout

\end_deeper
\begin_layout Itemize
use 
\family typewriter
pyOperator
\family default
 like
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyOperator(mfunc=yOperator, param=para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
all parameters of an operator are supported except for 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
 which are ignored for now.
\end_layout

\end_deeper
\begin_layout Standard
When 
\family typewriter
pyOperator
\family default
 is called, it will simply pass the accepted population to the function.
 If your function returns 
\family typewriter
False
\family default
, the simulation will be stopped.
\end_layout

\begin_layout Standard
This operator allows implementation of arbitrarily complicated operators,
 at a cost of efficiency.
 Of course, to use this operator, you will have to know how to use population-re
lated functions.
 The following example shows how to implement a dynamic mutator which mutate
 loci according to their allele frequencies.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyOperator.log}[caption={define a python operator},label={pyOperator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyOperatorUse.log}[caption={use of python operator},label={pyOperatorUse}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Note that 
\end_layout

\begin_layout Itemize
Currently, 
\family typewriter
pyOperator
\family default
 does not support parameters 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
.
 This is because of the incompatibility between Python and underlying C++
 in the way of handling file I/O stream.
 Consequently, you will have to handle file input/output by yourself through
 
\family typewriter
param
\family default
 parameter.
 Be careful that you 
\series bold
\emph on
can not
\series default
\emph default
 mix output of 
\family typewriter
pyOperator
\family default
 with those of other (normal) operators.
\end_layout

\begin_layout Itemize
If parameter 
\family typewriter
param
\family default
 is ignored, 
\family typewriter
myOperator
\family default
 must be without 
\family typewriter
para
\family default
 as well.
 Note that you can pass arbitrary number of parameters by putting them into
 a tuple and passing to 
\family typewriter
myOpeartor
\family default
.
\end_layout

\begin_layout Itemize
Since you can attach any information to a population, you can in practice
 use 
\family typewriter
pop.dvars()
\family default
 to pass parameters.
\end_layout

\begin_layout Itemize

\family typewriter
pyOperator
\family default
 is a post-mating operator by default.
 Remember to use 
\family typewriter
stage
\family default
 parameter to change this when necessary.
\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 can also be a during-mating operator.
 You will need to define a function 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def Func(pop, off, dad, mom, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def shortFunc(off, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
para
\family default
 can be ignored.
 To use this operator, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyOperator(stage=DuringMating, func=Func, param=someparam, formOffGenotype=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyOperator(stage=DuringMating, func=shortFunc, param=someparam,
\end_layout

\begin_layout Standard

formOffGenotype=False, passOffspringOnly=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two additional parameters are:
\end_layout

\begin_layout Itemize

\family typewriter
formOffGenotype
\family default
:
\family typewriter
 
\family default
(default to 
\family typewriter
False
\family default
) By default, a mating scheme will set the genotype of offspring by copying
 one of the parental chromosomes.
 However, if 
\family typewriter
formOffGenotype
\family default
 is 
\family typewriter
True
\family default
, the mating scheme will let you do the job.
 You will have to set offspring genotype and sex by yourself, using, most
 likely, a recombinator.
\end_layout

\begin_layout Itemize

\family typewriter
passOffspringOnly
\family default
: In case that your function will only deal with offspring, you can set
 this parameter to 
\family typewriter
True
\family default
 and use a short form of the function.
 
\end_layout

\begin_layout Standard
Note that if your during-mating 
\family typewriter
pyOpeartor
\family default
 returns 
\family typewriter
False
\family default
, the individual will be discarded.
 Therefore, you can write a filter in this way.
 However, since the Python function will be called for each mating event,
 the cost of using such an operator is high, especially when population
 size is large.
\end_layout

\begin_layout Standard
An example of during-mating 
\family typewriter
pyOperator
\family default
 can be found in 
\family typewriter
scripts/demoPyOperator.py
\family default
.
\end_layout

\begin_layout Subsection

\family typewriter
pyIndOperator
\end_layout

\begin_layout Standard
Another general Python operator is 
\family typewriter
pyIndOperator
\family default
 which is similar to 
\family typewriter
pyOpertor
\family default
 but it passes the user individuals, rather than the whole population.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def func(ind, param):
\end_layout

\begin_layout Standard

  ind.setInfo(param[0], 'myinfo)
\end_layout

\begin_layout Standard

pyIndOperator(func=func, param=(1,))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is the same as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def func(pop, param):
\end_layout

\begin_layout Standard

  for ind in pop.individuals():
\end_layout

\begin_layout Standard

    ind.setInfo(param[0], 'myinfo')
\end_layout

\begin_layout Standard

pyIndOperator(func=func, param=(1,))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
pyIndOperator
\family default
 may have some performance advantages over 
\family typewriter
pyOperator
\family default
 in some cases.
\end_layout

\begin_layout Subsection
References of class 
\family typewriter
pyOperator
\family default
 and 
\family typewriter
pyIndOperator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyOperatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyIndOperatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Initialization
\begin_inset LatexCommand index
name "initializer"

\end_inset


\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
initializerRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
initByFreq
\begin_inset LatexCommand index
name "operator!initByFreq"

\end_inset

,
\family default
 function 
\family typewriter
InitByFreq
\begin_inset LatexCommand index
name "function!InitByFreq"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
initByFreqRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is an example of using 
\family typewriter
alleleFreq
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/initByFreq.log}[caption={Init by freq},label={initByFreq}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Please refer to 
\family typewriter
test/test_init.py
\family default
 for more complicated examples.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
initByValue
\begin_inset LatexCommand index
name "operator!initByValue"

\end_inset

,
\family default
 function 
\family typewriter
InitByValue
\begin_inset LatexCommand index
name "function!InitByValue"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
initByValueRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/initByValue.log}[caption={Init by value},label={initByValue}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
spread
\begin_inset LatexCommand index
name "operator!spread"

\end_inset

,
\family default
 function 
\family typewriter
Spread
\begin_inset LatexCommand index
name "function!Spread"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
spreadRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyInit
\begin_inset LatexCommand index
name "operator!pyInit"

\end_inset

,
\family default
 function 
\family typewriter
PyInit
\begin_inset LatexCommand index
name "function!PyInit"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyInitRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyInit.log}[caption={Init by value},label={pyInit}]
preview false

\end_inset


\end_layout

\begin_layout Section
Migration
\begin_inset LatexCommand index
name "migrator"

\end_inset


\end_layout

\begin_layout Subsection
Class reference and Opertor (C++) 
\family typewriter
migrator
\begin_inset LatexCommand index
name "operator!migrator"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
migratorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Operator 
\family typewriter
migrator
\family default
 is used to migrate from 
\family typewriter
'fromSubPop'
\family default
 to 
\family typewriter
'toSubPop'.

\family default
 From and to subpop can be a number or an array of subpopulations.
 The migration probability/rate/counts from 
\family typewriter
i->j
\family default
 is specified in the rate matrix.
 The 
\family typewriter
'fromSubPop'
\family default
 and 
\family typewriter
'toSubPop'
\family default
 are default to all subpopulations.
\end_layout

\begin_layout Standard
An detailed example can be found in 'some real examples' -> 'complex Migration
 Scheme' section.
\end_layout

\begin_layout Subsection
Functions (Python) 
\family typewriter
MigrIslandRates
\begin_inset LatexCommand index
name "Function!migrIslandRates"

\end_inset

, MigrStepstoneRates
\begin_inset LatexCommand index
name "Function!migrStepstoneRates"

\end_inset


\family default
 (simuUtil.py)
\end_layout

\begin_layout Standard
Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpopulations
 to any (even new) other subset of subpopulations.
 Several functions are defined in simuUtil.py, however, for easy use of popular
 migration models:
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrStepstoneRates(r, n, circular=False)
\family default
 returns a migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++/Hybrid) 
\family typewriter
pyMigrator
\begin_inset LatexCommand index
name "operator!pyMigrator"

\end_inset


\end_layout

\begin_layout Standard
For even more complicated migration schemes, you may DIY using a 
\family typewriter
pyMigrator
\family default
.
 This operator is not strictly hybrid since it does not call Python function.
 However, it takes a 
\family typewriter
carray
\family default
 as subpopulation IDs for each individual.
 
\family typewriter
pyMigrator
\family default
 then complete migration according its content.
 For example:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyMigrator.log}[caption={pyMigrator},label={pyMigrator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Note that the application sequence of the operators is 
\family typewriter
initByFreq
\family default
, 
\family typewriter
dumper
\family default
,
\family typewriter
 pyMigrator
\family default
 and then 
\family typewriter
dumper
\family default
 again since its stage is set to 
\family typewriter
PrePostMating
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyMigratorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
splitSubPop
\family default

\begin_inset LatexCommand index
name "operator!splitSubPop"

\end_inset

, function 
\family typewriter
SplitSubPop
\begin_inset LatexCommand index
name "function!SplitSubPop"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
splitSubPopRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mergeSubPops
\family default

\begin_inset LatexCommand index
name "operator!mergeSubPops"

\end_inset

, function 
\family typewriter
MergeSubPops
\begin_inset LatexCommand index
name "function!MergeSubPops"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mergeSubPopsRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mutation
\begin_inset LatexCommand index
name "Mutation"

\end_inset


\end_layout

\begin_layout Standard
The only difference between the following mutators is the way they actually
 mutate an allele, and corresponding input parameters.
\end_layout

\begin_layout Standard
Mutators record the number of mutation events at each loci.
 You can retrieve this information using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

mut.mutationCount(locus)
\end_layout

\begin_layout Standard

mut.mutationCounts()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
mut
\family default
 is any mutator and 
\family typewriter
locus
\family default
 is locus index.
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
kamMutator
\begin_inset LatexCommand index
name "operator!kamMutator"

\end_inset

,
\family default
 function 
\family typewriter
KamMutate
\begin_inset LatexCommand index
name "function!KamMutate"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
kamMutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is an example of 
\family typewriter
kamMutator
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/kamMutator.log}[caption={kamMutator},label={kamMutator}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
smmMutator
\begin_inset LatexCommand index
name "operator!smmMutator"

\end_inset

,
\family default
 function 
\family typewriter
SmmMutate
\begin_inset LatexCommand index
name "function!SmmMutate"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
smmMutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following example demonstrates the use of 
\family typewriter
smmMutator
\family default
.
 Note that although the mutation rate is 1, some allele 1 is not mutated
 since they can not be mutated to 0.
 The same will be hold for the upper bound 
\family typewriter
maxAllele
\family default
 which is defaulted to 99 in this case.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/smmMutator.log}[caption={smmMutator},label={smmMutator}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++/Hybrid) 
\family typewriter
gsmMutator
\begin_inset LatexCommand index
name "operator!gsmMutator"

\end_inset

,
\family default
 function 
\family typewriter
GsmMutate
\begin_inset LatexCommand index
name "function!GsmMutate"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
gsmMutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is an example of 
\family typewriter
gsmMutator
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/gsmMutator.log}[caption={gsmMutator},label={gsmMutator}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyMutator
\begin_inset LatexCommand index
name "operator!pyMutator"

\end_inset

,
\family default
 function 
\family typewriter
PyMutate
\begin_inset LatexCommand index
name "function!PyMutate"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyMutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you can not accomplish your task with the above mutators, you can always
 use this hybrid mutator.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyMutator.log}[caption={pyMutator},label={pyMutator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
pointMutator
\begin_inset LatexCommand index
name "operator!pointMutator"

\end_inset

,
\family default
 function 
\family typewriter
PointMutate
\begin_inset LatexCommand index
name "function!PointMutate"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pointMutatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Recombination
\begin_inset LatexCommand index
name "recombination"

\end_inset


\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
recombinatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
recombinator
\begin_inset LatexCommand index
name "operator!recombinator"

\end_inset


\end_layout

\begin_layout Standard
This operator takes similar parameters as a mutator.
 However, because of potentially uneven allelic distance, you should use
 one of the two parameters listed in the last section.
\end_layout

\begin_layout Standard
The following example forces recombination (with rate 1, an unrealistic
 value since the maximum recombination rate should be .5) at loci 2, 6 and
 10.
 Here I use a 
\family typewriter
parentsTagger
\family default
 to mark the parents of each individual so you can (if you have enough patience)
 see exactly how recombination works.
 
\begin_inset Include \lstinputlisting{log/recombinator.log}[caption={Recombinator},label={recombinator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Recombinations after each locus will be recorded.
 You can retrieve this information through functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

rec.recCount(locus)
\end_layout

\begin_layout Standard

rec.recCounts()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
rec
\family default
 is the recombinator, 
\family typewriter
locus
\family default
 is locus index.
 
\end_layout

\begin_layout Section
Selection
\begin_inset LatexCommand index
name "selection"

\end_inset

 
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
selectorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mechanism
\end_layout

\begin_layout Standard
It is not very clear that our method agrees with the traditional 'average
 number of offspring' definition of fitness.
 (Note that this concept is very difficult to simulate since we do not know
 who will determine the number of offspring if two parents are involved.)
 We can, instead, look at the consequence of selection in a simple case
 (as derived in any population genetics textbook):
\end_layout

\begin_layout Quote
At generation 
\begin_inset Formula $t$
\end_inset

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset

 etc., should be
\end_layout

\begin_layout Quote
\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset


\end_layout

\begin_layout Standard
Now, using the 'ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset

 will be the number of 
\begin_inset Formula $11$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset

The same argument applies to the case of arbitrary number of genotypes and
 random mating.
 
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
selector alone can not do selection! Only mating schemes can actually select
 on individuals.
\end_layout

\begin_layout Itemize
selector has to be 
\family typewriter
PreMating
\family default
 operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter
PreMating
\family default
.
 However, if you use the function form of these selectors in a 
\family typewriter
pyOperator
\family default
, make sure to set the stage of 
\family typewriter
pyOperator
\family default
 to 
\family typewriter
PreMating
\family default
.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapSelector
\begin_inset LatexCommand index
name "operator!mapSelector"

\end_inset

,
\family default
function 
\family typewriter
MapSelector
\begin_inset LatexCommand index
name "function!MapSelect"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mapSelectorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following example is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if
\begin_inset Formula \begin{eqnarray*}
s_{1} & = & w_{12}-w_{11}\\
s_{2} & = & w_{12}-w_{22}\end{eqnarray*}

\end_inset

the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/basicSelector.log}[caption={map selector},label={basicSelector}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maSelector
\begin_inset LatexCommand index
name "operator!maSelector"

\end_inset

,
\family default
 function 
\family typewriter
MaSelect
\begin_inset LatexCommand index
name "function!MaSelect"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
maSelectorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
maSelector
\family default
 accepts an array of fitness values:
\end_layout

\begin_layout Itemize
For single-locus, 
\family typewriter
fitness
\family default
 is the fitness for genotype AA, Aa, aa, while A stands for wildtype alleles.
 
\end_layout

\begin_layout Itemize
For a two-locus model, 
\family typewriter
fitness
\family default
 is the fitness for genotype 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bb
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
AA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{12}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{13}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{21}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{22}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{23}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{31}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{32}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $w_{33}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
in the order of 
\begin_inset Formula $w_{11},w_{12,}...,w_{32},w_{33}$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Itemize
For a model with more than two loci, use a table of length 
\begin_inset Formula $3^{n}$
\end_inset

 in a order similar to the two-locus model.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlSelector
\begin_inset LatexCommand index
name "operator!mlSelector"

\end_inset


\family default
, function 
\family typewriter
MlSelect
\begin_inset LatexCommand index
name "function!MlSelect"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mlSelectorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pySelector
\begin_inset LatexCommand index
name "operator!pySelector"

\end_inset


\family default
, function 
\family typewriter
PySelect
\begin_inset LatexCommand index
name "function!PySelect"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pySelectorRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following example simulates the same scenario as before, with 
\begin_inset Formula $s_{1}=.2,s_{2}=.3$
\end_inset

 (so
\begin_inset Formula $p=.6$
\end_inset

) and a 
\family typewriter
pySelector
\family default
.
 Note that although alleles at two loci are passed, the 
\family typewriter
sel
\family default
 function only uses alleles from the first one.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pySelector.log}[caption={python selector},label={pySelector}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Penetrance
\begin_inset LatexCommand index
name "penetrance"

\end_inset


\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
penetranceRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapPenetrance
\family default

\begin_inset LatexCommand index
name "operator!mapPenetrance"

\end_inset

 (post, during-Mating), function 
\family typewriter
MapPenetrance
\begin_inset LatexCommand index
name "function!MapPenetrance"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mapPenetranceRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of this operator is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

mapPenetrance(locus=1, penetrance={'1-1':0, '1-2':0.5, '2-2':1})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this dictionary can take more than three elements to accommendate
 more than one disease alleles.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maPenetrance
\family default

\begin_inset LatexCommand index
name "operator!maPenetrance"

\end_inset

 (post, during-Mating), function 
\family typewriter
MaPenetrance
\begin_inset LatexCommand index
name "function!MaPenetrance"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
maPenetranceRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of operator 
\family typewriter
maPenetrance
\family default
 is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

maPenetrance(loci=[1,5], wildtype=[1], penetrance=[0,0.5,1,0,0,1,0,1,1])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This operator behaves the same as the 
\family typewriter
mapPenetrance
\family default
 example but will work if there are more than one disease alleles.
 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlPenetrance
\family default

\begin_inset LatexCommand index
name "operator!mlPenetrance"

\end_inset

(post, during-Mating), function 
\family typewriter
MlPenetrance
\begin_inset LatexCommand index
name "function!MlPenetrance"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mlPenetranceRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, if each locus follows an additive penetrance model, we can
 have
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pen = []
\end_layout

\begin_layout Standard

for loc in loci:
\end_layout

\begin_layout Standard

  pen.append( maPenetrance(locus=loc, wildtype=[1],
\end_layout

\begin_layout Standard

    penetrance=[0.0.3,0.6] ) )
\end_layout

\begin_layout Standard

# the multi-loci penetrance
\end_layout

\begin_layout Standard

penMulti = mlPenetrance(mode=PEN_Multiplicative, peneOps=pen)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyPenetrance
\family default

\begin_inset LatexCommand index
name "operator!pyPenetrance"

\end_inset

(post, during-Mating), function 
\family typewriter
PyPenetrance
\begin_inset LatexCommand index
name "function!PyPenetrance"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyPenetranceRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, for the same multi-locus model before, we can define the following
 function using 
\family typewriter
pyPenetrance
\family default
 as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def peneFunc(geno):
\end_layout

\begin_layout Standard

  p = 1
\end_layout

\begin_layout Standard

  for l in range(len(geno)/2):
\end_layout

\begin_layout Standard

    p *= (geno[l*2]+geno[l*2+1]-2)*0.3
\end_layout

\begin_layout Standard

  return p
\end_layout

\begin_layout Standard

penMulti = pyPenetrance(loci=loci, func=peneFunc)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, using this operator, you can define arbitrarily complex
 penetrance functions.
 Typical such penetrance functions are interaction between loci (using a
 multi-locus penetrance table), even random ones.
\end_layout

\begin_layout Standard
It would be useful to let 
\family typewriter
peneFunc
\family default
 take parameters.
 This can be done by defining a Python function that returns a penetrance
 function.
 This may sound intimidating but it is really easy:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def peneFunc(table):
\end_layout

\begin_layout Standard

  def func(geno):
\end_layout

\begin_layout Standard

    return table[geno[0]-1][geno[1]-1]
\end_layout

\begin_layout Standard

  return func
\end_layout

\begin_layout Standard

# then, given a table, you can do
\end_layout

\begin_layout Standard

pen = pyPenetrance(loci=loci, func=peneFunc( ((0,0.5),(0.3,0.8)) ) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, for any table, you can use 
\family typewriter
peneFunc
\family default
 to return a penetrance function that uses this table.
\end_layout

\begin_layout Section
Quantitative Trait
\begin_inset LatexCommand index
name "quantitative trait"

\end_inset


\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
quanTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mapQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!mapQuanTrait"

\end_inset

, function 
\family typewriter
MapQuanTrait
\begin_inset LatexCommand index
name "function!MapQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mapQuanTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
maQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!maQuanTrait"

\end_inset

, function 
\family typewriter
MaQuanTrait
\begin_inset LatexCommand index
name "function!MaQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
maQuanTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
mlQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!mlQuanTrait"

\end_inset

, function 
\family typewriter
MlQuanTrait
\begin_inset LatexCommand index
name "function!MlQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mlQuanTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (Hybrid) 
\family typewriter
pyQuanTrait
\family default

\begin_inset LatexCommand index
name "operator!pyQuanTrait"

\end_inset

, function 
\family typewriter
PyQuanTrait
\begin_inset LatexCommand index
name "function!PyQuanTrait"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyQuanTraitRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Ascertainment"

\end_inset

Ascertainment
\begin_inset LatexCommand index
name "ascertainment"

\end_inset

 (subset of population)
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
sampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
function 
\family typewriter
population::shrinkByIndID
\begin_inset LatexCommand index
name "thrinkByIndInfo"

\end_inset

()
\end_layout

\begin_layout Standard
This function looks at the 
\family typewriter
subPopID()
\family default
 field of each individual and remove anyone with a negative value.
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
pySubset
\family default

\begin_inset LatexCommand index
name "operator!pySubset"

\end_inset

, function 
\family typewriter
PySubset
\family default

\begin_inset LatexCommand index
name "function!PySubset"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pySubsetRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++/hybrid) 
\family typewriter
pySample
\begin_inset LatexCommand index
name "operator!pySample"

\end_inset

,
\family default
 function 
\family typewriter
PySample
\begin_inset LatexCommand index
name "function!PySample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
PySample
\begin_inset LatexCommand index
name "function!PySample"

\end_inset

(pop, info, name, saveAs, format)
\family default
 or 
\family typewriter
Sample
\begin_inset LatexCommand index
name "function!Sample"

\end_inset

(pop)
\family default
 if you already set subpopulation ID for each individual using 
\family typewriter
setSubPopID
\begin_inset LatexCommand index
name "population!setInfo"

\end_inset

()
\family default
 function.
 The operator version of these functions are 
\family typewriter
pySample
\begin_inset LatexCommand index
name "operator!pySample"

\end_inset

(info, times, name, nameExpr, saveAs, saveAsExpr, format)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pySampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
randomSample
\begin_inset LatexCommand index
name "operator!randomSample"

\end_inset

,
\family default
 function 
\family typewriter
RandomSample
\begin_inset LatexCommand index
name "function!RandomSample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
RandomSample
\begin_inset LatexCommand index
name "function!RandomSample"

\end_inset

(pop, size, times, name, saveAs, format)
\family default
 will randomly choose size individuals (or 
\family typewriter
sizes
\family default
 from subpopulations) and return a new population.
 The operator version is 
\family typewriter
randomSample
\family default

\begin_inset LatexCommand index
name "operator!randomSample"

\end_inset

(
\family typewriter
size, times, name, nameExpr, saveAs, saveAsExpr, format
\family default
).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
randomSampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Opeartor (C++) 
\family typewriter
caseControlSample
\begin_inset LatexCommand index
name "operator!caseControlSample"

\end_inset

,
\family default
 function 
\family typewriter
CaseControlSample
\begin_inset LatexCommand index
name "function!CaseControlSample"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
CaseControlSample(pop, cases, controls, times, name, saveAs, format)
\family default
 will randomly choose cases affected individuals and controls unaffected
 individuals.
 The operator version of this function is 
\family typewriter
caseControlSample(case, cases, control, controls, times, name, nameExpr,
 saveAs, saveAsExpr, format)
\family default
.
 
\end_layout

\begin_layout Standard
The following example shows how to draw a random sample (without replacement
 of course) from an existing population.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/randomSample.log}[caption={random sample},label={randomSample}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
caseControlSampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
affectedSibpairSample
\family default

\begin_inset LatexCommand index
name "operator!affectedSibpairsSample"

\end_inset

, function 
\family typewriter
AffectedSibpairSample
\family default

\begin_inset LatexCommand index
name "function!AffectedSibpairsSample"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
affectedSibpairSampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

endGen = 1000
\end_layout

\begin_layout Standard

# having two offsprings only at the last three generations
\end_layout

\begin_layout Standard

def numOffsprings(gen):
\end_layout

\begin_layout Standard

  if gen >= endGen - 3:
\end_layout

\begin_layout Standard

    return 2
\end_layout

\begin_layout Standard

  else 
\end_layout

\begin_layout Standard

    return 1
\end_layout

\begin_layout Standard

# evolve ...
\end_layout

\begin_layout Standard

simu = simulator(pop, randomMating(numOffspringsFunc = numOffsprings))
\end_layout

\begin_layout Standard

simu.evolve( ...
\end_layout

\begin_layout Standard

  parentsTagger(begin = endGen - 3),
\end_layout

\begin_layout Standard

  mapPenetrance(...., begin = endGen - 2),
\end_layout

\begin_layout Standard

  setAncestralDepth(1, at = endGen -2 )
\end_layout

\begin_layout Standard

...)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to let your population evolve 
\emph on
normally
\emph default
 and start to store ancestral generations and allow multiple offspring at
 the last several generations.
\end_layout

\begin_layout Standard
Briefly, you should
\end_layout

\begin_layout Itemize
set the ancestral depth to at least 
\family typewriter
1
\family default
 to allow analyzing of the parental generation.
\end_layout

\begin_layout Itemize
use 
\family typewriter
parentsTagger
\family default
 to track parents for each individual, with the usual limit of no post-mating
 migration.
 
\end_layout

\begin_layout Itemize
allow multiple offspring at least at the last generation.
 (You do not have to use fixed number of offspring.
 Other mating mode like 
\family typewriter
MATE_GeometricDistribution
\family default
 can also be used.)
\end_layout

\begin_layout Itemize
use a penetrance operator to set affected status of each individual
\end_layout

\begin_layout Standard
and finally use this operator (or function)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

affectedSibpairSample(size,  times, name, saveAs, format)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to get samples accessible from 
\family typewriter
dvars().name[i]
\family default
.
 Each sample will
\end_layout

\begin_layout Itemize
have 2*
\family typewriter
size
\family default
 of paired individuals.
 (e.g.
 
\family typewriter
individual(2n)
\family default
 and 
\family typewriter
individual(2n+1)
\family default
,
\family typewriter
 n=0,1,...
\family default
,
\family typewriter
 size-1
\family default
 are siblings.)
\end_layout

\begin_layout Itemize
have an ancestral generation of the same size, with parents to the sibling
 pairs.
\end_layout

\begin_layout Itemize
if 
\family typewriter
size
\family default
 is an array, get 
\family typewriter
size[sp]
\family default
 sibling pairs from subpopulation 
\family typewriter
sp
\family default
 .
\end_layout

\begin_layout Standard
Other than samples 
\family typewriter
name
\family default
, variable 
\family typewriter
numSibpairs
\family default
 will be set to indicate the total number of affected sibling pairs in the
 population.
 Subpopulation structure will be kept in the samples so you will know how
 many individuals are drawn from each subpopulation.
 (This information is also saved in variable 
\family typewriter
numSibpairs
\family default
 of each sample.)
\end_layout

\begin_layout Subsection
largePedigreeSample
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
largePedigreeSampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
nuclearFamilySample
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
nuclearFamilySampleRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Statistics Calculation
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
statorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
stat
\begin_inset LatexCommand index
name "operator!stat"

\end_inset

,
\family default
 function 
\family typewriter
Stat
\begin_inset LatexCommand index
name "function!Stat"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
statRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Linkage disequilibrium 
\end_layout

\begin_layout Itemize
parameter:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

LD: LD = [ [1,2], [ 0,1,1,2],[1,2,1,2]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
For each item 
\family typewriter
[loc1, loc2, allele1, allele2]
\family default
, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 will be calculated based on allele1 at loc1 and allele2 at loc2.
 If only two loci are given, the LD values are averaged over all allele
 pairs.
 For example, for allele 
\begin_inset Formula $A$
\end_inset

 at locus 1 and allele 
\begin_inset Formula $B$
\end_inset

 at locus 2, 
\begin_inset Formula \begin{eqnarray*}
D & = & P_{AB}-P_{A}P_{B}\\
D' & = & D/D_{max}\\
D_{max} & = & \begin{cases}
\min\left(P_{A}\left(1-P_{B}\right),\left(1-P_{A}\right)P_{B}\right) & \textrm{if }D>0\\
\min\left(P_{A}P_{B},\left(1-P_{A}\right)\left(1-P_{B}\right)\right) & \textrm{if }D<0\end{cases}\\
r^{2} & = & \frac{D^{2}}{P_{A}\left(1-P_{A}\right)P_{B}\left(1-P_{B}\right)}\end{eqnarray*}

\end_inset

If 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are not specified, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 will be the averaged value: (basically 
\begin_inset Formula $\sum\sum P_{A}P_{B}\left|\right|$
\end_inset

 )
\begin_inset Formula \begin{eqnarray*}
D & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D_{ij}\right|\\
D' & = & \sum_{i}\sum_{j}P_{i}P_{j}\left|D'_{ij}\right|\\
r^{2} & = & \sum_{i}\sum_{j}P_{i}P_{j}r_{ij}^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{\left(1-P_{i}\right)\left(1-P_{j}\right)}\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $p_{i}$
\end_inset

 and 
\begin_inset Formula $q_{j}$
\end_inset

 are the population allele frequencies of the 
\begin_inset Formula $i$
\end_inset

th allele on loc1 and the 
\begin_inset Formula $j$
\end_inset

th allele on loc2.
 Please note that some other authors uses
\begin_inset Formula \[
r^{2}=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{P_{i}P_{j}}\]

\end_inset

If you are sure the later is correct, please send me an email (with reference).
\end_layout

\end_deeper
\begin_layout Section
Expression and Statements
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
output
\begin_inset LatexCommand index
name "operator!output"

\end_inset


\end_layout

\begin_layout Standard
This operator output a simple string.
 For example, 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

output(r'
\backslash
n', rep=REP_LAST)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
output a newline at the last replicate.
 
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
tab
\begin_inset LatexCommand index
name "operator!tab"

\end_inset

 (defined in simuUtli.py)
\end_layout

\begin_layout Standard
Output a tab.
 (Wrapper of output operator)
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
endl
\begin_inset LatexCommand index
name "operator!endl"

\end_inset

 (defined in simuUtli.py)
\end_layout

\begin_layout Standard
Output a new line.
 (Wrapper of output operator)
\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyEval
\begin_inset LatexCommand index
name "operator!pyEval"

\end_inset

,
\family default
 function 
\family typewriter
PyEval
\begin_inset LatexCommand index
name "function!PyEval"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyEvalRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (hybrid) 
\family typewriter
pyExec
\begin_inset LatexCommand index
name "operator!pyEval"

\end_inset


\family default
, function 
\family typewriter
PyExec
\begin_inset LatexCommand index
name "function!PyExec"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyExecRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function (Python) 
\family typewriter
ListVars (defined in simuUtil.py)
\end_layout

\begin_layout Standard

\family typewriter
ListVars
\begin_inset LatexCommand index
name "function!listVars"

\end_inset

(variable)
\end_layout

\begin_layout Standard
This function lists any variable in an indented text format.
 You can use 
\family typewriter
listVar(simuVars)
\family default
 to have a look at all replicates or 
\family typewriter
listVar(simuVars[0]['subPop'][0])
\family default
 to see variables for the first subpopulation in replicate one.
\end_layout

\begin_layout Section
Visualization
\end_layout

\begin_layout Standard
There is no special visualizer (there was indeed a matlabPlotter before
 ver 0.5.9 but I decide to remove it since matlab is not universally available.)
 Since everything is exposed dynamically, all you need to do is plotting
 variables in whatever way you prefer.
 The basic steps are:
\end_layout

\begin_layout Itemize
find an appropriate tool.
 I prefer R/Rpy to any other tools since I am familiar with R.
 You can make your own choice.
\end_layout

\begin_layout Itemize
write a function to plot variable.
 If you would like to plot history of a variable, you can use the 
\family typewriter
Aggregator
\family default
 object defined in 
\family typewriter
simuUtil.py
\family default
.
 
\end_layout

\begin_layout Itemize
wrap this function as an operator.
\end_layout

\begin_layout Standard

\family typewriter
simuRPy.py
\family default
 provides a pure Python operator 
\family typewriter
varPlotter
\family default
.
 It is defined in 
\family typewriter
simuSciPy
\family default
 and 
\family typewriter
simuMatPlt.py
\family default
 as well but they are lack of subplot capacity (so the usages are different)
 due to the limit of SciPy/gplt and MatPlotLib's plotting capacities.
 Also note as of Apr, 2006, the development of gplt in scipy was stopped
 so support of simuPOP/simuSciPy was stopped as well.
\end_layout

\begin_layout Subsection
Operator (Python) 
\family typewriter
varPlotter (simuRPy.py)
\end_layout

\begin_layout Standard
The use of 
\family typewriter
varPlotter
\family default
 is easy, if you would like to 
\end_layout

\begin_layout Subsubsection*
Plotting with history
\end_layout

\begin_layout Itemize
plot a number in the form of a variable or expression, use
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

varPlotter(var='expr')
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
plot a vector in the same window and there is only one replicate in the
 simulator, use
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

varPlotter(var='expr', varDim=len)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
len
\family default
 is the dimension of your variable or expression.
 Each line in the figure represents the history of an item in the array.
\end_layout

\end_deeper
\begin_layout Itemize
plot a vector in the same window and there are several replicates, use 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

varPlotter(var='expr', varDim=len, numRep=nr, byRep=1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
varPlotter
\family default
 will try to use an appropriate layout for your subplots (for example, use
 3x4 if 
\family typewriter
numRep=10
\family default
).
 You can also specify parameter 
\family typewriter
mfrow
\family default
 to change the layout.
\end_layout

\end_deeper
\begin_layout Itemize
if you would like to plot each item of your array variables in a subplot,
 use
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

varPlotter(var='expr', varDim=len, byVal=1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or in case of a single replicate
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

varPlotter(var='expr', varDim=len, byVal=1, numRep=nr)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There will be 
\family typewriter
numRep
\family default
 lines in each subplot.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Plotting without history
\end_layout

\begin_layout Itemize
use option 
\family typewriter
history=False
\family default
.
 Parameters 
\family typewriter
byVal, varDim
\family default
 etc.
 will be ignored.
 
\end_layout

\begin_layout Standard
Other options are
\end_layout

\begin_layout Enumerate

\family typewriter
title, xtitle, ytitle:
\family default
 title of your figure(s).
 
\family typewriter
title
\family default
 is default to your expression, 
\family typewriter
xtitle
\family default
 is defaulted to 
\family typewriter
generation
\family default
.
\end_layout

\begin_layout Enumerate

\family typewriter
win:
\family default
 window of generations.
 I.e., how many generations to keep in a figure.
 This is useful when you want to keep track of only recent changes.
\end_layout

\begin_layout Enumerate

\family typewriter
update:
\family default
 update figure after 
\family typewriter
update
\family default
 generations.
 This is used when you do not want to update the figure at every generation.
\end_layout

\begin_layout Enumerate

\family typewriter
saveAs:
\family default
 save figures in files 
\family typewriter
saveAs#gen.eps.

\family default
 For example, if 
\family typewriter
saveAs='demo
\family default
', you will get files 
\family typewriter
demo1.eps
\family default
, 
\family typewriter
demo2.eps
\family default
 etc.
\end_layout

\begin_layout Enumerate

\family typewriter
separate:
\family default
 plot data lines in separate panels.
 
\end_layout

\begin_layout Enumerate

\family typewriter
image:
\family default
 use R image function to plot image, instead of lines.
\end_layout

\begin_layout Enumerate

\family typewriter
level:
\family default
 level of image colors (default to 20).
\end_layout

\begin_layout Enumerate

\family typewriter
leaveOpen:
\family default
 whether or not leave the plot open when plotting is done.
 Default to 
\family typewriter
True
\family default
.
\end_layout

\begin_layout Standard
Here is an example:
\end_layout

\begin_layout LyX-Code
\begin_inset Include \verbatiminput{log/simuPlotter.log}
preview false

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Tagging (used for pedigree tracking) 
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
taggerRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
inheritTagger,
\family default
 duringMating
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
inheritTaggerRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
parentsTagger
\family default
, duringMating
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
parentsTaggerRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
pyTagger
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pyTaggerRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data collector
\end_layout

\begin_layout Standard
Sometimes, instead of output data directly, we may want to collect history
 data on some expression.
 Data collector is designed for this purpose.
 
\end_layout

\begin_layout Subsection
operator (Python) 
\family typewriter
collector
\begin_inset LatexCommand index
name "operator!collector"

\end_inset


\family default
, in 
\family typewriter
simuUtil.py
\end_layout

\begin_layout Standard
This operator accepts the following parameters:
\end_layout

\begin_layout Itemize

\family typewriter
name:
\family default
 name by which the collected data will be displayed.
 Variable names will be a list of stored values.
 (
\family typewriter
generation
\family default
 is not stored.
 You can always put it in 
\family typewriter
expr
\family default
 though.)
\end_layout

\begin_layout Itemize

\family typewriter
expr:
\family default
 an expression that will be evaluated.
 The result will be converted to a list (if needed) and stored in 
\family typewriter
name[gen]
\family default
.
\end_layout

\begin_layout Standard
When this operator is called, it will evaluate 
\family typewriter
expr
\family default
 and store its result in 
\family typewriter
name[gen]
\family default
.
 After evolution, you will get a dictionary of values indexed by generation
 numbers.
\end_layout

\begin_layout Section
Output 
\end_layout

\begin_layout Subsection
operator (C++) 
\family typewriter
savePopulation
\begin_inset LatexCommand index
name "operator!savePopulation"

\end_inset


\end_layout

\begin_layout Subsection
function (Python) 
\family typewriter
SaveFstat
\begin_inset LatexCommand index
name "function!SaveFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Subsection
operator (Python) 
\family typewriter
saveFstat
\begin_inset LatexCommand index
name "operator!saveFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Subsection
function (Python) 
\family typewriter
loadFstat
\begin_inset LatexCommand index
name "function!loadFstat"

\end_inset


\family default
 (in 
\family typewriter
simuUtil.py
\family default
)
\end_layout

\begin_layout Section
Terminator
\end_layout

\begin_layout Subsection
Class reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
terminatorRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
terminateIf
\begin_inset LatexCommand index
name "operator!terminateIf"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
terminateIfRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
continueIf
\begin_inset LatexCommand index
name "operator!terminateIf"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
continueIfRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conditional operator 
\end_layout

\begin_layout Subsection
Operator (C++) 
\family typewriter
ifElse
\begin_inset LatexCommand index
name "operator!ifelse"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
ifElseRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following example uses some advanced operators of simuPOP:
\end_layout

\begin_layout Itemize
set affected status using 
\family typewriter
maPenetrance
\family default
 as a 
\family typewriter
DuringMating
\family default
 operator (penetrance can be used at other stages).
 
\end_layout

\begin_layout Itemize
count the number of affected individuals.
 Note that this has to be done after the penetrance operator is applied.
 
\end_layout

\begin_layout Itemize
if no one is affected, inject some mutations into the population.
 Note the use of 
\family typewriter
ifElse
\family default
 operator.
\end_layout

\begin_layout Itemize
expose individual affectedness to the local namespaces.
 Note the use of 
\family typewriter
exposePop
\family default
 option.
 With this, you can call any population member function.
\end_layout

\begin_layout Itemize
plot affectedness, use image.
 
\end_layout

\begin_layout Itemize
use dryrun to exam simulator first.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/ifElse.log}[caption={Conditional operator},label={ifElse}]
preview false

\end_inset


\end_layout

\begin_layout Section
Miscellaneous
\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
noneOp
\begin_inset LatexCommand index
name "operator!noneOp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
noneOpRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This operator is used like follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

if savePop :
\end_layout

\begin_layout Standard

  saveOp = savePopulation(output='a.txt')
\end_layout

\begin_layout Standard

else:
\end_layout

\begin_layout Standard

  saveOp = noneOp()
\end_layout

\begin_layout Standard

simu.evolve( [ ...
 saveOp ])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
pause
\begin_inset LatexCommand index
name "operator!pause"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pauseRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
ticToc
\begin_inset LatexCommand index
name "operator!ticToc"

\end_inset


\family default
, function 
\family typewriter
TicToc
\begin_inset LatexCommand index
name "function!TicToc"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
ticTocRef
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operator: (C++) 
\family typewriter
setAncestralDepth
\family default
, function 
\family typewriter
pop.setAncestralDepth
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
setAncestralDepthRef
\end_layout

\end_inset


\end_layout

\begin_layout Section
Random Number Generator
\end_layout

\begin_layout Standard
Random number generator is a tricky business.
 Reliable and fast RNGs are hard to find and everyone seems to trust/distrust
 certain RNGs.
 To avoid such arguments, I have included all RNGs from GNU Scientific Library
 and you can choose any of the 61 RNGs, if you really know what the differences
 between them.
 (I do not, except that some of them are really bad but fast.) Note that
 RNG that can not generate a full range of integers are removed.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/rng.log}[caption={Random number generator},label={rng}]
preview false

\end_inset


\end_layout

\begin_layout Standard
If you need to use a random number generator in your 
\family typewriter
pyEval
\family default
 operator, you can either use Python random module (
\family typewriter
import random
\family default
) or use 
\family typewriter
rng
\begin_inset LatexCommand index
name "function!rng"

\end_inset

()
\family default
 function to get the random number generator of simuPOP.
 Note that 
\family typewriter
rng()
\family default
 does not have many member functions and it might be tricky to use them
 correctly.
 (This object is not designed to be used at Python level.
 For a full list of member functions, check 
\family typewriter
src/utility.h
\family default
)
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/rngrand.log}[caption={Random number generator},label={rngrand}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Since simuPOP 0.7.1, RNGs are seeded in the following order:
\end_layout

\begin_layout Itemize
use random number from 
\family typewriter
/dev/urandom
\family default
 if it is available
\end_layout

\begin_layout Itemize
use random number from 
\family typewriter
/dev/random
\family default
 if it is available
\end_layout

\begin_layout Itemize
use Python expression 
\family typewriter
(random.randint(0, sys.maxint) + int(time.time())) % sys.maxint
\family default
 .
 This method is used only if simuPOP is first loaded and you are going to
 set random number generator by yourself.
 The relevant codes in simuPOP.py are recommended in this case.
\end_layout

\begin_layout Standard
The seed can also be retrieved using 
\family typewriter
rng().seed()
\family default
 function, which should be saved for serious simulations.
\end_layout

\begin_layout Section
Debug-related operators/functions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
turnOnDebugRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
turnOffDebugRef
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Standard 
\family typewriter
simuPOP
\family default
 library can print out lots of debug information upon request.
 These are mostly used for internal debugging purposes but you can also
 use them when error happens.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

>>> population(1).individual(0).arrAllele()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is not clear why this simple line will cause us trouble, instead of outputtin
g the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

>>> TurnOnDebug(DBG_ALL)
\end_layout

\begin_layout Standard

Debug code DBG_ALL is turned on.
 cf.
 listDebugCode(), turnOffDebug() 
\end_layout

\begin_layout Standard

>>> population(1).individual(0).arrAlleles()
\end_layout

\begin_layout Standard

Constructor of Population is called
\end_layout

\begin_layout Standard

Population size 1
\end_layout

\begin_layout Standard

Destructor of Population is called 
\end_layout

\begin_layout Standard

Segmentation fault (core dumped) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
population(1)
\family default
 creates a temporary object that is destroyed right after the execution
 of the input.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is to create a persistent population object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

>>> pop = population(1)
\end_layout

\begin_layout Standard

>>> pop.individual(0).arrAllele()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the output is overwhelming after you turn on all debug information, you
 can turn on certain part of the information by using the following functions:
\end_layout

\begin_layout Itemize

\family typewriter
ListDebugCode
\begin_inset LatexCommand index
name "listDebugCode"

\end_inset

()
\family default
 list all debug code.
\end_layout

\begin_layout Itemize

\family typewriter
turnOnDebug()
\begin_inset LatexCommand index
name "operator!turnOnDebug"

\end_inset

, TurnOnDebug
\begin_inset LatexCommand index
name "Function!TurnOnDebug"

\end_inset

(code)
\family default
 turn on debug codes.
\end_layout

\begin_layout Itemize

\family typewriter
turnOffDebug()
\begin_inset LatexCommand index
name "operator!turnOffDebug"

\end_inset

, TurnOffDebug
\begin_inset LatexCommand index
name "Function!turnOffDebug"

\end_inset

(code)
\family default
 turn off debug codes.
\end_layout

\begin_layout Standard

\family typewriter
turnOnDebug()
\family default
 and 
\family typewriter
turnOffDebug()
\family default
 are operators and accept all operator parameters 
\family typewriter
begin, step
\family default
 etc.
 Usually, you can use 
\family typewriter
turnOnDebug
\family default
 to output more information about a potential bug before simuPOP starts
 to misbehave.
 
\end_layout

\begin_layout Standard
Another useful debug code is 
\family typewriter
DBG_PROFILE.

\family default
 When turned on, it will display running time of each operator.
 This will give you a good sense of which operator runs slowly (or simply
 the order of operator execution if you are not sure).
 If most of the execution time is spent on a pure-Python operator, you may
 want to rewrite it in C++.
 Note that 
\family typewriter
DBG_PROFILE
\family default
 is suitable for measuring individual operator performance.
 If you would like to measure the execution time of all operators in several
 generations, 
\family typewriter
ticToc
\family default
 operator is better.
  
\end_layout

\begin_layout Chapter
Extending simuPOP
\end_layout

\begin_layout Standard
simuPOP can be extended easily using Python programming language.
 Because almost all data are exposed to the Python interface, your ability
 of extending simuPOP is 
\emph on
unlimited
\emph default
.
 However, because Python is slower than C++ and the exchange of data between
 internal C++ data structure and Python interface may be costly, it is not
 recommended to write frequently used operators in Python.
 Appropriate pure Python operators are visualizers, statistics calculators,
 file outputers etc.
\end_layout

\begin_layout Standard
To write simuPOP extension, you will have to know more about data structures
 and member functions of population.
 Note that for efficiency and implementation reasons, many of the following
 functions do not provide keyword parameters.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Genotypic-structure"

\end_inset

Genotypic structure
\end_layout

\begin_layout Standard
The genotypes of an individual are organized as a single array.
 For example, if you have an diploid individual with two chromosomes, having
 2 and 3 loci respectively.
 The genotypes should be in the order of
\end_layout

\begin_layout LyX-Code
0-0-0, 1-0-0, 0-1-0, 1-1-0, 2-1-0, 0-0-1, 1-0-1, 0-1-1, 1-1-1, 2-1-1,
\end_layout

\begin_layout Standard
where X-X-X are locus-chromosome-ploidy indices.
 An important consequence of this arrangement is that 'locus location' +
 'the total number of loci' is the location of the locus on the other set
 of chromosomes.
 
\end_layout

\begin_layout Standard
Several functions are provided to retrieve genotypic information:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\begin_inset LatexCommand index
name "function!ploidy"

\end_inset

()
\family default
, ploidy
\end_layout

\begin_layout Itemize

\family typewriter
numChrom
\begin_inset LatexCommand index
name "function!numChrom"

\end_inset

()
\family default
,
\family typewriter
 
\family default
the number of chromosomes
\end_layout

\begin_layout Itemize

\family typewriter
numLoci
\begin_inset LatexCommand index
name "function!numLoci"

\end_inset

(chrom)
\family default
, the number of loci on chromosome 
\family typewriter
chrom
\end_layout

\begin_layout Itemize

\family typewriter
totNumLoci
\begin_inset LatexCommand index
name "function!totNumLoci"

\end_inset

()
\family default
, the total number of loci
\end_layout

\begin_layout Itemize

\family typewriter
genoSize
\begin_inset LatexCommand index
name "function!genoSize"

\end_inset

()
\family default
, the size of genotype.
 Equals to 
\family typewriter
totNumLoci()*ploidy()
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
alleleName
\begin_inset LatexCommand index
name "function!alleleName"

\end_inset

()
\family default
, allele name given by parameter 
\family typewriter
alleleNames
\family default
.
 Otherwise the allele number is returned.
\end_layout

\begin_layout Itemize

\family typewriter
locusPos
\begin_inset LatexCommand index
name "function!locusPos"

\end_inset

(loc)
\family default
, the locus position on chromosome (Distance to the beginning of chromosome)
\end_layout

\begin_layout Itemize

\family typewriter
arrlociPos
\begin_inset LatexCommand index
name "function!arrLociPos"

\end_inset

()
\family default
, returns an 
\family typewriter
carray
\family default
 of the locus distances.
\end_layout

\begin_layout Standard
The last function is very interesting.
 It actually returns the reference of the internal locus distance array.
 If you change the values of the returned array, the internal locus distance
 will be changed! All functions with this property will be named 
\family typewriter
arrFunc()
\family default
.
\end_layout

\begin_layout Standard
The following example shows how to change the locus distance through this
 function.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/extgenostru.log}[caption={geno stru},label={extgenostru}]
preview false

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Accessing-genotype-and"

\end_inset

Accessing genotype and other info
\end_layout

\begin_layout Standard
Genotype of an individual can be retrieved through the following functions:
\end_layout

\begin_layout Itemize

\family typewriter
ind.allele
\begin_inset LatexCommand index
name "function!allele"

\end_inset

(index, p=0)
\family default
,
\end_layout

\begin_layout Itemize

\family typewriter
ind.setAllele
\begin_inset LatexCommand index
name "function!setAllele"

\end_inset

(value, index, p=0)
\family default
,
\end_layout

\begin_layout Itemize

\family typewriter
ind.arrGenotype
\begin_inset LatexCommand index
name "function!arrAlleles"

\end_inset

(p=0, ch=0)
\family default
,
\end_layout

\begin_layout Standard
where 
\family typewriter
p
\family default
 means ploidy.
 I.e., the index of the copy of chromosomes.
 
\family typewriter
ch
\family default
 means chromosome.
 For example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pop.individual(1).arrGenotype(1, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns an array of alleles on the third chromosome of the second copy of
 chromosomes, of the second individual in the population 
\family typewriter
pop
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/extgenotype.log}[caption={genotype},label={extgenotype}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Sex, affected status can be accessed through 
\family typewriter
sex, setSex, affected, setAffected
\family default
 functions.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/extother.log}[caption={genotype},label={extother}]
preview false

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Direct-populaiton-manipulation"

\end_inset

Direct population manipulation
\end_layout

\begin_layout Standard
FIXME
\end_layout

\begin_layout Section
Writing pure Python operator 
\end_layout

\begin_layout Standard
Now we know how to access information for individuals in a population, but
 how can we use them in reality? Namely, how can you write an pure Python
 operator?
\end_layout

\begin_layout Subsection
Use 
\family typewriter
pyOperator
\end_layout

\begin_layout Standard
There are two kinds of pure Python operators.
 The first one is easy: define a function and wrap it with a 
\family typewriter
pyOperator
\family default
 operator.
 This method is highly recommended because of its simplicity.
 Many user scripts will use this kind of pure Python operator.
 You can find such examples in scripts directory.
 A good one may be simuCDCV.py where a pure Python operator is used to calculate
 and visualize special statistics.
 
\end_layout

\begin_layout Standard
For example, if you would like to record a silly statistics, namely the
 genotype of the 
\begin_inset Formula $m$
\end_inset

 individual at locu 
\begin_inset Formula $n$
\end_inset

, you can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def sillyStat(pop, para):
\end_layout

\begin_layout Standard

  # para can be used to pass any number of parameters
\end_layout

\begin_layout Standard

  (filename, m, n) = para # unpack parameter
\end_layout

\begin_layout Standard

  f = open(filename)
\end_layout

\begin_layout Standard

  f.write('%d ' % pop.individual(m).allele(n) )
\end_layout

\begin_layout Standard

  f.close()
\end_layout

\begin_layout Standard

# then in the evole function
\end_layout

\begin_layout Standard

evolve(...
\end_layout

\begin_layout Standard

  ops=[ # other operators
\end_layout

\begin_layout Standard

    pyOperator(func=sillyStat, param=('file.txt', 2, 1) )
\end_layout

\begin_layout Standard

  ]
\end_layout

\begin_layout Standard

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is by default a post-mating operator, you can redefine its stage by 
\family typewriter
stage
\family default
 parameter.
 
\end_layout

\begin_layout Subsection
Use Python 
\family typewriter
eval
\family default
 function
\end_layout

\begin_layout Standard
This kind of pure Python operators acts more like an ordinary operator.
 They are usually 
\family typewriter
pyEval
\family default
 or 
\family typewriter
pyExec
\family default
 operators returned by a wrapper function.
 For example, the following function defines a 
\family typewriter
tab
\family default
 operator:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/tab.log}[caption={Tab operator},label={tab}]
preview false

\end_inset


\end_layout

\begin_layout Standard
This function actually returns an operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

output(r"
\backslash
t", rep=REP_LAST, begin=500)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This kind of operators have some advantages, namely
\end_layout

\begin_layout Itemize
it acts more like ordinary operator.
 
\end_layout

\begin_layout Itemize
it is more efficient since it is handled (at least the first layer) by a
 C/C++ operator.
\end_layout

\begin_layout Standard
However, because of its complexity, such operators can only be found in
 system libraries.
 You can ignore the rest of this section if 
\family typewriter
pyOperator
\family default
 is enough to you.
 
\end_layout

\begin_layout Standard
To define a pure Python operator, here are what you will generally do:
\end_layout

\begin_layout Itemize
write a function that acts on a population.
 This function should be able to be called like 
\family typewriter
func(simu.population(0))
\family default
.

\family typewriter
 
\end_layout

\begin_layout Itemize
wrap this function as an operator.
 
\end_layout

\begin_layout Standard
For example, function 
\family typewriter
saveInFstatFormat(pop, output, outputExpr, dict)
\family default
 saves a population in FSTAT format.
 Its definition is (first 15 lines)
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/extother.log}[caption={genotype},label={extother}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
you can use this function independently like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

saveInFstatFormat(simu.population(1),'a.txt')
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
pop.vars()
\family default
 is used to evaluate 
\family typewriter
outputExpr
\family default
.
 
\end_layout

\begin_layout Standard
Then you can wrap this function by an operator, actually a function that
 returns a 
\family typewriter
pyEval
\family default
 operator:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/saveFstat.log}[caption={save fstat},label={saveFstat}]
preview false

\end_inset


\end_layout

\begin_layout Standard
This function takes all parameters of an ordinary operator:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

saveFstat(at=[-1], outputExpr=r'a'+str(rep)+'.txt')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and generates a 
\family typewriter
pyEval
\family default
 operator (use above example).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyEval(exposePop=1, at=[-1], 
\end_layout

\begin_layout Standard

  stmts=r"""saveInFSTATFormat(pop,
\end_layout

\begin_layout Standard

    output='''''', outputExpr=r''' 'a'+str(rep)+'.txt' """ 
\end_layout

\begin_layout Standard

  )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example,
\end_layout

\begin_layout Itemize

\family typewriter
pyEval
\family default
 works in the local namespace of each replicate.
 To access that replicate of population, you should use the magic parameter
 
\family typewriter
exposePop
\family default
 of 
\family typewriter
pyEval
\family default
.
 When set 
\family typewriter
True
\family default
, 
\family typewriter
pyEval
\family default
 will automatically set a variable 
\family typewriter
pop
\family default
 in the current local namespace before any statement is executed.
 This is why we can call 
\family typewriter
saveInFSTATFormat(pop...)
\end_layout

\begin_layout Itemize

\family typewriter
'''a'''
\family default
 quotes are used to avoid conflicts with quotes in 
\family typewriter
outputExpr
\family default
 etc.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
 
\end_layout

\begin_layout Section
Ultimate extension: working in C++
\end_layout

\begin_layout Standard
It is sometimes desired to write simuPOP extension in C++.
 For example,
\end_layout

\begin_layout Itemize
when you need some other mating scheme.
\end_layout

\begin_layout Itemize
when you need certain operator that a pure Python implementation would be
 too slow.
\end_layout

\begin_layout Itemize
if some aspect of simuPOP is too limited (like the number of maximum alleles).
\end_layout

\begin_layout Standard
It is not difficult to write simuPOP extension in C++, once you know how
 simuPOP is organized.
 The general procedure is
\end_layout

\begin_layout Itemize
install the latest version of SWIG (>1.3.28)
\end_layout

\begin_layout Itemize
check out simuPOP source using subversion
\end_layout

\begin_layout Itemize
build from source and see if your programming environment works well
\end_layout

\begin_layout Itemize
to add an operator, make changes in appropriate 
\family typewriter
.h
\family default
 file.
 Check 
\family typewriter
simuPOP_common.i
\family default
 if your operator can not be used.
\end_layout

\begin_layout Standard
The source code is reasonably well commented with full doxygen based documentati
on.
 Please post to the simuPOP forum if you encounter any problem while writing
 operators in C++.
\end_layout

\begin_layout Section
Debugging
\end_layout

\begin_layout Subsection
Test scripts
\end_layout

\begin_layout Standard
There are many test scripts under the 
\family typewriter
test
\family default
 directory.
 It is recommended that you run the test scripts after you installed simuPOP.
 This will make sure that your system is working correctly.
 To run all tests, run
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

sh run_tests.sh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or, if you do not install RPy and R, run
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

sh run_tests.sh norpy
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please report any failed test.
\end_layout

\begin_layout Subsection
Memory leak detection
\end_layout

\begin_layout Standard
Python extensions tend to have memory leak problem, caused by the refcount
 mechanism.
 If your simuPOP script uses more and more RAM without population size increase,
 you may have this problem.
 You may try to disable individual operators and find out the offending
 operator if the problem persist.
 
\end_layout

\begin_layout Standard
Potential simuPOP developers can make use of simuPOP's built-in refcount
 detection mechanism.
 To use it,
\end_layout

\begin_layout Itemize
compile Python with configure option -- with - 
\family typewriter
pydebug
\family default
 .
 This will enable 
\family typewriter
sys.totalrefcount()
\family default
 etc.
\end_layout

\begin_layout Itemize
compile simuPOP with - 
\family typewriter
DPy_REF_DEBUG
\family default
.
 This can be done in setup.py, or better in SConstruct.
\end_layout

\begin_layout Standard

\family typewriter
simulator.evolve
\family default
 will check reference counts at the end of each generation and report any
 increased reference count.
 Some operators may create Python objects (like ascertainment operators)
 but if you see repeated warnings at each generation, there is definitely
 a memory leak.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "bibtotoc,plainnat"
bibfiles "bib/all"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
