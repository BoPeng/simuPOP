#LyX 1.6.2svn created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.9.1 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand{\lstlistlistingname}{List of Examples}
\renewcommand{\lstlistingname}{Example}

\sloppy

\definecolor{TitleColor}{rgb}{0.126,0.263,0.361}
\definecolor{LinkColor}{rgb}{0.208,0.374,0.486}
\definecolor{VerbatimColor}{rgb}{0,0,0}
\definecolor{VerbatimBackgroundColor}{rgb}{0.98,0.941,0.902}
\definecolor{VerbatimBorderColor}{rgb}{0,0,0}
\definecolor{VerbatimStringColor}{rgb}{0,0.5,0}
\definecolor{VerbatimCommentColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimPromptColor}{rgb}{0.588,0.098,0.054}

\usepackage{sectsty}
\sectionfont{\color{TitleColor}}
\subsectionfont{\color{TitleColor}}
\subsubsectionfont{\color{TitleColor}}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "simuPOP User's Guide"
\pdf_author "Bo Peng"
\pdf_keywords "simuPOP"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=TitleColor,urlcolor=LinkColor"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "alsoletter={>.},backgroundcolor={\color{VerbatimBackgroundColor}},basicstyle={\small\ttfamily\color{VerbatimColor}},commentstyle={\color{VerbatimCommentColor}\slshape},emph={[2]>>>,...},emphstyle={[2]\color{VerbatimPromptColor}\bf},language=Python,otherkeywords={>>>,...},showspaces=false,showstringspaces=false,showtabs=false,stringstyle={\color{VerbatimStringColor}},xleftmargin=10pt"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{7.5in} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2008 Bo Peng 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
simuPOP is provided as a number of Python modules, which provide of a large
 number of Python objects and functions, including population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 bundled scripts that perform simulations ranging from implementation of
 basic population genetics models to generating datasets under complex evolution
ary scenarios.
 No knowledge about Python or simuPOP would be needed to run these simulations,
 if they happen to fit your need.
\end_layout

\begin_layout Abstract
This user's guide shows you how to install and use simuPOP using a large
 number of examples.
 It describes all important concepts and features of simuPOP and shows you
 how to use them in a simuPOP script.
 For a complete and detailed description about all simuPOP functions and
 classes, please refer to the 
\emph on
simuPOP Reference Manual
\emph default
.
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP:
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
 (18): 3686-3687
\end_layout

\begin_layout Quote
Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
 mating populations using simuPOP.
 
\emph on
bioinformatics
\emph default
, 
\series bold
24
\series default
 (11) 1408-1409.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 'runSampleCode.py splitMerge.py', and simuPOP_ref.tex generated by 'doxygen;
 cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard
simuPOP is an individual-based forward-time population genetics simulation
 environment based on Python, a dynamic object-oriented programming language
 that has been widely used in biological studies.
 simuPOP provides a large number of Python objects and functions, and a
 mechanism to evolve populations forward in time.
 It is the users’ responsibility to write a Python script to form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 built-in scripts so that users who are unfamiliar with Python and simuPOP
 can perform some pre-specified simulation processes.
 These scripts range from implementation of basic population genetics models
 to generating datasets under complex evolutionary scenarios.
 In addition, simuPOP modules and functions are provided to load and manipulate
 HapMap samples and to perform a number of popular gene-mapping methods.
\end_layout

\begin_layout Standard
Unlike other population genetics simulation applications that aim at specific
 evolutionary scenarios, simuPOP aims at providing a general purpose simulation
 program that can be used to write and study arbitrarily complex evolutionary
 scenarios.
 This makes simuPOP an ideal tool in a wide variety of applications ranging
 from demonstrating simple population genetics models to studying the evolution
 of complex human genetic diseases.
\end_layout

\begin_layout Section
An overview of simuPOP concepts
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
population
\series default
 consists of individuals of the same 
\series bold
genotype structure
\series default
, which include properties such as number of homologous sets of chromosomes
 (ploidy), number of chromosomes, and names and locations of markers on
 each chromosome.
 Individuals can be divided into 
\series bold
subpopulations
\series default
 that can be further divided into 
\series bold
virtual subpopulations
\series default
 according to individual properties such as sex, affection status, or arbitrary
 auxiliary information such as age.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:life-cycle"

\end_inset

A life cycle of an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename evolve.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
Illustration of the discrete-generation evolutionary model used by simuPOP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators
\series default
 are Python objects that act on a population.
 They can be applied to a population before or after mating during a life
 cycle of an evolutionary process (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), or to one or two parents during the production of each offspring.
 Arbitrary numbers of operators can be applied to an evolving population.
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
mating scheme
\series default
 is responsible for choosing parent or parents from a parental (virtual)
 subpopulation and for populating an offspring subpopulation.
 simuPOP provides a number of pre-defined mating schemes, such as random,
 consanguineous, monogamous, or polygamous mating, selfing, and haplodiploid
 mating in hymenoptera.
 More complicated nonrandom mating schemes such as mating in age-structured
 populations can be constructed using 
\series bold
heterogeneous mating schemes
\series default
.
 
\end_layout

\begin_layout Standard
simuPOP evolves a population generation by generation, following the evolutionar
y cycle depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

.
 Briefly speaking, a number of 
\series bold
pre-mating operators
\series default
 such as a 
\family typewriter
mutator
\family default
 are applied to a population before a mating scheme repeatedly chooses a
 parent or parents to produce offspring.
 
\series bold
During-mating operators
\series default
 such as 
\emph on
recombinator
\emph default
 can be used to adjust how offspring genotypes are formed from parental
 genotypes.
 After an offspring population is populated, 
\series bold
post-mating operators
\series default
 can be applied, for example, to calculate population statistics.
 The offspring population will then become the parental population of the
 next evolutionary cycle.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simpleExample.log"
lstparams "caption={A simple example},label={simple-example}"

\end_inset


\end_layout

\begin_layout Standard
These concepts are demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, where a standard diploid Wright-Fisher model with recombination is simulated.
 The first line imports the standard simuPOP module.
 The second line creates a diploid population with 1000 individuals, each
 having one chromosome with two loci.
 The third line creates a simulator with three replicates of this population.
 Random mating will be used to generate offspring.
 The last statement uses the 
\family typewriter
evolve()
\family default
 function to evolve the populations for 100 generations, subject to five
 operators.
\end_layout

\begin_layout Standard
The first operator 
\family typewriter
initByValue
\family default
 is applied to all populations before evolution.
 This operator initializes all individuals with the same genotype 
\family typewriter
12/21
\family default
.
 The other operators can be applied at every generation.
 
\family typewriter
recombinator
\family default
 is a during-mating operator that recombines parental chromosomes with the
 given recombination rate 
\family typewriter
0.01
\family default
 during the generation of offspring; 
\family typewriter
stat
\family default
 calculates linkage disequilibrium between the first and second loci.
 The results of this operator are stored in a local variable space of each
 population.
 The last two operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOutput
\family default
 are applied at the end of every 10 generations.
 
\family typewriter
pyEval
\family default
 is applied to all replicates to output calculated linkage disequilibrium
 values with a trailing tab, and the last operator outputs a newline after
 the last replicate.
 The result is a table of three columns, representing the decay of linkage
 disequilibrium of each replicate at 10 generation intervals.
 The return value of the 
\family typewriter
evolve
\family default
 function, which is the number of evolved generations for each replicate,
 is also printed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
simuPOP offers a long list of features, many of which are unique among all
 forward-time population genetics simulation programs.
 The most distinguished features include:
\end_layout

\begin_layout Enumerate
simuPOP provides three types of modules that use 1, 8 or 16 bits to store
 an allele.
 The binary module (1 bit) is suitable for simulating a large number of
 SNP markers and the long module (16 bits) is suitable for simulating some
 population genetics models such as the infinite allele mutation model.
 simuPOP supports different types of chromosomes such as autosome, sex chromosom
es and mitochondrial, with arbitrary number of markers.
\end_layout

\begin_layout Enumerate
An arbitrary number of float numbers, called information fields, can be
 attached to individuals of a population.
 For example, information field father_idx and mother_idx are used to track
 an individual’s parents, and pack_year can be used to simulate an environmental
 factor associated with smoking.
\end_layout

\begin_layout Enumerate
simuPOP does not impose any limit on number of homologous sets of chromosomes,
 the size of the genome, or the number of individuals in a population.
 During an evolutionary process, a population can hold more than one most-recent
 generations.
 Pedigrees can be sampled from such multi-generation populations.
\end_layout

\begin_layout Enumerate
An operator can be native (implemented in C++) or hybrid (Python assisted).
 A hybrid operator calls a user-provided Python function to implement arbitrary
 genetic effects.
 For example, a hybrid mutator passes to-be-mutated alleles to a user-provided
 function and mutates these alleles according to the returned values.
\end_layout

\begin_layout Enumerate
simuPOP provides more than 70 operators that cover all important aspects
 of genetic studies.
 These include mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise and hybrid), migration (arbitrary,
 can create new subpopulation), recombination and gene conversion (uniform
 or nonuniform, sex-specific), quantitative trait (single, multilocus or
 hybrid), selection (single-locus, additive, multiplicative or hybrid multi-locu
s models), penetrance (single, multi-locus or hybrid), ascertainment (case–contr
ol, affected sibpairs, random, nuclear and large pedigree), statistics calculati
on (including but not limited to allele, genotype, haplotype, heterozygote
 number and frequency; expected heterozygosity; bi-allelic and multi-allelic
 , and linkage disequilibrium measures), pedigree tracing, visualization
 (using R or other Python modules) and load/save in simuPOP’s native format
 and many external formats such as Linkage.
\end_layout

\begin_layout Enumerate
Mating schemes and many operators can work on virtual subpopulations of
 a subpopulation.
 For example, positive assortative mating can be implemented by mating individua
ls with similar properties such as ancestry.
 The number of offspring per mating event can be fixed, or can follow a
 statistical distribution.
\end_layout

\begin_layout Standard
A number of forward-time simulation programs are available.
 If we exclude early forward-time simulation applications developed primarily
 for teaching purposes, notable forward-time simulation programs include
 
\emph on
easyPOP
\emph default
, 
\emph on
FPG
\emph default
, 
\emph on
Nemo
\emph default
 and 
\emph on
quantiNemo
\emph default
, 
\emph on
genoSIM
\emph default
 and 
\emph on
genomeSIMLA
\emph default
, 
\emph on
FreGene
\emph default
, 
\emph on
GenomePop
\emph default
, 
\emph on
ForwSim
\emph default
, and 
\emph on
ForSim
\emph default
.
 These programs are designed with specific applications and specific evolutionar
y scenarios in mind, and excel in what they are designed for.
 For some applications, these programs may be easier to use than simuPOP.
 For example, using a special look-ahead algorithm, 
\emph on
ForwSim
\emph default
 is among the fastest programs to simulate a standard Wright-Fisher process,
 and should be used if such a simulation is needed.
 However, these programs are not flexible enough to be applied to problems
 outside of their designed application area.
 For example, none of these programs can be used to study the evolution
 of a disease predisposing mutant, a process that is of great importance
 in statistical genetics and genetic epidemiology.
 Compared to such programs, simuPOP has the following advantages:
\end_layout

\begin_layout Itemize
The scripting interface gives simuPOP the flexibility to create arbitrarily
 complex evolutionary scenarios.
 For example, it is easy to use simuPOP to explicitly introduce a disease
 predisposing mutant to an evolving population, trace the allele frequency
 of them, and restart the simulation if they got lost due to genetic drift.
\end_layout

\begin_layout Itemize
The Python interface allows users to define customized genetic effects in
 Python.
 In contrast, other programs either do not allow customized effects or force
 users to modify code at a lower (e.g.
 C++) level.
\end_layout

\begin_layout Itemize
simuPOP is the only application that embodies the concept of virtual subpopulati
on that allows evolutions at a finer scale.
 This is required for realistic simulations of complex evolutionary scenarios.
\end_layout

\begin_layout Itemize
simuPOP allows users to examine an evolutionary process very closely because
 all simuPOP objects are Python objects that can be assessed using their
 member functions.
 For example, users can keep track of genotype at particular loci during
 evolution.
 In contrast, other programs work more or less like a black box where only
 limited types of statistics can be outputted.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
simuPOP is distributed under a GPL license and is hosted on
\family typewriter
 http://simupop.sourceforge.net
\family default
, the world's largest development and download repository of Open Source
 code and applications.
 simuPOP is available on any platform where Python is available, and is
 currently tested under both 32 and 64 bit versions of Windows (Windows
 2000 and later), Linux (Redhat), MacOS X and Sun Solaris systems.
 Different C++ compilers such as Microsoft Visual C++, gcc and Intel icc
 are supported under different operating systems.
 Standard installation packages are provided for Windows, Linux, MacOS X,
 and Sun Solaris systems.
\end_layout

\begin_layout Standard
If a binary distribution is unavailable for a specific platform, it is usually
 easy to compile simuPOP from source, following the standard 
\family typewriter

\begin_inset Quotes eld
\end_inset

python setup.py install
\begin_inset Quotes erd
\end_inset


\family default
 procedure.
 Besides a C++ compiler, several supporting tools and libraries are needed.
 Please refer to the 
\family typewriter
INSTALL
\family default
 file for further information.
\end_layout

\begin_layout Standard
Thanks to the ‘glue language’ nature of Python, it is easy to inter-operate
 Python with other applications within a simuPOP script.
 For example, users can call any R function from Python/simuPOP for the
 purposes of visualization and statistical analysis, using 
\series bold
R
\series default
 and a Python module 
\series bold
RPy
\series default
.
 This technique is widely used in simuPOP so it is highly recommended that
 you install R and rpy is your are familiar with R.
 In addition, although simuPOP uses the standard tkInter GUI toolkit when
 a graphical user interface is needed, it can make use of a 
\series bold
wxPython
\series default
 toolkit if it is available.
\end_layout

\begin_layout Section
Getting help
\end_layout

\begin_layout Subsection
Online help system
\end_layout

\begin_layout Standard
Most of the help information contained in this document and 
\emph on
the simuPOP reference manual
\emph default
 is available from command line.
 For example, after you install and import the simuPOP module, you can use
 
\family typewriter
help(population.addInfoField) 
\family default
to view the help information of member function 
\family typewriter
addInfoField
\family default
 of class 
\family typewriter
population
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/help.log"
lstparams "caption={Getting help using the \\texttt{help()} function},keywordstyle={\\ttfamily}"

\end_inset


\end_layout

\begin_layout Standard
It is important that you understand that
\end_layout

\begin_layout Itemize
The constructor of a class is named 
\family typewriter
__init__
\family default
 in Python.
 That is to say, you should use the following command to display the help
 information of the constructor of class 
\family typewriter
population
\family default
: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> help(population.__init__)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some classes are derived from other classes and have access to member functions
 of their base classes.
 For example, class 
\family typewriter
population
\family default
 and 
\family typewriter
individual
\family default
 are both derived from class 
\family typewriter
GenoStruTrait
\family default
.
 Therefore, you can use all 
\family typewriter
GenoStruTrait
\family default
 member functions from these classes.
 
\end_layout

\begin_deeper
\begin_layout Standard
In addition, the constructor of a derived class also calls the constructor
 of its base class so you may have to refer to the base class for some parameter
 definitions.
 For example, parameters 
\family typewriter
begin, end, step, at 
\family default
etc are shared by all operators, and are explained in details only in class
 
\family typewriter
baseOperator.
\end_layout

\end_deeper
\begin_layout Subsection
Debug-related operators/functions
\end_layout

\begin_layout Standard
If your simuPOP session or script does not behave as expected, it might
 be helpful to let simuPOP print out some debug information.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is unclear why this simple command causes us trouble, instead of outputting
 the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Turn on/off debug information
\end_layout

\end_inset

>>> TurnOnDebug(DBG_POPULATION)
\end_layout

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\begin_layout Plain Layout

Constructor of population is called
\end_layout

\begin_layout Plain Layout

Destructor of population is called 
\end_layout

\begin_layout Plain Layout

Segmentation fault (core dumped)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
population(1, loci=[100])
\family default
 creates a temporary object that is destroyed right after the execution
 of the command.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is to create a persistent population object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> pop = population(1, loci=[100])
\end_layout

\begin_layout Plain Layout

>>> pop.individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can use 
\family typewriter
TurnOnDebug(code) 
\family default
and 
\family typewriter
TurnOffDebug(code) 
\family default
to turn on and off debug information where 
\family typewriter
code 
\family default
can be any debug code listed in 
\family typewriter
ListDebugCode
\begin_inset Index
status collapsed

\begin_layout Plain Layout
listDebugCode
\end_layout

\end_inset

()
\family default
.
 If you would like to turn on debugging during an evolutionary process,
 you can use operators 
\family typewriter
turnOnDebug 
\family default
and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Subsection
Other help sources
\end_layout

\begin_layout Standard
If you are new to Python, it is recommended that you borrow a Python book,
 or at least go through the following online Python tutorials:
\end_layout

\begin_layout Enumerate
The Python tutorial (
\family typewriter
http://docs.python.org/tut/tut.html
\family default
)
\end_layout

\begin_layout Enumerate
Other online tutorials listed at 
\family typewriter
http://www.python.org/doc/
\end_layout

\begin_layout Standard
If you are new to simuPOP, please read this guide before you dive into 
\emph on
the simuPOP reference manual
\emph default
, which describes all the details of simuPOP but does not show you how to
 use it.
 The PDF versions of both documents are distributed with simuPOP.
 You can also get the latest version of the documents online, from the simuPOP
 subversion repository ( 
\family typewriter
http://simupop.sourceforge.net
\family default
, click
\family sans
 SF.net summary > Code > SVN Browse > trunk > doc
\family default
).
 However, because simuPOP is under active development, there may be discrepancie
s between your local simuPOP installation and these latest documents.
\end_layout

\begin_layout Standard
A number of bundled scripts are distributed with simuPOP.
 They range from simple demonstration of population genetics models to observing
 the evolution of complex human genetic diseases.
 These scripts can be a good source to learn how to write a simuPOP script.
 Of course, if any of these scripts happens to fit your need, you may be
 able to use them directly, with writing a line of code.
\end_layout

\begin_layout Standard
A 
\emph on
simuPOP cookbook
\emph default
 is under development.
 The goal of this book is to provide recipes of commonly used simulation
 scenarios.
 A number of recipes are currently available under the 
\family typewriter
doc/cookbook
\family default
 directory of a simuPOP distribution.
 This book might be made available online so that users can submit their
 own recipes.
\end_layout

\begin_layout Standard
If you cannot find the answer you need, or if you believe that you have
 located a bug, or if you would like to request a feature, please subscribe
 to the simuPOP mailinglist and send your questions there.
\end_layout

\begin_layout Section
How to read this user's guide
\end_layout

\begin_layout Standard
This user's guide describes all simuPOP features using a lot of examples.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Core-simuPOP-components"

\end_inset

 describes all classes in the simuPOP core.
 Although most topics and examples are simple, some topics need in-depth
 understanding of both the Python language and simuPOP.
 New simuPOP users can safely skip these sections.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:simuPOP-Operators"

\end_inset

 describes almost all simuPOP operators, divided largely by genetic models.
 Features listed in these two chapters are generally implemented at the
 C++ level and are provided through the 
\family typewriter
simuPOP
\family default
 module.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Utility-Modules"

\end_inset

 describes features that are provided by various simuPOP utility modules.
 These modules provide extensions to the simuPOP core that greatly improves
 the usability and userfriendliness of simuPOP.
 The next chapter (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

) demonstrates how to write a script to solve a real-world simulation problem.
 The last chapter gives a quick description on some bundled scripts.
\end_layout

\begin_layout Standard
simuPOP is a comprehensive forward-time population genetics simulation environme
nt with many unique features.
 If you are new to simuPOP, you can go through Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Core-simuPOP-components"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:simuPOP-Operators"

\end_inset

 quickly and understand what simuPOP is and what features it provide.
 Then, you can read Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

 and learn how to apply simuPOP in real-world problems.
 After you play with simuPOP for a while and start to write simple scripts,
 you can study relevant sections in details.
 The 
\emph on
simuPOP reference manual
\emph default
 will become more and more useful when the complexity of your scripts grow.
\end_layout

\begin_layout Standard
Before we dive into the details of simuPOP, it is helpful to know a few
 name conventions that simuPOP tries to follow.
 Generally speaking,
\end_layout

\begin_layout Itemize
All classes (e.g.
 
\family typewriter
population
\family default
()), member functions (e.g.
 
\family typewriter
population.vars
\family default
()) and parameter names start with small character and use capital character
 for the first character of each word afterward (e.g.
 
\family typewriter
population.subPopSize
\family default
(), 
\family typewriter
individual.setInfo
\family default
()).
\end_layout

\begin_layout Itemize
Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter
TurnOnDebug(DBG_POPULATION)
\family default
 is the function to turn on debug mode for population related functions
 and 
\family typewriter
turnOnDebug(DBG_POPULATION) 
\family default
will do nothing apparently, because it creates an operator.
 
\end_layout

\begin_layout Itemize
Constants start with Capital characters.
 Their names instead of their actual values should be used because those
 values can change without notice.
\end_layout

\begin_layout Itemize
simuPOP uses the abbreviated form of the following words in function and
 parameter names:
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
pos
\family default
 (position),  
\family typewriter
info
\family default
 (information), 
\family typewriter
migr
\family default
 (migration), 
\family typewriter
subPop
\family default
 (subpopulation and virtual subpopulation), 
\family typewriter
subPops
\family default
 (subpopulations and virtual subpopulations), 
\family typewriter
rep
\family default
 (replicate and replicates), 
\family typewriter
gen
\family default
 (generation), 
\family typewriter
ops
\family default
 (operators), 
\family typewriter
expr
\family default
 (expression), 
\family typewriter
stmts
\family default
 (statements).
\end_layout

\begin_layout Standard
It usually possible to guess whether or not a parameter accepts a single
 or a list of objects by its name.
 For example, 
\family typewriter
subPop
\family default
 accepts single subpopulation and 
\family typewriter
subPops
\family default
 accepts a list of subpopulations.
\end_layout

\end_deeper
\begin_layout Note
Plural form parameters usually accept single inputs.
 For example, 
\family typewriter
loci=1
\family default
 can be used as a shortcut for 
\family typewriter
loci=[1]
\family default
.
 An exception to this convention is list of strings (e.g.
 parameter 
\family typewriter
infoFields=['smoke']
\family default
) because a single string such as 
\family typewriter
infoFields='smoke'
\family default
 will be interpreted as 
\family typewriter
infoFields=['s', 'm', 'o', 'k', 'e']
\family default
.
\end_layout

\begin_layout Chapter
Core simuPOP components
\begin_inset CommandInset label
LatexCommand label
name "cha:Core-simuPOP-components"

\end_inset


\end_layout

\begin_layout Section
Loading a simuPOP module
\end_layout

\begin_layout Standard
simuPOP consists of a number of Python modules, documents, tests and examples.
 Using Linux as an example, simuPOP installs the following files to your
 operating system:
\end_layout

\begin_layout Itemize
Core simuPOP modules (
\family typewriter
simuPOP_XXX.py
\family default
, 
\family typewriter
_simuPOP_XXX.
\family default
so) and a number of utility modules (
\family typewriter
simuUtil.py, simuOpt.py
\family default
 etc) under 
\family typewriter
/usr/lib/python2X/site-packages
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/doc
\family default
: This directory contains the pdf version of this user's guide and the 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/test
\family default
: This directory contains all unit test cases.
 It is recommended that you test your simuPOP installation using these scripts
 if you compile simuPOP from source.
 
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/scripts
\family default
: This directory contains all the bundled scripts.
 It is worth noting that although these scripts are distributed with simuPOP,
 they are not tested as rigorously and as frequently as the simuPOP core.
 Please send an email to the simuPOP mailinglist if you notice any problem
 with them.
\end_layout

\begin_layout Subsection
Short, long and binary modules and their optimized versions
\end_layout

\begin_layout Standard
There are six flavors of the core simuPOP module: short, long and binary
 allele modules, and their optimized versions.
 The short allele modules use 8 bits to store each allele which limits the
 possible allele states to 256.
 This is enough most of the times but not so if you need to simulate models
 such as the infinite allele model.
 In those cases, you should use the long allele version of the modules,
 which use 16 bits for each allele and can have 
\begin_inset Formula $2^{16}$
\end_inset

 possible allele states.
 On the other hand, if you would like to simulate a large number of binary
 (SNP) markers, binary libraries can save you a lot of RAM because they
 use 1 bit for each allele.
 Despite of differences in internal memory layout, all these modules have
 the same interface.
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure a simulation executes correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time validation varies from case to case but can be
 high under some extreme circumstances.
 Because of this, optimized versions for all modules are provided.
 They bypass all parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confident
 that your simulation is running as expected.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 demonstrate the differences between standard and optimized modules, by
 executing two invalid commands.
 A standard module returns proper error messages, while an optimized module
 returns erroneous results and or simply crashes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/standard.log"
lstparams "caption={Use of standard simuPOP modules},keywords={from,import},label={lst:Use-of-standard-module}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Use-of-optimized-module"

\end_inset

Use of optimized simuPOP modules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

% python
\end_layout

\begin_layout Plain Layout

>>> from simuOpt import setOptions
\end_layout

\begin_layout Plain Layout

>>> setOptions(optimized=True, alleleType='long', quiet=True)
\end_layout

\begin_layout Plain Layout

>>> from simuPOP import *
\end_layout

\begin_layout Plain Layout

>>> pop = population(10, loci=[2])
\end_layout

\begin_layout Plain Layout

>>> pop.locusPos(10)
\end_layout

\begin_layout Plain Layout

1.2731974748756028e-313
\end_layout

\begin_layout Plain Layout

>>> pop.individual(20).setAllele(1, 0)
\end_layout

\begin_layout Plain Layout

Segmentation fault
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 also demonstrates how to use the 
\family typewriter
setOptions
\family default
 function in the 
\family typewriter
simuOpt
\family default
 module to control the choice of one of the six simuPOP modules.
 By specifying one of 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary 
\family default
for option 
\family typewriter
alleleType
\family default
, and setting
\family typewriter
 optimized
\family default
 to 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
, the right flavor of module will be chosen when simuPOP is loaded.
 In addition, option 
\family typewriter
quiet
\family default
 can be used suppress initial output.
 An alternative method is to set environmental variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
r
\end_layout

\end_inset

 to 
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
binary
\family default
 to use the standard short, long or binary module, and variable 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules.
 Command line options 
\family typewriter
--optimized
\family default
 can also be used.
\end_layout

\begin_layout Subsection
Random number generator
\end_layout

\begin_layout Standard
When simuPOP is loaded, it creates a default random number generator (
\family typewriter
RNG
\family default
) of type 
\family typewriter
mt19937
\family default
 using a random seed from a system random number generator that guarantees
 random seeds for all instances of simuPOP even if they are initialized
 at the same time.
 After simuPOP is loaded, you can reset this system RNG with a different
 random number generator (c.f.
 
\family typewriter
AvailableRNGs()
\family default

\begin_inset Index
status open

\begin_layout Plain Layout
AvailableRNG
\end_layout

\end_inset

, 
\family typewriter
SetRNG(name, seed)
\family default
)
\begin_inset Index
status open

\begin_layout Plain Layout
SetRNG
\end_layout

\end_inset

.
 It is also possible to save the random seed of a simuPOP session (c.f.
 
\family typewriter
rng().seed()
\family default
) and use it to replay the session later.
 
\end_layout

\begin_layout Note

\family typewriter
rng().seed()
\family default
 returns the seed of the simuPOP random number generator.
 It can be used to replay your simulation if 
\family typewriter
rng()
\family default
 is your only source of random number generator.
 If you also use the Python 
\family typewriter
random
\family default
 module, it is a good practise to set its seed using 
\family typewriter
random.seed(rng().seed())
\family default
.
\end_layout

\begin_layout Subsection
Graphical user interface
\end_layout

\begin_layout Standard
There is no graphical user interface to simuPOP but various dialogs can
 be used for simple tasks.
 For example, a parameter input dialog can be constructed automatically
 from a parameter specification list, and be used to accept user input if
 class 
\family typewriter
simuOpt.simuOpt
\family default
 is used to handle parameters.
 Other examples include class 
\family typewriter
simuUtil.simuProgress
\family default
 that makes use of a progress dialog, and function 
\family typewriter
simuUtil.ViewVars
\family default
 that uses a dialog to display a large number of variables.
 Note that the 
\series bold
use of GUI in simuPOP is optional in the sense that all functionalities
 can be achieved without a GUI
\series default
.
 For examples, 
\family typewriter
simuOpt.getParam()
\family default
 will use a terminal to accept user input and 
\family typewriter
simuUtil.simuProgress
\family default
 turns to a text-based progress bar in the non-GUI mode.
\end_layout

\begin_layout Standard
The use of GUI can be controlled either globally or individually.
 More specifically,
\end_layout

\begin_layout Itemize
By default, a GUI is used whenever possible.
 All GUI-capable functions support 
\family typewriter
wxPython
\family default
 so a 
\family typewriter
wxPython
\family default
 dialog will be used if 
\family typewriter
wxPython
\family default
 is available.
 Otherwise, 
\family typewriter
tkInter
\family default
 based dialogs or text-mode will be used.
\end_layout

\begin_layout Itemize
If environmental variable 
\family typewriter
SIMUGUI
\family default
 is set to 
\family typewriter
False
\family default
, no GUI will be used.
 If it is set to 
\family typewriter
Tkinter
\family default
, 
\family typewriter
Tkinter
\family default
-based dialogs will be used even if 
\family typewriter
wxPython
\family default
 is available.
\end_layout

\begin_layout Itemize
The same parameters 
\family typewriter
True/False/wxPython/Tkinter
\family default
 at the script level using command line option 
\family typewriter
--gui.
 
\family default
Note that 
\family typewriter
--gui=False
\family default
 is commonly used to run scripts in batch mode.
\end_layout

\begin_layout Itemize
For each involved function or class, parameter 
\family typewriter
gui
\family default
 is usually provided.
 The same set of options apply.
\end_layout

\begin_layout Section
Pythonic issues
\end_layout

\begin_layout Subsection
References and the 
\family typewriter
clone() 
\family default
member function
\end_layout

\begin_layout Standard
Assignment in Python only creates a new reference to an existing object.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop = population()
\end_layout

\begin_layout Plain Layout

pop1 = pop
\end_layout

\end_inset

will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well and the removal of 
\family typewriter
pop
\family default
 will invalidate 
\family typewriter
pop1
\family default
.
 For example, a reference to the first population in a simulator is returned
 from function 
\family typewriter
func()
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

.
 The subsequent use of this 
\family typewriter
pop
\family default
 object may crash simuPOP because the simulator 
\family typewriter
simu
\family default
 is destroyed, along with all its internal populations, after 
\family typewriter
func()
\family default
 is finished, leaving 
\family typewriter
pop
\family default
 referring to an invalid object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Reference-to-population"

\end_inset

Reference to a population in a simulator
\end_layout

\end_inset

def func():
\end_layout

\begin_layout Plain Layout

    simu = simulator(population(10), randomMating(), rep=5)
\end_layout

\begin_layout Plain Layout

    # return a reference to the first population in the simulator
\end_layout

\begin_layout Plain Layout

    return simu.population(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pop = func()
\end_layout

\begin_layout Plain Layout

# simuPOP will crash because pop refers to an invalid population.
\end_layout

\begin_layout Plain Layout

pop.popSize()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to have an independent copy of a population, you can use
 the 
\family typewriter
clone()
\family default
 member function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

 would behave properly if the 
\family typewriter
return
\family default
 statement is replaced by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.population(0).clone()
\end_layout

\end_inset

although in this specific case, extracting the first population from the
 simulator using the 
\family typewriter
extract
\family default
 function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.extract(0)
\end_layout

\end_inset

would be more efficient because we do not need to copy the first population
 from 
\family typewriter
simu
\family default
 if it will be destroyed soon.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
clone()
\family default
 function exists for all simuPOP classes (objects) such as 
\emph on
simulator
\emph default
, 
\emph on
mating schemes
\emph default
 and 
\emph on
operators
\emph default
.
 simuPOP also supports the standard Python shallow and deep copy operations
 so you can also make a cloned copy of 
\family typewriter
pop
\family default
 using the 
\family typewriter
deepcopy
\family default
 function defined in the Python 
\family typewriter
copy
\family default
 module
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy
\end_layout

\begin_layout Plain Layout

pop1 = copy.deepcopy(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zero-based indexes, absolute and relative indexes
\end_layout

\begin_layout Standard

\series bold
All arrays in simuPOP start at index 0
\series default
.
 This conforms to Python and C++ indexes.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the 
\emph on
absolute index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and the 
\emph on
relative index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 of a locus.
 The former index ignores chromosome structure.
 For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two chromosomes are (0, 1, 2, 3, 4), (5, 6, 7,
 8, 9, 10, 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3,
 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(idx)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 An individual can also be referred by its 
\emph on
absolute index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and 
\emph on
relative index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 where 
\emph on
relative index
\emph default
 is the index in its subpopulation.
 Related member functions are 
\family typewriter
subPopIndPair(idx)
\family default
 and 
\family typewriter
absIndIndex(idx, subPop)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/absIndex.log"
lstparams "caption={Conversion between absolute and relative indexes},label={absIndex}"

\end_inset


\end_layout

\begin_layout Subsection
Ranges and iterators
\end_layout

\begin_layout Standard
Ranges in simuPOP also conform to Python ranges.
 That is to say, a range has the form of 
\family typewriter
[a,b) 
\family default
where 
\family typewriter
a 
\family default
belongs to the range, and 
\family typewriter
b 
\family default
does not.
 For example, 
\family typewriter
pop.chromBegin(1) 
\family default
refers to the index of the first locus on chromosome 1 (actually exists),
 and 
\family typewriter
pop.chromEnd(1) 
\family default
refers to the index of the last locus on chromosome 1 
\series bold
plus 1
\series default
, which might or might not be a valid index.
\end_layout

\begin_layout Standard
A number of simuPOP functions return Python iterators that can be used to
 iterate through an internal array of objects.
 For example, 
\family typewriter
population::individuals([subPop])
\family default
 returns an iterator that can be used to iterate through all individuals,
 or all individuals in a (virtual) subpoulation.
 
\family typewriter
simulator::populations()
\family default
 can be used to iterate through all populations in a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of ranges and iterators in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/iterator.log"
lstparams "caption={Ranges and iterators},label={iterator.log}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
\series medium
\size normal
carray
\family default
\series default
\size default
 datatype
\begin_inset CommandInset label
LatexCommand label
name "sub:carray-datatype"

\end_inset


\end_layout

\begin_layout Standard
simuPOP uses mostly standard Python types such as tuples, lists and dictionaries.
 However, for efficiency considerations, simuPOP defines and uses a new
 
\family typewriter
carray 
\family default
datatype to refer to an internal array of genotypes.
 Such an object can only be returned from 
\family typewriter
individual::genotype
\family default
 and 
\family typewriter
population::genotype
\family default
 functions.
 Instead of copying all genotypes to a Python tuple or list, these functions
 return a 
\family typewriter
carray 
\family default
object that directly reflect the underlying genotype.
 This object behaves like a regular Python list except that the underlying
 genotype will be changed if elements of this object are changed.
 In addition, elements in this array will be changed if the underlying genotype
 is changed using another method.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of this datatype.
 It also shows how to get an independent list of alleles using the 
\family typewriter
list()
\family default
 built-in function.
 Compare to 
\family typewriter
allele()
\family default
, 
\family typewriter
setAllele()
\family default
 and 
\family typewriter
setGenotype()
\family default
 functions, it is usually more efficient and more convenient to read and
 write genotypes using carray objects, although this usage is usually less
 readable.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/carray.log"
lstparams "caption={The carray datatype},label={carraydatatype}"

\end_inset


\end_layout

\begin_layout Section
Genotypic structure 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
genotypic structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to structural information shared by all individuals
 in a population, including number of homologous copies of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidy
\end_layout

\end_inset

(), ploidyName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidyName
\end_layout

\end_inset

()
\family default
), chromosome types and names (c.f.
 
\family typewriter
numChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numChrom
\end_layout

\end_inset

(), chromType()
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromType
\end_layout

\end_inset

, chromName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromName
\end_layout

\end_inset

()
\family default
), position and name of each locus (c.f.
 
\family typewriter
numLoci
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numLoci
\end_layout

\end_inset

(ch),
\family default
 
\family typewriter
locusPos
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!locusPos
\end_layout

\end_inset

(loc),
\family default
 
\family typewriter
locusName(loc)
\family default
), and axillary information attached to each individual (c.f.
 
\family typewriter
infoField
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoField
\end_layout

\end_inset

(idx), infoFields
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoFields
\end_layout

\end_inset

()
\family default
).
 In addition to property access functions, a number of utility functions
 are provided to, for example, look up the index of a locus by its name
 (c.f.
 
\family typewriter
locusByName()
\family default
, 
\family typewriter
chromBegin()
\family default
, 
\family typewriter
chromLocusPair()
\family default
).
\end_layout

\begin_layout Standard
A genotypic structure can be retrieved from 
\emph on
individual
\emph default
 and 
\emph on
population
\emph default
 objects.
 Because a population consists of individuals of the same type, genotypic
 information can only be changed for all individuals at the population level.
 Populations in a simulator usually have the same genotypic structure because
 they are created by as replicates, but their structure may change during
 evolution.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to access genotypic structure functions at the population
 and individual levels.
 Note that 
\family typewriter
lociPos
\family default
 determines the order at which loci are arranged on a chromosome.
 Loci positions and names will be rearranged if given 
\family typewriter
lociPos
\family default
 is unordered.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genoStru.log"
lstparams "caption={Genotypic structure functions},label={genostructure}"

\end_inset


\end_layout

\begin_layout Subsection
Haploid, diploid and haplodiploid populations
\end_layout

\begin_layout Standard
simuPOP is most widely used to study human (diploid) populations.
 A large number of mating schemes, operators and population statistics are
 designed around the evolution of such a population.
 simuPOP also supports haploid and haplodiploid populations although there
 are fewer choices of mating schemes and operators.
 simuPOP can also support other types of populations such as triploid and
 tetraploid populations, but these features are largely untested due to
 their limited usage.
 It is expected that supports for these population would be enhanced over
 time.
\end_layout

\begin_layout Standard
For efficiency considerations, simuPOP saves the same numbers of homologous
 sets of chromosomes even if some individuals have different numbers of
 homologous sets in a population.
 For example, in a haplodiploid population, because male individuals have
 only one set of chromosomes, their second homologous set of chromosomes
 are 
\emph on
unused
\emph default
, which are labeled as 
\family typewriter
'_'
\family default
, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploid.log"
lstparams "caption={An example of haplodiploid population},keywordstyle={\\ttfamily},label={haplodiploid}"

\end_inset


\end_layout

\begin_layout Subsection
Autosomes, sex chromosomes, and other types of chromosomes
\end_layout

\begin_layout Standard
The default chromosome type is autosome, which is the 
\emph on
normal
\emph default
 chromosomes in diploid, and in haploid populations.
 simuPOP supports three other types of chromosomes, namely 
\emph on
ChromosomeX
\emph default
, 
\emph on
ChromosomeY
\emph default
 and 
\emph on
Customized
\emph default
.
 Sex chromosomes are only valid in haploid populations where chromosomes
 X and Y are used to determine the sex of an offspring.
 Customized chromosomes rely on user defined functions and operators to
 be passed from parents to offspring.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 shows how to specify different chromosome types, and how genotypes of these
 special chromosomes are arranged.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/chromType.log"
lstparams "caption={Different chromosome types},keywordstyle={\\ttfamily},label={chromtypes}"

\end_inset


\end_layout

\begin_layout Standard
The evolution of sex chromosomes follow the following rules
\end_layout

\begin_layout Itemize
There can be only one X chromosome and one Y chromosome.
 It is not allowed to have only one kind of sex chromosome.
\end_layout

\begin_layout Itemize
The Y chromosome of female individuals are ignored.
 The second homologous copy of the X chromosome and the first copy of the
 Y chromosome are ignored for male individuals.
\end_layout

\begin_layout Itemize
During mating, female parent pass one of her X chromosome to her offspring,
 male parent pass chromosome X or Y to his offspring.
 Recombination is allowed for the X chromosomes of females, but not allowed
 for males.
\end_layout

\begin_layout Itemize
The sex of offspring is determined by the types of sex chromosomes he/she
 inherits, XX for female, and XY for male.
\end_layout

\begin_layout Standard
As an advanced feature of simuPOP, chromosomes that do not follow the inheritanc
e patterns of autosomes or sex chromosomes can be handled separately (see
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Pre-defined-genotype-transmitters"

\end_inset

 for an Example).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:chromTypes"

\end_inset

 depicts the possible chromosome structure of two diploid parents, and how
 offspring chromosomes are formed.
 It uses two customized chromosomes to model multiple copies of mitochondrial
 chromosomes that are passed randomly from mother to offspring.
 The second homologous copy of customized chromosomes are unused in this
 example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chromTypes"

\end_inset

Inheritance of different types of chromosomes in a diploid population
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename chromType.png
	lyxscale 40
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
Individuals in this population have five chromosomes, one autosome (A),
 one X chromosome (X), one Y chromosome (Y) and two customized chromosomes
 (C).
 The customized chromosomes model multiple copies of mitochondrial chromosomes
 that are passed randomly from mother to offspring.
 Y chromosomes for the female parent, the second copy of chromosome X and
 the first copy of chromosome Y for the male parent, and the second copy
 of customized chromosomes are unused (gray chromosome regions).
 A male offspring inherits one copy of autosome from his mother (with recombinat
ion), one copy of autosome from his father (with recombination), an X chromosome
 from his mother (with recombination), a Y chromosome from his father (without
 recombination), and two copies of the first customized chromosome.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sub:stru-infoFields"

\end_inset


\end_layout

\begin_layout Standard
Different kinds of simulations require different kinds of individuals.
 Individuals with only genotype information are sufficient to simulate the
 basic Wright-Fisher model.
 Sex is needed to simulate such a model in diploid populations with sex.
 Individual fitness may be needed if selection is induced, and age may be
 needed if the population is age-structured.
 In addition, different types of quantitative traits or affection status
 may be needed to study the impact of genotype on individual phenotype.
 Because it is infeasible to provide all such information to an individual,
 simuPOP keeps genotype, sex (
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
) and affection status as 
\emph on
built-in properties
\emph default
 of an individual, and all others as optional 
\emph on
information fields
\emph default
 (float numbers) attached to each individual.
\end_layout

\begin_layout Standard
Information fields can be specified when a population is created, or added
 later using relevant function.
 They are essential for the function of many simuPOP operators.
 For example, all selection operators require information field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 Operator 
\family typewriter
migrator
\family default
 uses information field 
\family typewriter
migrate_to
\family default
 to store the ID of subpopulation an individual will migrate to.
 An error will be raised if these operators are applied to a population
 without needed information fields.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoField.log"
lstparams "caption={Basic usage of information fields},label={basicInfoFields}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the basic usage of information fields.
 In this example, a population with two information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 are created.
 It can hold one ancestral generations (
\family typewriter
ancGen=1
\family default
, see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details) so the most recent parental generations will be kept in a
 population object.
 After initializing each individual with two chromosomes with all zero and
 all one alleles respectively, the population evolves one generation, subject
 to recombination at rate 0.01.
 Parents of each individual are recorded, by operator 
\family typewriter
parentsTagger
\family default
, to information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 of each offspring
\family typewriter
.
\end_layout

\begin_layout Standard
After evolution, the population is extracted from the simulator, and the
 values of information field 
\family typewriter
mother_idx
\family default
 of all individuals are printed.
 The next several statements get the first individual from the population,
 and his mother from the parental generation using the index stored in this
 individual's information field.
 Genotypes at the first homologous copy of this individual's chromosome
 is printed, along with two parental chromosomes.
\end_layout

\begin_layout Section
Individual
\end_layout

\begin_layout Standard
Individuals are building blocks of populations.
 An individual object cannot be created independently, but references to
 inidividuals can be retrieved using member functions of a population object.
 In addition to structural information shared by all individuals in a population
, the individual class provides member functions to get and set 
\emph on
genotype
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
affection status
\emph default
 and 
\emph on
information fields
\emph default
 of an individual.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates how to access and modify individual sex, affection status
 and information fields.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual.log"
lstparams "caption={Access Individual properties},label={individuals}"

\end_inset


\end_layout

\begin_layout Standard
Genotypes of an individual are stored sequentially and can be accessed locus
 by locus, or in batch.
 The alleles are arranged by position, chromosome and ploidy.
 That is to say, the first allele on the first chromosome of the first homologou
s set is followed by alleles at other loci on the same chromosome, then
 markers on the second and later chromosomes, followed by alleles on the
 second homologous set of the chromosomes for a diploid individual.
 A consequence of this memory layout is that alleles at the same locus of
 a non-haploid individual are separated by 
\family typewriter
individual::totNumLoci()
\family default
 loci.
 The memory layout of a diploid individual with two chromosomes is illustrated
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:genotype-layout"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:genotype-layout"

\end_inset

Memory layout of individual genotype
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename genotype.png
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
simuPOP provides several functions to read/write individual genotype.
 It is worth noting that, instead of copying genotypes of an individual
 to a Python tuple or list, the return value of function 
\family typewriter
genotype([p, [ch]])
\family default
 is a special python carray object that reflects the underlying genotypes.
 Modifying elements of this array will change the genotype of an individual
 directly.
 Only 
\family typewriter
count
\family default
 and
\family typewriter
 index
\family default
 list functions can be used, but all comparison, assignment and slice operations
 are allowed.
 If you would like to copy the content of this 
\family typewriter
carray
\family default
 to a Python list, use the 
\family typewriter
list()
\family default
 function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates the use of these functions.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual_genotype.log"
lstparams "caption={Access individual genotype},label={individual_genotype}"

\end_inset


\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard
The 
\family typewriter
population
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population
\end_layout

\end_inset


\family default
 object is the most important object of simuPOP.
 It consists of one or more generations of individuals, grouped by subpopulation
s, and a local Python dictionary to hold arbitrary population information.
 This class provides a large number of functions to access and modify population
 structure, individuals and their genotypes and information fields.
 The following sections explain these features in detail.
\end_layout

\begin_layout Subsection
Subpopulations
\end_layout

\begin_layout Standard
A simuPOP population consists of one or more subpopulations.
 Subpopulations serve as barriers of individuals in the sense that mating
 only happens between individuals in the same subpopulation.
 A number of functions are provided to merge, remove, resize subpopulations,
 and move individuals between subpopulations (migration).
 You will rarely get a chance to use them directly because such operations
 are usually handled by operators.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to use subpopulation related functions.
 Of particular interest is the 
\family typewriter
setSubPopByIndInfo()
\family default
 function.
 This function takes an information field as parameter and rearrange individuals
 according to their values at this information field.
 Individuals with invalid (negative) values at this information field are
 removed.
 This is essentially how migration is implemented in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPop.log"
lstparams "caption={Manipulation of subpopulations},label={subPop}"

\end_inset


\end_layout

\begin_layout Standard
Some population operations change the IDs of subpopulations.
 For example, if a population has three subpopulations 0, 1, and 2, and
 subpopulation 1 is split into two subpouplations, subpopulation 2 will
 become subpopulation 3.
 Tracking the ID of a subpopulation can be problematic, especially when
 conditional or random subpopulation operations are involved.
 In this case, you can specify names to subpopulations.
 These names will follow their associated subpopulations during population
 operations so you can identify the ID of a subpopulation by its name.
 Note that simuPOP allows duplicate subpopulation names.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPopName.log"
lstparams "caption={Use of subpopulation names},label={subPopName}"

\end_inset


\end_layout

\begin_layout Subsection
Virtual subpopulations
\end_layout

\begin_layout Standard
simuPOP subpopulations can be further divided into virtual subpopulations
 (VSP), which are groups of individuals who share certain properties.
 For example, all male individuals, all unaffected individuals, all individuals
 with information field age > 20, all individuals with genotype 0, 0 at
 a given locus, can form VSPs.
 VSPs do not have to add up to the whole subpopulation, nor do they have
 to be non-overlapping.
 Unlike subpopulations that have strict boundaries, VSPs change easily with
 the changes of individual properties.
\end_layout

\begin_layout Standard
VSPs are defined by virtual splitters.
 A splitter defines the same number of VSPs in all subpopulations, although
 sizes of these VSPs vary across subpopulations due to subpopulation differences.
 For example, a 
\family typewriter
sexSplitter()
\family default
 defines two VSPs, the first with all male individuals and the second with
 all female individuals, and a 
\family typewriter
infoSplitter(field='x', values=[1, 2, 4])
\family default
 defines three VSPs whose members have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 and 
\family typewriter
4
\family default
 at information field 
\family typewriter
x
\family default
, respectively.
 If different types of VSPs are needed, a combined splitter can be used
 to combine VSPs defined by several splitters.
\end_layout

\begin_layout Standard
A VSP is represented by a 
\family typewriter
[spID, vspID]
\family default
 pair.
 Its name and size can be obtained using functions 
\family typewriter
subPopName()
\family default
 and 
\family typewriter
subPopSize()
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSplitter"

\end_inset

 demonstrates how to apply virtual splitters to a population, and how to
 check VSP names and sizes.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSplitter.log"
lstparams "caption={Define virtual subpopulations in a population},label={virtualSplitter}"

\end_inset


\end_layout

\begin_layout Standard
VSP provides an easy way to access groups of individuals in a subpopulation
 and allows finer control of an evolutionary process.
 For example, mating schemes can be applied to VSPs which makes it possible
 to apply different mating schemes to, for example, individuals with different
 ages.
 By applying migration, mutation etc to VSPs, it is easy to implement advanced
 features such as sex-biased migrations, different mutation rates for individual
s at different stages of a disease.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to initialize genotype and information fields to individuals
 in male and female VSPs.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSubPop.log"
lstparams "caption={Applications of virtual subpopulations},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Individuals"

\end_inset

Access individuals and their properties
\end_layout

\begin_layout Standard
There are many ways to access individuals of a population.
 For example, function 
\family typewriter
population::individual(idx)
\family default
 returns a reference to the 
\family typewriter
idx
\family default
-th individual in a population.
 An optional parameter 
\family typewriter
subPop
\family default
 can be specified to return the 
\family typewriter
idx
\family default
-th individual in the 
\family typewriter
subPop
\family default
-th subpopulation.
\end_layout

\begin_layout Standard
If you would like to access a group of individuals, either from a whole
 population, a subpopulation, or from a virtual subpopulation, 
\family typewriter
population::individuals([subPop])
\family default
 is easier to use.
 This function returns a Python iterator that can be used to iterate through
 individuals.
 An advantage of this function is that 
\family typewriter
subPop 
\family default
can be a virtual subpopulation which makes it easy to iterate through individual
s with certain properties (such as all male individuals).
\end_layout

\begin_layout Standard
If more then one generations are stored in a population, function 
\family typewriter
ancestor(idx, [subPop], gen)
\family default
 can be used to access individual from an ancestral generation (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details).
 Because there is no group access function for ancestors, it may be more
 convenient to use 
\family typewriter
useAncestralGen
\family default
 to make an 
\emph on
ancestral
\emph default
 generation the 
\emph on
current
\emph default
 generation, and use 
\family typewriter
population::individuals
\family default
.
 Note that ancestor() function can always access individuals at a certain
 generation, regardless which generation the current generation is.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to use all these individual-access functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/accessIndividual.log"
lstparams "caption={Access individuals of a population},label={accessIndividual}"

\end_inset


\end_layout

\begin_layout Standard
Although it is easy to access individuals in a population, it is often more
 efficient to access genotypes and information fields in batch mode.
 For example, functions 
\family typewriter
genotype()
\family default
 and
\family typewriter
 setGenotype()
\family default
 can read/write genotype of all individuals in a population or (virtual)
 subpopulation, functions 
\family typewriter
indInfo()
\family default
 and 
\family typewriter
setIndInfo()
\family default
 can read/write certain information fields in a population or (virtual)
 subpopulation.
 The write functions work in a circular manner in the sense that provided
 values are reused if they are not enough to fill all genotypes or information
 fields.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates the use of such functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/batchAccess.log"
lstparams "caption={Access individual properties in batch mode},label={batchAccess}"

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sec:Information-fields"

\end_inset


\end_layout

\begin_layout Standard
Information fields are usually set during population creation, using the
 
\family typewriter
infoFields
\family default
 parameter of the population constructor.
 It can also be set or added using functions 
\family typewriter
setInfoFields, addInfoField 
\family default
and 
\family typewriter
addInfoFields
\family default
.
 Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:stru-infoFields"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Individuals"

\end_inset

 have demonstrated how to read and write information fields from an individual,
 or from a population in batch mode.
\end_layout

\begin_layout Standard
Information fields can not located by their names or indexes.
 We have always used field names for clarity, at a cost of performance because
 these names have to be translated into indexes each time.
 When performance is a concern, you can use
\family typewriter
 idx=pop.infoIdx(name)
\family default
 to get and use the index of an information field.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popInfo.log"
lstparams "caption={Add and use of information fields in a population},label={popInfo}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
A simuPOP population usually holds individuals in one generation.
 During evolution, an offspring generation will replace the parental generation
 and become the present generation (population), after it is populated from
 a parental population.
 The parental generation is discarded.
\end_layout

\begin_layout Standard
This is usually enough when only the present generation is of interest.
 However, parental generations can provide useful information on how genotype
 and other information are passed from parental to offspring generations.
 simuPOP provides a mechanism to store and access arbitrary number of ancestral
 generations in a population object.
 Applications of this feature include pedigree tracking, reconstruction,
 and pedigree ascertainments.
\end_layout

\begin_layout Standard
A parameter 
\family typewriter
ancGen
\family default
 is used to specify how many generations a population object 
\emph on
can
\emph default
 store (which is usually called the 
\emph on
ancestral depth
\emph default
 of a population).
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number 
\family typewriter
n
\family default
 to store n most recent generations; or -
\family typewriter
1
\family default
 to store all generations.
 Of course, storing all generations during an evolutionary process is likely
 to exhaust the RAM of your computer quickly.
\end_layout

\begin_layout Standard
Several member functions can be used to manipulate ancestral generations:
\end_layout

\begin_layout Itemize

\family typewriter
ancestralGens() 
\family default
returns the number of ancestral generations stored in a population.
\end_layout

\begin_layout Itemize

\family typewriter
setAncestralDepth(depth)
\family default
 resets the number of generations a population can store.
\end_layout

\begin_layout Itemize

\family typewriter
push(pop)
\family default
 will push population 
\family typewriter
pop
\family default
 into the current population.
 
\family typewriter
pop
\family default
 will become the current generation, and the current generation will either
 be removed (if ancGen == 0), or become the parental generation of pop.
 The greatest ancestral generation may be removed.
 This function is rarely used because populations with ancestral generations
 are usually created during an evolutionary process.
\end_layout

\begin_layout Itemize

\family typewriter
useAncestralGen(idx)
\family default
 set the present generation to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the parental generation, 
\family typewriter
2
\family default
 for grand-parental, ..., and 
\family typewriter
0
\family default
 for the present generation.
 This is useful because most population functions act on the 
\emph on
present
\emph default
 generation.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral generations.
 
\end_layout

\begin_layout Standard
A typical use of ancestral generations is demonstrated in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

.
 In this example, a population is created and is initialized with allele
 frequency 0.5.
 Its ancestral depth is set to 2 at the beginning of generation 18 so that
 it can hold parental generations at generation 18 and 19.
 The allele frequency at each generation is calculated and displayed, both
 during evolution using a 
\family typewriter
stat
\family default
 operator, and after evolution using the function form this operator.
 Note that setting the ancestral depth at the end of an evolutionary process
 is a common practice because we are usually only interested in the last
 few generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ancestralPop.log"
lstparams "caption={Ancestral populations},label={ancestralPop}"

\end_inset


\end_layout

\begin_layout Subsection
Add and remove loci
\end_layout

\begin_layout Standard
Several functions are provided to remove, add empty loci or chromosomes,
 and to merge loci or chromosomes from another population.
 They can be used to trim unneeded loci, expand existing population or merge
 two populations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates how to use these populations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/addRemoveLoci.log"
lstparams "caption={Add and remove loci and chromosomes},keywordstyle={\\ttfamily},label={addRemoveLoci}"

\end_inset


\end_layout

\begin_layout Subsection
Population extraction
\end_layout

\begin_layout Standard
Another import population member function is 
\family typewriter
population::extract(field=None, loci=None, info=None, ancGen=-1, ped=None)
\family default
.
 It is a powerful function that can extract subset of individuals, loci,
 information fields and ancestral generations from an existing population.
 This function is widely used in ascertainment operators where individuals
 or pedigrees are extracted from an existing population and form a sample.
\end_layout

\begin_layout Standard
If all default parameters are used, this function is equivalent to 
\family typewriter
population::clone()
\family default
.
 If a list of loci or information fields are given to parameters 
\family typewriter
loci
\family default
 and 
\family typewriter
info
\family default
, other specified loci and information fields will be copied to the extracted
 population.
 If a positive 
\family typewriter
ancGen
\family default
 is given, only generations 
\family typewriter
0
\family default
 -
\family typewriter
 ancGen
\family default
 will be extracted.
 The most interesting parameter is 
\family typewriter
ind
\family default
.
 Instead of given a list of individuals that will be extract, an information
 field is expected.
 This information field is expected to hold the new subpopulation ID to
 which each individual will belong in the extracted population.
 Individuals with negative values (invalid subpopulation ID) at this information
 field will not be extracted.
 If another population (or pedigree) with the same number of individuals
 is given, the information field from that population is used.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates the use of this powerful function.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/extract.log"
lstparams "caption={Extract individuals, loci and information fields from an existing population},keywordstyle={\\ttfamily},label={extract}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Each simuPOP population has a Python dictionary that can be used to store
 arbitrary Python variables.
 These variables are usually used by various operators to share information
 between them.
 For example, the 
\family typewriter
stat
\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!stat
\end_layout

\end_inset


\family default
 operator calculates population statistics and stores the results in this
 Python dictionary.
 Other operators such as the 
\family typewriter
pyEval
\family default
 and 
\family typewriter
terminateIf 
\family default
read from this dictionary and act upon its information.
\end_layout

\begin_layout Standard
simuPOP provides two functions, namely 
\family typewriter
population::vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!vars
\end_layout

\end_inset

()
\family default
 and 
\family typewriter
population::
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!population
\end_layout

\end_inset

dvars()
\family default
 to access a population dictionary.
 These functions return the same dictionary object but 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is equivalent to 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 Because dictionary 
\family typewriter
subPop[spID]
\family default
 is frequently used by operators to store variables related to a particular
 (virtual) subpopulation, function 
\family typewriter
pop.vars(subPop)
\family default
 is provided as a shortcut to 
\family typewriter
pop.vars()['subPop'][spID]
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popVars"

\end_inset

 demonstrates how to set and access Population variables.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popVars.log"
lstparams "caption={Population variables},label={popVars}"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that this dictionary forms a 
\series bold
local namespace
\series default
 in which Python expressions can be evaluated.
 This is the basis of how expression-based operators work.
 For example, the 
\family typewriter
pyEval 
\family default
operator in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

 evaluates expression 
\family typewriter
``'%.2f
\backslash
t' % LD[0][1]''
\family default
 in each population's local namespace when it is applied to that population.
 This yields different results for different population because their LD
 values are different.
 In addition to Python expressions, Python statements can also be executed
 in the local namespace of a population, using the 
\family typewriter
stmts
\family default
 parameter of the 
\family typewriter
pyEval
\family default
 or 
\family typewriter
pyExec
\family default
 operator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates the use of a simuPOP terminator, which terminates the evolution
 of a population when its expression is evaluated as 
\family typewriter
True
\family default
.
 Note that The 
\family typewriter
evolve() 
\family default
function of this example does not specify how many generations to evolve
 so it will stop only after all replicates stop.
 The return value of this function indicates how many generations each replicate
 has evolved.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/expression.log"
lstparams "caption={Expression evaluation in the local namespace of a population},label={expression}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and load a population
\end_layout

\begin_layout Standard
simuPOP populations can be saved to and loaded from disk files using 
\family typewriter
population::save
\begin_inset Index
status open

\begin_layout Plain Layout
population!save
\end_layout

\end_inset

(file)
\family default
 member function and global function 
\family typewriter
LoadPopulation
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
function!LoadPopulation
\end_layout

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 because 
\family typewriter
LoadPopulation
\family default
 is a global function.).
 
\series bold
Virtual splitters are not saved
\series default
 because they are considered as runtime definitions.
 Although files in any extension can be used, extension 
\family typewriter
.pop
\family default
 is recommended.
 
\end_layout

\begin_layout Standard
The native simuPOP format is not human readable and is not recognized by
 other applications.
 Other formats such as the one used by the popular 
\family typewriter
FSTAT 
\family default
software is supported.
 They are implemented in Python in a Python utility module 
\family typewriter
simuUtil.py
\family default
.
 simuPOP cannot use one of such formats because none of them can handle
 huge populations that simuPOP can handle, and unique features such as populatio
n variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to save and load a population in the native simuPOP format.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePop.log"
lstparams "caption={Save and load a population},label={savePop}"

\end_inset


\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They can be used in the following ways:
\end_layout

\begin_layout Itemize
Operators are usually passed to the 
\family typewriter
ops
\family default
, 
\family typewriter
preOps 
\family default
and 
\family typewriter
postOps
\family default
 parameters the 
\family typewriter
evolve
\family default
 function of a simulator.
 The simulator will apply these operators before (
\family typewriter
preOps
\family default
), after (
\family typewriter
postPos
\family default
) or during (
\family typewriter
ops
\family default
) an evolutionary process.
 Depending on parameters of an operator, it can be applied before, during,
 and/or after mating in a life cycle of a generation (parameter 
\family typewriter
stage
\family default
, see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), to a subset of generations (parameters 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
), a subset of populations in a simulator (parameter 
\family typewriter
rep
\family default
), a subset of (virtual) subpopulations in each replicate (parameter 
\family typewriter
subPop
\family default
).
\end_layout

\begin_layout Itemize
During-mating operators are used by mating schemes to transmit parental
 genotype (and sometimes information fields) to offspring.
 Applicability parameters such as 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
rep
\family default
 are ignored.
\end_layout

\begin_layout Itemize
Most of the operators can be applied to a population directly, using their
 function forms.
 Applicability parameters are ignored.
\end_layout

\begin_layout Standard
The following sections will introduce common features of all operators.
 The next chapter will explain some of the operators in detail.
\end_layout

\begin_layout Subsection
Applicable stages and generations
\end_layout

\begin_layout Standard
A simuPOP life cycle (a 
\emph on
generation
\emph default
) can be divided into 
\emph on
pre-mating
\emph default
, 
\emph on
during-mating
\emph default
 and 
\emph on
post-mating
\emph default
.
 In the pre-mating stage, the present generation is the parental generation.
 In the during-mating stage, an offspring generation is populated from the
 parental generation.
 In the post-mating stage, the offspring generation has become the present
 generation.
 An operator can be applied at one or more stages at a life cycle.
 However, each operator has its own default value for the 
\family typewriter
stage
\family default
 parameter and changes to this parameter are not always allowed.
 For example, a 
\family typewriter
recombinator
\family default
 can only be applied 
\family typewriter
DuringMating
\family default
 and it will ignore your attemp to apply it at another stage.
\end_layout

\begin_layout Standard
Operators that are passed to the 
\family typewriter
ops
\family default
 parameter of the 
\family typewriter
simulator::evolve
\family default
 function are, by default, applied to all generations during an evolutionary
 process.
 This can be changed using the 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
 parameters.
 As their names indicate, these parameters control the starting generation
 (
\family typewriter
begin
\family default
), ending generation (
\family typewriter
end
\family default
), generations between two applicable generations (
\family typewriter
step
\family default
), and an explicit list of applicable generations (
\family typewriter
at
\family default
, a single generation number is also acceptable).
 Other parameters will be ignored if 
\family typewriter
at
\family default
 is specified.
 It is worth noting that, if the simulator has an ending generation, negative
 generations numbers are allowed.
 They are counted backward from the ending generation.
\end_layout

\begin_layout Standard
For example, if a simulator starts at generation 
\family typewriter
0
\family default
, and the 
\family typewriter
evolve
\family default
 function has parameter 
\family typewriter
gen=10
\family default
, the simulator will stop at the 
\emph on
beginning
\emph default
 of generation 
\family typewriter
10
\family default
.
 Generation 
\family typewriter
-1
\family default
 refers to generation 
\family typewriter
9
\family default
, and generation 
\family typewriter
-2
\family default
 refers to generation 
\family typewriter
8
\family default
, and so on.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to set applicable stages and generations of an operator.
 In this example, a population is initialized before evolution using a 
\family typewriter
initByFreq
\family default
 operator.
 allele frequency at locus 
\family typewriter
0
\family default
 is calculated at generation 
\family typewriter
80
\family default
, 
\family typewriter
90
\family default
, but not 
\family typewriter
100
\family default
 because the evolution stops at the beginning of generation 
\family typewriter
100
\family default
.
 A 
\family typewriter
pyEval
\family default
 operator outputs generation number and allele frequency at the end of generatio
n 
\family typewriter
80
\family default
 and 
\family typewriter
90
\family default
.
 Another 
\family typewriter
pyEval
\family default
 operator outputs similar information at generation 
\family typewriter
90
\family default
 and 
\family typewriter
99
\family default
, before and after mating.
 Note, however, because allele frequencies are only calculated twice, the
 pre-mating allele frequency at generation 
\family typewriter
90
\family default
 is actually calculated at generation 
\family typewriter
80
\family default
, and the allele frequencies display for generation 
\family typewriter
99
\family default
 are calculated at generation 
\family typewriter
90
\family default
.
 At the end of the evolution, the population is saved to a file using a
 
\family typewriter
savePopulation
\family default
 operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/stageAndGen.log"
lstparams "caption={Applicable stages and generations of an operator.},label={stageAndGen}"

\end_inset


\end_layout

\begin_layout Subsection
Applicable populations
\end_layout

\begin_layout Standard
A simulator can evolve multiple replicates of a population simultaneously.
 Different operators can be applied to different replicates of this population.
 This allows side by side comparison between simulations.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
rep
\family default
 is used to control which replicate(s) an operator can be applied to.
 This parameter can be a list of replicate numbers or a single replicate
 number.
 Negative index is allowed where 
\family typewriter
-1
\family default
 refers to the last replicate.
 This technique has been widely used to produce table-like output where
 a 
\family typewriter
pyOutput
\family default
 outputs a newline when it is applied to the last replicate of a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to use this 
\family typewriter
rep
\family default
 parameter.
 It is worth noting that negative indexes are 
\emph on
dynamic
\emph default
 indexes relative to number of active populations.
 For example, 
\family typewriter
rep=-1
\family default
 will refer to a previous population if the last population has stopped
 evolving.
 Use a non-negative replicate number if this is not intended.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/replicate.log"
lstparams "caption={Apply operators to a subset of populations},label={replicate}"

\end_inset


\end_layout

\begin_layout Standard
An operator can also be applied to specified (virtual) subpopulations.
 For example, an 
\family typewriter
initializer
\family default
 can be applied to male individuals in the first subpopulation, and everyone
 in the second subpopulation using parameter 
\family typewriter
subPops=[(0,0)
\family default
, 1], if a virtual subpopulation is defined by individual sex.
 However, not all operators support this parameter, and even if they do,
 their interpretations of parameter input may vary.
 Please refer to 
\emph on
the simuPOP reference manual
\emph default
 for details.
\end_layout

\begin_layout Subsection
Operator output
\end_layout

\begin_layout Standard
All operators we have seen, except for the 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

, write their output to the standard output, namely your terminal window.
 However, it would be much easier for bookkeeping and further analysis if
 these output can be redirected to disk files.
 Parameter 
\family typewriter
output
\family default
 is designed for this purpose.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
output
\family default
 can take the following values:
\end_layout

\begin_layout Itemize

\family typewriter
''
\family default
 (an empty string): No output.
\end_layout

\begin_layout Itemize

\family typewriter
'>'
\family default
: Write to standard output.
\end_layout

\begin_layout Itemize

\family typewriter
'filename'
\family default
 or 
\family typewriter
'>filename'
\family default
: Write the output to a file named filename.
 If multiple operators write to the same file, or if the same operator writes
 to the file file several times, only the last write operation will succeed.
\end_layout

\begin_layout Itemize

\family typewriter
'>>filename'
\family default
: Append the output to a file named filename.
 The file will be opened at the beginning of 
\family typewriter
evolve
\family default
 function and closed at the end.
 An existing file will be cleared.
\end_layout

\begin_layout Itemize

\family typewriter
'>>>filename'
\family default
: This is similar to the 
\family typewriter
'>>'
\family default
 form but the file will not be cleared at the beginning of the 
\family typewriter
evolve
\family default
 function.
\end_layout

\begin_layout Itemize

\family typewriter
'!expr'
\family default
: 
\family typewriter
expr
\family default
 is considered as a Python expression that will be evaluated at a population's
 local namespace whenever an output string is needed.
 For example, 
\family typewriter
'!
\begin_inset Quotes erd
\end_inset

%d.txt
\begin_inset Quotes erd
\end_inset

 % gen'
\family default
 would return 
\family typewriter
0.txt
\family default
, 
\family typewriter
1.txt
\family default
 etc at generation 
\family typewriter
0
\family default
, 
\family typewriter
1
\family default
, ....
\end_layout

\begin_layout Standard
Because a table output such as the one in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 is written by several operators, it is clear that all of them need to use
 the 
\family typewriter
'>>'
\family default
 output format.
\end_layout

\begin_layout Standard
The 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

 write to file 
\family typewriter
sample.pop
\family default
.
 This works well if there is only one replicate but not so when the operator
 is applied to multiple populations.
 Only the last population will be saved successfully! In this case, the
 expression form of parameter 
\family typewriter
output
\family default
 should be used.
\end_layout

\begin_layout Standard
The expression form of this parameter accepts a Python expression.
 Whenever a filename is needed, this expression is evaluated against the
 local namespace of the population it is applied to.
 Because the 
\family typewriter
evolve
\family default
 function automatically sets variables 
\family typewriter
gen
\family default
 and 
\family typewriter
rep
\family default
 in a population's local namespace, such information can be used to produce
 an output string.
 Of course, any variable in this namespace can be used so you are not limited
 to these two variable.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates the use of these two parameters.
 In this example, a table is written to file 
\family typewriter
LD.txt
\family default
 using 
\family typewriter
output='>>LD.txt'
\family default
.
 Similar operation to 
\family typewriter
output='R2.txt'
\family default
 fails because only the last 
\begin_inset Formula $R^{2}$
\end_inset

 value is written to this file.
 The last operator writes output for each replicate to their respective
 output file such as 
\family typewriter
LD_0.txt
\family default
, using an expression that involves variable 
\family typewriter
rep
\family default
.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/output.log"
lstparams "caption={Use the output and outputExpr parameters},label={output}"

\end_inset


\end_layout

\begin_layout Subsection
Hybrid operators
\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a 
\emph on
hybrid operator
\emph default
.
\end_layout

\begin_layout Standard
A 
\emph on
hybrid operator
\emph default
 is an operator that calls a user-defined function when its applied to a
 population.
 The number and meaning of input parameters and return values vary from
 operator to operator.
 For example, a hybrid mutator sends a to-be-mutated allele to a user-defined
 function and use its return value as a mutant allele.
 A hybrid selector uses the return value of a user defined function as individua
l fitness.
 Such an operator handles the routine part of the work (e.g.
 scan through a chromosome and determine which allele needs to be mutated),
 and leave the creative part to users.
 Such a mutator can be used to implement complicated genetic models such
 as an asymmetric stepwise mutation model for microsatellite markers.
\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset CommandInset citation
LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (parameter 
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability that this individual will become
 affected.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/hybrid.log"
lstparams "caption={Use a hybrid operator},keywordstyle={\\ttfamily},label={hybridOperator}"

\end_inset


\end_layout

\begin_layout Subsection
Python operators
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can always resort
 to a pure-Python operator 
\family typewriter
pyOperator
\family default
.
 This operator has full access to the evolving population (or parents and
 offspring when 
\family typewriter
stage=DuringMating
\family default
), and can therefore perform arbitrary operations.
\end_layout

\begin_layout Standard
A pre- or post-mating 
\family typewriter
pyOperator
\family default
 expects a function in the form of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

func(pop [, param])
\end_layout

\end_inset

where 
\family typewriter
param
\family default
 is optional, depending on whether or not a parameter is passed to the 
\family typewriter
pyOperator()
\family default
 constructor.
 Function 
\family typewriter
func
\family default
 can perform arbitrary action to 
\family typewriter
pop
\family default
 and must return 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
.
 The evolution of 
\family typewriter
pop
\family default
 will be stopped if this function returns 
\family typewriter
False
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 defines such a function.
 It accepts a cutoff value and two mutation rates as parameters.
 It then calculate the frequency of allele 1 at each locus and apply a two-allel
e model at high mutation rate if the frequency is lower than the cutoff
 and a low mutation rate otherwise.
 The 
\family typewriter
KamMutate
\family default
 function is the function form of a mutator 
\family typewriter
kamMutator
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Function-form"

\end_inset

 for details).
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.py"
lstparams "caption={A frequency dependent mutation operator},firstline=5,label={pyOperator},lastline=19"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 demonstrates how to use this operator.
 It first initializes the population using two 
\family typewriter
initByFreq
\family default
 operators that initialize loci with different allele frequencies.
 It applies a 
\family typewriter
pyOperator 
\family default
with function 
\family typewriter
dynaMutator
\family default
 and a tuple of parameters.
 Allele frequencies at all loci are printed at generation 
\family typewriter
0
\family default
, 
\family typewriter
10
\family default
, 
\family typewriter
20
\family default
, and 
\family typewriter
30
\family default
.
 Note that this 
\family typewriter
pyOperator
\family default
 is applied at 
\family typewriter
stage=PreMating
\family default
 (the default stage is post mating) so allele frequencies have to be recalculate
d to be used by post-mating operator 
\family typewriter
pyEval
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.log"
lstparams "caption={Use a pyOperator during evolution},firstline=16,label={usePyOperator}"

\end_inset


\end_layout

\begin_layout Standard
An 
\family typewriter
pyOperator
\family default
 can also be applied during-mating.
 They can be used to filter out unwanted offspring (by returning 
\family typewriter
False
\family default
 in a user-defined function), modify offspring, calculate statistics, or
 pass additional information from parents to offspring.
 Depending on parameter 
\family typewriter
param
\family default
 and 
\family typewriter
offspringOnly
\family default
, such an operator accepts a function in the form of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

func(pop, dad, mom, off [, param])  # if offspringOnly=False (default)
\end_layout

\begin_layout Plain Layout

func(off [, param])                 # if offspringOnly=True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "duringMatingPyOperator"

\end_inset

 demonstrates the use of a during-mating Python operator.
 This operator rejects an offspring if it has allele 1 at the first locus
 of the first homologous chromosome, and results in an offspring population
 without such individuals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyDuringMatingOperator.log"
lstparams "caption={Use a during-mating pyOperator},label={duringMatingPyOperator}"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is the most powerful operator in simuPOP and has been widely used, for
 example, to calculate statistics and is not supported by the 
\family typewriter
stat()
\family default
 operator, to examine population property during evolution, or prepare populatio
ns for a special mating scheme.
 However, because 
\family typewriter
pyOperator 
\family default
works in the Python interpreter, it is expected that it runs slower than
 operators that are implemented at the C/C++ level.
 If performance becomes an issue, you can re-implement part or all the operator
 in C++.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Using-C++"

\end_inset

 describes how to do this.
\end_layout

\begin_layout Subsection
Define your own operators
\end_layout

\begin_layout Standard

\emph on
This is an advanced topic of simuPOP.
 New simuPOP users can safely skip this section.
\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is a Python class so you can derive your own operator from this operator.
 The tricky part is that the constructor of the derived operator needs to
 call the 
\family typewriter
__init__
\family default
 function of 
\family typewriter
pyOperator
\family default
 will proper functions.
 This technique has been used by simuPOP in a number of occasions.
 For example, the 
\family typewriter
varPlotter
\family default
 operator defined in 
\family typewriter
simuRPy.py
\family default
 is derived from 
\family typewriter
pyOperator
\family default
.
 This class encapsulates several different plot class that uses 
\family typewriter
rpy
\family default
 to plot python expressions.
 One of the plotters is passed to the func parameter of 
\family typewriter
pyOperator::__init__
\family default
 so that it can be called when this operator is applied.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 rewrites the 
\family typewriter
dynaMutator
\family default
 defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 into a derived operator.
 The parameters are now passed to the constructor of 
\family typewriter
dynaMutator
\family default
 and are saved as member variables.
 A member function 
\family typewriter
mutate
\family default
 is defined and is passed to the constructor of 
\family typewriter
pyOperator
\family default
.
 Other than making 
\family typewriter
dynaMutator
\family default
 look like a real simuPOP operator, this example does not show a lot of
 advantage over defining a function.
 However, when the operator gets complicated (as in the case for 
\family typewriter
varPlotter
\family default
), the object oriented implementation will prevail.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/newOperator.log"
lstparams "caption={Define a new Python operator},label={newOperator}"

\end_inset


\end_layout

\begin_layout Standard
New during-mating operators can be defined similarly.
 They are usually used to define customized genotype transmitters.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Customized-genotype-transmitter"

\end_inset

 will describe this feature in detail.
\end_layout

\begin_layout Subsection
Function form of an operator
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-form"

\end_inset


\end_layout

\begin_layout Standard
Operators are usually applied to populations through a simulator but they
 can also be applied to a population directly.
 For example, it is possible to create an 
\family typewriter
initByFreq
\family default
 operator and apply to a population as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initByFreq([.3, .2, .5]).apply(pop)
\end_layout

\end_inset

Similarly, you can apply the hybrid penetrance model defined in Example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 to a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyPenetrance(func=myPenetrance, loci=[10, 30, 50]).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This usage is used so often that it deserves some simplification.
 Equivalent functions are defined for most operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitByFreq.log"
lstparams "caption={The function form of operator \\texttt{initByFreq}},label={InitByFreq}"

\end_inset


\end_layout

\begin_layout Standard
These functions are called function form of operators.
 Using these functions, the above two example can be written as 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InitByFreq(pop, [.3, .2, .5])
\end_layout

\end_inset

and 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyPenetrance(pop, func=myPenetrance, loci=[10, 30, 50])
\end_layout

\end_inset

respectively.
 Note that applicability parameters such as 
\family typewriter
begin
\family default
 and 
\family typewriter
end
\family default
 can still be passed, but they are ignored by these functions.
\end_layout

\begin_layout Section
Mating Schemes
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mating schemes are responsible for populating an offspring generation from
 the parental generation.
 There are currently three types of mating schemes
\end_layout

\begin_layout Itemize
A 
\series bold
homogeneous mating scheme
\series default
 is the most flexible and most frequently used mating scheme and is the
 center topic of this section.
 A homogeneous mating is composed of a 
\emph on
parent chooser
\emph default
 that is responsible for choosing parent(s) from a (virtual) subpopulation
 and an 
\emph on
offspring generator
\emph default
 that is used to populate all or part of the offspring generation.
 During-mating operators are used to transmit genotypes from parents to
 offspring.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:homogeneous-mating-scheme"

\end_inset

 demonstrates this process.
\end_layout

\begin_layout Itemize
A 
\series bold
heterogeneous mating scheme
\series default
 applies several homogeneous mating scheme to different (virtual) subpopulations.
 Because the division of virtual subpopulations can be arbitrary, this mating
 scheme can be used to simulate mating in heterogeneous populations such
 as populations with age structure.
\end_layout

\begin_layout Itemize
A 
\series bold
pedigree mating scheme
\series default
 that follows a recorded evolutionary scenario.
 The selection of parents and the production of offspring are controlled
 by a pedigree.
 This mating scheme does not support virtual subpopulation.
\end_layout

\begin_layout Standard
This section describes some standard features of mating schemes and most
 pre-defined mating schemes.
 The next section will demonstrate how to build complex nonrandom mating
 schemes from scratch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:homogeneous-mating-scheme"

\end_inset

A homogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename HomoMatingScheme.eps
	lyxscale 20
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
A homogeneous mating scheme is responsible to choose parent(s) from a subpopulat
ion or a virtual subpopulation, and population part or all of the corresponding
 offspring subpopulation.
 A parent chooser is used to choose one or two parents from the parental
 generation, and pass it to an offspring generator, which produces one or
 more offspring.
 During mating operators such as taggers and recombinator can be applied
 when offspring is generated.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Control the size of the offspring generation
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-size"

\end_inset


\end_layout

\begin_layout Standard
A mating scheme goes through each subpopulation and populates the subpopulations
 of an offspring generation sequentially.
 The number of offspring in each subpopulation is determined by the mating
 scheme, following the following rules:
\end_layout

\begin_layout Itemize
A simuPOP mating scheme, by default, produces an offspring generation that
 has the same subpopulation sizes as the parental generation.
 This does not guarantee a constant population size because some operators,
 such as a migrator, can change population or subpopulation sizes.
\end_layout

\begin_layout Itemize
If fixed subpopulation sizes are given to parameter 
\family typewriter
subPopSize
\family default
.
 A mating scheme will generation an offspring generation with specified
 sizes even if an operator has changed parental population sizes.
\end_layout

\begin_layout Itemize
A demographic function can be specified to parameter 
\family typewriter
subPopSize
\family default
.
 This function should take two parameters: the generation number and the
 current subpopulation sizes, and return an array of new subpopulation sizes.
 A single number can be returned if there is only one subpopulation.
\end_layout

\begin_layout Standard
The following examples demonstrate these cases.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrSize"

\end_inset

 uses a default 
\family typewriter
randomMating()
\family default
 scheme that keeps parental subpopulation sizes.
 Because migration between two subpopulations are asymmetric, the size of
 the first subpopulation increases at each generation, although the overall
 population size keeps constant.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrSize.log"
lstparams "caption={Free change of subpopulation sizes},label={migrSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrFixedSize"

\end_inset

 uses the same migrator to move individuals between two subpopulations.
 Because a constant subpopulation size is specified, the offspring generation
 always has 500 and 1000 individuals in its two subpopulations.
 Note that operators 
\family typewriter
stat
\family default
 and 
\family typewriter
pyEval
\family default
 are applied both before and after mating.
 It is clear that subpopulation sizes changes before mating as a result
 of migration, although the pre-mating population sizes vary because of
 uncertainties of migration.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrFixedSize.log"
lstparams "caption={Force constant subpopulation sizes},label={migrFixedSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "polygamous"

\end_inset

 uses a demographic function to control the subpopulation size of the offspring
 generation.
 This example implements a linear population expansion model but arbitrarily
 complex demographic model can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoFunc.log"
lstparams "caption={Use a demographic function to control population size},label={demoFunc}"

\end_inset


\end_layout

\begin_layout Standard
All these examples have fixed number of subpopulations.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:splitAndMerge"

\end_inset

 will introduce how to split and merge subpopulations dynamically.
\end_layout

\begin_layout Subsection
Determine the number of offspring during mating
\begin_inset CommandInset label
LatexCommand label
name "sub:number-of-offspring"

\end_inset


\end_layout

\begin_layout Standard
simuPOP by default produces only one offspring per mating event.
 Because more parents are involved in the production of offspring, this
 setting leads to larger effective population sizes than mating schemes
 that produce more offspring at each mating event.
 However, various situations require a larger family size or even varying
 family sizes.
 In these cases, parameter 
\family typewriter
numOffspring
\family default
 can be used to control the number of offspring that are produced at each
 mating event.
 This parameter takes the following types of inputs
\end_layout

\begin_layout Itemize
If a single number is given, 
\family typewriter
numOffspring
\family default
 offspring are produced at each mating event.
\end_layout

\begin_layout Itemize
If a Python function is given, this function will be called each time when
 a mating event happens.
 Generation number will be passed to this function, which allows different
 numbers of offspring at different generations.
\end_layout

\begin_layout Itemize
If a tuple (or list) with more than one numbers is given, the first number
 must be one of 
\family typewriter
GeometricDistribution
\family default
, 
\family typewriter
PoissonDistribution
\family default
, 
\family typewriter
BinomialDistribution
\family default
 and 
\family typewriter
UniformDistribution
\family default
, with one or two additional parameters.
 The number of offspring will then follow a specific statistical distribution.
 Note that all these distributions are adjusted so that the minimal number
 of offspring is 1.
\end_layout

\begin_layout Standard
More specifically, 
\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(GeometricDistribution, p)
\family default
: The number of offspring for each mating event follows a geometric distribution
 with mean 
\begin_inset Formula $1/p$
\end_inset

 and variance 
\begin_inset Formula $\left(1-p\right)/p^{2}$
\end_inset

: 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(PoissonDistribution, p)
\family default
: The number of offspring for each mating event follows a shifted Poisson
 distribution with mean 
\begin_inset Formula $p+1$
\end_inset

 (you need to specify, for example, 2, if you want a mean family size of
 3) and variance 
\begin_inset Formula $p$
\end_inset

.
 The distribution is
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=p^{k-1}\frac{e^{-p}}{\left(k-1\right)!}\;\textrm{ for}k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(BinomialDistribution, p, n): 
\family default
The number of offspring for each mating event follows a shifted Binomial
 distribution with mean 
\begin_inset Formula $(n-1)p+1$
\end_inset

 and variance 
\begin_inset Formula $\left(n-1\right)p\left(1-p\right)$
\end_inset

.
 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}+1\;\textrm{ for }n\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(UniformDistribution, a, b):
\family default
 The number of offspring for each mating event follows a discrete uniform
 distribution with lower bound 
\begin_inset Formula $a$
\end_inset

 and upper bound 
\begin_inset Formula $b$
\end_inset

.
 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=\frac{1}{b-a+1}\;\textrm{ for }b\geq k\geq a\]

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "numOff"

\end_inset

 demonstrates how to use parameter 
\family typewriter
numOffspring
\family default
.
 In this example, a function 
\family typewriter
checkNumOffspring
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 30 individuals.
 After evolving a population for one generation, parental indexes are used
 to identify siblings, and then the number of offspring per mating event.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/numOff.log"
lstparams "caption={Control the number of offspring per mating event.},label={numOff}"

\end_inset


\end_layout

\begin_layout Subsection
Determine offspring sex
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-sex"

\end_inset


\end_layout

\begin_layout Standard
Because sex can influence how genotypes are transmitted (e.g.
 sex chromosomes, haplodiploid population), simuPOP determines offspring
 sex before it passes an offspring to a 
\emph on
genotype transmitter
\emph default
 (during-mating operator) to transmit genotype from parents to offspring.
 The default 
\family typewriter
sexMode
\family default
 in almost all mating schemes is 
\family typewriter
RandomSex
\family default
, in which case simuPOP assign 
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
 to offspring with equal probability.
\end_layout

\begin_layout Standard
Other sex determination methods are also available:
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=NoSex
\family default
: Sex is not simulated so everyone is Male.
 This is the default mode where offspring can be Male or Female with equal
 probability.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(ProbOfMale, prob)
\family default
: Produce males with given probability.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NumOfMale, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Male
\family default
.
 If the number of offspring at a mating event is less than or equal to 
\family typewriter
n
\family default
, all offspring will be male.
 
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NumOfFemale, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Female
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
NumOfMale
\family default
 and 
\family typewriter
NumOfFemale
\family default
 are useful in theoretical studies where the sex ratio of a population needs
 to be controlled strictly, or in special mating schemes, usually for animal
 populations, where only a certain number of male or female individuals
 are allowed in a family.
 It worth noting that a genotype transmitter can override specified offspring
 sex.
 This is the case for 
\family typewriter
cloneGenoTransmitter
\family default
 where an offspring inherits both genotype and sex from his/her parent.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexMode"

\end_inset

 demonstrates how to use parameter 
\family typewriter
sexMode
\family default
.
 In this example, a function 
\family typewriter
checkSexMode
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 40 individuals.
 After evolving a population for one generation, sexes of all offspring
 are returned as a string.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexMode.log"
lstparams "caption={Determine the sex of offspring},label={sexMode}"

\end_inset


\end_layout

\begin_layout Subsection
Monogamous mating
\end_layout

\begin_layout Standard
Monogamous mating (monogamy) in simuPOP refers to mating schemes in which
 each parent mates only once.
 In an asexual setting, this implies parents are chosen without replacement.
 In sexual mating schemes, this means that parents are chosen without replacemen
t, they have only one spouse during their life time so that all siblings
 have the same parents (no half-sibling).
\end_layout

\begin_layout Standard
simuPOP provides a diploid sexual monogamous mating scheme 
\family typewriter
monogamousMating
\family default
.
 However, without careful planning, this mating scheme can easily stop working
 due to the lack of parents.
 For example, if a population has 40 males and 55 females, only 40 successful
 mating events can happen and result in 40 offspring in the offspring generation.
 
\family typewriter
monogamousMating
\family default
 will exit if the offspring generation is larger than 40.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "monogamous"

\end_inset

 demonstrates one scenario of using a monogamous mating scheme where sex
 of parents and offspring are strictly specified so that parents will not
 be exhausted.
 The sex initializer 
\family typewriter
initSex
\family default
 assigns exactly 10 males and 10 females to the initial population.
 Because of the use of 
\family typewriter
numOffspring=2, sexMode=(NumOfMale, 1)
\family default
, each mating event will produce exactly one male and one female.
 Unlike a random mating scheme that only about 80% of parents are involved
 in the production of an offspring population with the same size, this mating
 scheme makes use of all parents.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/monogamous.log"
lstparams "caption={Sexual monogamous mating},label={monogamous}"

\end_inset


\end_layout

\begin_layout Subsection
Polygamous mating
\end_layout

\begin_layout Standard
In comparison to monogamous mating, parents in a polygamous mate with more
 than one spouse during their life-cycle.
 Both 
\emph on
polygany
\emph default
 (one man has more than one wife) and 
\family typewriter
\emph on
polyandry
\family default
\emph default
 (one woman has more than one husband) are supported.
\end_layout

\begin_layout Standard
Other than regular parameters such as 
\family typewriter
numOffspring
\family default
, mating scheme 
\family typewriter
polygamousMating
\family default
 accepts parameters 
\family typewriter
polySex
\family default
 (default to 
\family typewriter
Male
\family default
) and 
\family typewriter
polyNum
\family default
 (default to 1).
 During mating, an individual with 
\family typewriter
polySex
\family default
 is selected and then mate with 
\family typewriter
polyNum
\family default
 randomly selected spouse.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "polygamous"

\end_inset

 demonstrates the use of this mating schemes.
 Note that this mating scheme support natural selection, but does not yet
 handle varying 
\family typewriter
polyNum
\family default
 and selection of parents without replacement.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/polygamous.log"
lstparams "caption={Sexual polygamous mating},label={polygamous}"

\end_inset


\end_layout

\begin_layout Subsection
Asexual random mating
\end_layout

\begin_layout Standard
Mating scheme 
\family typewriter
randomSelection
\family default
 implements an asexual random mating scheme.
 It randomly select parents from a parental population (with replacement)
 and copy them to an offspring generation.
 Both genotypes and sex of the parents are copied because genotype and sex
 are sometimes related.
 This mating scheme can be used to simulate the evolution of haploid sequences
 in a standard haploid Wright-Fisher model.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomSelection"

\end_inset

 applies a 
\family typewriter
randomSelection
\family default
 mating scheme to a haploid population with 100 sequences.
 A 
\family typewriter
parentTagger
\family default
 is used to track the parent of each individual.
 Although sex information is not used in this mating scheme, individual
 sexes are initialized and passed to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomSelection.log"
lstparams "caption={Asexual random mating},label={randomSelection}"

\end_inset


\end_layout

\begin_layout Subsection
Mating with alpha individuals
\end_layout

\begin_layout Standard
The 
\family typewriter
alphaMating
\family default
 mating scheme is intended to simulate animal populations in which only
 individuals with alpha status have the power to mate.
 In this mating scheme, a number of alpha individuals with specified sex
 (
\family typewriter
alphaSex
\family default
) are determined, either randomly (
\family typewriter
alphaNum
\family default
) or according to values at an information field (
\family typewriter
alphaField
\family default
).
 During mating, only individuals from this alpha group can be selected to
 mate.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "alphaMating"

\end_inset

 gives a simple evolutionary scenario where two alpha males are chosen according
 to individual fitness values at each generation.
 The fitness value of each individual is determined by his/her genotype
 at the first locus, 
\family typewriter
0.8
\family default
, 
\family typewriter
0.8
\family default
, and 
\family typewriter
1
\family default
 for genotype 
\family typewriter
AA
\family default
, 
\family typewriter
Aa
\family default
, and 
\family typewriter
aa
\family default
 respectively.
 Because individuals having mutant 
\family typewriter
a
\family default
 have a high probability to be selected, and become the alpha male in this
 population, the frequency of this mutant tend to increase in this population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/alphaMating.log"
lstparams "caption={Random mating with alpha individuals},label={alphaMating}"

\end_inset


\end_layout

\begin_layout Subsection
Mating in haplodiploid populations
\end_layout

\begin_layout Standard
Male individuals in a haplodiploid population are derived from unfertilized
 eggs and thus have only one set of chromosomes.
 Mating in such a population is handled by a special mating scheme called
 
\family typewriter
haplodiplodMating
\family default
.
 This mating scheme chooses a pair of parents randomly and produces some
 offspring.
 It transmit maternal chromosomes and paternal chromosomes (the only copy)
 to female offspring, and only maternal chromosomes to male offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "haplodiploidMating"

\end_inset

 demonstrates how to use this mating scheme.
 It uses three initializers because sex has to be initialized before two
 other intializers can initialize genotype by sex.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploidMating.log"
lstparams "caption={Random mating in haplodiploid populations},label={haplodiploidMating}"

\end_inset


\end_layout

\begin_layout Standard
Note that this mating scheme does not support recombination and the standard
 recombinator does not work with haplodiploid populations.
 Please refer to the next Chapter for how to define a customized genotype
 transmitter to handle such a situation.
\end_layout

\begin_layout Subsection
Self-fertilization
\end_layout

\begin_layout Standard
Some plant populations evolve through self-fertilization.
 That is to say, a parent fertilizes with itself during the production of
 offspring (seeds).
 In a 
\family typewriter
selfMating
\family default
 mating scheme, parents are chosen randomly (one at a time), and are used
 twice to produce two homologous sets of offspring chromosomes.
 The standard recombinator can be used with this mating scheme.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selfMating"

\end_inset

 initializes each chromosome with different alleles to demonstrate how these
 alleles are transmitted in this population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selfMating.log"
lstparams "caption={Selfing mating scheme},label={selfMating}"

\end_inset


\end_layout

\begin_layout Subsection
Heterogeneous mating schemes
\end_layout

\begin_layout Standard
Different groups of individuals in a population may have different mating
 patterns.
 For example, individuals with different properties can have varying fecundity,
 represented by different numbers of offspring generated per mating event.
 This can be extended to aged populations in which only adults (may be defined
 by age > 20 and age < 40) can produce offspring, where other individuals
 will either be copied to the offspring generation or die.
\end_layout

\begin_layout Standard
A heterogeneous mating scheme (
\family typewriter
heteroMating
\family default
) accepts a list of mating schemes that are applied to different subpopulation
 or virtual subpopulations.
 If multiple mating schemes are applied to the same subpopulation, each
 of them only population part of the offspring subpopulation.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heterogenous-mating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heterogenous-mating"

\end_inset

Illustration of a heterogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename MatingScheme.eps
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
A heterogeneous mating scheme that applies homogeneous mating schemes MS0,
 MS0.0, MS0.1, MS1, MS2.0 and MS2.1 to subpopulation 0, the first and second
 virtual subpopulation in subpopulation 0, subpopulation 1, the first and
 second virtual subpopulation in subpopulation 2, respectively.
 Note that VSP 0 and 1 in subpopulation 0 overlap, and do not add up to
 subpopulation 0.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingSP"

\end_inset

 applies two random mating schemes to two subpopulations.
 The first mating scheme produces two offspring per mating event, and the
 second mating scheme produces four.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingSP.log"
lstparams "caption={Applying different mating schemes to different subpopulations },label={hateroMatingSP}"

\end_inset


\end_layout

\begin_layout Standard
The real power of heterogeneous mating schemes lies on their ability to
 apply different mating schemes to different virtual subpopulations.
 For example, due to different micro-environmental factors, plants in the
 same population may exercise both self and cross-fertilization.
 Because of the randomness of such environmental factors, it is difficult
 to divide a population into self and cross-mating subpopulations.
 Applying different mating schemes to groups of individuals in the same
 subpopulation is more appropriate.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingVSP"

\end_inset

 applies two mating schemes to two VSPs defined by proportions of individuals.
 In this mating scheme, 20% of individuals go through self-mating and 80%
 of individuals go through random mating.
 This can be seen from the parental indexes of individuals in the offspring
 generation: individuals whose 
\family typewriter
mother_idx
\family default
 are 
\family typewriter
-1
\family default
 are genetically only derived from their fathers.
 
\end_layout

\begin_layout Standard
It might be surprising that offspring resulted from two mating schemes mix
 with each other so the same VSPs in the next generation include both selfed
 and cross-fertilized offspring.
 If this not desired, you can set parameter 
\family typewriter
shuffleOffspring=False
\family default
 in 
\family typewriter
heteroMating
\family default
().
 Because the number of offspring that are produced by each mating scheme
 is proportional to the size of parental (virtual) subpopulation, the first
 20% of individuals that are produced by self-fertilization will continue
 to self-fertilize.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingVSP.log"
lstparams "caption={Applying different mating schemes to different virtual subpopulations },label={hateroMatingVSP}"

\end_inset


\end_layout

\begin_layout Standard
Because there is no restriction on the choice of VSPs, mating schemes can
 be applied to overlapped (virtual) subpopulations.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        selfMating(subPop=(0, 0)),
\end_layout

\begin_layout Plain Layout

        randomMating(subPop=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will apply selfMating to the first 20% individuals, and randomMating will
 be applied to all individuals.
 Similarly,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        selfMating(subPop=0),
\end_layout

\begin_layout Plain Layout

        randomMating(subPop=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will allow all individuals to be involved in both 
\family typewriter
selfMating
\family default
 and 
\family typewriter
randomMating
\family default
.
\end_layout

\begin_layout Standard
This raises the question of how many offspring each mating scheme will produce.
 By default, the number of offspring produced will be proportional to the
 size of parental (virtual) subpopulations.
 In the last example, because both mating schemes are applied to the same
 subpopulation, half of all offspring will be produced by selfing and the
 other half will be produced by random mating.
\end_layout

\begin_layout Standard
This behavior can be changed by a weighting scheme controlled by parameter
 
\family typewriter
weight
\family default
 of each homogeneous mating scheme.
 Briefly speaking, a positive weight will be compared against other mating
 schemes.
 a negative weight is considered proportional to the existing (virtual)
 subpopulation size.
 Negative weights are considered before position or zero weights.
\end_layout

\begin_layout Standard
This weighting scheme is best explained by an example.
 Assuming that there are three mating schemes working on the same parental
 subpopulation
\end_layout

\begin_layout Itemize
Mating scheme A works on the whole subpopulation of size 1000
\end_layout

\begin_layout Itemize
Mating scheme B works on a virtual subpopulation of size 500
\end_layout

\begin_layout Itemize
Mating scheme C works on another virtual subpopulation of size 800
\end_layout

\begin_layout Standard
Assuming the corresponding offspring subpopulation has 
\begin_inset Formula $N$
\end_inset

 individuals, 
\end_layout

\begin_layout Itemize
If all weights are 0, the offspring subpopulation is divided in proportion
 to parental (virtual) subpopulation sizes.
 In this example, the mating schemes will produce 
\begin_inset Formula $\frac{10}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{5}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{8}{23}N$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Itemize
If all weights are negative, they are multiplied to their parental (virtual)
 subpopulation sizes.
 For example, weight (-1, -2, -0.5) will lead to sizes (1000, 1000, 400)
 in the offspring subpopulation.
 If 
\begin_inset Formula $N\ne2400$
\end_inset

 in this case, an error will be raised.
\end_layout

\begin_layout Itemize
If all weights are positive, the number of offspring produced from each
 mating scheme is proportional to these weights.
 For example, weights (1, 2, 3) will lead to 
\begin_inset Formula $\frac{1}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{2}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{1}{3}N$
\end_inset

 individuals respectively.
 In this case, 0 weights will produce no offspring.
\end_layout

\begin_layout Itemize
If there are mixed positive and negative weights, the negative weights are
 processed first, and the rest of the individuals are divided using non-negative
 weights.
 For example, three mating schemes with weights (-0.5, 2, 3) will produce
 500, 
\begin_inset Formula $\frac{2}{5}\left(N-500\right)$
\end_inset

, 
\begin_inset Formula $\frac{3}{5}\left(N-500\right)$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Standard
The last case is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMatingWeight"

\end_inset

 where three random mating schemes are applied to subpopulation 
\family typewriter
0
\family default
, virtual subpopulation
\family typewriter
 (0, 0)
\family default
 and virtual subpopulation 
\family typewriter
(0, 1)
\family default
, with weights 
\family typewriter
-
\family default
0.5, 
\family typewriter
2
\family default
, and 
\family typewriter
3
\family default
 respectively.
 This example uses an advanced features that will be described in the next
 section.
 Namely, three during-mating Python operators are passed to each mating
 scheme to mark their offspring with different numbers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingWeight.log"
lstparams "caption={A weighting scheme used by heterogeneous mating schemes.},label={heteroMatingWeight}"

\end_inset


\end_layout

\begin_layout Section
Non-random and customized mating schemes
\end_layout

\begin_layout Standard

\emph on
The following sections discuss advanced topics of simuPOP.
 New simuPOP users can safely skip these sections.
\end_layout

\begin_layout Subsection
The structure of a homogeneous mating scheme
\end_layout

\begin_layout Standard
A 
\emph on
homogeneous mating scheme
\emph default
 populates an offspring generation as follows:
\end_layout

\begin_layout Enumerate
Create an empty offspring population (generation) with appropriate size.
 Parental and offspring generation can differ in size but they must have
 the same number of subpopulations.
\end_layout

\begin_layout Enumerate
For each subpopulation, repeatedly choose a parent or a pair of parents
 from the parental generation.
 This is done by a simuPOP object called a 
\series bold
parent chooser
\series default
.
\end_layout

\begin_layout Enumerate
One or more offspring are produced from the chosen parent(s) and are placed
 in the offspring population.
 This is done by a simuPOP 
\series bold
offspring generator
\series default
.
\end_layout

\begin_layout Enumerate
A offspring generator uses one or more during-mating operators to transmit
 parental genotype to offspring.
 These operators are call 
\series bold
genotype transmitters
\series default
.
\end_layout

\begin_layout Enumerate
After the offspring generation is populated, it will replace the parental
 generation and becomes the present generation of a population.
\end_layout

\begin_layout Standard
A simuPOP mating scheme uses a particular set of parent chooser, offspring
 generator, and genotype transmitters.
 For example, a 
\family typewriter
selfingMating
\family default
 mating scheme uses a 
\family typewriter
randomParentChooser
\family default
 to choose a parent randomly from a population, possibly according to individual
 fitness, it uses a standard 
\family typewriter
offspringGenerator
\family default
 that uses a 
\family typewriter
selfingOffspringGenerator
\family default
 to transmit genotype.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomMating"

\end_inset

 demonstrates how the most commonly used mating scheme, the diploid sexual
 
\family typewriter
randomMating
\family default
 mating scheme is defined in 
\family typewriter
simuPOP.py
\family default
.
 The following sections basically explain how you can construct your own
 mating scheme from scratch, using stocked or customized parent chooser,
 offspring generator and genotype transmitters.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomMating.py"
lstparams "caption={Define a random mating scheme},firstline=4,label={randomMating}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
homoMating
\family default
 mating scheme
\end_layout

\begin_layout Standard

\family typewriter
homoMating
\family default
 is used to define all pre-defined homogeneous mating schemes.
 It takes five parameters: 
\family typewriter
chooser
\family default
 (a 
\emph on
parent chooser
\emph default
 that is responsible for choosing one or two parents from the parental generatio
n), 
\family typewriter
generator
\family default
 (an 
\emph on
offspring generator
\emph default
 that is responsible for generating a number of offspring from the chosen
 parents), 
\family typewriter
subPopSize
\family default
 (parameter to control offspring subpopulation sizes), 
\family typewriter
subPop
\family default
 (applicable subpopulation or virtual subpopulation), and 
\family typewriter
weight
\family default
 (weighting parameter when used in a heterogeneous mating scheme).
 When this mating scheme is applied to the whole population, 
\family typewriter
subPopSize
\family default
 is used to determine the subpopulation sizes of the offspring generation
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

 for details), parameters 
\family typewriter
subPop
\family default
 and 
\family typewriter
weight
\family default
 are ignored.
 Otherwise, the number of offspring this mating scheme will produce is determine
d by the heterogeneous mating scheme.
 Figure 
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
subPopSize
\family default
, 
\family typewriter
subPop
\family default
 and 
\family typewriter
weight
\family default
 are more or less standard but different parent choosers and offspring generator
s can be combined to define a large number of homogeneous mating schemes.
 For example, the standard 
\family typewriter
selfMating
\family default
 mating scheme uses a 
\family typewriter
randomParentChooser
\family default
 but you can easily use a 
\family typewriter
sequentialParentChooser
\family default
 to choose parents sequentially and self-fertilize parents one by one.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sequentialSelfing.log"
lstparams "caption={Define a sequential selfing mating scheme},label={sequentialSelfing}"

\end_inset


\end_layout

\begin_layout Standard
The simuPOP reference manual lists all pre-defined parent choosers and offspring
 generators.
 They may or may not work together depending on the number of parents a
 parent chooser produces, and the number of parents an offspring generator
 can handle.
 You can also define your own parent choosers and offspring generators,
 as shown below.
\end_layout

\begin_layout Subsection
Offspring generators
\end_layout

\begin_layout Standard
An 
\family typewriter
offspringGenerator
\family default
 accepts a parameters 
\family typewriter
ops
\family default
 (a list of during-mating operators), 
\family typewriter
numOffspring
\family default
 (control number of offspring per mating event) and 
\family typewriter
sexMode
\family default
 (control offspring sex).
 We have examined the last two parameters in detail in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:number-of-offspring"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-sex"

\end_inset

.
 
\end_layout

\begin_layout Standard
The most tricky parameter is the 
\family typewriter
ops
\family default
 parameter.
 It accepts a list of during mating operators that are used to transmit
 genotypes from parent(s) to offspring.
 The standard 
\family typewriter
offspringGenerator
\family default
 does not have any default operator so no genotype will be transmitted by
 default.
 A number of specialized offspring generators are therefore defined.
 For example, a 
\family typewriter
mendelianOffspringGenerator
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomMating"

\end_inset

 uses a 
\family typewriter
mendelianGenoTransmitter 
\family default
as the default genotype transmitter.
 Additional during-mating operators can be added to the operator list, as
 shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMatingWeight"

\end_inset

, but the 
\family typewriter
mendelianGenoTransmitter
\family default
 will always be used to transmit genotypes.
\end_layout

\begin_layout Standard
Another offspring generator is provided in simuPOP.
 This 
\family typewriter
controlledOffspringGenerator 
\family default
is used to control an evolutionary process so that the allele frequencies
 at certain loci follows some pre-simulated 
\emph on
frequency trajectories
\emph default
.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

 for rationals behind such an offspring generator and its applications in
 the simulation of complex human diseases.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

 demonstrates the use of such a controlled offspring generator.
 Instead of using a realistic frequency trajectory function, it forces allele
 frequency at locus 5 to increase linearly.
 In contrast, the allele frequency at locus 15 on the second chromosome
 oscillates as a result of genetic drift.
 Note that the random mating version of this mating scheme is defined in
 simuPOP as 
\family typewriter
controlledRandomMating
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/controlledOffGenerator.log"
lstparams "caption={A controlled random mating scheme},label={controlledOffGenerator}"

\end_inset


\end_layout

\begin_layout Subsection
Pre-defined genotype transmitters
\begin_inset CommandInset label
LatexCommand label
name "sub:Pre-defined-genotype-transmitters"

\end_inset


\end_layout

\begin_layout Standard
Although any during mating operators can be used in parameter 
\family typewriter
ops 
\family default
of an offspring generator, only those that transmit genotype from parents
 to offspring are called 
\emph on
genotype transmitters
\emph default
.
 simuPOP provides a number of genotype transmitters including clone, Mendelian,
 selfing, haplodiploid, genotype transmitter, and a recombinator.
 They are usually used implicitly in a mating scheme, but they can also
 be used explicitly.
\end_layout

\begin_layout Standard
Genotype transmitters in an offspring generator are the 
\emph on
default
\emph default
 transmitters that can be replaced by another transmitter.
 If another transmitter is used in the 
\family typewriter
evolve
\family default
 function, it will override the default transmitter.
 For example, a 
\family typewriter
recombiantor
\family default
 will override the 
\family typewriter
mendelianGenoTransmitter()
\family default
 used in a 
\family typewriter
randomMating
\family default
 mating scheme.
 This is usually not a concern, but will be important if you are defining
 your own genotype transmitters.
\end_layout

\begin_layout Standard
All genotype transmitters only handle known chromosome types such as Autosome,
 ChromosomeX and ChromosomeY.
 Customized chromosomes are left untouched because simuPOP does not know
 how they should be transmitted from parents to offspring.
 In case that Customized chromosomes are treated as mitochondrial chromosomes,
 a 
\family typewriter
mitochondrialGenoTransmitter
\family default
 can be used to transmit Customized chromosomes randomly from mother to
 offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mitochondrial.log"

\end_inset

 demonstrates the use of a 
\family typewriter
recombinator
\family default
 to recombine an autosome and two sex chromosomes, and a 
\family typewriter
mitochondrialGenoTransmitter
\family default
 to transmit mitochondrial chromosomes.
 Note that,
\end_layout

\begin_layout Itemize
These two operators can be used in the ops parameter of both the 
\family typewriter
evolve
\family default
 function and the mating scheme.
 Recombinator overrides the default Mendelian genotype transmitter defined
 in the random mating scheme.
\end_layout

\begin_layout Itemize
Different applicability rules are applied to these operators when they are
 used in the 
\family typewriter
evolve
\family default
 function or in a mating scheme.
 Namely, it is possible to apply recombination at certain generations if
 it is used in the evolve function, and it is possible to apply recombination
 to individuals in a virtual subpopulation if it is used in the mating scheme.
\end_layout

\begin_layout Itemize
Because the mitochondrial genotype transmitter is only applied to customized
 chromosomes, it is not considered as a genotype transmitter so that it
 will not override any default genotype transmitter.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mitochondrial.log"
lstparams "caption={Transmission of mitochondrial chromosomes},label={mitochondrial.log}"

\end_inset


\end_layout

\begin_layout Subsection
Customized genotype transmitter
\begin_inset CommandInset label
LatexCommand label
name "sub:Customized-genotype-transmitter"

\end_inset


\end_layout

\begin_layout Standard
Although simuPOP provides a number of genotype transmitters, they may still
 be cases where customized genotype transmitter is needed.
 For example, a recombinator can be used to recombine parental chromosomes
 but it is well known that male and female individuals differ in recombination
 rates.
 How can you apply two different recombinators to male and female individuals
 separately?
\end_layout

\begin_layout Standard
An immediate thought can be the use of virtual subpopulations.
 If you apply two random mating schemes to two virtual subpopulations defined
 by sex, 
\family typewriter
randomParentsChooser
\family default
 will not work because no opposite sex can be found in each virtual subpopulatio
n.
 In this case, a customized genotype transmitter can be used.
\end_layout

\begin_layout Standard
A customized genotype transmitter is only a Python during-mating operator.
 Although it is possible to define a function and use a pyOperator directly
 (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

), it is much better to derive an operator from pyOperator, as the case
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "newOperator"

\end_inset

.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoChooser"

\end_inset

 defines a 
\family typewriter
sexSpecificRecombinator
\family default
 that uses, internally, two different recombinators to recombine male and
 female parents.
 The key statement is the 
\family typewriter
pyOperator.__init__
\family default
 line which initializes a Python operator with given function 
\family typewriter
self.transmitGenotype
\family default
.
 This operator will override the default Mendelian genotype transmitter
 used in the random mating scheme because 
\family typewriter
formOffGenotype=True
\family default
.
 
\end_layout

\begin_layout Standard
The actual function to transmit parental genotype is 
\family typewriter
self.transmitGenotype
\family default
.
 This function initializes two recombinators if they have not been initialized
 and uses them to transmit parental genotypes.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 outputs the population in two generations.
 You should notice that paternal chromosome are not recombined when they
 are transmitted to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexSpecificRec.log"
lstparams "caption={A customized genotype transmitter for sex-specific recombination},label={sexSpecificRec}"

\end_inset


\end_layout

\begin_layout Subsection
Pre-define parent choosers
\end_layout

\begin_layout Standard
Parent choosers are responsible for choosing one or two parents from a parental
 (virtual) subpopulation.
 simuPOP defines a few parent choosers that choose parent(s) sequentially,
 randomly (with or without replacement), or with additional conditions.
 Some of these parent choosers support natual selection.
 Please refer to the simuPOP reference manual for details about these objects.
\end_layout

\begin_layout Standard
We have seen sequential and random parent choosers in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

.
 A less-used parent chooser is 
\family typewriter
infoParentsChooser
\family default
, which chooses a parent randomly, and his/her spouse from indexes stored
 in his/her information fields.
 This parent chooser is usually used in a consanguineous mating scheme where
 certain types of relatives of each individual are stored in his/her information
 fields, and used during the selection of spouses.
 For example, a 
\family typewriter
consanguineousMating
\family default
 mating scheme in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoChooser"

\end_inset

 produces a male and a female offspring at each mating event.
 Before mating, a function is called to record every individual's sibling
 in his/her information field 
\family typewriter
sibling
\family default
.
 During mating, a parent is chosen randomly, and mates with his/her sibling.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoChooser.log"
lstparams "caption={A consanguineous mating scheme.},label={infoChooser}"

\end_inset


\end_layout

\begin_layout Standard
This example does not make such sense because consanguineous mating usually
 happens between first and second degree relatives, and represents only
 a small fraction of total parents in a population.
 
\family typewriter
doc/cook/Mating_consanguineous.py
\family default
 gives a more realistic example in which certain proportion of offspring
 are produced by random mating, and others are results of marriages between
 first-degree cousins.
\end_layout

\begin_layout Subsection
A Python parent chooser
\end_layout

\begin_layout Standard
A parent choosing scheme can be quite complicated in reality.
 For example, salamanders along a river may mate with their neighbors and
 form several subspecies.
 This behavior cannot be readily simulated using any pre-define parent choosers
 so a hybrid parent chooser 
\family typewriter
pyParentsChooser()
\family default
 should be used.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyParentsChooser
\family default
 accepts a user-defined Python generator function, instead of a normal python
 function, that returns a parent, or a pair of parents repeatedly.
 Briefly speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when this iterator iterates, this function resumes where it was
 stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,5$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 sequentially.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator.log"
lstparams "caption={A sample generator function},label={generator}"

\end_inset


\end_layout

\begin_layout Standard
A 
\family typewriter
pyParentsChooser
\family default
 accepts a parent generator function, which takes a population and a subpopulati
on index as parameters.
 When this parent chooser is applied to a subpopulation, it will call this
 generator function and ask the generated generator object repeated for
 either a parent, or a pair of parents (
\emph on
both are indexes relative to a subpopulation
\emph default
).
 Note that 
\family typewriter
pyParentsChooser
\family default
 does not support virtual subpopulation but you can mimic the effect by
 returning only parents from certain virtual subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyParentsChooser"

\end_inset

 implements a hybrid parent chooser that chooses parents with equal social
 status (
\family typewriter
rank
\family default
).
 In this parent chooser, all males and females are categorized by their
 sex and social status.
 A parent is chosen randomly, and then his/her spouse is chosen from females/mal
es with the same social status.
 The rank of their offspring can increase or decrease randomly.
 It becomes obvious now that whereas a python function can return random
 male/female pair, the generator interface is much more efficient because
 the identification of sex/status groups is done only once.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyParentsChooser.log"
lstparams "caption={A hybrid parent chooser that chooses parents by their social status},label={pyParentsChooser}"

\end_inset


\end_layout

\begin_layout Subsection
Using C++ to implement a parent chooser
\begin_inset CommandInset label
LatexCommand label
name "sub:Using-C++"

\end_inset


\end_layout

\begin_layout Standard
A user defined parent chooser can be fairly complex and computationally
 intensive.
 For example, if a parent tends to find a spouse in his/her vincinity, geometric
 distances between all qualified individuals and a chosen parent need to
 be calculated for each mating event.
 If the optimization of the parent chooser can speed up the simulation significa
ntly, it may be worthwhile to write the parent chooser in C++.
 
\end_layout

\begin_layout Standard
Although it is feasible, and sometimes easier to derive a class from class
 
\family typewriter
parentChooser
\family default
 in mating.h (.cpp), modifying simuPOP source code is not recommended because
 you would have to modify a new version of simuPOP whenever you upgrade
 your simuPOP distribution.
 Implementing your parent choosing algorithm in another Python module is
 preferred.
\end_layout

\begin_layout Standard
The first step is to write your own parent chooser in C/C++.
 Basically, you will need to pass all necessary information to the C++ level
 and implement an algorithm to choose parents randomly.
 Although simple function based solutions are possible, a C++ level class
 such as the 
\family typewriter
myParentsChooser 
\family default
class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 is recommended.
 This class is initialized with indexes of male and female individuals and
 use a function 
\family typewriter
chooseParents
\family default
 to return a pair of parents randomly.
 This parent chooser is very simple but more complicated parent selection
 scenarios can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.h"
lstparams "caption={Implement a parent chooser in C++},label={parentChooseHeader},language=C"

\end_inset


\end_layout

\begin_layout Standard
The second step is to wrap your C++ functions and classes to a Python module.
 There are many tools available but SWIG (
\family typewriter
www.swig.org
\family default
) is arguably the most convenient and powerful one.
 To use SWIG, you will need to prepare an interface file, which basically
 tells SWIG which functions and classes you would like to expose and how
 to pass parameters between Python and C++.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserInterface"

\end_inset

 lists an interface file for the C++ class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

.
 Please refer to the SWIG reference manual for details.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.i"
lstparams "caption={An interface file for the myParentsChooser class},label={parentsChooserInterface},language=Awk"

\end_inset


\end_layout

\begin_layout Standard
The exact procedure to generate and compile a wrapper file varies from system
 to system, and from compiler to compiler.
 Fortunately, the standard Python module setup process supports SWIG.
 All you need to do is to write a Python 
\family typewriter
setup.py
\family default
 file and let the 
\family typewriter
distutil
\family default
 module of Python handle all the details for you.
 A typical 
\family typewriter
setup.py
\family default
 file is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserSetup"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/setup.py"
lstparams "caption={Building and installing the myParentsChooser module},label={parentsChooserSetup}"

\end_inset


\end_layout

\begin_layout Standard
You parent chooser can now be compiled and installed using the standard
 Python 
\family typewriter
setup.py
\family default
 commands such as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to the Python reference manual for other building and installation
 options.
 Note that Python 2.4 and earlier do not support option swig_opts well so
 you might have to pass these options using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py build_ext --swig-opts=
\begin_inset Quotes erd
\end_inset

-O -templatereduce 
\backslash

\end_layout

\begin_layout Plain Layout

    -shadow -c++ -keyword -nodefaultctor
\begin_inset Quotes erd
\end_inset

 install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 demonstrates how to use such a C++ parents chooser in your simuPOP script.
 It uses the same Python parent chooser interface as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyParentsChooser"

\end_inset

, but leaves all the (potentially) computationally intensive parts to the
 C++ level 
\family typewriter
myParentsChooser
\family default
 object.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/cppParentChooser.py"
lstparams "caption={Implement a parent chooser in C++},firstline=5,label={cppParentChooser}"

\end_inset


\end_layout

\begin_layout Subsection
The pedigree mating scheme
\end_layout

\begin_layout Standard
This feature is still under major revision.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
A simuPOP simulator evolves one or more copies of a population forward in
 time, subject to various operators.
 Although simulators have been used extensively in the previous chapters,
 it is worthwhile to have a detailed look at this object.
\end_layout

\begin_layout Subsection
Number of generations to evolve
\end_layout

\begin_layout Standard
A simulator usually evolves a specific number of generations according to
 parameter 
\family typewriter
gen
\family default
 of the 
\family typewriter
evolve
\family default
 function.
 A generation number is used to track the number of generations a simulator
 has evolved.
 Because a new simulator has generation number 0, a simulator would be at
 the beginning of generation 
\begin_inset Formula $n$
\end_inset

 after it evolves 
\begin_inset Formula $n$
\end_inset

 generations.
 The generation number would increase if the simulator continues to evolve.
 During evoluting, variables 
\family typewriter
rep
\family default
 (replicate number) and 
\family typewriter
gen
\family default
 (current generation number) are set to each population's local namespace.
\end_layout

\begin_layout Standard
It is not always possible to know in advance the number of generations to
 evolve.
 For example, you may want to evolve a population until a specific allele
 gets fixed or lost in the population.
 In this case, you can let the simulator run indefinitely (do not set the
 
\family typewriter
gen
\family default
 parameter) and depend on a 
\emph on
terminator 
\emph default
to terminate the evolution of a population.
 The easiest method to do this is to use population variables to track the
 status of a population, and use a 
\family typewriter
terminateIf
\family default
 operator to terminate the evolution according to the value of an expression.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simuGen"

\end_inset

 demonstrates the use of such a terminator, which terminates the evolution
 of a population if allele 0 at locus 5 is fixed or lost.
 It also shows the application of an interesting operator 
\family typewriter
ifElse
\family default
, which applies an operator, in this case 
\family typewriter
pyEval
\family default
, only when an expression returns 
\family typewriter
True
\family default
.
 Note that this example calls the 
\family typewriter
evolve
\family default
 function twice so the second part starts at generation 5.
 You can also use 
\family typewriter
simu.setGen(0)
\family default
 to reset the generation number if you would like to have a fresh start
 for the second 
\family typewriter
evove()
\family default
 call.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuGen.log"
lstparams "caption={Generation number of a simulator},keywordstyle={\\ttfamily},label={simuGen}"

\end_inset


\end_layout

\begin_layout Subsection
Operator calling sequence
\end_layout

\begin_layout Standard
Operators can be applied at different stages of a life cycle (pre-, during-,
 and post-mating, controlled by parameter 
\family typewriter
stage
\family default
), at specified generations (controlled by parameters 
\family typewriter
begin, end, step
\family default
 and 
\family typewriter
at
\family default
), and to specified replicates (controlled by parameter 
\family typewriter
rep
\family default
).
 The order at which operators are applied is usually clear but can become
 confusing when the number of operators increases.
 For example, 
\family typewriter
stat(...)
\family default
 should be put before any operator (such as an terminator) that uses the
 shared variable set by this operator.
 An error will occur if the variables are used before they are set.
\end_layout

\begin_layout Standard
Because it is not always clear which stage(s) an operator can be applied
 and in which order they will be applied, a parameter 
\family typewriter
dryrun
\family default
 is provided to the 
\family typewriter
simulator::evolve()
\family default
 function.
 If set to 
\family typewriter
True
\family default
, the 
\family typewriter
evolve
\family default
 function will list all operators in the order at which they will be applied.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "dryrun"

\end_inset

 shows the operator calling sequence for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/dryrun.log"
lstparams "caption={List the order at which operators are applied},keywordstyle={\\ttfamily},label={dryrun}"

\end_inset


\end_layout

\begin_layout Subsection
Population access and other simulator operations
\end_layout

\begin_layout Standard
Function 
\family typewriter
population()
\family default
 and 
\family typewriter
populations()
\family default
 are provided to access populations within a simulator.
 Similar to functions 
\family typewriter
individual()
\family default
 and 
\family typewriter
individuals()
\family default
 for a population
\family typewriter
,population(rep)
\family default
 returns a reference to the 
\family typewriter
rep
\family default
th population in a simulator and 
\family typewriter
populations()
\family default
 returns an Python iterator that can be used to iterate through all populations.
 Modifying these references will change the corresponding populations within
 the simulator.
 An independent copy of a population can be made using the 
\family typewriter
clone()
\family default
 function of a population (e.g.
 
\family typewriter
simu.population(0).clone()
\family default
).
\end_layout

\begin_layout Standard
Populations in a simulator can be added or removed using functions 
\family typewriter
add()
\family default
 and 
\family typewriter
extract()
\family default
.
 The
\series bold
 newly added populations do not have to have the same genotypic structure
 as existing populations
\series default
.
 However, because the same operators will be applied to all populations,
 it is your responsibility to make sure that the operators can be applied
 to these populations.
\end_layout

\begin_layout Standard
Just like populations, a simulator can be cloned, saved and loaded.
 This makes it easy to stop a simulator, take a snapshot and resume evolution.
 It is even easy to save a simlator, transfer it to another machine and
 resume the evolution over there.
 Because 
\series bold
virtual splitters are not saved with populations
\series default
, you will have to re-assign splitters to populations if they are needed
 for subsequent simulations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuFunc.log"
lstparams "caption={Clone, save and load a simulator},label={simuFunc}"

\end_inset


\end_layout

\begin_layout Subsection
Modifying populations and mating scheme
\end_layout

\begin_layout Standard
Although a standard Wright-Fisher random mating scheme is usually preferred
 because it leads to a larger effective population size than other mating
 schemes, it is difficult to ascertain pedigrees from a random mating population
 because there will be very few siblings in such a population.
 In addition, because we usually only sample from the last few generations,
 it would be more efficient to keep tract of pedigree information only for
 these generations.
 Such considerations lead to the popularity of a two stage evolutionary
 scenario where the standard random mating scheme is used in the first stage
 and another mating scheme that is more suitable for pedigree ascertainment
 is used in the second stage.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "twoStage"

\end_inset

 demonstrates the implementation of such a scenario.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/twoStage.log"
lstparams "caption={A two-stage evolutionary process},label={twoStage}"

\end_inset


\end_layout

\begin_layout Subsection
Change genotypic structure during evolution
\end_layout

\begin_layout Standard
Most operators do not change the genotypic structure of populations during
 evolution.
 However, it is possible to change the structure of a population, such as
 adding or removing information fields, loci or chromosomes during evolution.
 The only restriction is that all individual in a population needs to have
 the same genotypic structure.
 That is to say, if you are inserting a new locus to an individual, all
 individuals in this population should have it.
 This is why there is no individual-level structure-modification functions.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "changeStru"

\end_inset

 gives an example of a dynamic mutator.
 This mutator is not a conventional mutator in that it does not mutate any
 existing loci.
 It assumes a chromosome region that originally has no polymorphic markers.
 When a mutation happens, a monomorphic marker that is not simulated becomes
 polymorphic and is inserted to the chromosome.
 If the region is long enough, this example effectively simulates an infinite
 allele mode.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/changeStru.log"
lstparams "caption={A Python mutator that adds new loci to populations.},label={changeStru}"

\end_inset


\end_layout

\begin_layout Section
Pedigrees
\end_layout

\begin_layout Standard
This feature is still under major revision.
\end_layout

\begin_layout Chapter
simuPOP Operators
\begin_inset CommandInset label
LatexCommand label
name "cha:simuPOP-Operators"

\end_inset


\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 80 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), gene conversion,
 quantitative trait, selection, penetrance (single or multi-locus, hybrid),
 ascertainment (case-control, affected sibpairs, random), statistics calculation
 (allele, genotype, haplotype, heterozygote number and frequency; expected
 heterozygosity; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules).
 This chapter covers the basic and some not-so-basic usages of these operators,
 organized roughly by genetic factors.
\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
simuPOP provides three operators to initialize individual sex and genotype.
 A number of parameter are provided to cover most commonly used initialization
 scenarios.
 A Python operator can be used to intialize a population explicitly if none
 of the operators fits your need.
 
\end_layout

\begin_layout Subsection
Initialize individual sex (operator 
\family typewriter
initSex
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initSex()
\family default
 and function 
\family typewriter
InitSex()
\family default
 initialize individual sex either randomly or using a given sequence.
 In the first case, individuals are assigned 
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
 with equal probability unless parameter 
\emph on
maleFreq
\emph default
 is used to specify the probability of having a male individual.
 In the second case, a sequence of sex (
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
) is assigned to individuals succesively.
 The list will be reused if needed.
 If a list of (virtual) subpopulations are given, this operator will only
 initialize individuals in these (virtual) subpopulations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initSex"

\end_inset

 uses two 
\family typewriter
initSex
\family default
 operators to initialize two subpopulations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initSex.log"
lstparams "caption={Initialize individual sex},label={initSex}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize by allele frequency (operator 
\family typewriter
initByFreq
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initByFreq
\family default
 (and its function form 
\family typewriter
InitByFreq
\family default
) initialize individual genotype by 
\series bold
allelic spectrum
\series default
, which is the number and frequency of alleles at a locus.
 For example, 
\family typewriter
alleleFreq=(0, 0.2, 0.4, 0.2)
\family default
 will yield allele 0, 1, 2, and 3 with probability 0, 0.2, 0.4 and 0.2 respectively.
 Parameter 
\family typewriter
loci
\family default
 and 
\family typewriter
ploidy
\family default
 can be used to specify a subset of loci and homologous sets of chromosomes
 to initialize, and parameter 
\family typewriter
subPops
\family default
 can be used to specify subsets of individuals to initialize.
 In the latter case, a list of allelic spectra can be given to assign different
 genotype with different allele frequency for each (virtual) subpopulation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByFreq.log"
lstparams "caption={Initialize by allele frequency},label={initByFreq}"

\end_inset


\end_layout

\begin_layout Standard
It is sometimes desired to creates identical individuals with random genotype.
 Parameter 
\family typewriter
identicalInds
\family default
 can be used for this purpose.
 When this parameter is set to true, a random individual will be created
 for each subpopulation (using different allele frequencies if a list of
 allelic spectra are given), and be copied to all other individuals in the
 subpopulation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByFreqIdenticalInds"

\end_inset

 demonstrates this usage.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByFreqIdenticalInds.log"
lstparams "caption={Initialize by allele frequency with identical individuals in each subpopulation},label={initByFreqIdenticalInds}"

\end_inset


\end_layout

\begin_layout Standard
For convenience and for backward-compatibility, this operator by default
 also initialize individual sex (parameters 
\emph on
maleFreq
\emph default
 and 
\emph on
sex
\emph default
 are accepted).
 If this is not needed (e.g.
 indiviudal sex has already been initialized), you can set paramter 
\emph on
initSex
\emph default
 to 
\family typewriter
False
\family default
.
\end_layout

\begin_layout Subsection
Initialize by haplotype (operator 
\family typewriter
initByValue
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initByValue
\family default
 (and its function form 
\family typewriter
InitByValue
\family default
) initializes individual genotypes using given haplotypes.
 The simplest form of this operator is to specify genotype on one or all
 homologous sets of chromosomes.
 For example, all individuals in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByValue"

\end_inset

 get the same genotype using such an operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByValue.log"
lstparams "caption={initialize by haplotype},label={initByValue}"

\end_inset


\end_layout

\begin_layout Standard
A number of parameters are provided to initialize individual genotype at
 a finer scale.
 More specifically, you can apply the operator to specified loci (parameter
 
\emph on
loci
\emph default
), (virtual) subpopulations (parameter 
\family typewriter
subPops
\family default
), homologous sets of chromosomes (parameter 
\family typewriter
ploidy
\family default
).
 If multiple haplotypes are given, you can specify the probabilities at
 which each haplotype will be used using parameter 
\family typewriter
proportions
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByValueProp"

\end_inset

 demonstrates the use of these parameters.
 Note that operator 
\family typewriter
initByValue
\family default
 also initializes individual sex so 
\family typewriter
\emph on
initSex
\family default
\emph default
 should be set to 
\family typewriter
False
\family default
 when multiple initializers are applied.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByValueProp.log"
lstparams "caption={initialize by haplotypes with given proportion},label={initByValueProp}"

\end_inset


\end_layout

\begin_layout Section
Expressions and statements
\end_layout

\begin_layout Subsection
Output an Python string (operator 
\family typewriter
pyOutput
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyOutput
\family default
 is a simple operator that prints a Python string when it is applied to
 a population.
 It is commonly used to print the progress of a simulation (e.g.
 
\family typewriter
pyOutput('start migration
\backslash
n', at=200)
\family default
) or output separators to beautify outputs from 
\family typewriter
pyEval
\family default
 outputs (e.g.
 
\family typewriter
pyOutput('
\backslash
n', rep=-1)
\family default
.
\end_layout

\begin_layout Subsection
Execute Python statements (operator 
\family typewriter
pyExec
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyExec
\family default
 executes Python statements in a population's local namespace when it is
 applied to that population.
 This operator is designed to execute short Python statements but multiple
 statements separated by newline characters are allowed.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyExec"

\end_inset

 uses two 
\family typewriter
pyExec
\family default
 operators to create and use a variable 
\family typewriter
traj
\family default
 in each population's local namespace.
 The first operator initialize this variable as an empty list.
 During evolution, the frequency of allele 1 at locus 0 is calcuated (operator
 
\family typewriter
stat
\family default
) and appended to this variable (operator 
\family typewriter
pyExec
\family default
).
 The result is a trajectory of allele frequencies during evolution.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyExec.log"
lstparams "caption={Execute Python statements during evolution},label={pyExec}"

\end_inset


\end_layout

\begin_layout Subsection
Evaluate and output Python expressions (operator 
\family typewriter
pyEval
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyEval
\family default
 evaluate a given Python expression in a population's local namespace and
 output its return value.
 This operator has been widely used (e.g.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "ancestralPop"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

) to output statistics of populations and report progress.
\end_layout

\begin_layout Standard
Two additional features of this operator may become handy from time to time.
 First, an optional Python statements (parameter 
\emph on
stmts
\emph default
) can be specified which will be executed before the expression is evaluated.
 Second, the population being applied can be exposed in its own namespace
 as a variable (parameter 
\emph on
exposePop
\emph default
).
 This makes it possible to access properties of a population other than
 its variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyEval"

\end_inset

 demonstrates both features.
 In this example, two statements are executed to count the number of unique
 parents in an offspring population and save them as variables 
\family typewriter
numFather
\family default
 and 
\family typewriter
numMother
\family default
.
 The operator outputs these two variables alone with a generation number.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyEval.log"
lstparams "caption={Evaluate a expression and statements in a population's local namespace.},label={pyEval}"

\end_inset


\end_layout

\begin_layout Standard
Note that the function form of this operator (
\family typewriter
PyEval
\family default
) returns the result of the expression rather than writting it to an output.
\end_layout

\begin_layout Subsection
Expression and statement involving individual information fields (operator
 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
)
\end_layout

\begin_layout Standard
Operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyExec
\family default
 work at the population level, using the local namespace of populations.
 Operator 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
, on the contraray, work at the individual level, using individual information
 fields.
\end_layout

\begin_layout Standard
Because there is no individual-specific namespace, these two operators make
 use of either a temporary namespace for every individual, or the population
 namespace (parameter 
\emph on
usePopVars
\emph default
).
 In the first case, a namespace is created for each invidividual, with variables
 being the information fields of this individual.
 In the second case, individual information fields are copied to the population
 namespace one by one.
 Expressions and statements can make use of population variables in this
 case.
 Optionally, the individual object can be exposed to these namespace using
 a user-specified name (parameter 
\emph on
exposeInd
\emph default
).
\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoEval
\family default
 evaluates an expression and outputs its value.
 Operator 
\family typewriter
infoExec
\family default
 executes one or more statements and does not produce any output.
 The major difference between them is that 
\family typewriter
infoEval
\family default
 does not change individual information fields while 
\family typewriter
infoExec
\family default
 update individual information fields from the namespace after the statements
 are executed.
\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoEval
\family default
 is usually used to output individual information fields and properties
 in batch mode.
 It is faster and sometimes easier to use than corresponding for loop plus
 individual level operations.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
infoEval(r'
\begin_inset Quotes erd
\end_inset

%.2f
\backslash
t
\begin_inset Quotes erd
\end_inset

 % a')
\family default
 outputs the value of information field a for all individuals, separated
 by tabs.
\end_layout

\begin_layout Itemize

\family typewriter
infoEval('ind.sexChar()', exposeInd='ind')
\family default
 outputs the sex of all individuals using an exposed individual object 
\family typewriter
ind
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
infoEval('a+b**2')
\family default
 outputs 
\begin_inset Formula $a+b^{2}$
\end_inset

 for information fields 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 for all individuals.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoEval"

\end_inset

 demonstrates the use of this operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoEval.log"
lstparams "caption={Evaluate expressions using individual information fields},label={infoEval}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoExec
\family default
 is usually used to set individual information fields.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('age += 1')
\family default
 increases the age of all individuals by one.
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('risk = 2 if packPerYear > 10 else 1.5')
\family default
 sets information field 
\family typewriter
risk
\family default
 to 
\family typewriter
2
\family default
 if 
\family typewriter
packPerYear
\family default
 is greater than 
\family typewriter
10
\family default
, and 
\family typewriter
1.5
\family default
 otherwise.
 Note that conditional expression is only available for Python version 2.5
 or later.
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('a = b*c')
\family default
 sets the value of information field 
\family typewriter
a
\family default
 to the product of 
\family typewriter
b
\family default
 and 
\family typewriter
c
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoExec"

\end_inset

 demonstrates the use of this operator, using its function form 
\family typewriter
InfoExec
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoExec.log"
lstparams "caption={Execute statements using individual information fields},label={infoExec}"

\end_inset


\end_layout

\begin_layout Note
Except for the local (temporary) namespace, operator 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
 can also access variables and functions in a global namespace, which is
 the module namespace of your script.
 However, use of global variables in these operators are strongly discouraged.
\end_layout

\begin_layout Section
Demographic changes
\end_layout

\begin_layout Subsection
Change of population size
\end_layout

\begin_layout Standard
A mating scheme controls the size of an offspring generation using parameter
 
\family typewriter
subPopSize
\family default
.
 This parameter has been described in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

.
 In summary,
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPopSize
\family default
 is not set, the offspring generation will have the same subpopulation sizes
 as the parental generation.
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPopSize
\family default
 is set to a number (no subpopulation) or a list of subpopulation sizes,
 
\end_layout

\begin_layout Subsection
Split and merge
\end_layout

\begin_layout Standard
You first need to understand that mating schemes populate subpopulations
 from their corresponding ancestral subpopulations one by one, so it can
 not change number of subpopulations.
 Split and merge of subpopulations are done by operators 
\family typewriter
splitSubPop
\begin_inset Index
status collapsed

\begin_layout Plain Layout
splitSubPop
\end_layout

\end_inset


\family default
 and 
\family typewriter
mergeSubPops
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mergeSubPops
\end_layout

\end_inset


\family default
 respectively.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMerge"

\end_inset

, these two operators are used to split and merge subpopulations, but keep
 total population size untouched.
 Note that after subpopulation merge, subpopulation 2 still exists, but
 with size 0.
 This is used to keep subpopulation id of other subpopulations unchanged.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitMerge.log"
lstparams "caption={Split and merge subpopulations during evolution.},label={splitMerge}"

\end_inset


\end_layout

\begin_layout Subsection
Demographic mode with selection
\end_layout

\begin_layout Standard
Migration can change subpopulation size, but not total population size.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrFixedSize"

\end_inset

, two migrators are used.
 The first migrator moves individuals from subpopulation 0 to subpopulation
 1.
 The second migrator moves individuals around, with given proportions.
 For example, the migration rate
\begin_inset Formula \[
\left(\begin{array}{ccc}
0. & 0.2 & 0.4\\
0. & 0. & 0.1\\
0.1 & 0.1 & 0.\end{array}\right)\]

\end_inset

means moving 20% of individuals from subpop 0 to 1, 40% of individuals from
 subpop 0 to 1, and keep 40% (automatically determined).
 Subpopulation sizes change accordingly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitMigration.log"
lstparams "caption={Population split and migration},label={splitMigration}"

\end_inset


\end_layout

\begin_layout Standard
But what if you need to control total population size? In this case, a demograph
ic function is needed to specify the size of each subpopulation, at each
 generation.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration2"

\end_inset

, function 
\family typewriter
popSize
\family default
 returns exact subpopulation size at each generation, and the population
 will behave accordingly.
 It might surprise you that migration can no longer control the size of
 subpopulation sizes.
 What exactly happened is that, for example
\end_layout

\begin_layout Itemize
subpopulation size = [200, 400, 400], at the beginning of a generation
\end_layout

\begin_layout Itemize
apply migrator, subpopulation size changed to [100, 470, 430]
\end_layout

\begin_layout Itemize
pre mating operator 
\family typewriter
stat
\family default
 is applied and report subpopulation sizes
\end_layout

\begin_layout Itemize
during mating, with given subpopulation sizes 200, 400, 400 of the offspring
 generation, the mating scheme generate 200 offspring from 100 parents in
 subpopulation 0, 400 offspring from 470 parents in subpopulation 1, and
 400 offspring from 430 parents in subpopulation 2.
\end_layout

\begin_layout Itemize
post mating operator 
\family typewriter
stat
\family default
 is applied and get the new subpopulation size.
\end_layout

\begin_layout Standard
This example also demonstrates the use of stage parameter.
 As a matter of fact, you can use only one 
\family typewriter
stat
\family default
 operator by using 
\family typewriter
stage
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stage
\end_layout

\end_inset

=PrePostMating
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
PrePostMating
\end_layout

\end_inset

.
 If you are confused by the order of operators, use the 
\family typewriter
dryrun=True
\family default
 parameter of 
\family typewriter
evolve
\family default
 to check.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitMigration2.log"
lstparams "caption={Population split with changing population size},label={splitMigration2}"

\end_inset


\end_layout

\begin_layout Standard
You might say, OK, this looks nice, but how can I grow a population with
 migration acting freely? This is also easy, all you need to do is using
 the oldSize parameter of a demographic function in a clever way.
 The underlying story is that
\end_layout

\begin_layout Itemize
before mating, a mating scheme calculates current subpopulation sizes
\end_layout

\begin_layout Itemize
it calls the given demographic function with current generation number and
 current subpopulation sizes
\end_layout

\begin_layout Itemize
it uses the return value as the new subpopulation sizes.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration3"

\end_inset

 demonstrate an exponentially increase population with free migration between
 subpopulations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitMigration3.log"
lstparams "caption={Population split with changing population size},label={splitMigration3}"

\end_inset


\end_layout

\begin_layout Standard
Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpopulations
 to any (even new) other subset of subpopulations.
 To facilitate the use of common theoretical migration models, several functions
 are defined in
\family typewriter
 simuUtil.py.
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates(r, n, circular=False)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Subsection
The standard migrator
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrator.log"
lstparams "caption={A complex migration model},label={migrator}"

\end_inset


\end_layout

\begin_layout Subsection
Migrate from a virtual subpopulation
\end_layout

\begin_layout Section
Miscellaneous operators
\end_layout

\begin_layout Subsection
An operator that does nothing (operator 
\family typewriter
noneOp
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
noneOp
\family default
 does nothing when it is applied to a population.
 It provides a placeholder when an operator is needed but no action is required.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "noneOp"

\end_inset

 demonstrates a typical usage of this operator
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "noneOp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if hasSelection:
\end_layout

\begin_layout Plain Layout

    sel = mapSelector(loci=[0], fitness=[1, 0.99, 0.98])
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    sel = noneOp()
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    ops = [sel], # and other operators
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dump the content of a population (operator 
\family typewriter
dumper
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
dumper
\family default
 and its function form 
\family typewriter
Dump
\family default
 has been used extensively in this guide.
 They are prefect for demonstration and debugging purposes because they
 display all properties of a population in a human readable format.
 They are, however, rarely used in realistic settings because outputting
 a large population to your terminal can be disastrous.
\end_layout

\begin_layout Standard
Even with modestly-sized populations, it is a good idea to dump only parts
 of the population that you are interested.
 For example, you can use parameter 
\family typewriter
genotype=False
\family default
 to stop outputting individual genotype, 
\family typewriter
structure=False
\family default
 to stop outtputing genotypic and population structure information, 
\family typewriter
loci=range(5)
\family default
 to output genotype only at the first five loci, 
\family typewriter
max=N
\family default
 to output only the first 
\family typewriter
N
\family default
 individuals (default to 
\family typewriter
100
\family default
), 
\family typewriter
subPops=[(0, 0)]
\family default
 to output, for example, only the first virtual subpopulation in subpopulation
 0.
 This operator by default only dump the present generation but you can set
 
\family typewriter
ancGen
\family default
 to a positive number or 
\family typewriter
-1
\family default
 to dump part or all ancestral generations.
 Finally, if there are more than 10 alleles, you can set the 
\family typewriter
width
\family default
 at which each allele will be printed.
 The following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "dumper"

\end_inset

) presents a rather complicated usage of this operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/dumper.log"
lstparams "caption={Dump the content of a population},label={dumper}"

\end_inset


\end_layout

\begin_layout Subsection
Save a population during evolution (operator 
\family typewriter
savePopulation
\family default
)
\end_layout

\begin_layout Standard
Because it is usually not feasible to store all parental generations of
 an evolving population, it is a common practise to save snapshots of a
 population during an evolutionary process for further analysis.
 Operator 
\family typewriter
savePopulation
\family default
 is designed for this purpose.
 When it is applied to a population, it will save the population to a file
 specified by parameter 
\family typewriter
output
\family default
.
\end_layout

\begin_layout Standard
The tricky part is that populations at different generations need to be
 saved to different filenames so the expression version of parameter 
\family typewriter
output
\family default
 needs to be used (see operator 
\family typewriter
baseOperator
\family default
 for details).
 For example, expression 
\family typewriter
'snapshot_%d_%d.pop' % (rep, gen)
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "savePopulation"

\end_inset

 to save population to files such as 
\family typewriter
snapshot_5_20.pop
\family default
 during the evolution.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePopulation.log"
lstparams "caption={Save snapshots of an evolving population},label={savePopulation}"

\end_inset


\end_layout

\begin_layout Subsection
Change ancestral depth of populations (operator 
\family typewriter
setAncestralDepth
\family default
)
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "twoStage"

\end_inset

 describes a two-stage evolutionary process where a random mating scheme
 is used in the first stage and another mating scheme is used in the second
 stage to prepare for pedigree ascertainment.
 The ancestral depth of each population is changed to 1 before the second
 
\family typewriter
simulator.evolve
\family default
 call.
 This step can also be done using a 
\family typewriter
setAncestralDepth
\family default
 operator, which simply set the ancestral depth of each population to a
 given depth (please refer to class 
\family typewriter
population
\family default
 for a detailed explanation for 
\emph on
ancetral depth
\emph default
).
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "setAncDepth"

\end_inset

 demonstrates a tpical usage of this operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/setAncDepth.log"
lstparams "caption={Change ancestral depth during the evolution},label={setAncDepth}"

\end_inset


\end_layout

\begin_layout Subsection
Conditional operator (operator 
\family typewriter
ifElse
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
ifElse
\family default
 provides a simple way to conditionally apply an operator.
 For example, you can re-introduce a mutant if it gets lost in the population,
 output a warning when certain condition is met, or record the occurance
 of certain events in a population.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ticToc"

\end_inset

 records the number of generations the frequency of an allele goes below
 0.4 and beyong 0.6 before it gets lost or fixed in the population.
 Note that an else-operator can also be executed when the condition is not
 met.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ifElse.log"
lstparams "caption={A conditional opeartor},label={ifElse}"

\end_inset


\end_layout

\begin_layout Standard
If more complicated logic is involved, a Python operator (
\family typewriter
pyOperator
\family default
) should be used.
\end_layout

\begin_layout Subsection
Turn on and off debugging mode (operator 
\family typewriter
turnOnDebug
\family default
 and 
\family typewriter
turnOffDebug
\family default
)
\end_layout

\begin_layout Standard
Debug information can be useful when something looks suspicious.
 By turnning on certain debug code, simuPOP will print out some internal
 information before and during evolution.
 The usually way to turn on and off debug information is to use functions
 
\family typewriter
TurnOnDebug(code)
\family default
 and 
\family typewriter
TurnOffDebug(code)
\family default
, or setting environmental variable 
\family typewriter
SIMUDEBUG=code
\family default
 where 
\family typewriter
code
\family default
 is one of the debug codes listed by function 
\family typewriter
ListDebugCodes
\family default
.
 Note that debug information is only available in standard modules.
\end_layout

\begin_layout Standard
However, the amount of output can be overwhelming in some cases which makes
 it necessary to limit the debug information to certain generations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "debug"

\end_inset

 demonstrates how to turn on debug information conditionally and turn it
 off afterwards, using operators 
\family typewriter
turnOnDebug
\family default
 and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/debug.log"
lstparams "caption={Turn on and off debug information during evolution.},label={debug},lastline=17"

\end_inset


\end_layout

\begin_layout Subsection
Pause and resume an evolutionary process (operator 
\family typewriter
pause
\family default
)
\end_layout

\begin_layout Standard
If you are presenting an evolutinary process in public, you might want to
 temporarily stop the evolution so that your audience can have a better
 look at intermediate results or figures.
 If you have an exceptionally long evolutionary process, you might want
 to examine the status of the evolution process from time to time.
 These can be done using a 
\family typewriter
pause
\family default
 operator.
\end_layout

\begin_layout Standard
The 
\family typewriter
pause
\family default
 operator can stop the evolution at specified generations, or when you press
 a key.
 In the first case, you usually specify the generations to pause (e.g.
 
\family typewriter
pause(step=1000)
\family default
) so that you can examine the status of a simulation from time to time.
 In the second case, you can apply the operator at each generation and pause
 the simulation when you press a key (e.g.
 
\family typewriter
pause(stopOnKeyStroke=True)
\family default
).
 A specific key can be specified so that you can use different keys to stop
 different populations, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pause"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pause.log"
lstparams "caption={Pause the evolution of a simulation},label={pause}"

\end_inset


\end_layout

\begin_layout Standard
When a simulation is paused, you are given the options to resume evolution,
 stop the evolution of the paused population or all populations, or enter
 an interactive Python shell to examine the status of a population, which
 will be available in the Python shell as 
\family typewriter
pop_X_Y
\family default
 where 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 are generation and replicate number of the population, respectively.
 The evolution will resume after you exit the Python shell.
\end_layout

\begin_layout Subsection
Measuring execution time of operators (operator 
\family typewriter
ticToc
\family default
)
\end_layout

\begin_layout Standard
The 
\family typewriter
ticToc
\family default
 operator can be used to measure the time between two events during an evolution
ary process.
 It outputs the elapsed time since the last time it is called, and the overall
 time since the operator is created.
 It is very flexible in that you can measure the time spent for mating in
 an evolutionary cycle if you set its stage to 
\family typewriter
prePostMating
\family default
, and you can measure time spent for several evolutionary cycles using generatio
n applicability parameters such as 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
.
 The latter usage is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ticToc"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ticToc.log"
lstparams "caption={Monitor the performance of operators},label={ticToc}"

\end_inset


\end_layout

\begin_layout Section
Mutation
\end_layout

\begin_layout Subsection
k-allele mutation model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/kamMutator.log"
lstparams "caption={A k-allele mutation model},label={kamMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Stepwise mutation model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/smmMutator.log"
lstparams "caption={A stepwise mutation model},label={smmMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Generalized stepwise mutation model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/gsmMutator.log"
lstparams "caption={A generalized stepwise mutation model},label={gsmMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Hybrid mutation model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyMutator.log"
lstparams "caption={A hybrid mutation model},label={pyMutator}"

\end_inset


\end_layout

\begin_layout Section
Selection
\end_layout

\begin_layout Standard
It is not very clear that our method agrees with the traditional 'average
 number of offspring' definition of fitness.
 (Note that this concept is very difficult to simulate because we do not
 know who will determine the number of offspring if two parents are involved.)
 We can, instead, look at the consequence of selection in a simple case
 (as derived in any population genetics textbook):
\end_layout

\begin_layout Standard
At generation 
\begin_inset Formula $t$
\end_inset

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset

 etc., should be
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset


\end_layout

\begin_layout Standard
Now, using the 'ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset

 will be the number of 
\begin_inset Formula $11$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset

The same argument applies to the case of arbitrary number of genotypes and
 random mating.
 
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
Selector only set information field and mark subpopulations as selection
 ready.
 However, how these information are used to select parents can vary from
 mating scheme to mating scheme.
 As a matter of fact, some mating schemes do not support selection at all.
\end_layout

\begin_layout Itemize
selector has to be 
\family typewriter
PreMating
\family default
 operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter
PreMating
\family default
.
 However, if you use the function form of these selectors in a 
\family typewriter
pyOperator
\family default
, make sure to set the stage of 
\family typewriter
pyOperator
\family default
 to 
\family typewriter
PreMating
\family default
.
 
\end_layout

\begin_layout Standard
The example for 
\family typewriter
class mapSelector
\family default
 is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if 
\begin_inset Formula $s_{1}=w_{12}-w_{11}$
\end_inset

 and 
\begin_inset Formula $s_{2}=w_{12}-w_{22}$
\end_inset

, the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Subsection
Map selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mapSelector.log"
lstparams "caption={A selector that uses pre-defined fitness value},label={mapSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-allele selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/maSelector.log"
lstparams "caption={A multi-allele selector},label={maSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-loci selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mlSelector.log"
lstparams "caption={A multi-loci selector},label={mlSelector}"

\end_inset


\end_layout

\begin_layout Subsection
A hybrid selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pySelector.log"
lstparams "caption={A hybrid selector},label={pySelector}"

\end_inset


\end_layout

\begin_layout Section
Recombination and Gene conversion
\end_layout

\begin_layout Subsection
Recombination
\end_layout

\begin_layout Subsection
Recombination with gene conversion
\end_layout

\begin_layout Standard
simuPOP uses the Holliday junction model to simulate gene conversion.
 This model treats recombination and conversion as a unified process.
 The key features of this model is
\end_layout

\begin_layout Itemize
Two (out of four) chromatids pair and a single strand cut is made in each
 chromatid
\end_layout

\begin_layout Itemize
Strand exchange takes place between the chromatids
\end_layout

\begin_layout Itemize
Ligation occurs yielding two completely intact DNA molecules
\end_layout

\begin_layout Itemize
Branch migration occurs, giving regions of heteroduplex DNA
\end_layout

\begin_layout Itemize
Resulution of the Holliday junction gives two DNA molecules with heteroduplex
 DNA.
 Depending upon how the holliday junction is resolved, we either observe
 no exchange of flanking markers, or an exchange of flanking markers.
 The former forms a conversion event, which can be considered as a double
 recombination.
\end_layout

\begin_layout Standard
Translated to simulation, recombination and conversion are performed in
 the following steps
\end_layout

\begin_layout Enumerate
Users specify the following paremters to a recombinator:
\end_layout

\begin_deeper
\begin_layout Enumerate
recombination points (recombinations are allowed after specified markers)
 (
\family typewriter
loci
\family default
),
\end_layout

\begin_layout Enumerate
recombination rates (can vary from marker to marker) (
\family typewriter
rates
\family default
),
\end_layout

\begin_layout Enumerate
probability of conversion if a recombination event happens (
\family typewriter
convProb
\family default
),
\end_layout

\begin_layout Enumerate
track length parameters (
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
, will discuss later).
\end_layout

\end_deeper
\begin_layout Enumerate
Starting with two parental chromosomes, randomly choose one of them to copy
 to an offspring chromosome until a recombination event happens.
\end_layout

\begin_layout Enumerate
This recombination event is a conversion event if
\end_layout

\begin_deeper
\begin_layout Enumerate
A random uniform number U(0,1) is less than the probability of conversion
\end_layout

\begin_layout Enumerate
The length of flanking regions does not exceed the end of chromosome 
\end_layout

\begin_layout Standard
If a conversion happens, record the end of flanking region as another recombinat
ion event.
\end_layout

\end_deeper
\begin_layout Enumerate
Copy from another copy of parental chromosome (recombination happens), until
 the recorded second recombination event is reached, or another recombination
 event happens.
 
\end_layout

\begin_layout Enumerate
Repeat these steps for all chromosomes.
\end_layout

\begin_layout Standard
The tract length of a flanking region is determined by parameters 
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
.
 
\family typewriter
convMode 
\family default
can be
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_NumMarkers
\family default
 Convert a fixed number (
\family typewriter
convParam
\family default
) of markers.
 This is the default mode with
\family typewriter
 convParam=1
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_TractLength
\family default
 Convert a fixed length (
\family typewriter
convParam
\family default
) of chromosome regions.
 This can be used when markers are not equally spaced on chromosomes.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_GeometricDistribution
\family default
 Convert a random number of markers, with a geometric distribution with
 parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_ExponentialDistribution
\family default
 Convert Convert a random length of chromosome region, using a exponential
 distribution with parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
If tract length is determined by length (
\family typewriter
CONVERT_TractLength
\family default
 or 
\family typewriter
CONVERT_ExponentialDistribution
\family default
), the starting point of the flanking region is uniformly distributed between
 marker 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

, if the recombination happens at marker 
\begin_inset Formula $i$
\end_inset

.
 That is to say, it is possible that no marker is converted with positive
 tract length.
\end_layout

\begin_layout Itemize
A conversion event will act like a recombination event if its flanking region
 exceeds the end of chromosome, or if another recombination event happens
 before the end of the flanking region.
\end_layout

\begin_layout Standard
Although any parameters can be used in a recombinator, it is worth noting
 that
\end_layout

\begin_layout Itemize
The probability of conversion event among all recombination events if usually
 expressed as ratio of conversion to recombination events in the literature.
 This varies greatly from study to study, ranging from 0.1 to 15 (Chen et
 al, Nature Review Genetics, 2007).
 This translate to 0.1/0.9~0.1 to 15/16~0.94 of this parameter.
 When 
\backslash
c convProb is 1, all recombination events will be conversion events.
 The default value if 
\family typewriter
convProb=0
\family default
, meaning no conversion.
\end_layout

\begin_layout Itemize
Conversion tract length is usually short, and is estimated to be between
 337 and 456 bp, with overall range between maybe 50 - 2500 bp.
 simuPOP does not impose a unit for marker distance so your choice of 
\family typewriter
convParam
\family default
 needs to be consistent with your unit.
 In the HapMap dataset, cM is usually assumed and marker distances are around
 10kb (0.001cM ~- 1kb).
 At this marker density, gene conversion can largely be ignored.
\end_layout

\begin_layout Section
Penetrance
\end_layout

\begin_layout Subsection
Map penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mapPenetrance.log"
lstparams "caption={A penetrance model that uses pre-defined fitness value},label={mapPenetrance}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-loci penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mlPenetrance.log"
lstparams "caption={A multi-loci penetrance model},label={mlPenetrance}"

\end_inset


\end_layout

\begin_layout Subsection
Hybrid penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyPenetrance.log"
lstparams "caption={A hybrid penetrance model},label={pyPenetrance}"

\end_inset


\end_layout

\begin_layout Chapter
Utility Modules (under revision)
\begin_inset CommandInset label
LatexCommand label
name "cha:Utility-Modules"

\end_inset


\end_layout

\begin_layout Section
simuOpt
\end_layout

\begin_layout Standard
Module 
\family typewriter
simuOpt
\family default
 handles options to specify which simuPOP module to load and how this module
 should be loaded, using function 
\family typewriter
simuOpt.setOptions 
\family default
with parameters 
\emph on
alleleType
\emph default
 (
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
, or 
\family typewriter
binary
\family default
 ), 
\emph on
optimized
\emph default
 (
\family typewriter
standard
\family default
 or 
\family typewriter
optimized
\family default
), 
\emph on
gui
\emph default
 (whether or not use a graphical user interface and which graphical toolkit
 to use), 
\emph on
revision
\emph default
 
\family typewriter
(
\family default
minimal required version/revision), 
\emph on
quiet
\emph default
 (with or without banner message, and 
\emph on
debug
\emph default
 (which debug code to turn on).
 These options have been discussed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 and other related sections.
 Note that 
\series bold
most options can be set by environmental variables and command line options
\series default
 which are sometimes more versatile to use.
\end_layout

\begin_layout Standard
The 
\family typewriter
simuOpt
\family default
 module also provides a class 
\family typewriter
simuOpt
\family default
 to help users handle and manage script parameters.
 There are many other standard or third-party parameter handling modules
 in Python but this class is designed to help users run a simuPOP script
 in both batch and GUI modes, using a combination of parameter determination
 methods.
 More specifically, if a script uses the 
\family typewriter
simuOpt.simuOpt
\family default
 class to handle parameters,
\end_layout

\begin_layout Itemize
By default, a parameter input dialog is used to accept user input if the
 script is executed directly.
 Default values are given to each parameter and users are allowed to edit
 them using standard parameter input widgets (on/off button, edit box, dropdown
 list etc).
 Detailed explanations to parameters are available as tooltips of corresponding
 input widgets.
 A help button is provided that will display the usage of the script when
 clicked.
\end_layout

\begin_layout Itemize
If a configuration file is saved for a previous simulation, command line
 option 
\family typewriter
--config configFile
\family default
 can be used to load all parameters from that configuration file.
 The parameter input dialog is still used to review and modify parameters.
\end_layout

\begin_layout Itemize
Each parameter can also be set using command line options.
 Command line inputs will override values read from a configuration file.
\end_layout

\begin_layout Itemize
If command line option 
\family typewriter
--gui=False
\family default
 is given, the script will work in batch mode.
 If the value of a parameter cannot be determined through command line or
 a configuration file, and is set not to use its default value, users will
 be asked to enter its value interactively.
 For example, 
\family typewriter
myscript.py --gui=False --config configFile
\family default
 will execute a previous simulation directly.
\end_layout

\begin_layout Standard
The following sections describes how to use the 
\family typewriter
simuOpt
\family default
 class in a simuPOP script.
\end_layout

\begin_layout Subsection
Define a parameter specification list.
\end_layout

\begin_layout Standard
A 
\family typewriter
simuOpt
\family default
 object is created from a list of parameter specification dictionaries,
 and optional short and long descriptions of a script.
 Each parameter specification dictionary consits of mandatory fields 
\family typewriter
longarg
\family default
 (long command line argument) and 
\family typewriter
default
\family default
 (default value for this parameter) and optional fields such as 
\family typewriter
label
\family default
 (label to display in the parameter input dialog and as prompt for user
 input), 
\family typewriter
description
\family default
 (a detailed description), 
\family typewriter
allowedTypes
\family default
 (allowed types of input parameter), 
\family typewriter
validate
\family default
 (a function that return tells if a user input is valid), 
\family typewriter
chooseOneOf
\family default
 (tells the parameter input dialog to allow users to choose one of the provided
 values) and 
\family typewriter
chooseFrom
\family default
 (tells the parameter input dialog to allow users to choose one or more
 values from the provided values).
 Although it can be lengthy to describe a parameter in this way, it is a
 self-documentary process from which your users and even yourself will benefit.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 shows a parameter specification list that defines parameter 
\family typewriter
help
\family default
, 
\family typewriter
rate
\family default
, 
\family typewriter
rep
\family default
 and 
\family typewriter
pops
\family default
.
 What is special about each parameter is that 
\family typewriter
help
\family default
 will not be listed in the parameter input dialog (no 
\family typewriter
label
\family default
) and setting 
\family typewriter
help
\family default
 to 
\family typewriter
True
\family default
 during interactive parameter input will ignore all other options (
\family typewriter
jump
\family default
); 
\family typewriter
rate
\family default
 has to be between 0 and 1 (using a validation function 
\family typewriter
valueBetween
\family default
), 
\family typewriter
rep
\family default
 has to be a positive integer, and 
\family typewriter
pops
\family default
 can be one of the three HapMap populations.
 Please refer to the simuPOP reference manual for details about each dictionary
 key.
 The 
\family typewriter
description
\family default
 of parameter 
\family typewriter
pop 
\family default
demonstrates a special rule in the formatting of such description texts,
 namely 
\series bold
lines with symbol 
\family typewriter
'|'
\family default
 as the first non-space/tab character are outputed as a separate line without
 the leading 
\family typewriter
'|'
\family default
 character
\series default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.py"
lstparams "caption={A sample parameter specification list},firstline=5,label={paramSpec},lastline=39"

\end_inset


\end_layout

\begin_layout Subsection
Get parameters
\end_layout

\begin_layout Standard
A 
\family typewriter
simuOpt
\family default
 object can be created from a parameter specification list.
 A few member functions are immediately usable.
 For example, 
\family typewriter
simuOpt.usage()
\family default
 returns a detailed usage message about the script and all its parameters
 (although the usage message will be displayed automatically if command
 line option 
\family typewriter
-h
\family default
 or 
\family typewriter
--help
\family default
 is detected).
 The parameters become attributes of this object using 
\family typewriter
longarg
\family default
 names so that you can access them easily (e.g.
 
\family typewriter
par.rate
\family default
).
 Not surprosingly, all parameters now have the default value you assigned
 to them.
\end_layout

\begin_layout Standard
The 
\family typewriter
simuOpt.simuOpt
\family default
 class provides a number of member functions that allow you to acquire user
 input in a number of ways.
 For example 
\family typewriter
simuOpt.loadConfig
\family default
 reads a configuration file, 
\family typewriter
simuOpt.processArgs
\family default
 checks commandline options, 
\family typewriter
simuOpt.termGetParam
\family default
 asks user input interactively, and 
\family typewriter
simuOpt.guiGetParam
\family default
 generates and uses a parameter input dialog.
 These functions can be used several times, on different sets of parameters.
 In addition, new options could be added programmatically using function
 
\family typewriter
simuOpt.addOption
\family default
 and allows further flexibility on how parameters are generated.
 Please refer to 
\emph on
the simuPOP reference manual
\emph default
 on how to use these functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Get prameters using function getParam},firstline=37,keywordstyle={\\small\\ttfamily},label={getParam},lastline=67"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 lists some methods to determine parameter values but the last function,
 
\family typewriter
simuOpt.getParam()
\family default
, will be used most of the time.
 This function processes each parameter in the following order:
\end_layout

\begin_layout Itemize
If a short or a long command line argument exists, use the command line
 argument.
\end_layout

\begin_layout Itemize
If a configuration file is specified from command line (
\family typewriter
--config configFile
\family default
), look in this configuration file for a value.
\end_layout

\begin_layout Itemize
If 
\family typewriter
useDefault
\family default
 is specified, assign a default value to this parameter.
\end_layout

\begin_layout Itemize
If 
\family typewriter
--gui=False
\family default
 is specified, and the value of the parameter has not be determined, ask
 users interactively for a value.
 Otherwise, a parameter input dialog is displayed.
 A 
\emph on
Tkinter
\emph default
 dialog is usually used but a 
\emph on
wxPython
\emph default
 dialog will be used if 
\emph on
wxPython
\emph default
 is available (unless parameter 
\family typewriter
--gui=Tkinter
\family default
 is set).
\end_layout

\begin_layout Standard

\family typewriter
simuOpt.getParam
\family default
 returns 
\family typewriter
False
\family default
 if this process fails (e.g.
 users click cancel in the parameter input dialog).
 The parameter input dialog for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parameter-input-dialog"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:parameter-input-dialog"

\end_inset

A sample parameter input dialog
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename getParam.png
	width 50line%

\end_inset


\end_layout

\begin_layout Plain Layout
A parameter input dialog for a script that uses the same parameter specification
 list as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

.
 The command line is 
\family typewriter
simu.py --pop=YRI
\family default
.
 The first parameter is in red because its input is invalid.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Access, manipulate and extract parameters
\end_layout

\begin_layout Standard
If 
\family typewriter
simuOpt.getParam
\family default
 runs successfully, the 
\family typewriter
simuOpt
\family default
 object should have valid value for each parameter.
 They can be retrieved as attributes (such as 
\family typewriter
par.rate
\family default
) and manipulated easily.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "useSimuOpt"

\end_inset

 demonstrates how to extend parameter 
\family typewriter
par.rate
\family default
 to have the same length as 
\family typewriter
par.rep
\family default
.
 Additional derived parameters can be added if needed.
\end_layout

\begin_layout Standard
When there are a large number of parameters, passing this 
\family typewriter
simuOpt
\family default
 object, instead of tens of parameters, is a good way to provide clean interface
s.
 Alternatively, you can get a list or a dictionary of parameters using member
 functions 
\family typewriter
simuOpt.asList()
\family default
 and 
\family typewriter
simuOpt.asDict()
\family default
.
 Note that derived parameters are not returned because they are not listed
 in the parameter specification list.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Use the simuOpt object},firstline=68,label={useSimuOpt}"

\end_inset


\end_layout

\begin_layout Section
simuUtil
\end_layout

\begin_layout Section
simuRPy
\end_layout

\begin_layout Chapter
A real example (under revision)
\begin_inset CommandInset label
LatexCommand label
name "cha:A-real-example"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, I will show you, step by step, how to write a simuPOP script.
 The example is a simplified version of 
\family typewriter
scripts/simuCDCV.py
\family default
 which uses a python operator to calculate and save many more statistics,
 and use rpy to display the dynamics of disease allele frequency.
 
\end_layout

\begin_layout Section
Simulation scenario
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
I use simuPOP to simulate this evolution process and observe the allelic
 spectra of both types of diseases.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Section
Demographic model
\end_layout

\begin_layout Standard
The initial population size is set to 10,000, as suggested in the paper.
 The simulation will evolve 500 generations with constant population size
 to reach mutation-selection equilibrium.
 Then, the population size will increase by around 20,000 every 10 generations
 and reach 1,000,000 at generation 1000.
 The population growth takes around 12,500 years if we assume 25 years per
 generation.
 
\end_layout

\begin_layout Section
Mutation model
\end_layout

\begin_layout Standard
The maximum number of alleles at each locus is set to be 2000, a number
 that is hopefully big enough to mimic the infinite allele model.
 Allele 0 is the wild type (
\begin_inset Formula $A$
\end_inset

) and all others are disease alleles (
\begin_inset Formula $a$
\end_inset

).
 The 
\begin_inset Formula $k-$
\end_inset

allele mutation model is used.
 That is to say, an allele can mutate to any other allele with equal probability.
 An immediate implication of this model is that 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more 
\begin_inset Formula $a$
\end_inset

 than 
\begin_inset Formula $A$
\end_inset

.
 The mutation rate is set to 
\begin_inset Formula $\mu=3.2\times10^{-5}$
\end_inset

 per locus per generation.
\end_layout

\begin_layout Section
Selection on a common and a rare disease 
\end_layout

\begin_layout Standard
Two diseases are simulated: a common disease with initial allele frequency
 of 
\begin_inset Formula $f_{0}=0.2$
\end_inset

; and a rare disease with initial allele frequency of 
\begin_inset Formula $f_{0}=0.001$
\end_inset

.
 The diseases are unlinked in the sense that their corresponding loci reside
 on separated chromosomes.
 The allelic spectra of both diseases are set to be 
\begin_inset Formula $\left[.9,.02,.02,.02,.02,.02\right]$
\end_inset

.
 I.e., one allele accounts for 90% of the disease cases.
 
\end_layout

\begin_layout Standard
Both diseases are recessive in that their fitness values are 
\begin_inset Formula $\left[1,1,1-s\right]$
\end_inset

 for genotype 
\begin_inset Formula $AA$
\end_inset

, 
\begin_inset Formula $Aa$
\end_inset

 and 
\begin_inset Formula $aa$
\end_inset

 respectively.
 
\begin_inset Formula $s_{c}=0.1$
\end_inset

 , 
\begin_inset Formula $s_{r}=0.9$
\end_inset

 are used in the simulation which imply weak selection on the common disease
 and strong selection on the rare disease.
 If an individual has both diseases, his fitness value follows a multiplicative
 model, i.e., 
\begin_inset Formula $\left(1-s_{c}\right)\times\left(1-s_{r}\right)=0.09$
\end_inset

.
 
\end_layout

\begin_layout Standard
These parameters, translated to python, are shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:reich0"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichParam.py"
lstparams "caption={Set parameters},label={alg:reich0}"

\end_inset


\end_layout

\begin_layout Section
Create a simulator
\end_layout

\begin_layout Standard
Several parameters are needed to create a population:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\family default
: 2, default
\end_layout

\begin_layout Itemize

\family typewriter
size
\family default
: initial population size, known
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: no subpopulation (or one single population).
 size can be ignored if 
\family typewriter
subPop
\family default
 is given.
\end_layout

\begin_layout Itemize

\family typewriter
loci
\family default
: number of chromosomes and number of loci on each chromosome: we use two
 unlinked loci.
 use 
\family typewriter
loci=[1,1]
\family default
.
 This array gives the number of loci on each chromosome.
\end_layout

\begin_layout Itemize
loci name and position: no need to specify
\end_layout

\begin_layout Itemize

\family typewriter
infoFields
\family default
: This parameter is tricky since you need to specify what auxiliary information
 to attach to each individual.
 During the simulation, 
\family typewriter
fitness
\family default
 is needed because all selectors generate this information and mating schemes
 will make use of it.
 If you forget to provide this parameter, never mind, the simulation will
 fail and tell you that a information field 
\family typewriter
fitness
\family default
 is needed.
 Similar information fields include 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 when you want to track each individual's parents using 
\family typewriter
taggers.
\end_layout

\begin_layout Standard
You can then create a population with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

population(size=1000, loci=[1,1], infoFields=['fitness'])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create simulator, we need to decide on a mating scheme.
 
\family typewriter
randomMating
\family default
 should of course be used, but we need to tell 
\family typewriter
randomMating
\family default
 how population size should be changed.
 By default, all mating schemes keep the population size of ancestral population
, but we need an instant population expansion model.
\end_layout

\begin_layout Standard
The easiest way to achieve this is defining a function that accept generation
 number and the population size of previous generation, and return the size
 of this generation.
 The input and output population sizes need to be arrays, indicating sizes
 of all subpopulations.
 In our case, something like 
\family typewriter
[1000]
\family default
 should be used.
 The instant population growth model is actually quite easy to write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ins_exp(gen, oldSize=[]):
\end_layout

\begin_layout Plain Layout

     if gen < burnin:
\end_layout

\begin_layout Plain Layout

         return [initSize]
\end_layout

\begin_layout Plain Layout

     else:
\end_layout

\begin_layout Plain Layout

         return [finalSize] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a little adjustment of how population size is given to 
\family typewriter
population()
\family default
, and use demographic function as a parameter to allow other demographic
 models to be used, we end up with example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich1"

\end_inset

.
 Note that because we use loci with more than 255 allele states, the long
 allele module is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichSimulator.py"
lstparams "caption={Create a simulator},label={reich1}"

\end_inset


\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
We start the simulation with initial allele spectra at the two loci.
 This can be achieved by operator 
\family typewriter
initByFreq
\family default
, which allows you to initialize individuals with alleles proportional to
 given allele frequencies.
 Using a large number of parameters, this operator can initialize any subset
 of loci, for any subset(s) of individuals, even given ploidy.
 We need only to specify locus to initialize, and use it like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# initialize locus 0 (for common disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[0], alleleFreq=C_f),
\end_layout

\begin_layout Plain Layout

# initialize locus 1 (for rare disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[1], alleleFreq=R_f),
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mutation and selection
\end_layout

\begin_layout Standard
You will need to read the relative sections of the reference manual to pick
 suitable mutator and selectors.
 What we need in this case are
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

-allele mutator with given number of allele states (
\begin_inset Formula $k$
\end_inset

).
 This is exactly
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kamMutator(rate=mu, maxAllele=max_allele)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
single locus selector that treat 0 as wildtype, and any other allele as
 mutant.
 The selector to use is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Because an individual has only one fitness value, fitness values obtained
 from two selectors need to be combined (another choice is that you can
 use a selector that handle multiple loci.).
 Therefore, we use a multi-locus selector as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mlSelector([
\end_layout

\begin_layout Plain Layout

    maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0]),
\end_layout

\begin_layout Plain Layout

    maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\begin_layout Plain Layout

    ], mode=SEL_Multiplicative)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
With these operators, the simulator can be started.
 It first initialize a population with given allelic spectra, and then evolve
 it, subject to mutation and selection, specific to each locus.
 The program is listed in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich2"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichMutSel.py"
lstparams "caption={Run the simulator},label={reich2}"

\end_inset


\end_layout

\begin_layout Section
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy since 
\family typewriter
stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use 
\family typewriter
stat()
\family default
 operator to calculate allele frequency and set variable 
\family typewriter
alleleFreq
\family default
 (and 
\family typewriter
alleleNum
\family default
) in each population's local namespace,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0,1]),
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then use a 
\family typewriter
pyEval
\family default
 (python expression) operator to print out the values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(r' %.3f
\backslash
t%.3f
\backslash
n % (1-alleleFreq[0][0], 1-alleleFreq[1][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
pyEval
\family default
 operator can accept any valid python expression so the above expression
 calculate 
\begin_inset Formula $f_{0}=\sum_{i=1}^{\infty}f_{i}$
\end_inset

 at each locus (0 and 1) and print it in the format of 
\family typewriter
'%.3f
\backslash
t%.3f
\backslash
n'
\family default
.
\end_layout

\begin_layout Standard
There is no operator to calculate effective number of alleles 
\begin_inset CommandInset citation
LatexCommand citep
key "Reich2001a"

\end_inset

 so we need to do that by ourselves, using allele frequencies.
 The formula to calculate effective number of alleles is
\begin_inset Formula \[
n_{e}=\left(\sum_{i}\left(\frac{f_{i}}{f_{0}}\right)^{2}\right)^{-1}\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

 , and 
\begin_inset Formula $f_{0}$
\end_inset

 is defined as above.
 To calculate 
\begin_inset Formula $n_{e}$
\end_inset

 at the first locus, we can use a 
\family typewriter
pyEval
\family default
 operator (a direct translation of the formula):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval('1./sum([(x/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0][1:]])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this expression looks complicated and can not handle the case when
 
\begin_inset Formula $f_{0}=0$
\end_inset

.
 A more complicated, and robust method is using the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
 ,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(stmts='''ne = [0,0]
\end_layout

\begin_layout Plain Layout

for i in range(2):
\end_layout

\begin_layout Plain Layout

    freq = alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

    f0 = 1 - alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

    if f0 == 0:
\end_layout

\begin_layout Plain Layout

        ne[i] = 0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        ne[i] = 1./sum([(x/f0)**2 for x in freq])
\end_layout

\begin_layout Plain Layout

''', expr=r'%.4f
\backslash
t%.4f
\backslash
n % (ne[0], ne[1])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the 
\family typewriter
pyEval
\family default
 can be really complicated and calculate any statistics.
 However, if you plan to calculate more statistics, a pure python operator
 may be easier to write.
 The simplest form of a python operator is just a python function that accept
 a population as the first parameter (and an optional parameter),
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ne(pop):
\end_layout

\begin_layout Plain Layout

    ' calculate effective number of alleles '
\end_layout

\begin_layout Plain Layout

    Stat(pop, alleleFreq=[0,1])
\end_layout

\begin_layout Plain Layout

    f0 = [0, 0]
\end_layout

\begin_layout Plain Layout

    ne = [0, 0]
\end_layout

\begin_layout Plain Layout

    for i in range(2):
\end_layout

\begin_layout Plain Layout

        freq = pop.dvars().alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

        f0[i] = 1 - pop.dvars().alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

        if f0[i] == 0:
\end_layout

\begin_layout Plain Layout

            ne[i] = 0
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            ne[i] = 1.
 / sum([(x/f0[i])**2 for x in freq])
\end_layout

\begin_layout Plain Layout

    print '%d
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
n' % (pop.gen(), f0[0], f0[1], ne[0], ne[1])
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can use this function in a python operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(func=ne, step=5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOperator
\family default
 is that 
\family typewriter
pyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the vars explicitly using the 
\family typewriter
pop.dvars()
\family default
 function.
 (This also implies that you can do whatever you want to the population.).
 In this example, the function form of the 
\family typewriter
stat
\family default
 operator is used to explicitly calculate allele frequency.
 The results are also explicitly printed using the 
\family typewriter
print
\family default
 command.
 The explicities lead to longer, but clearer program.
 This becomes obvious when you need to calculate and print many statistics.
\end_layout

\begin_layout Standard
The following program (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich3"

\end_inset

) uses the 
\family typewriter
pyOperator
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
pyOperator
\end_layout

\end_inset

 solution.
 In this program, user can input two demographic models as command line
 parameter.
 Two other operators are used
\end_layout

\begin_layout Itemize
A 
\family typewriter
ticToc
\family default
 operator that prints out elapsed time at every 100 generations
\end_layout

\begin_layout Itemize
A 
\family typewriter
pause
\family default
 operator that pause the simulation whenever you press a key.
 You can actually enter a python command shell to examine the results.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichStat.py"
lstparams "caption={The whole program},label={reich3}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Section
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to run more simulations with
 different parameters like initial population size.
 Editing the script again and again is out of the question.
 Since this script is a python script, it is tempting to use python modules
 like 
\family typewriter
getopt
\family default
 to parse options from command line.
 A better choice would be using the 
\family typewriter
simuOpt
\family default
 module.
 Using this module properly, your simuPOP should be able to get options
 from short or long command line option, from a configuration file, from
 a tkInter of wxPython dialog, or from user input.
 Taking 
\family typewriter
c:
\backslash
python
\backslash
share
\backslash
simuPOP
\backslash
scripts
\backslash
simuLDDecay.py
\family default
 as an example, you can run this script as follows:
\end_layout

\begin_layout Itemize
use command '
\family typewriter
simuLDDecay.py
\family default
' or double click the program
\end_layout

\begin_layout Itemize
click the help button on the dialog, or run 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -h
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to view help information.
\end_layout

\end_deeper
\begin_layout Standard
enter parameters in a parameter dialog, or use short or long command arguments
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -s 500 -e 10 --recRate 0.1 --numRep 5 --gui=False
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
use the optimized module by
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --optimized
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
save the parameters to a config file
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --quiet -s 500 -e 10 --saveConfig decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this will result in a config file 
\family typewriter
decay.cfg
\family default
 with these parameters.
\end_layout

\begin_layout Itemize
and of course use 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --config decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to load parameters from the config file.
\end_layout

\end_deeper
\begin_layout Standard
The last function is very useful since you frequently need to run many slightly
 different simulations, saving a configuration file along with your results
 will make your life much easier.
\end_layout

\begin_layout Standard
To achieve all the above, you need to write your scripts in the following
 order:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Write the introduction of the whole script in a module-wise doc string.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'''
\end_layout

\begin_layout Plain Layout

This script will ....
\end_layout

\begin_layout Plain Layout

'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Define an option data structure.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

options = [ 
\end_layout

\begin_layout Plain Layout

...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
 The detailed description of this structure is given in simuPOP reference
 manual.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation functions
\end_layout

\begin_layout Enumerate
In the executable part of the script (under 
\family typewriter
__name__ == '__main__'
\family default
), you should call 
\family typewriter
simuOpt.getParam
\family default
 to let 
\family typewriter
simuOpt
\family default
 handle all parameter input for you and obtain a list of parameters.
 You usually need to handle some special cases (
\family typewriter
-h, --saveConfig
\family default
 etc), and they are all standard.
\end_layout

\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\begin_inset Index
status collapsed

\begin_layout Plain Layout
simuOpt
\end_layout

\end_inset


\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, print usage, save configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
 The following example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich4"

\end_inset

 shows the beginning and the execution part of the complete 
\family typewriter
reich.py
\family default
 script, which can be found under the doc directory.
 For a complete reference of the Options structure, please refer to the
 reference manual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichOpt.py"
lstparams "caption={Option handling},label={reich4}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "simuPOP"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
