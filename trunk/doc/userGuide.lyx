#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.8.8 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand\lstlistlistingname{List of Examples}
\renewcommand\lstlistingname{Example}

\sloppy

\definecolor{TitleColor}{rgb}{0.126,0.263,0.361}
\definecolor{LinkColor}{rgb}{0.208,0.374,0.486}
\definecolor{VerbatimColor}{rgb}{0,0,0}
\definecolor{VerbatimBackgroundColor}{rgb}{0.98,0.941,0.902}
\definecolor{VerbatimBorderColor}{rgb}{0,0,0}
\definecolor{VerbatimStringColor}{rgb}{0,0.5,0}
\definecolor{VerbatimCommentColor}{rgb}{0.5,0.5,0.5}
\definecolor{VerbatimPromptColor}{rgb}{0.588,0.098,0.054}

\usepackage{sectsty}
\sectionfont{\color{TitleColor}}
\subsectionfont{\color{TitleColor}}
\subsubsectionfont{\color{TitleColor}}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "simuPOP User's Guide"
\pdf_author "Bo Peng"
\pdf_keywords "simuPOP"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=TitleColor,urlcolor=LinkColor"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "alsoletter={>.},backgroundcolor={\color{VerbatimBackgroundColor}},basicstyle={\ttfamily\color{VerbatimColor}},commentstyle={\color{VerbatimCommentColor}\slshape},emph={[2]>>>,...},emphstyle={[2]\color{VerbatimPromptColor}\bf},language=Python,otherkeywords={>>>,...},showspaces=false,showstringspaces=false,showtabs=false,stringstyle={\color{VerbatimStringColor}},xleftmargin=15pt"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{7.5in} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2008 Bo Peng 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
simuPOP is provided as a number of Python modules, which provide of a large
 number of Python objects and functions, including population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 bundled scripts that perform simulations ranging from implementation of
 basic population genetics models to generating datasets under complex evolution
ary scenarios.
 No knowledge about Python or simuPOP would be needed to run these simulations,
 if they happen to fit your need.
\end_layout

\begin_layout Abstract
This user's guide shows you how to install and use simuPOP using a large
 number of examples.
 It describes all important concepts and features of simuPOP and shows you
 how to use them in a simuPOP script.
 For a complete and detailed desciprion about all simuPOP functions and
 classes, please refer to the 
\emph on
simuPOP Reference Manual.

\emph default
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP: 
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
(18): 3686-3687
\end_layout

\begin_layout Quote
Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
 mating populations using simuPOP.
 
\emph on
bioinformatics,
\emph default
 
\series bold
24
\series default
 (11)
\begin_inset Quotes erd
\end_inset

 1408-1409.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 'runSampleCode.py splitMerge.py', and simuPOP_ref.tex generated by 'doxygen;
 cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard
simuPOP is an individual-based forward-time population genetics simulation
 environment based on Python, a dynamic object-oriented programming language
 that has been widely used in biological studies.
 simuPOP provides a large number of Python objects and functions, and a
 mechanism to evolve populations forward in time.
 It is the users’ responsibility to write a Python script to form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 built-in scripts so that users who are unfamiliar with Python and simuPOP
 can perform some pre-specified simulation processes.
 These scripts range from implementation of basic population genetics models
 to generating datasets under complex evolutionary scenarios.
 In addition, simuPOP modules and functions are provided to load and manipulate
 HapMap samples and to perform a number of popular gene-mapping methods.
\end_layout

\begin_layout Standard
Unlike other population genetics simulation applications that aim at specific
 evolutionary scenarios, simuPOP aims at providing a general purpose simulation
 program that can be used to write and study arbitrarily complex evolutionary
 scenarios.
 This makes simuPOP an ideal tool in a wide variety of applications ranging
 from demonstrating simple population genetics models to studying the evolution
 of complex human genetic diseases.
\end_layout

\begin_layout Section
An overview of simuPOP concepts
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
population
\series default
 consists of individuals of the same 
\series bold
genotype structure
\series default
, which include properties such as number of homologous sets of chromosomes
 (ploidy), number of chromosomes, and names and locations of markers on
 each chromosome.
 Individuals can be divided into 
\series bold
subpopulations
\series default
 that can be further divided into
\emph on
 
\series bold
\emph default
virtual subpopulations
\series default
 according to individual properties such as sex, affection status, or arbitrary
 auxiliary information such as age.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:life-cycle"

\end_inset

A life cycle of an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename evolve.png
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators
\series default
 are Python objects that act on a population.
 They can be applied to a population before or after mating during a life
 cycle of an evolutionary process (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), or to one or two parents during the production of each offspring.
 Arbitrary numbers of operators can be applied to an evolving population.
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
mating scheme
\series default
 is responsible for choosing parent or parents from a parental (virtual)
 subpopulation and for populating an offspring subpopulation.
 simuPOP provides a number of pre-defined mating schemes, such as random,
 consanguineous, monogamous, or polygamous mating, selfing, and haplodiploid
 mating in hymenoptera.
 More complicated nonrandom mating schemes such as mating in age-structured
 populations can be constructed using 
\series bold
heterogeneous mating schemes
\series default
.
 
\end_layout

\begin_layout Standard
simuPOP evolves a population generation by generation, following the evolutionar
y cycle depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

.
 Briefly speaking, a number of 
\series bold
pre-mating operators
\series default
 such as a 
\emph on
mutator
\emph default
 are applied to a population before a mating scheme repeatedly chooses a
 parent or parents to produce offspring.
 
\series bold
During-mating operators
\series default
 such as 
\emph on
recombinator
\emph default
 can be used to adjust how offspring genotypes are formed from parental
 genotypes.
 After an offspring population is populated, 
\series bold
post-mating operators
\series default
 can be applied, for example, to calculate population statistics.
 The offspring population will then become the parental population of the
 next evolutionary cycle.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simpleExample.log"
lstparams "caption={A simple example},label={simple-example}"

\end_inset


\end_layout

\begin_layout Standard
These concepts are demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, where a standard diploid Wright-Fisher model with recombination is simulated.
 The first line imports the standard simuPOP module.
 The second line creates a diploid population with 1000 individuals, each
 having one chromosome with two loci.
 The third line creates a simulator with three replicates of this population.
 Random mating will be used to generate offspring.
 The last statement uses the 
\family typewriter
evolve()
\family default
 function to evolve the populations for 100 generations, subject to five
 operators.
\end_layout

\begin_layout Standard
The first operator 
\family typewriter
initByValue
\family default
 is applied to all populations before evolution.
 This operator initializes all individuals with the same genotype 
\family typewriter
12/21
\family default
.
 The other operators can be applied at every generation.
 
\family typewriter
recombinator
\family default
 is a during-mating operator that recombines parental chromosomes with the
 given recombination rate 
\family typewriter
0.01
\family default
 during the generation of offspring; 
\family typewriter
stat
\family default
 calculates linkage disequilibrium between the first and second loci.
 The results of this operator are stored in a local variable space of each
 population.
 The last two operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOutput
\family default
 are applied at the end of every 10 generations.
 
\family typewriter
pyEval
\family default
 is applied to all replicates to output calculated linkage disequilibrium
 values with a trailing tab, and the last operator outputs a newline after
 the last replicate.
 The result is a table of three columns, representing the decay of linkage
 disequilibrium of each replicate at 10 generation intervals.
 The return value of the 
\family typewriter
evolve
\family default
 function, which is the number of evolved generations for each replicate,
 is also printed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
simuPOP offers a long list of features, many of which are unique among all
 forward-time population genetics simulation programs.
 The most distinguished features include:
\end_layout

\begin_layout Enumerate
simuPOP provides three types of modules that use 1, 8 or 16 bits to store
 an allele.
 The binary module (1 bit) is suitable for simulating a large number of
 SNP markers and the long module (16 bits) is suitable for simulating some
 population genetics models such as the infinite allele mutation model.
 simuPOP supports different types of chromosomes such as autosome, sex chromosom
es and mitochondrial, with arbitrary number of markers.
\end_layout

\begin_layout Enumerate
An arbitrary number of float numbers, called information fields, can be
 attached to individuals of a population.
 For example, information field father_idx and mother_idx are used to track
 an individual’s parents, and pack_year can be used to simulate an environmental
 factor associated with smoking.
\end_layout

\begin_layout Enumerate
simuPOP does not impose any limit on number of homologous sets of chromosomes,
 the size of the genome, or the number of individuals in a population.
 During an evolutionary process, a population can hold more than one most-recent
 generations.
 Pedigrees can be sampled from such multi-generation populations.
\end_layout

\begin_layout Enumerate
An operator can be native (implemented in C++) or hybrid (Python assisted).
 A hybrid operator calls a user-provided Python function to implement arbitrary
 genetic effects.
 For example, a hybrid mutator passes to-be-mutated alleles to a user-provided
 function and mutates these alleles according to the returned values.
\end_layout

\begin_layout Enumerate
simuPOP provides more than 70 operators that cover all important aspects
 of genetic studies.
 These include mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise and hybrid), migration (arbitrary,
 can create new subpopulation), recombination and gene conversion (uniform
 or nonuniform, sex-specific), quantitative trait (single, multilocus or
 hybrid), selection (single-locus, additive, multiplicative or hybrid multi-locu
s models), penetrance (single, multi-locus or hybrid), ascertainment (case–contr
ol, affected sibpairs, random, nuclear and large pedigree), statistics calculati
on (including but not limited to allele, genotype, haplotype, heterozygote
 number and frequency; expected heterozygosity; bi-allelic and multi-allelic
 , and linkage disequilibrium measures), pedigree tracing, visualization
 (using R or other Python modules) and load/save in simuPOP’s native format
 and many external formats such as Linkage.
\end_layout

\begin_layout Enumerate
Mating schemes and many operators can work on virtual subpopulations of
 a subpopulation.
 For example, positive assortative mating can be implemented by mating individua
ls with similar properties such as ancestry.
 The number of offspring per mating event can be fixed, or can follow a
 statistical distribution.
\end_layout

\begin_layout Standard
A number of forward-time simulation programs are available.
 If we exclude early forward-time simulation applications developed primarily
 for teaching purposes, notable forward-time simulation programs include
 
\emph on
easyPOP
\emph default
, 
\emph on
FPG
\emph default
, 
\emph on
Nemo
\emph default
 and 
\emph on
quantiNemo
\emph default
, 
\emph on
genoSIM
\emph default
 and 
\emph on
genomeSIMLA
\emph default
, 
\emph on
FreGene
\emph default
, 
\emph on
GenomePop
\emph default
, 
\emph on
ForwSim
\emph default
, and 
\emph on
ForSim
\emph default
.
 These programs are designed with specific applications and specific evolutionar
y scenarios in mind, and excel in what they are designed for.
 For some applications, these programs may be easier to use than simuPOP.
 For example, using a special look-ahead algorithm, 
\emph on
ForwSim
\emph default
 is among the fastest programs to simulate a standard Wright-Fisher process,
 and should be used if such a simulation is needed.
 However, these programs are not flexible enough to be applied to problems
 outside of their designed application area.
 For example, none of these programs can be used to study the evolution
 of a disease predisposing mutant, a process that is of great importance
 in statistical genetics and genetic epidemiology.
 Compared to such programs, simuPOP has the following advantages:
\end_layout

\begin_layout Itemize
The scripting interface gives simuPOP the flexibility to create arbitrarily
 complex evolutionary scenarios.
 For example, it is easy to use simuPOP to explicitly introduce a disease
 predisposing mutant to an evolving population, trace the allele frequency
 of them, and restart the simulation if they got lost due to genetic drift.
\end_layout

\begin_layout Itemize
The Python interface allows users to define customized genetic effects in
 Python.
 In contrast, other programs either do not allow customized effects or force
 users to modify code at a lower (e.g.
 C++) level.
\end_layout

\begin_layout Itemize
simuPOP is the only application that embodies the concept of virtual subpopulati
on that allows evolutions at a finer scale.
 This is required for realistic simulations of complex evolutionary scenarios.
\end_layout

\begin_layout Itemize
simuPOP allows users to examine an evolutionary process very closely because
 all simuPOP objects are Python objects that can be assessed using their
 member functions.
 For example, users can keep track of genotype at particular loci during
 evolution.
 In contrast, other programs work more or less like a black box where only
 limited types of statistics can be outputted.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
simuPOP is distributed under a GPL license and is hosted on
\family typewriter
 http://simupop.sourceforge.net
\family default
, the world's largest development and download repository of Open Source
 code and applications.
 simuPOP is available on any platform where Python is available, and is
 currently tested under both 32 and 64 bit versions of Windows (Windows
 2000 and later), Linux (Redhat), MacOS X and Sun Solaris systems.
 Different C++ compilers such as Microsoft Visual C++, gcc and Intel icc
 are supported under different operating systems.
 Standard installation packages are provided for Windows, Linux, MacOS X,
 and Sun Solaris systems.
\end_layout

\begin_layout Standard
If a binary distribution is unavailable for a specific platform, it is usually
 easy to compile simuPOP from source, following the standard 
\family typewriter

\begin_inset Quotes eld
\end_inset

python setup.py install
\begin_inset Quotes erd
\end_inset


\family default
 procedure.
 Besides a C++ compiler, several supporting tools and libraries are needed.
 Please refer to the 
\family typewriter
INSTALL
\family default
 file for further information.
\end_layout

\begin_layout Standard
Thanks to the ‘glue language’ nature of Python, it is easy to interoperate
 Python with other applications within a simuPOP script.
 For example, users can call any R function from Python/simuPOP for the
 purposes of visualization and statistical analysis, using 
\series bold
R
\series default
 and a Python module 
\series bold
RPy
\series default
.
 This technique is widely used in simuPOP so it is highly recommended that
 you install R and rpy is your are familiar with R.
 In addition, although simuPOP uses the standard tkInter GUI toolkit when
 a graphical user interface is needed, it can make use of a 
\series bold
wxPython
\series default
 toolkit if it is available.
 Several functions, such as the graphical version of the 
\family typewriter
ListVars()
\family default
 function, are only available for wxPython.
\end_layout

\begin_layout Section
Getting help
\end_layout

\begin_layout Subsection
Online help system
\end_layout

\begin_layout Standard
Most of the help information contained in this document and 
\emph on
the simuPOP reference manual
\emph default
 is available from command line.
 For example, after you install and import the simuPOP module, you can use
 
\family typewriter
help(population.addInfoField) 
\family default
to view the help information of member function 
\family typewriter
addInfoField
\family default
 of class 
\family typewriter
population
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/help.log"
lstparams "caption={Getting help using the \\texttt{help()} function},keywordstyle={\\ttfamily}"

\end_inset


\end_layout

\begin_layout Standard
It is important that you understand that
\end_layout

\begin_layout Itemize
The constructor of a class is named 
\family typewriter
__init__
\family default
 in Python.
 That is to say, you should use the following command to display the help
 information of the constructor of class 
\family typewriter
population
\family default
: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> help(population.__init__)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some classes are derived from other classes and have access to member functions
 of their base classes.
 For example, class 
\family typewriter
population
\family default
, 
\family typewriter
individual
\family default
 and 
\family typewriter
simulator
\family default
 are all derived from class 
\family typewriter
GenoStruTrait
\family default
.
 Therefore, you can use all 
\family typewriter
GenoStruTrait
\family default
 member functions from these classes.
 
\end_layout

\begin_deeper
\begin_layout Standard
In addition, the constructor of a derived class also calls the constructor
 of its base class so you may have to refer to the base class for some parameter
 definitions.
 For example, parameters 
\family typewriter
begin, end, step, at 
\family default
etc are shared by all operators, and are explained in details only in class
 
\family typewriter
baseOperator.
\end_layout

\end_deeper
\begin_layout Subsection
Debug-related operators/functions
\end_layout

\begin_layout Standard
If your simuPOP session or script does not behave as expected, it might
 be helpful to let simuPOP print out some debug information.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is unclear why this simple command causes us trouble, instead of outputting
 the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Turn on/off debug information
\end_layout

\end_inset

>>> TurnOnDebug(DBG_POPULATION)
\end_layout

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\begin_layout Plain Layout

Constructor of population is called
\end_layout

\begin_layout Plain Layout

Destructor of population is called 
\end_layout

\begin_layout Plain Layout

Segmentation fault (core dumped)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
population(1, loci=[100])
\family default
 creates a temporary object that is destroyed right after the execution
 of the command.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is to create a persistent population object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> pop = population(1, loci=[100])
\end_layout

\begin_layout Plain Layout

>>> pop.individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can use 
\family typewriter
TurnOnDebug(code) 
\family default
and 
\family typewriter
TurnOffDebug(code) 
\family default
to turn on and off debug information where 
\family typewriter
code 
\family default
can be any debug code listed in 
\family typewriter
ListDebugCode
\begin_inset Index
status collapsed

\begin_layout Plain Layout
listDebugCode
\end_layout

\end_inset

()
\family default
.
 If you would like to turn on debugging during an evolutionary process,
 you can use operators 
\family typewriter
turnOnDebug 
\family default
and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Subsection
Other help sources
\end_layout

\begin_layout Standard
If you are new to Python, it is recommended that you borrow a Python book,
 or at least go through the following online Python tutorials:
\end_layout

\begin_layout Enumerate
The Python tutorial (
\family typewriter
http://docs.python.org/tut/tut.html
\family default
)
\end_layout

\begin_layout Enumerate
Other online tutorials listed at 
\family typewriter
http://www.python.org/doc/
\end_layout

\begin_layout Standard
If you are new to simuPOP, please read this guide before you dive into 
\emph on
the simuPOP reference manual
\emph default
, which describes all the details of simuPOP but does not show you how to
 use it.
 The PDF versions of both documents are distributed with simuPOP.
 You can also get the latest version of the documents online, from the simuPOP
 subversion repository ( 
\family typewriter
http://simupop.sourceforge.net
\family default
, click
\family sans
 SF.net summary > Code > SVN Browse > trunk > doc
\family default
).
 However, because simuPOP is under active development, there may be discrepancie
s between your local simuPOP installation and these latest documents.
\end_layout

\begin_layout Standard
A number of bundled scripts are distributed with simuPOP.
 They range from simple demonstration of population genetics models to observing
 the evolution of complex human genetic diseases.
 These scripts can be a good source to learn how to write a simuPOP script.
 Of course, if any of these scripts happens to fit your need, you may be
 able to use them directly, with writting a line of code.
\end_layout

\begin_layout Standard
A 
\emph on
simuPOP cookbook
\emph default
 is under development.
 The goal of this book is to provide recipes of commonly used simulation
 scenarios.
 A number of recipes are currently available under the 
\family typewriter
doc/cookbook
\family default
 directory of a simuPOP distribution.
 This book might be made available online so that users can submit their
 own recipes.
\end_layout

\begin_layout Standard
If you cannot find the answer you need, or if you believe that you have
 located a bug, or if you would like to request a feature, please subscribe
 to the simuPOP mailinglist and send your questions there.
\end_layout

\begin_layout Section
Naming Conventions
\end_layout

\begin_layout Standard
Before we dive into the details of simuPOP, it is helpful to know a few
 name conventions that simuPOP tries to follow.
 Generally speaking, 
\end_layout

\begin_layout Itemize
All classes (objects, e.g.
 
\family typewriter
population
\family default
()), member functions (e.g.
 
\family typewriter
population::vars()
\family default
) and parameter names start with small character and use capital character
 for the first character of each word afterward (e.g.
 
\family typewriter
population::subPopSize(), individual::setInfo
\family default
()).
\end_layout

\begin_layout Itemize
Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter
TurnOnDebug(DBG_POPULATION)
\family default
 is the function to turn on debug mode for population related functions
 and 
\family typewriter
turnOnDebug(DBG_POPULATION) 
\family default
will do nothing apparently, because it creates an operator.
 
\end_layout

\begin_layout Itemize
Constants start with Capital characters as well.
 They are usually prefixed with a category name.
 For example, 
\family typewriter
MigrByProportion
\family default
 specifies a migration mode.
\end_layout

\begin_layout Standard
Finally, simuPOP uses the abbreviated forms of the following words in function
 and parameter names:
\end_layout

\begin_layout Quote

\family typewriter
pos 
\family default
(position)
\family typewriter
,  info 
\family default
(information)
\family typewriter
, migr 
\family default
(migration)
\family typewriter
, subPop 
\family default
(subpopulation and virtual subpopulation)
\family typewriter
, rep 
\family default
(replicate)
\family typewriter
, gen 
\family default
(generation)
\family typewriter
, ops 
\family default
(operators)
\family typewriter
, expr 
\family default
(expression),
\family typewriter
 stmts 
\family default
(statements).
\end_layout

\begin_layout Chapter
simuPOP components
\end_layout

\begin_layout Section
simuPOP modules
\end_layout

\begin_layout Standard
simuPOP consists of a number of Python modules, documents, tests and examples.
 Using windows as an example, simuPOP installs the following files to your
 operating system:
\end_layout

\begin_layout Itemize
Core simuPOP modules (
\family typewriter
simuPOP_XXX.py
\family default
, 
\family typewriter
_simuPOP_XXX.pyd
\family default
) and a number of utility modules (
\family typewriter
simuUtil.py, simuOpt.py
\family default
 etc) under 
\family typewriter
c:
\backslash
python2X
\backslash
Lib
\backslash
site-packages
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
doc
\family default
: This directory contains the pdf version of this user's guide and the 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
test:
\family default
 This directory contains all unit test cases.
 It is recommended that you test your simuPOP installation using these scripts
 if you compile simuPOP from source.
 
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
scripts
\series bold
\emph on
:
\family default
\series default
\emph default
 This directory contains all the bundled scripts.
 It is worth noting that although these scripts are distributed with simuPOP,
 they are not tested as rigorously and as frequently as the simuPOP core.
 Please send an email to the simuPOP mailinglist if you notice any problem
 with them.
\end_layout

\begin_layout Standard
There are six flavors of the core simuPOP module: short, long and binary
 allele modules, and their optimized versions.
 The short allele modules use 8 bits to store each allele which limits the
 possible allele states to 256.
 This is enough most of the times but not so if you need to simulate models
 such as the infinite allele model.
 In those cases, you should use the long allele version of the modules,
 which use 16 bits for each allele and can have 
\begin_inset Formula $2^{16}$
\end_inset

 possible allele states.
 On the other hand, if you would like to simulate a large number of binary
 (SNP) markers, binary libraries can save you a lot of RAM because they
 use 1 bit for each allele.
 Despite of differences in internal memory layout, all these modules have
 the same interface.
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure a simulation executes correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time validation varies from case to case but can be
 high under some extreme circumstances.
 Because of this, optimized versions for all modules are provided.
 They bypass all parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confident
 that your simulation is running as expected.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 demonstrate the differences between standard and optimized modules, by
 executing two invalid commands.
 A standard module returns proper error messages, while an optimized module
 returns erroneous results and or simply crashes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/standard.log"
lstparams "caption={Use of standard simuPOP modules},keywords={from,import},label={lst:Use-of-standard-module}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Use-of-optimized-module"

\end_inset

Use of optimized simuPOP modules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

% python
\end_layout

\begin_layout Plain Layout

>>> from simuOpt import setOptions
\end_layout

\begin_layout Plain Layout

>>> setOptions(optimized=True, alleleType='long', quiet=True)
\end_layout

\begin_layout Plain Layout

>>> from simuPOP import *
\end_layout

\begin_layout Plain Layout

>>> pop = population(10, loci=[2])
\end_layout

\begin_layout Plain Layout

>>> pop.locusPos(10)
\end_layout

\begin_layout Plain Layout

1.2731974748756028e-313
\end_layout

\begin_layout Plain Layout

>>> pop.individual(20).setAllele(1, 0)
\end_layout

\begin_layout Plain Layout

Segmentation fault
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 also demonstrates how to use the 
\family typewriter
setOptions
\family default
 function in the 
\family typewriter
simuOpt
\family default
 module to control the choice of one of the six simuPOP modules.
 By specifying one of 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary 
\family default
for option 
\family typewriter
alleleType
\family default
, and setting
\family typewriter
 optimized
\family default
 to 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
, the right flavor of module will be chosen when simuPOP is loaded.
 In addition, option 
\family typewriter
quiet
\family default
 can be used supress initial output.
 An alternative method is to set environmental variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
SIMUALLELETYPE
\end_layout

\end_inset

 to 
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
binary
\family default
 to use the standard short, long or binary module, and variable 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules.
\end_layout

\begin_layout Standard
When simuPOP is loaded, it creates a default random number generator (RNG)
 of type 
\family typewriter
mt19937
\family default
 using a random seed from a system random number generator that gurantees
 random seeds for all instances of simuPOP even if they are initialized
 at the same time.
 After simuPOP is loaded, you can reset this system RNG with a different
 random number generator (c.f.
 
\family typewriter
AvailableRNG
\begin_inset Index
status collapsed

\begin_layout Plain Layout

\family typewriter
AvailableRNG
\end_layout

\end_inset

()
\family default
, 
\family typewriter
SetRNG
\begin_inset Index
status open

\begin_layout Plain Layout

\family typewriter
SetRNG
\end_layout

\end_inset

(name, seed)
\family default
).
 It is also possible to save the random seed of a simuPOP session (c.f.
 
\family typewriter
rng().seed()
\family default
) and use it to replay the session later.
\end_layout

\begin_layout Section
Pythonic issues
\end_layout

\begin_layout Subsection
References and the 
\family typewriter
clone() 
\family default
member function
\end_layout

\begin_layout Standard
Assignment in Python only creates a new refernce to an exsting object.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop = population()
\end_layout

\begin_layout Plain Layout

pop1 = pop
\end_layout

\end_inset

will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well and the removal of 
\family typewriter
pop
\family default
 will invalidate 
\family typewriter
pop1
\family default
.
 For example, a reference to the first population in a simulator is returned
 from function 
\family typewriter
func()
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

.
 The subsequent use of this 
\family typewriter
pop
\family default
 object may crash simuPOP because the simulator 
\family typewriter
simu
\family default
 is destroyed, along with all its internal populations, after 
\family typewriter
func()
\family default
 is finished, leaving 
\family typewriter
pop
\family default
 referring to an invalid object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Reference-to-population"

\end_inset

Reference to a population in a simulator
\end_layout

\end_inset

def func():
\end_layout

\begin_layout Plain Layout

    simu = simulator(population(10), randomMating(), rep=5)
\end_layout

\begin_layout Plain Layout

    # return a reference to the first population in the simulator
\end_layout

\begin_layout Plain Layout

    return simu.population(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pop = func()
\end_layout

\begin_layout Plain Layout

# simuPOP will crash because pop refers to an invalid population.
\end_layout

\begin_layout Plain Layout

pop.popSize()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to have an independent copy of a population, you can use
 the 
\family typewriter
clone()
\family default
 member function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

 would behave properly if the 
\family typewriter
return
\family default
 statement is replaced by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.population(0).clone()
\end_layout

\end_inset

although in this specific case, extracting the first population from the
 simulator using the 
\family typewriter
extract
\family default
 function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.extract(0)
\end_layout

\end_inset

would be more efficient because we do not need to copy the first population
 from 
\family typewriter
simu
\family default
 if it will be destroyed soon.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
clone()
\family default
 function exists for all simuPOP classes (objects) such as 
\emph on
simulator
\emph default
, 
\emph on
mating schemes
\emph default
 and 
\emph on
operators
\emph default
.
 simuPOP also supports the standard Python shallow and deep copy operations
 so you can also make a cloned copy of 
\family typewriter
pop
\family default
 using the
\family typewriter
 deepcopy
\family default
 function defined in the Python 
\family typewriter
copy 
\family default
module
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy
\end_layout

\begin_layout Plain Layout

pop1 = copy.deepcopy(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zero-based indexes, absolute and relative indexes
\end_layout

\begin_layout Standard

\series bold
All arrays in simuPOP start at index 0
\series default
.
 This conforms to Python and C++ indexes.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the
\emph on
 absolute index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset


\emph default
 and
\emph on
 
\emph default
the
\emph on
 relative index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 
\emph default
of a locus.
 The former index ignores chromosome structure.

\emph on
 
\emph default
For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two chromosomes are (0, 1, 2, 3, 4), (5, 6, 7,
 8, 9, 10, 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3,
 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(idx)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 An individual can also be referred by its 
\emph on
absolute index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset


\emph default
 and
\emph on
 relative index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 
\emph default
where 
\emph on
relative index 
\emph default
is the index in its subpopulation.
 Related member functions are 
\family typewriter
subPopIndPair(idx)
\family default
 and 
\family typewriter
absIndIndex(idx, subPop)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/absIndex.log"
lstparams "caption={Conversion between absolute and relative indexes},label={absIndex}"

\end_inset


\end_layout

\begin_layout Subsection
Ranges and iterators
\end_layout

\begin_layout Standard
Ranges in simuPOP also conform to Python ranges.
 That is to say, a range has the form of 
\family typewriter
[a,b) 
\family default
where 
\family typewriter
a 
\family default
belongs to the range, and 
\family typewriter
b 
\family default
does not.
 For example, 
\family typewriter
pop.chromBegin(1) 
\family default
refers to the index of the first locus on chromosome 1 (actually exists),
 and 
\family typewriter
pop.chromEnd(1) 
\family default
refers to the index of the last locus on chromosome 1
\series bold
 plus 1
\series default
, which might or might not be a valid index.
\end_layout

\begin_layout Standard
A number of simuPOP functions return Python iterators that can be used to
 iterate through an internal array of objects.
 For example, 
\family typewriter
population::individuals([subPop])
\family default
 returns an iterator that can be used to iterate through all individuals,
 or all individuals in a (virtual) subpoulation.
 
\family typewriter
simulator::populations()
\family default
 can be used to iterate through all populations in a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "chromtypes"

\end_inset

 demonstrates the use of ranges and iterators in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/iterator.log"
lstparams "caption={Ranges and iterators},label={iterator.log}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
\series medium
\size normal
carray
\family default
\series default
\size default
 datatype
\end_layout

\begin_layout Standard
simuPOP uses mostly standard Python types such as tuples, lists and dictionaries.
 However, for efficiency considerations, simuPOP defines and uses a new
 
\family typewriter
carray 
\family default
datatype to refer to an internal array of genotypes.
 Such an object can only be returned from 
\family typewriter
individual::genotype
\family default
 and 
\family typewriter
population::genotype
\family default
 functions.
 Instead of copying all genotypes to a Python tuple or list, these functions
 return a 
\family typewriter
carray 
\family default
object that directly reflect the underlying genotype.
 This object behaves like a regular Python list except that the underlying
 genotype will be changed if elements of this object are changed.
 In addition, elements in this array will be changed if the underlying genotype
 is changed using another method.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "chromtypes"

\end_inset

 demonstrates the use of this datatype.
 It also shows how to get an independent list of alleles using the 
\family typewriter
list()
\family default
 built-in function.
 Compare to 
\family typewriter
allele()
\family default
, 
\family typewriter
setAllele()
\family default
 and 
\family typewriter
setGenotype()
\family default
 functions, it is usually more efficient and more convenient to read and
 write genotypes using carray objects, although this usage is usually less
 readable.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/carray.log"
lstparams "caption={The carray datatype},label={carraydatatype}"

\end_inset


\end_layout

\begin_layout Section
Genotypic structure 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
genotypic structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to stuctural information shared by all individuals
 in a population, including number of homologous copies of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidy
\end_layout

\end_inset

(), ploidyName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidyName
\end_layout

\end_inset

()
\family default
), chromosome types and names (c.f.
 
\family typewriter
numChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numChrom
\end_layout

\end_inset

(), chromType()
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromType
\end_layout

\end_inset

, chromName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromName
\end_layout

\end_inset

()
\family default
), position and name of each locus (c.f.
 
\family typewriter
numLoci
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numLoci
\end_layout

\end_inset

(ch),
\family default
 
\family typewriter
locusPos
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!locusPos
\end_layout

\end_inset

(loc),
\family default
 
\family typewriter
locusName(loc)
\family default
), and auxillary information attached to each individual (c.f.
 
\family typewriter
infoField
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoField
\end_layout

\end_inset

(idx), infoFields
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoFields
\end_layout

\end_inset

()
\family default
).
 In addition to property access functions, a number of utility functions
 are provided to, for example, look up the index of a locus by its name
 (c.f.
 
\family typewriter
locusByName()
\family default
, 
\family typewriter
chromBegin()
\family default
, 
\family typewriter
chromLocusPair()
\family default
).
\end_layout

\begin_layout Standard
A genotypic structure can be retrieved from 
\emph on
individual, population 
\emph default
and 
\emph on
simulator
\emph default
 objects.
 Because a population consists of individuals of the same type, and a simulator
 consists of populations of the same type, genotypic information
\emph on
 
\emph default
can only be changed for all individuals at the population level, or for
 all populations at the simulator level.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "chromtypes"

\end_inset

 demonstrates how to access genotypic structure functions at the population
 and individual levels.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genoStru.log"
lstparams "caption={Genotypic structure functions},label={genostructure}"

\end_inset


\end_layout

\begin_layout Subsection
Haploid, diploid and haplodiploid populations
\end_layout

\begin_layout Standard
simuPOP is most widely used to study human (diploid) populations.
 A large number of mating schemes, operators and population statistics are
 designed around the evolution of such a population.
 simuPOP also supports haploid and haplodiploid populations although there
 are fewer choices of mating schemes and operators.
 simuPOP can also support other types of populations such as triploid and
 tetraploid populations, but these features are largely untested due to
 their limited usage.
 It is expected that supports for these population would be enhanced over
 time.
\end_layout

\begin_layout Standard
For efficiency considerations, simuPOP saves the same numbers of homologous
 sets of chromosomes even if some individuals have different numbers of
 homologous sets in a population.
 For example, in a haplodiploid population, because male individuals have
 only one set of chromosomes, their second homologous set of chromosomes
 are 
\emph on
unused
\emph default
, which are labelled as 
\family typewriter
'.'
\family default
, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "chromtypes"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploid.log"
lstparams "caption={An example of haplodiploid population},label={haplodiploid}"

\end_inset


\end_layout

\begin_layout Subsection
Autosomes, sex chromosomes, and mitochondrial chromosome
\end_layout

\begin_layout Standard
The default chromosome type is autosome, which is the 
\emph on
normal
\emph default
 chromosomes in diploid, and in haploid populations.
 simuPOP supports three other types of chromosomes, namely 
\emph on
ChromosomeX
\emph default
, 
\emph on
ChromosomeY 
\emph default
and 
\emph on
Mitochondrial
\emph default
.
 They are only valid in haploid populations where chromosomes X and Y are
 used to determine the sex of an offspring, and mitochondria chromosomes
 are passed only maternally.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "chromtypes"

\end_inset

 shows how to specify different chromosome types, and how genotypes of these
 special chromosomes are arranged.
 Note again that unused marker locations are markered by 
\family typewriter
'.'
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/chromType.log"
lstparams "caption={Different chromosome types},label={chromtypes}"

\end_inset


\end_layout

\begin_layout Standard
The evolution of these special chromosomes follow the following rules
\end_layout

\begin_layout Itemize
There can be only one chromosome X and one chromosome Y.
 It is not allowed to have only one kind of sex chromosome.
\end_layout

\begin_layout Itemize
Chromosome Y of female individuals are ignored.
 The second homologous copy of chromosome X and Y are ignored for male individua
ls.
\end_layout

\begin_layout Itemize
During mating, female parent pass one of her chromosome X to her offspring,
 male parent pass chromosome X or Y to his offspring.
 Recombination is allowed for chromosome X of females, but not allowed for
 males.
\end_layout

\begin_layout Itemize
The sex of offspring is determined by the types of sex chromosomes he/she
 inherits, XX for female, and XY for male.
\end_layout

\begin_layout Itemize
There can be multiple mitochondrial chromosomes, but they have to have the
 same markers.
 The second homologous copies of mitochondrial chromosomes are ignored.
\end_layout

\begin_layout Itemize
Mitochondrial chromosomes are only passed from female parents to offspring.
 No recombination is allowed.
 If there are multiple mitochondrial chromosomes, they are drawn randomly.
\end_layout

\begin_layout Standard
Figure depicts the possible chromosome structure of two diploid parents,
 and how offspring chromosomes are formed.
\end_layout

\begin_layout Subsection
Information fields
\end_layout

\begin_layout Standard

\emph on
Information fields
\emph default
 refer to float numbers attached to each individual, such as fitness value,
 parent index, age.
 They are used to store auxiliary information of individuals, and are essential
 to the operations of some simuPOP components.
 For example, 
\family typewriter
'fitness'
\family default
 field is required by all selectors.
 Details please refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Information-fields"

\end_inset

.
\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard

\family typewriter
population
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population
\end_layout

\end_inset


\family default
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals,
 all have the same genotypic structure.
 A population can store arbitrary number of ancestral populations to facilitate
 pedigree analysis.
\end_layout

\begin_layout Standard
simuPOP uses one-level population structure, but aribitrary temprary subpopulati
on structure can be defined.
 Such temporary subpopulations are called
\emph on
 virtual subpopulations
\emph default
, where individuals can be grouped by sex, affection status, genotype, or
 values of information fields.
 Mating is within subpopulations only.
 Exchange of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
\end_layout

\begin_layout Standard
A very important feature of this population object is that you can store
 many generations of the population in a single population object.
 You can choose to store all or a limited number of generations during evolution.
 In the latter case, the oldest generation will be removed if a new generation
 is pushed in and the number of stored generations has exceeded the specified
 level.
\end_layout

\begin_layout Standard
simuPOP provides a large number of population related functions, they are
 used to
\end_layout

\begin_layout Itemize
access genotype structure
\end_layout

\begin_layout Itemize
access individuals and their genotypes
\end_layout

\begin_layout Itemize
manipulate subpopulations
\end_layout

\begin_layout Itemize
access ancestral generations
\end_layout

\begin_layout Itemize
manipulate genotype
\end_layout

\begin_layout Itemize
sample (subset) from the population
\end_layout

\begin_layout Itemize
access population variables
\end_layout

\begin_layout Itemize
save/load populations in various formats
\end_layout

\begin_layout Itemize
control virtual subpopulation structure.
\end_layout

\begin_layout Standard
You usually do not need to use these functions explicitly unless you need
 to write pure python functions/operators that involves complicated manipulation
 of populations, or when you need to manipulate populations directly for
 gene mapping, import/export purposes.
\end_layout

\begin_layout Standard

\family typewriter
population
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population
\end_layout

\end_inset


\family default
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals
 having the same genotypic structure.
 Class 
\family typewriter
population
\family default
 has a large number of member functions, ranging from reviewing simple propertie
s to generating a new population from the current one.
 Fortunately, you do not have to know all the member functions to use a
 population unless you need to write pure Python functions/operators that
 involves complicated manipulation of populations.
\end_layout

\begin_layout Standard
simuPOP supports subpopulations with boundary, and virtual subpopulations
 within subpopulations.
 Mating is within subpopulations only.
 Exchanges of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
 More specifically,
\end_layout

\begin_layout Itemize
migration can change subpopulation size; create or remove subpopulations.
 Since migration can not generate new individuals, the total population
 size will not be changed.
\end_layout

\begin_layout Itemize
mating can fill any population/subpopulation structure with offspring.
 Both population and subpopulation sizes can be changed.
 Since mating is within subpopulations, you can not create a new subpopulation
 through mating.
\end_layout

\begin_layout Itemize
a special operator 
\family typewriter
pySubset
\family default
 can shrink the population size.
 It removes individuals according to their 
\family typewriter
subPopID()
\family default
 status.
 (Will explain later.) This can be used to model a sudden population decrease
 due to some natural disaster.
 
\end_layout

\begin_layout Itemize
subpopulations can be split or merged.
\end_layout

\begin_layout Standard
Note that migration will most likely change the subpopulation sizes.
 To keep the subpopulation sizes constant, you can set the subpopulation
 sizes during mating so that the next generation will have desired subpopulation
 sizes.
\end_layout

\begin_layout Subsection
Virtual subpopulations
\end_layout

\begin_layout Standard
simuPOP 0.8.2 introduces the concept 
\emph on
virtual subpopulations
\emph default
.
 Virtual subpopulations are groups of individuals in a subpoulation, defined
 by certain criteria.
 For example, all male individuals, all unaffected individuals, all individuals
 with information field age > 20, all individuals with genotype 0, 0 at
 a given locus, can form virtual subpopulations.
 Virtual subpopulations do not have to add up to the whole subpopulation,
 nor do they have to be distinct.
 Because properties of individuals are variable, virtual subpopulations
 do not have fixed sizes as subpopulations do.
\end_layout

\begin_layout Standard
Virtual subpopulations allow easy handling of heterogeneous populations,
 and can facilitate some computations that are previously very difficult
 to do.
 For example, mating schemes can work on virtual subpopulations.
 This allows complicated mating schemes such as mating in aged population,
 and mixed mating schems.
 By limiting operators to virtual subpopulations, one can apply different
 genetic forces to different groups of individuals.
 A good example is to migrant only male from a subpopulation to other subpopulat
ions.
 It is also easy to calculate statistics at a finer scale, such as allele
 frequency of all males.
\end_layout

\begin_layout Standard
Virtual subpopulations are defined by virtual splitters.
 A splitter splits a subpopulation into pre-determined number of virtual
 subpopulations.
 It also assign a name, such as 
\family typewriter
age=5
\family default
 to each virtual subpopulation.
 For example
\end_layout

\begin_layout Itemize
A 
\family typewriter
sexSplitter
\family default
 splits the population into male and female virtual subpopulations.
 A 
\family typewriter
affectionSplitter
\family default
 splits the population into unaffected and affected virtual subpopulations.
\end_layout

\begin_layout Itemize
A 
\family typewriter
infoSplitter
\family default
 splits the population according to values of a given information field.
 It can split the population by given values, or by some cut-off values.
\end_layout

\begin_layout Itemize
A 
\family typewriter
proportionSplitter
\family default
 splits the population with given proportions, and a 
\family typewriter
rangeSplitters 
\family default
choose individuals from given ranges.
\end_layout

\begin_layout Itemize
A 
\family typewriter
genotypeSplitter 
\family default
splits the population with genotype values at given loci.
 Multiple genetypes are allowed for a virtual subpopulation.
 For example, 
\family typewriter
genotypeSplitter(1, [0, 0, 0, 1])
\family default
 defines a virtual subpopulation with individuals having genotype 
\family typewriter
0, 0
\family default
 or 
\family typewriter
0, 1
\family default
 at locus 
\family typewriter
1
\family default
.
\end_layout

\begin_layout Itemize
A 
\family typewriter
combinedSplitter
\family default
 allows the specification of multiple splitter at the same subpopulation.
 For example, the unaffected and affected virtual subpopulation of a subpopulati
on split by 
\family typewriter
combinedSplitter([sexSplitter(), affectionSplitter()])
\family default
 are 2 and 3, respectively.
 
\end_layout

\begin_layout Standard
There is currently no easy way to get the intersection or superset of two
 virtual subpopulations, such as a virtual subpopulation with male and/or
 affected individuals.
 It is possible, though, to define an information field that reflect these
 logics and define a virtual subpopulation according to this information
 field.
\end_layout

\begin_layout Standard
The population class provies several functions to assign a splitter to a
 given population, retrieve virtual subpopulation sizes and names.
 Note that one splitter is used for all subpopulations.
 If different splitters are needed for different subpopulations, a combined
 splitter can be used.
 More interestingly, the 
\family typewriter
individuals(subPop, virtualSubPop) 
\family default
member function allows you to iterate through all individuals of a virtual
 subpopulation.
 
\end_layout

\begin_layout Standard
Member functions 
\family typewriter
pop.numVirtualSubPop(sp), pop.virtualSubPopSize(sp, vsp)
\family default
 can be used to determine the number of virtual subpopulation a subpopulation
 has, and the size of the virtual subpoulation.
 Operator 
\family typewriter
stat(popSize=True)
\family default
 also calculates virtual subpoulation sizes, and save them in a variable
 
\family typewriter
virtualPopSize
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSubPop"

\end_inset

 demonstrates how to assign virtual splitter, and how to use them.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSubPop.log"
lstparams "caption={Virtual subpopulation related functions},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Individuals"

\end_inset

Access individuals from a population object
\end_layout

\begin_layout Standard
Individuals can not be created without population.
 You can create a population and access its individuals through the 
\family typewriter
individual
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!individual
\end_layout

\end_inset

(), individuals()
\family default
 functions.
 The returned 
\family typewriter
individual
\family default
 object has its own member functions, with which you can 
\end_layout

\begin_layout Itemize
access genotype structure
\end_layout

\begin_layout Itemize
retrieve/set genotype
\end_layout

\begin_layout Itemize
retrieve/set sex, affected status and some other auxiliary information (informat
ion fields)
\end_layout

\begin_layout Standard
Individuals of a population can be accessed through 
\family typewriter
individual
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!individual
\end_layout

\end_inset

()
\family default
, or its iteration form 
\family typewriter
individuals()
\family default
 function:
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind)
\family default
 returns the 
\family typewriter
ind
\family default
'th individual (absolute index) of the whole population.
\end_layout

\begin_layout Itemize

\family typewriter
individual(ind, subPop)
\family default
 returns the 
\family typewriter
ind
\family default
'th (relative index) individual in the 
\family typewriter
subPop
\family default
'th subpopulation.
\end_layout

\begin_layout Itemize

\family typewriter
individuals()
\family default
return an iterator that can be used to iterate through all individuals in
 a population.
\end_layout

\begin_layout Itemize

\family typewriter
individuals(subPop)
\family default
 return an iterator that can be used to iterate through all individuals
 in the 
\family typewriter
subPop
\family default
'th subpopulations.
\end_layout

\begin_layout Itemize

\family typewriter
ancestor(ind, gen)
\family default
 returns the 
\family typewriter
ind
\family default
'th individual (absolute index) of the gen'th ancestral generation.
\end_layout

\begin_layout Itemize

\family typewriter
ancestor(ind, subPop, gen)
\family default
 returns the
\family typewriter
 ind
\family default
'th (relative index) individual in the
\family typewriter
 subPop
\family default
'th subpopulation.
\end_layout

\begin_layout Standard
For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:population-individual"

\end_inset

 iterates through all individuals in subpopulaiton 2 using 
\family typewriter
population::individual() 
\family default
function, while 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:population-individuals"

\end_inset

 uses 
\family typewriter
population::individuals()
\family default
.
 The latter is usually easier to use.
\end_layout

\begin_layout Standard
You can also access individuals from the ancestral generations directly.
 There is no batch access functions such as 
\family typewriter
individuals()
\family default
.
 If they are needed, use 
\family typewriter
useAncestralPop()
\family default
 to switch to that ancestral generation and run
\family typewriter
 individuals()
\family default
 for the current generation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:population-individual"

\end_inset

Function population::individual()
\end_layout

\end_inset

for i in range(pop.subPopSize(2)):
\end_layout

\begin_layout Plain Layout

    ind = pop.individual(i, 2)
\end_layout

\begin_layout Plain Layout

    print ind.affected()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:population-individuals"

\end_inset

Function population::individuals()
\end_layout

\end_inset

for ind in pop.individuals(2):
\end_layout

\begin_layout Plain Layout

    # do something to ind
\end_layout

\begin_layout Plain Layout

    print ind.affected()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Access individual and population genotypes
\end_layout

\begin_layout Standard
simuPOP provies several functions to read/write individual genotype.
 It is important to understand how simuPOP store these genotypes before
 you use these functions.
 Regardless of internal implementation, you can consider the genotype of
 an individual as an array of alleles, ordered by marker, chromosome and
 ploidy.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:genotype-layout"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:genotype-layout"

\end_inset

Memory layout of individual genotype
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename genotype.pdf
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is worth noting that, instead of copying genotypes of an individual to
 a Python tuple or list, the return value of function 
\family typewriter
genotype([p, [ch]])
\family default
 is a special python carray object that reflects the underlying genotypes.
 Modifying elements of this array will change the genotype of an individual
 directly.
 This is demonstrated in the following example.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genotype.log"
lstparams "caption={Virtual subpopulation related functions},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Standard
The return value of two simuPOP functions, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

individual::genotype([p, [ch]])
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

population::genotype([sp])
\end_layout

\end_inset

 is of a special Python type 
\family typewriter
carray
\family default
.
 This object reflects the underlying C/C++ array which can be modified through
 this list-like interface, with the exception that you can not change the
 size of the array.
 Only 
\family typewriter
count
\family default
 and
\family typewriter
 index
\family default
 list functions can be used, but all comparison, assignment and slice operations
 are allowed.
 If you would like to copy the content of this 
\family typewriter
carray
\family default
 to a Python list, use the 
\family typewriter
list()
\family default
 function.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Populations are associated with python variables.
 These variables are usually set by various operators.
 For example, 
\family typewriter
stat
\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!stat
\end_layout

\end_inset


\family default
 operator calculates many population statistics and store results in population
 namespace.
 However, you can also make use of this mechanism to pass parameters, store
 variables etc.
 
\end_layout

\begin_layout Standard
The interface functions are 
\family typewriter
population::vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!vars
\end_layout

\end_inset

()
\family default
 and 
\family typewriter
population::
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!population
\end_layout

\end_inset

dvars()
\family default
 function.
 They are identical except that 
\family typewriter
vars()
\family default
 returns a python dictionary and 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is the same as 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 To have a look at all associated variables of a population, you can print
 
\family typewriter
pop.vars()
\family default
, or better pass 
\family typewriter
pop.vars()
\family default
 to a function 
\family typewriter
ListVars()
\family default
.
 A nice GUI will be used if wxPython is installed.
\end_layout

\begin_layout Standard
It is important to know that this dictionary forms a local namespace in
 which expressions can be evaluated.
 As we can see from example 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:A-simple-example"

\end_inset

, the same expression 
\family typewriter
``'%f ' % LD[0][1]''
\family default
 can be evaluated in each population's local namespace and yield different
 results.
\end_layout

\begin_layout Standard
Populations are associated with Python variables.
 These variables are usually set by various operators but you can also set
 them manually.
 For example, 
\family typewriter
stat
\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!stat
\end_layout

\end_inset


\family default
 operator calculates many population statistics and store the results in
 a population's local namespace.
\end_layout

\begin_layout Standard
Conceptually, population variables are organized as follows (looking from
 a simulator's point of view):
\end_layout

\begin_layout LyX-Code
simu.vars(0)        simu.vars(1) ...
     // replicate
\end_layout

\begin_layout LyX-Code
  popSize             popSize            // local namespace
\end_layout

\begin_layout LyX-Code
  alleleFreq[0]       alleleFreq[0]      // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
  alleleFreq[1]       alleleFreq[1]      // at locus 2
\end_layout

\begin_layout LyX-Code
  ...
                 ....
\end_layout

\begin_layout LyX-Code
  subPop[0]           subPop[0]          // subpop namespace
\end_layout

\begin_layout LyX-Code
    popSize             popSize          // subpopulation 1 size
\end_layout

\begin_layout LyX-Code
    allaleFreq[0]       allaleFreq[0]    // allele frequency at locus 1
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout LyX-Code
  subPop[1]           subPop[1]          // variables for subpop 2
\end_layout

\begin_layout LyX-Code
    ...
                 ...
\end_layout

\begin_layout Standard
You can refer to these variables using 
\family typewriter
population::vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!vars
\end_layout

\end_inset

()
\family default
 or 
\family typewriter
population::
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!population
\end_layout

\end_inset

dvars()
\family default
 function.
 The returned values of 
\family typewriter
vars()
\family default
 and 
\family typewriter
dvars()
\family default
 reflect the same dictionary, but 
\family typewriter
dvars()
\family default
 uses a little Python magic so that you can use attribute syntax to access
 dictionary keys.
 Because 
\family typewriter
a.allaleFreq[0]
\family default
 is easier to read than 
\family typewriter
a['alleleFreq'][0]
\family default
, 
\family typewriter
dvars()
\family default
 is more frequently used.
 
\end_layout

\begin_layout Standard
There are several ways to use these two functions
\end_layout

\begin_layout Itemize

\family typewriter
pop.vars(), pop.dvars()
\family default
 return the variables of population 
\family typewriter
pop
\end_layout

\begin_layout Itemize

\family typewriter
pop.vars(subPop), pop.dvars(subPop) 
\family default
returns dictionary 
\family typewriter
pop.vars()['subPop'][subPop]
\end_layout

\begin_layout Itemize

\family typewriter
simu.vars(rep), simu.dvars(rep) 
\family default
return the variables of the 
\family typewriter
rep
\family default
'th population of simulator 
\family typewriter
simu
\family default
 , i.e.
 
\family typewriter
simu.population(rep).vars().
\end_layout

\begin_layout Itemize

\family typewriter
simu.vars(rep, subPop), simu.dvars(rep, subPop) 
\family default
returns dictionary 
\family typewriter
simu.vars(rep)['subPop'][subPop]
\end_layout

\begin_layout Standard
Direct access to variables 
\family typewriter
pop.vars()['subPop'][subPop]
\family default
 is provided because statistics calculator 
\family typewriter
stat
\family default
, by default, calculates the same set of statistics for all subpopulations
 (and the whole population).
\end_layout

\begin_layout Standard
To have a look at all variables defined in this dictionary, you can use
 function 
\family typewriter
ListVars
\family default
 defined in 
\family typewriter
simuUtil.py
\family default
.
 With wxPython installed, this function opens a nice window with a tree
 representing the variables.
 Without wxPython (or use parameter 
\family typewriter
useWxPython=False
\family default
), variables are displayed in an indented form.
 Several parameters can be used to limit your display.
 They are
\end_layout

\begin_layout Itemize

\family typewriter
level
\family default
: the level of the tree, further nested variables will not be displayed
\end_layout

\begin_layout Itemize

\family typewriter
name
\family default
: the name of the variable to display
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: whether or not display variables for each subpopulation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popVars.log"
lstparams "caption={Population variables},label={popVars}"

\end_inset


\end_layout

\begin_layout Standard
Population variables is a Python dictionary, and furthermore a 
\emph on
Local namespace
\emph default
, which means that you can use dictionary items as variables during evaluation.
 To evaluate in a population's local namespace, you can use function 
\family typewriter
population::evalulate() 
\family default
or 
\family typewriter
population::execute()
\family default
.
 For example: 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/localNamespace.log"
lstparams "caption={Local namespaces of populations},label={localNamespace}"

\end_inset


\end_layout

\begin_layout Standard
These two functions are rarely used, because 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.evaluate('alleleNum[0][1] + 1')
\end_layout

\end_inset

is equivalent to 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.dvar().alleleNum[0][1] + 1
\end_layout

\end_inset

Operators 
\family typewriter
pyEval/pyExec
\family default
 are more useful in that they can be applied to different populations during
 evolution, and report statistics calculated by operator 
\family typewriter
stat
\family default
 dynamically.
 The difference between these two operators are that 
\family typewriter
pyEval 
\family default
evaluates a Python expression and returns its value, while
\family typewriter
 pyExec
\family default
 executes a list of statements in the form of a multi-line string, and does
 not return any value.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyEval.log"
lstparams "caption={Use of operators \\texttt{pyEval} and \\texttt{pyExec}},label={expreval}"

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sec:Information-fields"

\end_inset


\end_layout

\begin_layout Standard
An individuals have genotype, sex and affection status information, but
 other information may be needed.
 For example, one or more trait values may be needed to calculate quantitative
 traits, and one may want to keep track of all offspring of a parent.
 Because the need for information fields varies from simulation to simulation,
 simuPOP does not fix the amount of information fields, and allow users
 to specify these fields during the construction of populations, or add
 them when you need them.
\end_layout

\begin_layout Standard
Operators may require certain information fields to work properly.
 For example, all selectors require field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 
\family typewriter
parentTagger
\family default
 needs 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 to store indices of the parents of each individual in the parental generation.
 These information fields can be added by the 
\family typewriter
infoFields
\family default
 parameter of the population constructor or be added later using relevant
 function.
 If a required information field is unavailable, an error message will appear
 and tell you which field is needed.
 Some operators allow you to specify which information field(s) to use.
 For example, quantitative trait operator can work on specified fields so
 an individual can have several quantitative traits.
\end_layout

\begin_layout Standard
The information fields is usually set during population creation, using
 the 
\family typewriter
infoFields
\family default
 option of population constructor.
 It can also be set or added by functions
\end_layout

\begin_layout Itemize

\family typewriter
pop.setInfoFields(fields, init) 
\family default
set information fields of a population, removing all previous ones
\end_layout

\begin_layout Itemize

\family typewriter
pop.addInfoField(field, init) 
\family default
add an information field to a population
\end_layout

\begin_layout Itemize

\family typewriter
pop.addInfoFields(fields, init)
\family default
 add information fields to a population
\end_layout

\begin_layout Itemize

\family typewriter
simu.addInfoField(field, init)
\family default
 add an information field to all populations in a simulator
\end_layout

\begin_layout Itemize

\family typewriter
simu.addInfoFields(fields, init) 
\family default
add information fields to all populations in a simulator
\end_layout

\begin_layout Standard
When adding information fields to a simulator, information fields are added
 to all populations of the simulator.
 Note that it is illegal to add information field (or in a broader sense
 changing genotypic structure) to part of the populations of a simulator,
 because all populations in a simulator should have the same genotypic structure.
\end_layout

\begin_layout Standard
One can read/write information fields at individual level:
\end_layout

\begin_layout Itemize

\family typewriter
ind.info(idx), ind.info(name)
\family default
 return individual information field by index or name
\end_layout

\begin_layout Itemize

\family typewriter
ind.setInfo(value, idx), ind.setInfo(value, name)
\family default
 set individual information field by index or name
\end_layout

\begin_layout Itemize

\family typewriter
ind.arrInfo() 
\family default
returns a carray of all information fields of an individual
\end_layout

\begin_layout Standard
or at the population level
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx), pop.indInfo(name)
\family default
 return an information field (referred by index or name) of all individuals
\end_layout

\begin_layout Itemize

\family typewriter
pop.indInfo(idx, subPop), pop.indInfo(name, subPop)
\family default
 return an information field (referred by index or name) of all individuals
 in a subpopulation 
\family typewriter
subPop
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
pop.setIndInfo(values, idx), pop.setInfIndo(values, name)
\family default
 set information fields of all individuals with values in an array.
\end_layout

\begin_layout Standard
Both 
\family typewriter
idx
\family default
 or 
\family typewriter
name
\family default
 can be used in these functions.
 
\family typewriter
name
\family default
 is easier to use but 
\family typewriter
idx
\family default
, which can be obtained by
\family typewriter
 idx=pop.infoIdx(name),
\family default
 is faster.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/info1.log"
lstparams "caption={Use regular information field function},label={regu-info}"

\end_inset


\end_layout

\begin_layout Standard
Information fields can also be used to track individual information fields
 during evolution, using Python operators or operators 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
.
 The latter two operators can evaluate Python expressions and statements
 with varaibles being the information fields of individuals.
 Changes to these variables will change the corresponding information fields
 of an individul.
 For example, assuming that population 
\family typewriter
pop
\family default
 has information field 
\family typewriter
a
\family default
, the following function (function form of operator 
\family typewriter
infoExec
\family default
) will increase the information field 
\family typewriter
a 
\family default
of every individual in the population by 1.
\end_layout

\begin_layout LyX-Code
InfoExec(pop, 'a += 1')
\end_layout

\begin_layout Standard
These statements are usually used to change the values of an information
 field, or derive an information field from other ones.
 However, variables from a poulation's local namespace can be made available,
 using option 
\family typewriter
usePopVars=True
\family default
.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/info2.log"
lstparams "caption={Use infoExec and infoEval operators},label={infoExec}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
By default, a population object only holds the current generation.
 All ancestral populations (generations) will be discarded.
 You can, however, keep as many ancestral generations as you wish, provided
 that you have enough RAM to store all these extra information.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
ancestralDepth
\family default
 is used to specify the number of generations to keep.
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number 
\family typewriter
n
\family default
 to store most recent n generations; or -
\family typewriter
1
\family default
 to store all populations.
 
\end_layout

\begin_layout Standard
Several important usage of ancestral generations:
\end_layout

\begin_layout Itemize

\family typewriter
dumper()
\family default
 operator and 
\family typewriter
Dump()
\family default
 function has a parameter 
\family typewriter
ancestralPops
\family default
.
 If set to 
\family typewriter
True
\family default
, they will dump all ancestral generations.
\end_layout

\begin_layout Itemize
function 
\family typewriter
population::setAncestralDepth()
\family default
 and operator 
\family typewriter
setAncestralDepth()
\family default
 set the number of ancestral generations to keep for a population.
 A typical use of 
\family typewriter
setAncestralDepth()
\family default
 is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simu.evolve(...
\end_layout

\begin_layout Plain Layout

  setAncestralDepth(3, at=[-3])
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which saves the last three generations in populations so that pedigree based
 sampling schemes can be used.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
pop.useAncestralPop(idx)
\family default
 set the current generation of population 
\family typewriter
pop
\family default
 to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the first ancestral generation, 
\family typewriter
2
\family default
 for second ancestral ..., and 
\family typewriter
0
\family default
 for the current generation.
 After this function, all functions, operators will be applied to this ancestral
 generation.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral generations.
 
\end_layout

\begin_layout Standard
A typical use of this function is demonstrated in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ancestralPop"

\end_inset

.
 In this example, a population with two loci is created and with initial
 genotype 0.
 Two 
\family typewriter
kamMutator
\family default
 with different mutation rates are applied to these two loci.
 Five most recent populations are kept.
 The allele frequencies at these generations are calculated afterward.
 (Note that this is not the best way to exam the changes of allele frequencies,
 a 
\family typewriter
stat
\family default
 operator should be used.)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ancestralPop.log"
lstparams "caption={Ancestral populations},label={ancestralPop}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and Load a Population
\end_layout

\begin_layout Standard
Internally, population can be saved to or loaded from disk files using 
\family typewriter
savePopulation
\begin_inset Index
status collapsed

\begin_layout Plain Layout
savePopulation
\end_layout

\end_inset

(file)
\family default
 member function, global 
\family typewriter
SavePopulation
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Function!SavePopulation
\end_layout

\end_inset

(pop, file)
\family default
 and 
\family typewriter
LoadPopulation
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
function!LoadPopulation
\end_layout

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 because 
\family typewriter
savePopulation
\family default
 is a member function and 
\family typewriter
LoadPopulation
\family default
 is a global function.).
 Although files in any extension can be saved/loaded correctly, extension
 
\family typewriter
.pop
\family default
 is usually used.
 Populations are compressed in gzip format to save some disk space.
\end_layout

\begin_layout Standard
Populations can also be saved in other formats such as FSTAT so that they
 can be directly analyzed by other programs.
 These formats are not supported internally.
 They are handled in Python in the form of Python function or pure-Python
 operator.
 If you would like to save/load simuPOP population in your own format, you
 can do it by mimicking these functions in 
\family typewriter
simuUtil.py
\family default
.
 
\end_layout

\begin_layout Standard
Shared variables (c.f section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Population-Variables"

\end_inset

) are also saved (except for big objects like samples).
 Since the number of shared variables can be very large, it maybe a good
 idea to clear these variables before you save a population.
 On the other hand, you may want to save key parameters used to generate
 this population in the local namespace so that you will know these parameters
 after the population is loaded.
 For example, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Save population variables
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

pop.vars().clear()
\end_layout

\begin_layout Plain Layout

pop.dvars().migrationRate = 0.002
\end_layout

\begin_layout Plain Layout

pop.dvars().diseaseLoci = [4, 30]
\end_layout

\begin_layout Plain Layout

SavePopulation(pop, 'example.pop')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
View a population (GUI, wxPython required)
\end_layout

\begin_layout Standard
Introduced in version 0.6.9, 
\family typewriter
simuViewPop.py
\family default
 can be used to view a population.
 It can be used as a standalone application, or in an interactive session.
 First, you can use this script as a standalone application, simply run
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuViewPop.py mypop.bin
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will fire a GUI and allow you to exam population property, genotype and
 calculate statistics.
 
\end_layout

\begin_layout Standard
In a Python session, import this module will provide a function 
\family typewriter
viewPop
\family default
, apply it on a in-memory population or a filename will have the same effect.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Use simuViewPop to view a population
\end_layout

\end_inset

import simuViewPop
\end_layout

\begin_layout Plain Layout

simuViewPop.viewPop(myPop)
\end_layout

\begin_layout Plain Layout

simuViewPop.viewPop(filename='mypop.bin')
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout Section
Mating Scheme
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mating schemes specify how to generate offspring from the current population.
 It must be provided when a simulator is created.
 Mating can perform the following tasks:
\end_layout

\begin_layout Itemize
Choose parent(s) to generate offspring to populate the next generation.
 The number of offspring per mating event can be a fixed number (default
 to 1), or a random number following one of geometric, Poisson or binomial
 distribution.
 Customized (hybrid) parent choosers can be used.
 Offspring sex can be assigned randomly, with specified or default (0.5)
 probability, or arranged to have certain number of males/females per mating
 event.
\end_layout

\begin_layout Itemize
Change population/subpopulation sizes.
 This is where demographic models are handled in simuPOP.
 There are a few methods to control population sizes.
 The most flexible one is through a user-provided function that returns
 population (subpopulation) sizes at each generation.
\end_layout

\begin_layout Itemize
During-mating operators are applied to all offspring.
 The most commonly used during mating operator is a recombinator that can
 recombine parental chromosomes and form offspring genotype.
\end_layout

\begin_layout Itemize
Apply selection if applicable.
 If individual fitness are given (usually returned by a selector operator),
 a mating scheme will choose an individual to mate, according to its relative
 fitness.
\end_layout

\begin_layout Standard
A few mating schemes are available, among which 
\family typewriter
randomMating()
\family default
 is the most important.
 Non-random mating can be achieved using 
\family typewriter
pyMating
\family default
 and 
\family typewriter
heteroMating
\family default
, which is explained in detailed in 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Subsection
Determine the number of offspring during mating
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
numOffspring, maxNumOffspring, numOffspringFunc 
\family default
and 
\family typewriter
mode
\family default
 are provided for each mating scheme (each offspring generator, to be exact)
 to determine the number of offspring produced at each mating event.
\end_layout

\begin_layout Standard
The default value of 
\family typewriter
numOffspring
\family default
 parameter makes a mating scheme produces one offspring per mating event.
 This is required by random mating schemes and should be used whenever possible.
 However, various situations require a larger family size or even changing
 family sizes.
 simuPOP provides a comprehensive way to deal with this problem.
\end_layout

\begin_layout Standard
As described in the class reference, the method to determine the number
 of offspring is to set the 
\family typewriter
mode
\family default
 parameter:
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffspring:
\family default
 Produce 
\family typewriter
numOffspring
\family default
 offspring all the time.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_PyNumOffspring:
\family default
 When 
\family typewriter
numOffspringFunc
\family default
 is defined, this mode is automatically used.
 A user provided function is called whenever a mating event happens.
 The return value determins the number of offpspring to use.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_GeometricDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a geometric distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_PoissonDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a Poission distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{p^{k-1}}{\left(k-1\right)!}e^{-p}\;\textrm{ for}k\geq1\]

\end_inset

Since the mean of this shifted Poisson distribution is 
\begin_inset Formula $p+1$
\end_inset

, you need to specify, for example, 2, if you want a mean family size 3.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_BinomialDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a Binomial distribution.
 Let 
\begin_inset Formula $N$
\end_inset

=
\family typewriter
maxNumOffspring
\family default
, the number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}\;\textrm{ for }N\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_UniformDistribution:
\family default
 
\family typewriter
numOffspring
\family default
 is be considered as 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 for a Uniform distribution, respectively.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{1}{b-a}\;\textrm{ for }b\geq k\geq a\]

\end_inset


\end_layout

\begin_layout Standard
Note that all these distributions are adjusted to produce at least one offspring.
 
\end_layout

\begin_layout Subsection
Determine offspring sex
\end_layout

\begin_layout Standard
When the last chromosome is a sex chromosome (
\family typewriter
sexChrom=True
\family default
), offspring sex is determined by his/her genotype.
 If an offspring is cloned from his/her parent using a 
\family typewriter
cloneOffspringGenerator()
\family default
, offspring sex is the same as his/her parent.
 Otherwise, offspring is by default assigned to Male and Female with equal
 probability 0.5.
\end_layout

\begin_layout Standard
More advanced sex assignment mode is determined by parameters 
\family typewriter
sexMode 
\family default
and 
\family typewriter
sexParam
\family default
 of a mating scheme or an offspring generator (see later section).
 
\family typewriter
sexMode
\family default
 can be
\end_layout

\begin_layout Itemize

\family typewriter
MATE_RandomSex
\family default
 This is the default mode where offspring can be Male or Female with equal
 probability.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_ProbOfMale
\family default
 In this mode, parameter 
\family typewriter
sexParam
\family default
 is considered as the probability of a Male offspring.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOfMale
\family default
 In this mode, parameter 
\family typewriter
sexParam
\family default
 is the number of male in the family.
 If the number of offspring at a mating event is less than this number,
 all offspring will be male.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOfFemale
\family default
 Similar to 
\family typewriter
MATE_NumOfMale
\family default
 but parameter 
\family typewriter
sexParam
\family default
 is considered as the number of female in the family.
\end_layout

\begin_layout Standard

\family typewriter
MATE_NumOfMale
\family default
 and 
\family typewriter
MATE_NumOfFemale
\family default
 are useful in theoretical studies where the sex ratio of a population needs
 to be controlled strictly, or in special mating schemes, usually for animal
 populations, where only a certain number of male or female individuals
 are allowed in a family.
\end_layout

\begin_layout Subsection
Determine subpopulation sizes of the next generation
\end_layout

\begin_layout Standard
The default behavior of simuPOP is to use the same population/subpopulation
 sizes as those of the parent generation.
 You can change this behavior by setting one of 
\family typewriter
newSubPopSize
\family default
, 
\family typewriter
newSubPopSizeExpr
\family default
, and 
\family typewriter
newSubPopSizeFunc
\family default
 parameters:
\end_layout

\begin_layout Itemize
If you would like to have fixed subpopulation sizes, use 
\family typewriter
newSubPopSize=some_fixed_values
\family default
.
 This is useful when subpopulation sizes are changed by migration and you
 do want to keep constant subpopulation sizes.
\end_layout

\begin_layout Itemize
If subpopulation sizes can be easily calculated through an expression, you
 can use 
\family typewriter
newSubPopSizeExpr
\family default
 to determine the new subpopulation sizes.
 For example, 
\family typewriter
newSubPopSizeExpr='[gen+10]'
\family default
 uses the generation number + 10 as the new population size.
 More complicated expressions can be used, maybe along with 
\family typewriter
pyExec
\family default
 operators, but in these cases, a specialized function and 
\family typewriter
newSubPopSizeFunc
\family default
 are recommended.
\end_layout

\begin_layout Itemize
A more organized (and thus recommended) way to set new population/subpopulation
 sizes is through parameter 
\family typewriter
newSubPopSizeFunc
\family default
.
 To use this parameter, you need to define a Python function that takes
 two parameters: the generation number and the current subpopulation sizes,
 and return an array of new subpopulation sizes (return 
\family typewriter
[newsize]
\family default
 instead of 
\family typewriter
newsize
\family default
 when you do not have any subpopulation structure).
 The example of 
\family typewriter
class Mating 
\family default
demonstrates the use of this parameter.
\end_layout

\begin_layout Subsection
Demographic change functions
\end_layout

\begin_layout Standard

\family typewriter
newSubPopSizeFunc
\family default
 can take a function with parameters 
\family typewriter
gen
\family default
 and 
\family typewriter
oldSize.

\family default
 A few functions are defined in 
\family typewriter
simuUtil.py
\family default
 that will return such a function with given parameters.
 All these functions support a burnin stage and then split to equal sized
 subpopulations.
 For all these functions, you can test them by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

func = oneOfTheDemographicFunc(parameters)
\end_layout

\begin_layout Plain Layout

gen = range(0, yourEndGen)
\end_layout

\begin_layout Plain Layout

r.plot(gen, [func(x)[0] for x in gen])
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
numSubPop
\family default
 is default to 
\family typewriter
1
\family default
.
 
\family typewriter
split
\family default
 is default to 
\family typewriter
0
\family default
 or given 
\family typewriter
burnin
\family default
 value.
 Population size change happens 
\series bold
after
\series default
 burnin (start at 
\family typewriter
burnin+1
\family default
) and split happens at 
\family typewriter
split
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ConstSize(size, split, numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The population size is constant, but will split into 
\family typewriter
numSubPop
\family default
 subpopulations at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LinearExpansion(initSize, endSize, end, burnin, split, numSubPop, 
\end_layout

\begin_layout Plain Layout

    bottleneckGen, bottleneckSize)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Linearly expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ExponentialExpansion(initSize, endSize, end, burnin, split, 
\end_layout

\begin_layout Plain Layout

    numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exponentially expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantExpansion(initSize, endSize, end, burnin, split, 
\end_layout

\begin_layout Plain Layout

    numSubPop, bottleneckGen, bottleneckSize)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instaneously expand the population size from 
\family typewriter
intiSize
\family default
 to 
\family typewriter
endSize
\family default
 after 
\family typewriter
burnin
\family default
, split the population at generation 
\family typewriter
split
\family default
.
 If 
\family typewriter
bottleneckGen
\family default
 is specified, population size will be 
\family typewriter
bottleneckSize
\family default
 at that generation.
\end_layout

\begin_layout Subsection
Parent choosers and offspring generators
\end_layout

\begin_layout Standard
To implement more complex mating schemes, some concepts need to be understood.
 The first one is 
\emph on
parent chooser
\emph default
.
 Parent chooser determines how parent or parents are chosen from a given
 subpopulation.
 There are several predefined parent choosers such as 
\family typewriter
linearParentChooser
\family default
, 
\family typewriter
randomParentChooser, randomParentsChooser
\family default
, and the most powerful one is called 
\family typewriter
pyParentsChooser.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyParensChooser
\family default
 accepts a Python generator function, instead of a normal Python function.
 When this generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when the 
\family typewriter
next()
\family default
 member function of this object is called, this function resumes where it
 was stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 An example of generator is given in simuPOP user's guide.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator_random.log"
lstparams "caption={A generator function that mimicks random mating},label={generator_random}"

\end_inset


\end_layout

\begin_layout Standard
A user defined parents chooser can be very complicated, involving user defined
 information such as geometric locations.
 An example is given in 
\family typewriter
scripts/demoNonRandomMating.py
\family default
.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator_random"

\end_inset

, the parents chooser 
\family typewriter
randomChooser 
\family default
collects indexes of males and females that are over the age of 30 and return
 a pair of random male and female repeatedly.
 That is to say, individuals with age < 30 is not involved in mating.
 Of course, to completely implement age-dependent mating, other factors
 need to be considered.
 For example, a 
\family typewriter
pyTagger
\family default
 is likely to be used to assign age to offspring.
\end_layout

\begin_layout Standard
A parents chooser can yield a pair of parents, or a single parent.
 Obviously, a single diploid parent can not produce offspring using the
 usual Medelian fashion, so here comes another concept: 
\emph on
offspring generator
\emph default
, which determines how to produce offspring from given parent or parents.
 Currently, there are three standard offspring generators.
\end_layout

\begin_layout Standard
These offspring generator defines only the default way to fill offspring
 genotype.
 When a during-mating operator is involved, it may override what an offspring
 generator does.
 For example, a 
\family typewriter
recombinator
\family default
 recombines parental chromosomes to fill offspring genotype.
 In the diploid case, it will behave the same for 
\family typewriter
cloneOffspringGenerator
\family default
 and 
\family typewriter
selfingOffspringGenerator.
\end_layout

\begin_layout Subsection
Homogeneous and hybrid mating schemes
\end_layout

\begin_layout Standard
Parent choosers and offspring generators can be combined to form homogeneous
 mating schemes, which work identically on all (virtual) subpopulations
 it is applied.
 The only limit is that they have to be compatible in that a parent chooser
 that choose one parent can not be used with an offspring generator that
 needs two parents.
 A homogenou mating scheme is illustrated in Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:homogeneous-mating-scheme"

\end_inset

A homogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename HomoMatingScheme.eps
	lyxscale 20
	width 6in

\end_inset


\end_layout

\begin_layout Plain Layout
A homogeneous mating scheme is responsible to choose parent(s) from a subpopulat
ion or a virtual subpopulation, and population part or all of the corresponding
 offspring subpopulation.
 A parent chooser is used to choose one or two parents from the parental
 generation, and pass it to an offspring generator, which produces one or
 more offspring.
 During mating operators such as taggers and recombinator can be applied
 when offspring is generated.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic usage of a 
\family typewriter
pyMating 
\family default
operator is as follows
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyMating(randomParentChooser(),
\end_layout

\begin_layout Plain Layout

    selfingOffspringGenerator(numOffspring=2))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyMating(linearParentChooser(),
\end_layout

\begin_layout Plain Layout

    cloneOffspringGenerator())
\end_layout

\end_inset

The later simply copy everyone from the parental to the offspring genertion.
\end_layout

\begin_layout Subsection
Heterogeneous mating schemes
\end_layout

\begin_layout Standard
Non-random mating can also be introduced by mating individuals from different
 groups differently.
 Different subpopulations, or different virtual subpopulations, can have
 varying fecundity, represented by different numbers of offspring generated
 per mating event.
 For example, it is possible that only adults (may be defined by age > 30
 and age < 50) in a subpopulation can produce offspring, where other individual
 will either be copied to the offspring generation or die.
 It is also quite common in plant genetics that a certain portion of trees
 go through selfing, while others go through random mating.
\end_layout

\begin_layout Standard
A 
\family typewriter
heteroMating
\family default
 mating scheme accepts a list of mating schemes that works separately on
 different subpopulation, or virtual subpopulations.
 In this way, many homogenous mating schemes can be applied to different
 (virtual) subpopulations.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heterogenous-mating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heterogenous-mating"

\end_inset

Illustration of a heteogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename MatingScheme.eps
	lyxscale 30
	width 6in

\end_inset


\end_layout

\begin_layout Plain Layout
A heterogeneous mating scheme that applies homogenous mating schemes MS0,
 MS0.0, MS0.1, MS1, MS2.0 and MS2.1 to subpopulation 0, the first and second
 virtual subpopulation in subpopulation 0, subpopulation 1, the first and
 second virtual subpopulation in subpopulation 2, respectively.
 Note that VSP 0 and 1 in subpopulation 0 overlap, and do not add up to
 subpopulation 0.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating([randomMating(numOffspring=2, subPop=0),
\end_layout

\begin_layout Plain Layout

    randomMating(numOffspring=4, subPop=1)])
\end_layout

\end_inset

define a heterogeneous mating scheme that mating events in subpopulation
 0 produces two offspring, while producing four in subpopulation 1.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.setVirtualSplitter(proportionSplitter([0.2, 0.8]), 0)
\end_layout

\begin_layout Plain Layout

heteroMating([selfMating(numOffspring=2, subPop=0, virtualSubPop=0),
\end_layout

\begin_layout Plain Layout

    randomMating(subPop=0, virtualSubPop=1)],
\end_layout

\begin_layout Plain Layout

    shuffleOffspring=True
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

allows different mating schems in one subpopulation.
 In this example, the first subpopulation is splitted into two virtual subpopula
tions by proportion.
 Then, a selfing mating scheme is applied to the first virtual subpopulation,
 and a random mating scheme is applied to the second.
 In case that there are more than one mating schemes working on the same
 subpopulation, offspring are shuffled randomly by default, unless this
 is turned off by 
\family typewriter
shuffleOffspring=False
\family default
.
 Randomization of the order of offspring is usually desired because otherwise,
 taking this example, the first 20% of individuals will always go through
 selfing, and the rest will always go through random mating.
 When offspring are shuffled, each individual will have probability 0.2 to
 be selfing, and probability 0.8 to mate randomly.
\end_layout

\begin_layout Standard
simuPOP determines if a mating scheme will be applied to a particular subpopulat
ion using the following rules
\end_layout

\begin_layout Itemize
If neither 
\family typewriter
subPop
\family default
, nor 
\family typewriter
virtualSubPop
\family default
 is specified, the mating scheme is applied to all subpoulations (as a whole,
 not any virtual subpopulation).
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
, but not 
\family typewriter
virtualSubPop
\family default
 is specified, the mating scheme is applied to the specified subpopulation
 (as a whole).
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
 and 
\family typewriter
virtualSubPop
\family default
 are both specified, the mating scheme is applied to the specified virtual
 subpopulation.
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
 is not specified, but
\family typewriter
 virtualSubPop
\family default
 is, the mating scheme is applied to spcified virtual subpopulation of all
 subpopulations.
 Note that simuPOP will report an error if a subpopulation does not define
 such a virtual subpopulation.
\end_layout

\begin_layout Standard
If one mating scheme is specified for each parental subpopulation, offspring
 subpopulation sizes are determined as usual, through parameters 
\family typewriter
newSubPopSize, newSubPopSizeFunc
\family default
, etc.
 However, if multiple mating schemes will be applied to the same subpopulation,
 they have to share the same offspring subpopulation.
 This problem is addressed by a weight system.
 That is to say, each mating scheme can be given a weight using parameter
 
\family typewriter
weight
\family default
.
 A weight can be positive, zero (default) or negative.
 The number of offspring each mating scheme will produce is determined by
 these weights.
 
\end_layout

\begin_layout Standard
This weighting scheme is best explained by an example.
 Assuming that there are three mating schemes working on the same parental
 subpopulation
\end_layout

\begin_layout Itemize
Mating scheme A works on the whole subpopulation of size 1000
\end_layout

\begin_layout Itemize
Mating scheme B works on a virtual subpopulation of size 500
\end_layout

\begin_layout Itemize
Mating scheme C works on another virtual subpopulation of size 800
\end_layout

\begin_layout Standard
Assuming the corresponding offspring subpopulation has 
\begin_inset Formula $N$
\end_inset

 individuals, 
\end_layout

\begin_layout Itemize
If all weights are 0, the offspring subpopulation is divided in proportion
 to parental (virtual) subpopulation sizes.
 In this example, the mating schemes will produce 
\begin_inset Formula $\frac{10}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{5}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{8}{23}N$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Itemize
If all weights are negative, they are multiplied to their parental (virtual)
 subpopulation sizes to get a fixed size.
 For example, weight (-1, -2, -0.5) will lead to sizes (1000, 1000, 400)
 in the offspring subpopulation.
 If 
\begin_inset Formula $N\ne2400$
\end_inset

 in this case, an error will be raised.
\end_layout

\begin_layout Itemize
If all weights are positive, the number of offspring produced from each
 mating scheme is proportional to these weights.
 For example, weights (1, 2, 3) will lead to 
\begin_inset Formula $\frac{1}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{2}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{1}{3}N$
\end_inset

 individuals respectively.
 In this case, 0 weights will produce no offspring.
\end_layout

\begin_layout Itemize
If there are mixed positive and negative weights, the negative weights are
 first processed, and the rest of the individuals are divided using positive
 weights.
 For example, three mating schemes with weights (-1, 2, 3) will produce
 1000, 
\begin_inset Formula $\frac{2}{5}\left(N-1000\right)$
\end_inset

, 
\begin_inset Formula $\frac{3}{5}\left(N-1000\right)$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They (there are exceptions) can be applied to populations directly, but
 most of the time they are managed and applied by a simulator.
 There are three kinds of operators:
\end_layout

\begin_layout Itemize

\emph on
built-in:
\emph default
 written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\end_layout

\begin_layout Itemize

\emph on
hybrid
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
hybrid
\end_layout

\end_inset

: written in C++ but calls python function when execution.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter
pyMutator
\family default
 will determine if an allele will be mutated and call a user--defined Python
 function to mutate it.
\end_layout

\begin_layout Itemize

\emph on
pure python
\emph default
: written in python.
 Same speed as python.
 For example, a 
\family typewriter
varPlotter
\begin_inset Index
status collapsed

\begin_layout Plain Layout
varPlotter
\end_layout

\end_inset


\family default
 can plot python variables that are set by other operators.
\end_layout

\begin_layout Standard
You do not have to know the type of an operator to use them.
 The interface of them are all the same.
 Namely, they all accept a standard set of parameters, and are used in the
 same fashion.
 Such parameters include 
\family typewriter
rep, begin, step, end
\family default
 and 
\family typewriter
at
\family default
.
 The first two indicate that the operator only applies to one replicate,
 and the rest control which generation(s) the operator will be applied to.
 There are also parameters that redirect operator output to files.
 For details please refer to the reference manual.
\end_layout

\begin_layout Standard
A simuPOP life cycle (each generation) can be divided into pre-mating, during-ma
ting and post-mating and an operator can be applied to one or more of them.
 For example, a 
\family typewriter
stat
\family default
 operator usually applies post-mating, but if you prefer, you can change
 its 
\family typewriter
stage
\family default
 parameter to 
\family typewriter
preMating
\family default
 and apply it pre-mating.
\end_layout

\begin_layout Subsection
Function form of an operator
\end_layout

\begin_layout Standard
Operators are usually applied to populations through a simulator.
 They are created and passed as parameters to the 
\family typewriter
evolve 
\family default
function of a simulator.
 During evolution, the 
\family typewriter
evolve()
\family default
 function determines if an operator can be applied to a population and apply
 it when appropriate.
 More details about operators will be described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Operators"

\end_inset

.
\end_layout

\begin_layout Standard
You can ignore the specialties of an operator and call its 
\family typewriter
apply()
\family default
 function directly.
 For example, you can initialize a population outside a simulator by 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initByFreq( [.3, .2, .5] ).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or dump the content of a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dumper().apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This usage is used so often that it deserves some simplification.
 Equivalent functions are defined for most of the operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitByFreq.log"
lstparams "caption={Function \\texttt{InitByFreq}},label={InitByFreq}"

\end_inset


\end_layout

\begin_layout Standard
The function form of an operator is listed after its class name in this
 reference manual.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
Simulators combine three important components of simuPOP: population, mating
 scheme and operators together.
 A simulator is usually created with an instance of population, a replicate
 number and a mating scheme.
 It makes '
\family typewriter
rep
\family default
' replicates of this population and control the evolution process of these
 populations.
\end_layout

\begin_layout Standard
The most important function of a simulator is 
\family typewriter
evolve()
\family default
.
 It accepts arrays of operators as its parameters, among which, '
\family typewriter
preOps
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulato!preOps
\end_layout

\end_inset

' and '
\family typewriter
postOps
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulator!postOps
\end_layout

\end_inset

' will be applied to the populations at the beginning and end of evolution,
 respectively, whereas '
\family typewriter
ops
\family default
' will be applied at every generation.
 Of course, a simulator will probe and respect each operator's 
\family typewriter
rep, begin, end, step, at, stage
\family default
 properties and act accordingly.
 
\end_layout

\begin_layout Subsection
Generation number
\end_layout

\begin_layout Standard
Several aspects of the generation number may cause confusion:
\end_layout

\begin_layout Itemize
generation starts from zero
\end_layout

\begin_layout Itemize
a generation number presents a 'to-be-evolved' generation
\end_layout

\begin_layout Itemize
the ending generation specified in 
\family typewriter
evolve()
\family default
 will be executed
\end_layout

\begin_layout Standard
That is to say, a new simulator will have generation 0 (at the beginning
 of generation 0).
 If you do 
\family typewriter
evolve(..., end=0), evolve
\family default
 will evolve one generation and stop at the beginning of generation 1.
\end_layout

\begin_layout Standard
It may sound strange that 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

evolve(end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
evolve the population 3 generations.
 Generation 0, generation 1, and generation 2.
 When you use 
\family typewriter
start=0, step=5, end=10
\family default
 for your operator, it will be applied at generations 
\family typewriter
0,5,10
\family default
 etc.
 At the end of the simulation, current generation number is 3! (If you are
 familiar with C, this is like a 
\family typewriter
for
\family default
 loop index).
 This is why you should test if a simulation is finished correctly by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(simu.gen() == endGen+1)
\end_layout

\end_inset

instead of 
\family typewriter
simu.gen() == endGen.

\family default
 (endGen is the value for parameter 
\family typewriter
end
\family default
).
\end_layout

\begin_layout Subsection
Operator calling sequence
\end_layout

\begin_layout Standard
In a simulation, operators are applied at different stages, pre-, during-,
 and post-mating (controlled by 
\family typewriter
stage
\family default
 parameter), at specified generations (controlled by 
\family typewriter
begin, end, step, at
\family default
 parameters), and to specified replicates (controlled by 
\family typewriter
rep
\family default
 parameter).
 The order of applying operators usually does not matter but errors may
 occur if you are not careful.
 For example, 
\family typewriter
stat(...)
\family default
 calculates the statistics of the current population.
 It is a pre-mating operator so you should set 
\family typewriter
stage=PostMating
\family default
 and put it after all operators if you would like to measure a post-mating
 population.
 It also should be put before any operator (such as an terminator) that
 uses the shared variable set by 
\family typewriter
stat(...).
\end_layout

\begin_layout Standard
If you are not sure about the calling sequence of operators, you can set
 the 
\family typewriter
dryrun
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulator!dryun
\end_layout

\end_inset

 parameter of 
\family typewriter
evolve()
\family default
 function to 
\family typewriter
True
\family default
.
 
\family typewriter
evolve
\family default
 will then print out the order of operators to apply.
 Consider that operators can be 
\family typewriter
PreMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PreMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PreMating
\end_layout

\end_inset

, PostMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PostMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PostMating
\end_layout

\end_inset

, PrePostMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PrePostMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PrePostMating
\end_layout

\end_inset

, DuringMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!DuringMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!DuringMating
\end_layout

\end_inset


\family default
 and the default value (parameter 
\family typewriter
stage
\family default
) may not be what you expect.
 Having a look at the calling sequence before the real evolution is always
 a good idea.
\end_layout

\begin_layout Subsection
Save and Load
\end_layout

\begin_layout Standard
Using function 
\family typewriter
saveSimulator
\family default
, we can save a simulator to a file.
 Although files with any extension can be correctly saved/loaded, extension
 
\family typewriter
.sim
\family default
 is usually used.
 Note that a mating scheme can not be saved and has to be re-specified in
 
\family typewriter
LoadSimulator
\begin_inset Index
status collapsed

\begin_layout Plain Layout
loadSimulator
\end_layout

\end_inset

()
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simulatorsaveload.log"
lstparams "caption={Save and load a simulator},label={simulatorsaveload}"

\end_inset


\end_layout

\begin_layout Section
Utilities
\end_layout

\begin_layout Chapter
Selected topics
\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 80 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), gene conversion
 (new in v 0.8.5), quantitative trait, selection, penetrance (single or multi-locu
s, hybrid), ascertainment (case-control, affected sibpairs, random), statistics
 calculation (allele, genotype, haplotype, heterozygote number and frequency;
 expected heterozygosity; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules), load/save
 in text, XML, Fstat or Linkage format.
 In this chapter, I will discuss some practical usages of simuPOP.
\end_layout

\begin_layout Section
Selection
\end_layout

\begin_layout Standard
It is not very clear that our method agrees with the traditional 'average
 number of offspring' definition of fitness.
 (Note that this concept is very difficult to simulate because we do not
 know who will determine the number of offspring if two parents are involved.)
 We can, instead, look at the consequence of selection in a simple case
 (as derived in any population genetics textbook):
\end_layout

\begin_layout Quote
At generation 
\begin_inset Formula $t$
\end_inset

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset

 etc., should be
\end_layout

\begin_layout Quote
\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset


\end_layout

\begin_layout Standard
Now, using the 'ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset

 will be the number of 
\begin_inset Formula $11$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset

The same argument applies to the case of arbitrary number of genotypes and
 random mating.
 
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
Selector only set information field and mark subpopulations as selection
 ready.
 However, how these information are used to select parents can vary from
 mating scheme to mating scheme.
 As a matter of fact, some mating schemes do not support selection at all.
\end_layout

\begin_layout Itemize
selector has to be 
\family typewriter
PreMating
\family default
 operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter
PreMating
\family default
.
 However, if you use the function form of these selectors in a 
\family typewriter
pyOperator
\family default
, make sure to set the stage of 
\family typewriter
pyOperator
\family default
 to 
\family typewriter
PreMating
\family default
.
 
\end_layout

\begin_layout Standard
The example for 
\family typewriter
class mapSelector
\family default
 is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if
\begin_inset Formula \begin{eqnarray*}
s_{1} & = & w_{12}-w_{11}\\
s_{2} & = & w_{12}-w_{22}\end{eqnarray*}

\end_inset

the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Section
Gene conversion
\end_layout

\begin_layout Standard
simuPOP uses the Holliday junction model to simulate gene conversion.
 This model treats recombination and conversion as a unified process.
 The key features of this model is
\end_layout

\begin_layout Itemize
Two (out of four) chromatids pair and a single strand cut is made in each
 chromatid
\end_layout

\begin_layout Itemize
Strand exchange takes place between the chromatids
\end_layout

\begin_layout Itemize
Ligation occurs yielding two completely intact DNA molecules
\end_layout

\begin_layout Itemize
Branch migration occurs, giving regions of heteroduplex DNA
\end_layout

\begin_layout Itemize
Resulution of the Holliday junction gives two DNA molecules with heteroduplex
 DNA.
 Depending upon how the holliday junction is resolved, we either observe
 no exchange of flanking markers, or an exchange of flanking markers.
 The former forms a conversion event, which can be considered as a double
 recombination.
\end_layout

\begin_layout Standard
Translated to simulation, recombination and conversion are performed in
 the following steps
\end_layout

\begin_layout Enumerate
Users specify the following paremters to a recombinator:
\end_layout

\begin_deeper
\begin_layout Enumerate
recombination points (recombinations are allowed after specified markers)
 (
\family typewriter
loci
\family default
),
\end_layout

\begin_layout Enumerate
recombination rates (can vary from marker to marker) (
\family typewriter
rates
\family default
),
\end_layout

\begin_layout Enumerate
probability of conversion if a recombination event happens (
\family typewriter
convProb
\family default
),
\end_layout

\begin_layout Enumerate
track length parameters (
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
, will discuss later).
\end_layout

\end_deeper
\begin_layout Enumerate
Starting with two parental chromosomes, randomly choose one of them to copy
 to an offspring chromosome until a recombination event happens.
\end_layout

\begin_layout Enumerate
This recombination event is a conversion event if
\end_layout

\begin_deeper
\begin_layout Enumerate
A random uniform number U(0,1) is less than the probability of conversion
\end_layout

\begin_layout Enumerate
The length of flanking regions does not exceed the end of chromosome 
\end_layout

\begin_layout Standard
If a conversion happens, record the end of flanking region as another recombinat
ion event.
\end_layout

\end_deeper
\begin_layout Enumerate
Copy from another copy of parental chromosome (recombination happens), until
 the recorded second recombination event is reached, or another recombination
 event happens.
 
\end_layout

\begin_layout Enumerate
Repeat these steps for all chromosomes.
\end_layout

\begin_layout Standard
The tract length of a flanking region is determined by parameters 
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
.
 
\family typewriter
convMode 
\family default
can be
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_NumMarkers
\family default
 Convert a fixed number (
\family typewriter
convParam
\family default
) of markers.
 This is the default mode with
\family typewriter
 convParam=1
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_TractLength
\family default
 Convert a fixed length (
\family typewriter
convParam
\family default
) of chromosome regions.
 This can be used when markers are not equally spaced on chromosomes.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_GeometricDistribution
\family default
 Convert a random number of markers, with a geometric distribution with
 parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_ExponentialDistribution
\family default
 Convert Convert a random length of chromosome region, using a exponential
 distribution with parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
If tract length is determined by length (
\family typewriter
CONVERT_TractLength
\family default
 or 
\family typewriter
CONVERT_ExponentialDistribution
\family default
), the starting point of the flanking region is uniformly distributed between
 marker 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

, if the recombination happens at marker 
\begin_inset Formula $i$
\end_inset

.
 That is to say, it is possible that no marker is converted with positive
 tract length.
\end_layout

\begin_layout Itemize
A conversion event will act like a recombination event if its flanking region
 exceeds the end of chromosome, or if another recombination event happens
 before the end of the flanking region.
\end_layout

\begin_layout Standard
Although any parameters can be used in a recombinator, it is worth noting
 that
\end_layout

\begin_layout Itemize
The probability of conversion event among all recombination events if usually
 expressed as ratio of conversion to recombination events in the literature.
 This varies greatly from study to study, ranging from 0.1 to 15 (Chen et
 al, Nature Review Genetics, 2007).
 This translate to 0.1/0.9~0.1 to 15/16~0.94 of this parameter.
 When 
\backslash
c convProb is 1, all recombination events will be conversion events.
 The default value if 
\family typewriter
convProb=0
\family default
, meaning no conversion.
\end_layout

\begin_layout Itemize
Conversion tract length is usually short, and is estimated to be between
 337 and 456 bp, with overall range between maybe 50 - 2500 bp.
 simuPOP does not impose a unit for marker distance so your choice of 
\family typewriter
convParam
\family default
 needs to be consistent with your unit.
 In the HapMap dataset, cM is usually assumed and marker distances are around
 10kb (0.001cM ~- 1kb).
 At this marker density, gene conversion can largely be ignored.
\end_layout

\begin_layout Section
Migration
\end_layout

\begin_layout Standard
Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpopulations
 to any (even new) other subset of subpopulations.
 To facilitate the use of common theoretical migration models, several functions
 are defined in
\family typewriter
 simuUtil.py.
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates(r, n, circular=False)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Section
Hybrid
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Hybrid operator
\end_layout

\end_inset

 and pure-Python operator
\begin_inset Index
status collapsed

\begin_layout Plain Layout
python operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a simuPOP feature called 
\emph on
hybrid operator
\emph default
.
 Such operators accept a Python function and will call this function with
 appropriate parameter(s) when needed.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybrid"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset CommandInset citation
LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability of being affected.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "hybrid.py"
lstparams "caption={An example of hybrid operators},label={hybrid}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybrid"

\end_inset

 uses the function form of operator 
\family typewriter
pyPenetrance
\family default
 and 
\family typewriter
stat
\family default
 and you should use the operator form in a simulator.
 In these functions, operators are created with the same set of parameters
 as their operator form, applied to the population, and are destroyed afterward.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyPenetrance(pop, parameters)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is the same as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyPenetrance(parameters).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, parameters 
\family typewriter
begin, end, step
\family default
 etc become meaningless in the function form.
 Note that if you need to apply the same operator to dozens of populations,
 creating one operator and applying it to all populations is more efficient
 than using the function form, since dozens of operators will be created
 and destroyed for each population in the latter usage.
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can write operators
 in Python.
 Such operators will have full access to the evolving population, and can
 therefore perform arbitrary operations on it.
 A pure-python operator has been used in the previous chapter where complex
 statistics are calculated and printed.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 uses a python operator to define a frequency-dependent selection operator
 which has different selection pressures depending on current disease allele
 frequency.
 In this example, a population is initialized with disease allele frequency
 0.3 (allele 1).
 Then, at each generation, a python function 
\family typewriter
freqDependSelector
\family default
 is called.
 This function
\end_layout

\begin_layout Itemize
unpact parameters (
\family typewriter
DSL, min, max
\family default
)
\end_layout

\begin_layout Itemize
calculate allele frequency at the disease locus
\end_layout

\begin_layout Itemize
if disease allele frequency is less than 
\family typewriter
min
\family default
, apply a multi-allele selector and give disease allele strong advantage
 selection;
\end_layout

\begin_layout Itemize
if disease allele frequency is greater than 
\family typewriter
max
\family default
, apply a multi-allele selector and give disease allele strong purifying
 selection;
\end_layout

\begin_layout Standard
The result of this operator, unseen to users, is individual 
\family typewriter
fitness
\begin_inset Index
status collapsed

\begin_layout Plain Layout
fitness
\end_layout

\end_inset


\family default
 values set by one of (maybe none of) the multi-allele selector, which will
 be used by 
\family typewriter
randomMating()
\family default
 to select individuals accordingly to population the next generation.
\end_layout

\begin_layout Standard
One tricky point of this python operator is that although selectors are
 
\family typewriter
PreMating
\family default
, namely fitness will be calculated before mating, 
\family typewriter
pyOperator
\family default
 is 
\family typewriter
PostMating
\family default
.
 To calculate 
\family typewriter
fitness
\family default
 before mating, a 
\family typewriter
stage=PreMating
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
PreMating
\end_layout

\end_inset

 parameter should be used.
 Otherwise, the fitness will be calculated for the offspring generation,
 not the current generation, as shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

preMating | mating -> offspring generation | postMating, fitness calculated
\end_layout

\begin_layout Plain Layout

preMating | mating -> ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, because the simulator clears selection flag at the beginning of each
 generation, the fitness will not be used.
 Tricky enough, right? The good news is that 
\end_layout

\begin_layout Itemize
If you are using non-optimization libraries, simulation will fail if selection
 flag is on at the beginning of a generation.
 This prevents the use of post-mating selectors.
\end_layout

\begin_layout Itemize
If you are not sure in which order the operators are applied, use the 
\family typewriter
dryrun
\begin_inset Index
status collapsed

\begin_layout Plain Layout
dryrun
\end_layout

\end_inset

=True
\family default
 in the evolve function.
 
\family typewriter
evolve
\begin_inset Index
status collapsed

\begin_layout Plain Layout
evolve
\end_layout

\end_inset

()
\family default
 function will do nothing but printing out when and in which order operators
 will be applied.
\end_layout

\begin_layout Standard
Pure-python operators are extremely flexible and even more complicated form
 can be used.
 For example, 
\family typewriter
varPlotter
\family default
 in 
\family typewriter
simuRPy.py
\family default
 is a class with an instance of different plotters, and a python operator
 is used to call one of them.
 Such advanced usage of pure Python operator is beyond the scope of this
 guide.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "pyOperator.py"
lstparams "caption={A frequency dependent selection operator},label={pyOperator}"

\end_inset


\end_layout

\begin_layout Section
Python Individual operator (moved from refManual.lyx)
\end_layout

\begin_layout Standard
A Python operator accepts a function and an optional parameter.
 When 
\family typewriter
pyOperator
\family default
 is called, it will simply pass the accepted population (or parents and
 offspring in the case of 
\family typewriter
stage=DuringMating
\family default
) to the function.
 To use this operator, in case of 
\family typewriter
stage=PostMating
\family default
, you will need to 
\end_layout

\begin_layout Itemize
define a function that handle a population as you wish.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def myOperator(pop, para):
\end_layout

\begin_layout Plain Layout

    'do whatever you want'
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you return 
\family typewriter
False
\family default
, this operator will work like a terminator.
\end_layout

\end_deeper
\begin_layout Itemize
use 
\family typewriter
pyOperator
\family default
 in the form of
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(mfunc=pyOperator, param=para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
all parameters of an operator are supported except for 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
 which are ignored for now.
\end_layout

\end_deeper
\begin_layout Standard
This operator allows implementation of arbitrarily complicated operators,.
 To use this operator, you will have to know how to use population-related
 functions.
 The following example shows how to implement a dynamic mutator which mutate
 loci according to their allele frequencies.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.log"
lstparams "caption={Define a python operator},label={pyOperator}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperatorUse.log"
lstparams "caption={Use of python operator},label={pyOperatorUse}"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 can also be a during-mating operator.
 You will need to define a function 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def Func(pop, off, dad, mom, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def shortFunc(off, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
para
\family default
 can be ignored.
 To use this operator, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(stage=DuringMating, func=Func, param=someparam, formOffGenotype=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(stage=DuringMating, func=shortFunc, param=someparam,
\end_layout

\begin_layout Plain Layout

formOffGenotype=False, passOffspringOnly=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If your during-mating 
\family typewriter
pyOpeartor
\family default
 returns 
\family typewriter
False
\family default
, the individual will be discarded.
 Therefore, you can write a filter in this way.
 However, since the Python function will be called for each mating event,
 the cost of using such an operator is high, especially when population
 size is large.
\end_layout

\begin_layout Standard
An example of during-mating 
\family typewriter
pyOperator
\family default
 can be found in 
\family typewriter
scripts/demoPyOperator.py
\family default
.
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
Information fields are, in short, double values attached to each individual.
 Since different applications require different information fields, simuPOP
 takes a minimal approach in that no information field will be used (to
 save RAM) by default.
 When you apply an operator that needs a particular field, and your population
 does not have it, an error message will be given so that you can add appropriat
e fields to the 
\family typewriter
infoFields
\family default
 parameter of 
\family typewriter
population()
\family default
, or use 
\family typewriter
setInfoFields(), addInfoField(), addInfoFields()
\family default
 member functions to add them.
 Commonly used information fields are
\end_layout

\begin_layout Itemize

\family typewriter
fitness:
\family default
 used by all selectors, and by mating schemes
\end_layout

\begin_layout Itemize

\family typewriter
father_idx, mother_id
\family default
x: used by taggers to track parental information
\end_layout

\begin_layout Itemize

\family typewriter
spouse, pedindex, oldindex:
\family default
 used by ascertainment operators to obtain pedigree information.
\end_layout

\begin_layout Standard
Besides these standard information fields, you can define any fields for
 your use.
 The most frequently used functions are 
\family typewriter
individual::setInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setInfo
\end_layout

\end_inset

(value, field), individual::info
\begin_inset Index
status collapsed

\begin_layout Plain Layout
info
\end_layout

\end_inset

(field), population::setIndInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setIndInfo
\end_layout

\end_inset

(values, field)
\family default
 and 
\family typewriter
population::indInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
indInfo
\end_layout

\end_inset

(field).

\family default
 Here field can be the name of the field, or an id returned by 
\family typewriter
population::infoIdx
\begin_inset Index
status collapsed

\begin_layout Plain Layout
infoIdx
\end_layout

\end_inset

(field)
\family default
.
 Accessing information fields using indices is faster than using names.
\end_layout

\begin_layout Standard
In the following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoFields"

\end_inset

), a proportional hazard model is used to determine the age of onset of
 an individual with given genotype.
 Briefly,
\end_layout

\begin_layout Itemize
The base hazard is 
\begin_inset Formula $h_{0}\left(t\right)=\beta_{0}t$
\end_inset

, the corresponding survival function is 
\begin_inset Formula $S\left(s\right)=\exp\left(-\int_{0}^{s}h\left(t\right)dt\right)$
\end_inset

.
 The age of onset is determined randomly by the survival function.
 (
\begin_inset Formula $F\left(x\right)=1-S\left(x\right)$
\end_inset

 is used in the example.) The relevant functions are 
\family typewriter
hazard, cumHazard, cdf, ageOfOnset
\family default
.
 In the last function, 
\begin_inset Formula $\beta$
\end_inset

 is the fold change of the hazard function so 
\begin_inset Formula $h\left(t,\beta\right)=\beta\beta_{0}t$
\end_inset

.
\end_layout

\begin_layout Itemize
Date of birth is calculated as 2005 - age, where age is 
\begin_inset Formula $U\left(0,75\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
The proportional hazard model is
\begin_inset Formula \[
h\left(t,X\right)=h_{0}\left(t\right)\exp\left(\beta X\right)\]

\end_inset

where 
\begin_inset Formula $X$
\end_inset

 is the number of disease alleles at the given disease susceptibility loci.
 The age of onset is determined by individual 
\begin_inset Formula $h\left(t,X\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Affection status is determined by date of birth + age of onset < 2005.
\end_layout

\begin_layout Standard
The program is pretty self-explainary so I do not comment on the code here.
 The resulting population has information fields 
\family typewriter
DateOfBirth
\family default
, 
\family typewriter
betaX
\family default
 and 
\family typewriter
ageOfOnset
\family default
.
 Note that this example does not any operator or simulator, and demonstrate
 simuPOP's ability to manipulation populations.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "infoFields.py"
lstparams "caption={Proportional hazard model and use of information fields},label={infoFields}"

\end_inset


\end_layout

\begin_layout Standard
Information fields can also be manipulated during evolution, using one of
 the Python operators, or operators 
\family typewriter
infoEval 
\family default
and 
\family typewriter
infoExec
\family default
 (new in version 0.8.4).
 Please refer to simuPOP reference manual for details.
\end_layout

\begin_layout Section
Pedigree
\end_layout

\begin_layout Standard
A pedigree records the parent(s) of each individual during evolution.
 It can be created manually or using tagging operators 
\family typewriter
parentTagger
\family default
 (tagging one parent) and 
\family typewriter
parentsTagger 
\family default
(tagging both parents).
 The pedigree can be analyzed to study various properties of the evolutionary
 process, manipulated (e.g.
 removing individuals without offspring), and used to re-realize the evolutionar
y process using 
\family typewriter
pedigreeMating
\family default
.
\end_layout

\begin_layout Standard
A pedigree file has the following format:
\end_layout

\begin_layout LyX-Code
p1 p2 p3 p4 .....
 # sp1 sp2 sp3
\end_layout

\begin_layout LyX-Code
p1 p2 p3 p4 .....
 # sp1 sp2 sp3
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Standard
Numbers before # of each line of a pedigree file are the parent(s) of individual
s, starting from generation 0.
 If only one parent is used to produce offspring (e.g.
 using the 
\family typewriter
selfMating
\family default
 mating scheme), 
\family typewriter
parentTagger(output, outputExpr)
\family default
 records the index of the parent of each individual (
\family typewriter
p...
\family default
) in the parental generation.
 Otherwise, 
\family typewriter
parentsTagger(output, outputExpr)
\family default
 records the indexes of both parents.
\end_layout

\begin_layout Standard
The generation number and the size of subpopulations are listed after the
 # character.
 The sum of subpopulation sizes should match the individuals listed before
 #.
\end_layout

\begin_layout Standard
A number of auxillary information pedigrees can be loaded after a pedigree
 is created.
 These information pedigree files does not have subpopulation and generation
 information (does not have character # and numbers after it).
 If there are 
\begin_inset Formula $n$
\end_inset

 individuals at a generation, the corresponding line in an information pedigree
 file should have 
\begin_inset Formula $m*n$
\end_inset

 numbers where 
\begin_inset Formula $m$
\end_inset

 is the number of properties for each individual.
 Information pedigrees can be created by other tagging operators such as
 
\family typewriter
pyTagger(output, outputExpr)
\family default
.
 
\end_layout

\begin_layout Standard
These auxiliary information will be attached to individuals in a pedigree.
 They will be removed if an individual is removed from the pedigree.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Population structure and migration
\end_layout

\begin_layout Standard
You first need to understand that mating schemes populate subpopulations
 from their corresponding ancestral subpopulations one by one, so it can
 not change number of subpopulations.
 Split and merge of subpopulations are done by operators 
\family typewriter
splitSubPop
\begin_inset Index
status collapsed

\begin_layout Plain Layout
splitSubPop
\end_layout

\end_inset


\family default
 and 
\family typewriter
mergeSubPops
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mergeSubPops
\end_layout

\end_inset


\family default
 respectively.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitAndMerge"

\end_inset

, these two operators are used to split and merge subpopulations, but keep
 total population size untouched.
 Note that after subpopulation merge, subpopulation 2 still exists, but
 with size 0.
 This is used to keep subpopulation id of other subpopulations unchanged.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitAndMerge.out"
lstparams "caption={Population split and merge},label={splitAndMerge}"

\end_inset


\end_layout

\begin_layout Standard
Migration can change subpopulation size, but not total population size.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitAndMerge"

\end_inset

, two migrators are used.
 The first migrator moves individuals from subpopulation 0 to subpopulation
 1.
 The second migrator moves individuals around, with given proportions.
 For example, the migration rate
\begin_inset Formula \[
\left(\begin{array}{ccc}
0. & 0.2 & 0.4\\
0. & 0. & 0.1\\
0.1 & 0.1 & 0.\end{array}\right)\]

\end_inset

means moving 20% of individuals from subpop 0 to 1, 40% of individuals from
 subpop 0 to 1, and keep 40% (automatically determined).
 Subpopulation sizes change accordingly.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration.out"
lstparams "caption={Population split and migration},label={splitMigration}"

\end_inset


\end_layout

\begin_layout Standard
But what if you need to control total population size? In this case, a demograph
ic function is needed to specify the size of each subpopulation, at each
 generation.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration2"

\end_inset

, function 
\family typewriter
popSize
\family default
 returns exact subpopulation size at each generation, and the population
 will behave accordingly.
 It might surprise you that migration can no longer control the size of
 subpopulation sizes.
 What exactly happened is that, for example
\end_layout

\begin_layout Itemize
subpopulation size = [200, 400, 400], at the beginning of a generation
\end_layout

\begin_layout Itemize
apply migrator, subpopulation size changed to [100, 470, 430]
\end_layout

\begin_layout Itemize
pre mating operator 
\family typewriter
stat
\family default
 is applied and report subpopulation sizes
\end_layout

\begin_layout Itemize
during mating, with given subpopulation sizes 200, 400, 400 of the offspring
 generation, the mating scheme generate 200 offspring from 100 parents in
 subpopulation 0, 400 offspring from 470 parents in subpopulation 1, and
 400 offspring from 430 parents in subpopulation 2.
\end_layout

\begin_layout Itemize
post mating operator 
\family typewriter
stat
\family default
 is applied and get the new subpopulation size.
\end_layout

\begin_layout Standard
This example also demonstrates the use of stage parameter.
 As a matter of fact, you can use only one 
\family typewriter
stat
\family default
 operator by using 
\family typewriter
stage
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stage
\end_layout

\end_inset

=PrePostMating
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
PrePostMating
\end_layout

\end_inset

.
 If you are confused by the order of operators, use the 
\family typewriter
dryrun=True
\family default
 parameter of 
\family typewriter
evolve
\family default
 to check.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration2.out"
lstparams "caption={Population split with changing population size},label={splitMigration2}"

\end_inset


\end_layout

\begin_layout Standard
You might say, OK, this looks nice, but how can I grow a population with
 migration acting freely? This is also easy, all you need to do is using
 the oldSize parameter of a demographic function in a clever way.
 The underlying story is that
\end_layout

\begin_layout Itemize
before mating, a mating scheme calculates current subpopulation sizes
\end_layout

\begin_layout Itemize
it calls the given demographic function with current generation number and
 current subpopulation sizes
\end_layout

\begin_layout Itemize
it uses the return value as the new subpopulation sizes.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration3"

\end_inset

 demonstrate an exponentially increase population with free migration between
 subpopulations.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration3.out"
lstparams "caption={Population split with changing population size},label={splitMigration3}"

\end_inset


\end_layout

\begin_layout Section
Non-random mating
\end_layout

\begin_layout Standard
Random-mating implies random choices of parents.
 Non-random mating is much more difficult to implement because there are
 numerous way to introduce non-randomness.
 One of the ways to achive non-random mating in simuPOP is to use a hybrid
 operator 
\family typewriter
pyMating
\family default
.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyMating
\family default
 mating scheme accepts a 
\emph on
parents chooser
\emph default
 and an 
\emph on
offspring generator
\emph default
.
 The parents chooser is responsible for choosing one or two parents from
 the parental generation, and the offspring generator is responsible for
 generating a number of offspring from the chosen parents.
 There are a number of default parents choosers and offspring generators
 and a 
\family typewriter
pyMating
\family default
 can be built with them.
 For example
\end_layout

\begin_layout LyX-Code
pyMating(randomParentsChooser(), mendelianOffspringGenerator())
\end_layout

\begin_layout Standard
works exactly as a 
\family typewriter
randomMating
\family default
 scheme, and
\end_layout

\begin_layout LyX-Code
pyMating(randomParentChooser(), selfingOffspringGenerator(numOffspring=2))
\end_layout

\begin_layout Standard
works as 
\family typewriter
selfMating(numOffspring=2)
\family default
.
 Note that parent chooser and offspring generator should be compatible ,
 meaning that if a parent chooser chooses one parent each time, the offspring
 generator should be able to produce offspring from a single parent.
\end_layout

\begin_layout Standard
The power of 
\family typewriter
pyMating 
\family default
lies in its 
\family typewriter
pyParentChooser()
\family default
, which accepts a user-defined Python generator function, instead of a normal
 python function.
 Generally speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when the 
\family typewriter
next()
\family default
 member function of this object is called, this function resumes where it
 was stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,10$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 in a sequence interface.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator.log"
lstparams "caption={A sample generator function},label={generator}"

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
parents chooser
\emph default
 takes two parameters, a population and a subpopulation index.
 It can return different generator objects for different subpopulations.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator_random.log"
lstparams "caption={A generator function that mimicks random mating},label={generator_random}"

\end_inset


\end_layout

\begin_layout Standard
A user defined parents chooser can be very complicated, involving user defined
 information such as geometric locations.
 An example is given in 
\family typewriter
cookbook/Mating_pyMating_cpp.py
\family default
.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator_random"

\end_inset

, the parents chooser 
\family typewriter
randomChooser 
\family default
collects indexes of males and females and simply return a pair of random
 male and female repeatedly.
 This is exactly what 
\family typewriter
randomMating
\family default
 does if selection is not considered.
 It becomes obvious now that whereas a python function can return random
 male/famale pair, the generator interface is much more efficient because
 the identification of two sex groups is done only once.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyMating"

\end_inset

 demonstrates how to use this user-defined parent chooser.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyMating.log"
lstparams "caption={pyMating with a user-defined parent chooser},label={pyMating}"

\end_inset


\end_layout

\begin_layout Standard
Because arbitrary information can be stored with an individual through informati
on fields, 
\family typewriter
pyMating
\family default
 can be very complicated.
 For example, one can choose individuals according their age, and/or geographic
 information.
 For populations with well-defined structure, virtual subpopulations can
 be used.
 Basically, one needs to specify a virtual subpopulation splitter to a subpopula
tion.
 Then, different mating schemes can be applied to different virtual subpopulatio
ns.
 A simple example is given in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMating"

\end_inset

 where the first subpopulation is divided into two parts.
 The first 20% of individuals undergo selfing, and the rest of the subpopulation
 undergoes usual sexed random mating.
 Note that two mating schemes produce different number of offspring per
 mating event, and the family sizes are recorded in a shared variable 
\family typewriter
famSizes
\family default
 when 
\family typewriter
DBG_MATING
\family default
 is turned on.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMating.log"
lstparams "caption={A heterogeneous mating scheme},label={heteroMating}"

\end_inset


\end_layout

\begin_layout Section
Sex chromosomes
\end_layout

\begin_layout Standard
Supports for sex chromosomes are done in simuPOP in the following ways:
\end_layout

\begin_layout Itemize
If 
\family typewriter
sexChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sexChrom
\end_layout

\end_inset

=True
\family default
 is specified in 
\family typewriter
population()
\family default
, the last chromosome is assumed to be the sex chromosome.
 For female, it is 
\family typewriter
XX,
\family default
 for male, it is 
\family typewriter
XY
\family default
, in that order.
\end_layout

\begin_layout Itemize
During mating, sex of offspring is determined by sex chromosome.
 (It is otherwise determined randomly with probability 0.5).
\end_layout

\begin_layout Itemize
Recombination can not happen between 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 chromosomes.
 That is to say, offspring can get recombined 
\family typewriter
X
\family default
 from his/her mother, but untouched 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 from father.
\end_layout

\begin_layout Standard
As of version 0.7.5, no other operator recognize sex chromosome.
 Most notably, 
\family typewriter
stat
\family default
 counts allele frequencies etc regardless sex chromosome and can not count
 allele frequency for 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 separately.
 
\end_layout

\begin_layout Section
Pedigree tracking
\end_layout

\begin_layout Standard
simuPOP provides the following functions to manipulate pedigrees
\end_layout

\begin_layout Itemize
If you set 
\family typewriter
ancestralDepth
\family default
 of a population to a positive number (default 0), 
\family typewriter
ancestralDepth
\family default
 number of ancestral generations will be saved to the population, which
 makes a total of 
\family typewriter
ancestralDepth + 1
\family default
 generations.
\end_layout

\begin_layout Itemize
You can use 
\family typewriter
population::useAncestralPop
\begin_inset Index
status collapsed

\begin_layout Plain Layout
useAncestralPop
\end_layout

\end_inset

(idx)
\family default
 to use current (0), parental (1), grand-parental (2) generations etc.
 Just remember to call 
\family typewriter
population::useAncestralPop(0)
\family default
 to set current generation back.
\end_layout

\begin_layout Itemize
You can set 
\family typewriter
ancestralDepth
\family default
 dynamically using operator 
\family typewriter
setAncestralDepth
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setAncestralDepth
\end_layout

\end_inset

.

\family default
 Usually, this operator is called, for example, as 
\family typewriter
setAncestralDepth(at=[-2])
\family default
, to allow last several generations to be saved at the end of evolution.
\end_layout

\begin_layout Itemize
No parental information is saved by default we usually do not know the parents
 of an offspring.
 This can be changed by using the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields, and an appropriate tagger such as 
\family typewriter
parentTagger
\begin_inset Index
status collapsed

\begin_layout Plain Layout
parentTagger
\end_layout

\end_inset

()
\family default
, which is a during mating operator that will record the parents' indices
 in the parental generation to offspring's information fields.
\end_layout

\begin_layout Itemize

\family typewriter
randomMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
randomMating
\end_layout

\end_inset

()
\family default
 only produce one offspring per mating event.
 This makes full siblings very unlikely.
 You usually need to change this at the last several generations.
\end_layout

\begin_layout Standard
You can see that generating multi-generation populations are quite different
 from the usual evolutionary process where random mating is used, and one
 offspring is generated for each mating event.
 In practice (see 
\family typewriter
scripts/simuComplexDisease.py
\family default
), if we need to prepare a population for pedigree sampling, we can run
 a simulator like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
One-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(...., ancestralDepth=2,
\end_layout

\begin_layout Plain Layout

    infoFields=['father_idx', 'mother_idx'])
\end_layout

\begin_layout Plain Layout

simu = simulator(pop, randomMating(numOffspring=2))
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    preOps=[...],
\end_layout

\begin_layout Plain Layout

    ops = operators,
\end_layout

\begin_layout Plain Layout

    end = 1000
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with this approach is that two generations are saved at all
 generations, and all mating events produce two offspring.
 The former is not a big deal but the latter will reduce effective population
 size of the resulting population.
 To avoid these problems, a two-stage simulation can be done 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Two-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(....)
\end_layout

\begin_layout Plain Layout

simu = simulator(pop, randomMating())
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    preOps=[...],
\end_layout

\begin_layout Plain Layout

    ops = operators,
\end_layout

\begin_layout Plain Layout

    end = 1000 - 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

simu.setAncestralDepth(2)
\end_layout

\begin_layout Plain Layout

simu.addInfoFields(['father_idx', 'mother_idx'])
\end_layout

\begin_layout Plain Layout

simu.setMatingScheme(randomMating(numOffspring=2))
\end_layout

\begin_layout Plain Layout

operators.append(parentsTagger())
\end_layout

\begin_layout Plain Layout

simu.evolve(ops=operators, end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is to say, we separate the simulation into two parts.
 The first part is geared toward performance and maximum effective population
 size (use true random mating), and the second part is tweaked for the final
 multi-generation population.
 Note that 
\family typewriter
setAncestralDepth 
\family default
and 
\family typewriter
addInfoFields
\family default
 should be done at the simulator level so that every replicates in the simulator
 have the same new information fields.
 
\family typewriter
simu.population(0).addInfoFields(['father_idx', 'mother_idx']) 
\family default
will compromise the integrity of the simulator and is disallowed.
 (Integrity refers to the fact that all populations in a simulator should
 have the same genotypic structure as the simulator).
\end_layout

\begin_layout Standard
Now, at the end of the simulation, you get a population with multiple generation
s, with parental information.
 But it is still not easy to obtain pedigrees.
 As a matter of fact, since individuals can belong to multiple pedigrees,
 it is not even easy to define a pedigree.
 simuPOP provides a few pedigree ascertainment operators
\end_layout

\begin_layout Itemize

\family typewriter
AffectedSibpairSample
\family default
: sample affected sibpairs, along with their parents from a population.
 Affection status should have been set by other means such as a penetrance
 operator.
\end_layout

\begin_layout Itemize

\family typewriter
LargePedigreeSample:
\family default
 sample grand parents, their children, and the spouse and children of them.
 Affection status is ignored, although the minimal number of affected individual
s in each family can be specified.
\end_layout

\begin_layout Itemize

\family typewriter
NuclearFamilySample: 
\family default
sample two-generation pedigrees.
\end_layout

\begin_layout Standard
If you need to sample more complicated pedigrees, you should first use 
\family typewriter
sample::findOffspringAndSpouse
\family default
 to locate each individual's offspring and spouse, then use 
\family typewriter
useAncestralPop()
\family default
 to go through the generations and set 
\family typewriter
pedIndex
\family default
 for the pedigree you choose, and then use 
\family typewriter
setSubPopID()
\family default
, 
\family typewriter
newPopByIndID()
\family default
 to exclude and remove unneeded individuals.
 
\family typewriter
sample::resetParentalIndex()
\family default
 should also be used to reset the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 fields.
 Sound complicated? It is complicated! I hope that I can get some better
 idea and make this process a bit easier, but this is where simuPOP is at
 right now.
\end_layout

\begin_layout Standard
Finally, you can save the sample populations in a pedigree-aware format
 like Linkage or Merlin/QTDT format.
 simuPOP can do this easily for you.
\end_layout

\begin_layout Section
Save and load to other formats
\end_layout

\begin_layout Standard
simuPOP data structure is open in that many functions are provided to access
 every aspect of the population.
 This makes it easy to save and load populations in other formats.
 As an example, I will explain 
\family typewriter
SaveTDT
\family default
 function in detail here, which is available in 
\family typewriter
simuUtil.py
\family default
.
\end_layout

\begin_layout Standard
Although all file formats have different characteristics, 
\family typewriter
simuPOP
\family default
 tries to provide a uniform interface to them.
 Common parameters are
\end_layout

\begin_layout Itemize
pop: population to save, can be a file name, or a file object (loaded simuPOP
 population)
\end_layout

\begin_layout Itemize
output and outputExpr: output is the base filename, and outputExpr should
 be evaluated from pop's local namespace.
\end_layout

\begin_layout Itemize
loci: loci to output, default is [], meaning output all loci
\end_layout

\begin_layout Itemize
fields: information fields to output.
 
\end_layout

\begin_layout Itemize
combine: a python function, if given, used to combine two alleles at the
 same locus.
 For example
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def comb(geno):
\end_layout

\begin_layout Plain Layout

    return geno[0]+geno[1]+1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns 1 for genotype(0, 0), 2 for genotype (0, 1) and so on.
\end_layout

\end_deeper
\begin_layout Itemize
shift: default to 1.
 simuPOP uses 0 based allele and many formats use 1 based allele.
 Setting shift=1 output (1,2) for genotype (0,1).
\end_layout

\begin_layout Standard
The 
\family typewriter
Merlin/QTDT
\family default
 format uses several files to store genotype and phenotype information.
 Namely a 
\family typewriter
.dat
\family default
 file for phenotype, 
\family typewriter
.map
\family default
 file for chromosome structure, and 
\family typewriter
.ped
\family default
 for pedigree.
 The population given must have 
\family typewriter
pedindex, father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields to indicate family id and parents of each individual.
 These information fields will be available if the sample is obtained from
 
\family typewriter
affectedSibpairSample
\family default
 or 
\family typewriter
largePedigreeSample
\family default
 operators.
\end_layout

\begin_layout Standard
The first part of the function is the usual housekeeping part (see example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT1"

\end_inset

).
 It loads population if 
\family typewriter
pop
\family default
 is a name, evaluate 
\family typewriter
outputExpr
\family default
 if needed, and open the files to write.
 This part is likely to be similar for all such functions.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT1.py"
lstparams "caption={Function SaveQTDT, part one},label={saveQTDT1}"

\end_inset


\end_layout

\begin_layout Standard
Part two of the code (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT2"

\end_inset

) output data file.
 There are three kinds of phenotype, affection status, trait and markers.
 We determine if a user wants to output affection from the 
\family typewriter
fields
\family default
 parameter.
 We remove 
\family typewriter
affection
\family default
 from 
\family typewriter
fields
\family default
 because 
\family typewriter
affection
\family default
 is not a real information field (that can be retrieved by 
\family typewriter
info()
\family default
 function).
 You can learn how to use the 
\family typewriter
locusName
\family default
 function from this part.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT2.py"
lstparams "caption={Function SaveQTDT, part two},label={saveQTDT2}"

\end_inset


\end_layout

\begin_layout Standard
Part three (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT3"

\end_inset

) of the function output a map file.
 We need to know the chromosome number (+1 to use 1 based index), locus
 name and locus position, all of which can be retrieved from simple 
\family typewriter
simuPOP
\family default
 functions.
 Note that if locus name, position are not given explicitly when a population
 is created, they all have default values.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT3.py"
lstparams "caption={Function SaveQTDT, part three},label={saveQTDT3}"

\end_inset


\end_layout

\begin_layout Standard
The next part (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT4"

\end_inset

) prepares pedigree output.
 It determines the code to output for sex and affection status.
 These are likely to be different from format to format so we define explicitly
 here.
 The 
\family typewriter
writeInd
\family default
 output the line for one individual, given family id, id, father and mother.
 For QTDT format, two alleles of a genotype are outputted separately so
 the 
\family typewriter
combine
\family default
 parameter is ignored.
 
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT4.py"
lstparams "caption={Function SaveQTDT, part four},label={saveQTDT4}"

\end_inset


\end_layout

\begin_layout Standard
The last part of the code (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT5"

\end_inset

) look most complicated.
 It first get the 
\family typewriter
pedindex
\family default
 information field of the whole population, and figure out how many pedigrees
 to output.
 Then, it go from ancestral generation 2, 1, 0 and look for individuals
 within each pedigree.
 A map is used to map absolute index to within pedigree index.
 Of course, this part would be easier if you do not need to handle pedigree,
 for example, when outputting case control samples.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT5.py"
lstparams "caption={Function SaveQTDT, part five},label={saveQTDT5}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gene mapping
\end_layout

\begin_layout Standard
Once you output your sample into a format that can be processed by other
 applications, you can handle them in whatever way you want.
 If you are interested in processing the data in simuPOP (actually, in python),
 you can use python to call these programs.
 
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "mapping.py"
lstparams "caption={Example of gene mapping},label={mapping}"

\end_inset


\end_layout

\begin_layout Standard
An example is given in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mapping"

\end_inset

.
 In this function, 
\family typewriter
merlin
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Abecasis2002"

\end_inset

 is called to process file produced by the 
\family typewriter
SaveQTDT
\family default
 function.
 The output is fed into a pipe (
\family typewriter
popen
\family default
) and be filtered by the python 
\family typewriter
re
\family default
 (regex) module.
 Only the 
\begin_inset Formula $p$
\end_inset

-values are obtained and returned.
\end_layout

\begin_layout Chapter
A real example
\end_layout

\begin_layout Standard
In this chapter, I will show you, step by step, how to write a simuPOP script.
 The example is a simplified version of 
\family typewriter
scripts/simuCDCV.py
\family default
 which uses a python operator to calculate and save many more statistics,
 and use rpy to display the dynamics of disease allele frequency.
 
\end_layout

\begin_layout Subsection
Simulation scenario
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
I use simuPOP to simulate this evolution process and observe the allelic
 spectra of both types of diseases.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Subsubsection
Demographic model
\end_layout

\begin_layout Standard
The initial population size is set to 10,000, as suggested in the paper.
 The simulation will evolve 500 generations with constant population size
 to reach mutation-selection equilibrium.
 Then, the population size will increase by around 20,000 every 10 generations
 and reach 1,000,000 at generation 1000.
 The population growth takes around 12,500 years if we assume 25 years per
 generation.
 
\end_layout

\begin_layout Subsubsection
Mutation model
\end_layout

\begin_layout Standard
The maximum number of alleles at each locus is set to be 2000, a number
 that is hopefully big enough to mimic the infinite allele model.
 Allele 0 is the wild type (
\begin_inset Formula $A$
\end_inset

) and all others are disease alleles (
\begin_inset Formula $a$
\end_inset

).
 The 
\begin_inset Formula $k-$
\end_inset

allele mutation model is used.
 That is to say, an allele can mutate to any other allele with equal probability.
 An immediate implication of this model is that 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more 
\begin_inset Formula $a$
\end_inset

 than 
\begin_inset Formula $A$
\end_inset

.
 The mutation rate is set to 
\begin_inset Formula $\mu=3.2\times10^{-5}$
\end_inset

 per locus per generation.
\end_layout

\begin_layout Subsubsection
Selection on a common and a rare disease 
\end_layout

\begin_layout Standard
Two diseases are simulated: a common disease with initial allele frequency
 of 
\begin_inset Formula $f_{0}=0.2$
\end_inset

; and a rare disease with initial allele frequency of 
\begin_inset Formula $f_{0}=0.001$
\end_inset

.
 The diseases are unlinked in the sense that their corresponding loci reside
 on separated chromosomes.
 The allelic spectra of both diseases are set to be 
\begin_inset Formula $\left[.9,.02,.02,.02,.02,.02\right]$
\end_inset

.
 I.e., one allele accounts for 90% of the disease cases.
 
\end_layout

\begin_layout Standard
Both diseases are recessive in that their fitness values are 
\begin_inset Formula $\left[1,1,1-s\right]$
\end_inset

 for genotype 
\begin_inset Formula $AA$
\end_inset

, 
\begin_inset Formula $Aa$
\end_inset

 and 
\begin_inset Formula $aa$
\end_inset

 respectively.
 
\begin_inset Formula $s_{c}=0.1$
\end_inset

 , 
\begin_inset Formula $s_{r}=0.9$
\end_inset

 are used in the simulation which imply weak selection on the common disease
 and strong selection on the rare disease.
 If an individual has both diseases, his fitness value follows a multiplicative
 model, i.e., 
\begin_inset Formula $\left(1-s_{c}\right)\times\left(1-s_{r}\right)=0.09$
\end_inset

.
 
\end_layout

\begin_layout Standard
These parameters, translated to python, are shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:reich0"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich0.py"
lstparams "caption={Set parameters},label={alg:reich0}"

\end_inset


\end_layout

\begin_layout Subsection
Create a simulator
\end_layout

\begin_layout Standard
Several parameters are needed to create a population:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\family default
: 2, default
\end_layout

\begin_layout Itemize

\family typewriter
size
\family default
: initial population size, known
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: no subpopulation (or one single population).
 size can be ignored if 
\family typewriter
subPop
\family default
 is given.
\end_layout

\begin_layout Itemize

\family typewriter
loci
\family default
: number of chromosomes and number of loci on each chromosome: we use two
 unlinked loci.
 use 
\family typewriter
loci=[1,1]
\family default
.
 This array gives the number of loci on each chromosome.
\end_layout

\begin_layout Itemize
loci name and position: no need to specify
\end_layout

\begin_layout Itemize

\family typewriter
infoFields
\family default
: This parameter is tricky since you need to specify what auxiliary information
 to attach to each individual.
 During the simulation, 
\family typewriter
fitness
\family default
 is needed because all selectors generate this information and mating schemes
 will make use of it.
 If you forget to provide this parameter, never mind, the simulation will
 fail and tell you that a information field 
\family typewriter
fitness
\family default
 is needed.
 Similar information fields include 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 when you want to track each individual's parents using 
\family typewriter
taggers.
\end_layout

\begin_layout Standard
You can then create a population with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

population(size=1000, loci=[1,1], infoFields=['fitness'])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create simulator, we need to decide on a mating scheme.
 
\family typewriter
randomMating
\family default
 should of course be used, but we need to tell 
\family typewriter
randomMating
\family default
 how population size should be changed.
 By default, all mating schemes keep the population size of ancestral population
, but we need an instant population expansion model.
\end_layout

\begin_layout Standard
The easiest way to achieve this is defining a function that accept generation
 number and the population size of previous generation, and return the size
 of this generation.
 The input and output population sizes need to be arrays, indicating sizes
 of all subpopulations.
 In our case, something like 
\family typewriter
[1000]
\family default
 should be used.
 The instant population growth model is actually quite easy to write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ins_exp(gen, oldSize=[]):
\end_layout

\begin_layout Plain Layout

     if gen < burnin:
\end_layout

\begin_layout Plain Layout

         return [initSize]
\end_layout

\begin_layout Plain Layout

     else:
\end_layout

\begin_layout Plain Layout

         return [finalSize] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a little adjustment of how population size is given to 
\family typewriter
population()
\family default
, and use demographic function as a parameter to allow other demographic
 models to be used, we end up with example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich1"

\end_inset

.
 Note that because we use loci with more than 255 allele states, the long
 allele module is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich1.py"
lstparams "caption={Create a simulator},label={reich1}"

\end_inset


\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
We start the simulation with initial allele spectra at the two loci.
 This can be achieved by operator 
\family typewriter
initByFreq
\family default
, which allows you to initialize individuals with alleles proportional to
 given allele frequencies.
 Using a large number of parameters, this operator can initialize any subset
 of loci, for any subset(s) of individuals, even given ploidy.
 We need only to specify locus to initialize, and use it like
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# initialize locus 0 (for common disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[0], alleleFreq=C_f),
\end_layout

\begin_layout Plain Layout

# initialize locus 1 (for rare disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[1], alleleFreq=R_f),
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mutation and selection
\end_layout

\begin_layout Standard
You will need to read the relative sections of the reference manual to pick
 suitable mutator and selectors.
 What we need in this case are
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

-allele mutator with given number of allele states (
\begin_inset Formula $k$
\end_inset

).
 This is exactly
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kamMutator(rate=mu, maxAllele=max_allele)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
single locus selector that treat 0 as wildtype, and any other allele as
 mutant.
 The selector to use is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Because an individual has only one fitness value, fitness values obtained
 from two selectors need to be combined (another choice is that you can
 use a selector that handle multiple loci.).
 Therefore, we use a multi-locus selector as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mlSelector([
\end_layout

\begin_layout Plain Layout

    maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0]),
\end_layout

\begin_layout Plain Layout

    maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\begin_layout Plain Layout

    ], mode=SEL_Multiplicative)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
With these operators, the simulator can be started.
 It first initialize a population with given allelic spectra, and then evolve
 it, subject to mutation and selection, specific to each locus.
 The program is listed in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich2"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich2.py"
lstparams "caption={Run the simulator},label={reich2}"

\end_inset


\end_layout

\begin_layout Subsection
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy since 
\family typewriter
stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use 
\family typewriter
stat()
\family default
 operator to calculate allele frequency and set variable 
\family typewriter
alleleFreq
\family default
 (and 
\family typewriter
alleleNum
\family default
) in each population's local namespace,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0,1]),
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then use a 
\family typewriter
pyEval
\family default
 (python expression) operator to print out the values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(r' %.3f
\backslash
t%.3f
\backslash
n % (1-alleleFreq[0][0], 1-alleleFreq[1][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
pyEval
\family default
 operator can accept any valid python expression so the above expression
 calculate 
\begin_inset Formula $f_{0}=\sum_{i=1}^{\infty}f_{i}$
\end_inset

 at each locus (0 and 1) and print it in the format of 
\family typewriter
'%.3f
\backslash
t%.3f
\backslash
n'
\family default
.
\end_layout

\begin_layout Standard
There is no operator to calculate effective number of alleles 
\begin_inset CommandInset citation
LatexCommand citep
key "Reich2001a"

\end_inset

 so we need to do that by ourselves, using allele frequencies.
 The formula to calculate effective number of alleles is
\begin_inset Formula \[
n_{e}=\left(\sum_{i}\left(\frac{f_{i}}{f_{0}}\right)^{2}\right)^{-1}\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

 , and 
\begin_inset Formula $f_{0}$
\end_inset

 is defined as above.
 To calculate 
\begin_inset Formula $n_{e}$
\end_inset

 at the first locus, we can use a 
\family typewriter
pyEval
\family default
 operator (a direct translation of the formula):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval('1./sum([(x/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0][1:]])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this expression looks complicated and can not handle the case when
 
\begin_inset Formula $f_{0}=0$
\end_inset

.
 A more complicated, and robust method is using the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
 ,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(stmts='''ne = [0,0]
\end_layout

\begin_layout Plain Layout

for i in range(2):
\end_layout

\begin_layout Plain Layout

    freq = alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

    f0 = 1 - alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

    if f0 == 0:
\end_layout

\begin_layout Plain Layout

        ne[i] = 0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        ne[i] = 1./sum([(x/f0)**2 for x in freq])
\end_layout

\begin_layout Plain Layout

''', expr=r'%.4f
\backslash
t%.4f
\backslash
n % (ne[0], ne[1])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the 
\family typewriter
pyEval
\family default
 can be really complicated and calculate any statistics.
 However, if you plan to calculate more statistics, a pure python operator
 may be easier to write.
 The simplest form of a python operator is just a python function that accept
 a population as the first parameter (and an optional parameter),
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ne(pop):
\end_layout

\begin_layout Plain Layout

    ' calculate effective number of alleles '
\end_layout

\begin_layout Plain Layout

    Stat(pop, alleleFreq=[0,1])
\end_layout

\begin_layout Plain Layout

    f0 = [0, 0]
\end_layout

\begin_layout Plain Layout

    ne = [0, 0]
\end_layout

\begin_layout Plain Layout

    for i in range(2):
\end_layout

\begin_layout Plain Layout

        freq = pop.dvars().alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

        f0[i] = 1 - pop.dvars().alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

        if f0[i] == 0:
\end_layout

\begin_layout Plain Layout

            ne[i] = 0
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            ne[i] = 1.
 / sum([(x/f0[i])**2 for x in freq])
\end_layout

\begin_layout Plain Layout

    print '%d
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
n' % (pop.gen(), f0[0], f0[1], ne[0], ne[1])
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can use this function in a python operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(func=ne, step=5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOperator
\family default
 is that 
\family typewriter
pyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the vars explicitly using the 
\family typewriter
pop.dvars()
\family default
 function.
 (This also implies that you can do whatever you want to the population.).
 In this example, the function form of the 
\family typewriter
stat
\family default
 operator is used to explicitly calculate allele frequency.
 The results are also explicitly printed using the 
\family typewriter
print
\family default
 command.
 The explicities lead to longer, but clearer program.
 This becomes obvious when you need to calculate and print many statistics.
\end_layout

\begin_layout Standard
The following program (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich3"

\end_inset

) uses the 
\family typewriter
pyOperator
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
pyOperator
\end_layout

\end_inset

 solution.
 In this program, user can input two demographic models as command line
 parameter.
 Two other operators are used
\end_layout

\begin_layout Itemize
A 
\family typewriter
ticToc
\family default
 operator that prints out elapsed time at every 100 generations
\end_layout

\begin_layout Itemize
A 
\family typewriter
pause
\family default
 operator that pause the simulation whenever you press a key.
 You can actually enter a python command shell to examine the results.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich3.py"
lstparams "caption={The whole program},label={reich3}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Subsection
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to run more simulations with
 different parameters like initial population size.
 Editing the script again and again is out of the question.
 Since this script is a python script, it is tempting to use python modules
 like 
\family typewriter
getopt
\family default
 to parse options from command line.
 A better choice would be using the 
\family typewriter
simuOpt
\family default
 module.
 Using this module properly, your simuPOP should be able to get options
 from short or long command line option, from a configuration file, from
 a tkInter of wxPython dialog, or from user input.
 Taking 
\family typewriter
c:
\backslash
python
\backslash
share
\backslash
simuPOP
\backslash
scripts
\backslash
simuLDDecay.py
\family default
 as an example, you can run this script as follows:
\end_layout

\begin_layout Itemize
use command '
\family typewriter
simuLDDecay.py
\family default
' or double click the program
\end_layout

\begin_layout Itemize
click the help button on the dialog, or run 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -h
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to view help information.
\end_layout

\end_deeper
\begin_layout Standard
enter parameters in a parameter dialog, or use short or long command arguments
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -s 500 -e 10 --recRate 0.1 --numRep 5 --noDialog
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
use the optimized module by
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --optimized
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
save the parameters to a config file
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --quiet -s 500 -e 10 --saveConfig decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this will result in a config file 
\family typewriter
decay.cfg
\family default
 with these parameters.
\end_layout

\begin_layout Itemize
and of course use 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
,
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --config decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to load parameters from the config file.
\end_layout

\end_deeper
\begin_layout Standard
The last function is very useful since you frequently need to run many slightly
 different simulations, saving a configuration file along with your results
 will make your life much easier.
\end_layout

\begin_layout Standard
To achieve all the above, you need to write your scripts in the following
 order:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Write the introduction of the whole script in a module-wise doc string.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'''
\end_layout

\begin_layout Plain Layout

This script will ....
\end_layout

\begin_layout Plain Layout

'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Define an option data structure.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

options = [ 
\end_layout

\begin_layout Plain Layout

...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
 The detailed description of this structure is given in simuPOP reference
 manual.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation functions
\end_layout

\begin_layout Enumerate
In the executable part of the script (under 
\family typewriter
__name__ == '__main__'
\family default
), you should call 
\family typewriter
simuOpt.getParam
\family default
 to let 
\family typewriter
simuOpt
\family default
 handle all parameter input for you and obtain a list of parameters.
 You usually need to handle some special cases (
\family typewriter
-h, --saveConfig
\family default
 etc), and they are all standard.
\end_layout

\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\begin_inset Index
status collapsed

\begin_layout Plain Layout
simuOpt
\end_layout

\end_inset


\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, print usage, save configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
 The following example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich4"

\end_inset

 shows the beginning and the execution part of the complete 
\family typewriter
reich.py
\family default
 script, which can be found under the doc directory.
 For a complete reference of the Options structure, please refer to the
 reference manual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich4.py"
lstparams "caption={Option handling},label={reich4}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Chapter
Introduction to bundled scripts
\end_layout

\begin_layout Standard
Several scripts are bundled with simuPOP, under the 
\family typewriter
/usr/share/simuPOP/scripts
\family default
 directory under a *nix system and 
\family typewriter
c:
\backslash
python25
\backslash
share
\backslash
simuPOP
\backslash
scripts
\family default
 under windows.
 These scripts all use 
\family typewriter
simuOpt
\family default
 module to organize help messages so you can get detailed information about
 the scripts and the parameter used by clicking on help button of the parameter
 dialog, or use commands like '
\family typewriter
simuComplexDisease.py -h'
\family default
 to get the help messages.
\end_layout

\begin_layout Standard
In this chapter, I will briefly explain what these scripts do, from a more
 methodology side of view.
 Be warned, though, that these scripts are less actively maintained than
 simuPOP core and I mostly rely on user bug report to identify problems
 in these scripts.
\end_layout

\begin_layout Section
Examples and teaching scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuLDDecay.py
\end_layout

\begin_layout Standard
This is the simplest script under the 
\family typewriter
scripts
\family default
 directory, showing the decay of linkage disequilibrium under recombination.
 It is intended to be a template for many more such simulations for teaching
 a population genetics course.
 
\end_layout

\begin_layout Subsection

\family typewriter
demoPyOperator.py
\end_layout

\begin_layout Standard
This script demonstrate the use of a during-mating pure-Python operator.
 Since such operator will be called very frequently (at each mating event),
 the performance of such operators tend to be bad.
 Since most of the task performed by such an operator can be achieved by
 other means (for example a post-mating operator), it is rarely used.
\end_layout

\begin_layout Section
Utility scripts
\end_layout

\begin_layout Standard
These scripts are not necessarily written in simuPOP.
 It is written to facilitate the use of simuPOP.
\end_layout

\begin_layout Subsection

\family typewriter
simuViewPop.py
\end_layout

\begin_layout Standard

\family typewriter
simuViewPop.py
\family default
 is a 
\family typewriter
wxPython
\family default
 application written to view simuPOP populations.
 You will need to have 
\family typewriter
wxPython
\family default
 installed to use it.
 There are two ways to use this script:
\end_layout

\begin_layout Itemize
Import this script and call 
\family typewriter
viewPop(pop)
\family default
 to view population 
\family typewriter
pop
\end_layout

\begin_layout Itemize
Run from command line
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ simuViewPop.py /path/to/population.txt
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This script shows four tabs to show the information of a population
\end_layout

\begin_layout Itemize
basic information
\end_layout

\begin_layout Itemize
a table view of all genotype
\end_layout

\begin_layout Itemize
calculation of statistics, with a tree-view of local name space
\end_layout

\begin_layout Itemize
save to other formats
\end_layout

\begin_layout Subsection

\family typewriter
simuCluster.py
\end_layout

\begin_layout Standard

\family typewriter
simuCluster.py
\family default
 helps you manage a large number of simulations on a cluster system.
 You only need to maintain a single job-description file and 
\family typewriter
simuCluster.py
\family default
 will help you submit them.
 The command line options are
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ simuCluster.py -l simulation.lst -a  -r -f key=val jobs
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Itemize

\family typewriter
-l (--list) list:
\family default
 a list file (actually a python file) that specifies variale 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\end_layout

\begin_layout Itemize

\family typewriter
-a (--all):
\family default
 use all jobs defined in the list file
\end_layout

\begin_layout Itemize

\family typewriter
-r (--run):
\family default
 run the jobs, by default, this script will only list the jobs and generate
 job file.
\end_layout

\begin_layout Itemize

\family typewriter
-p (--repeat) n:
\family default
 execute command 
\family typewriter
n
\family default
 times.
\end_layout

\begin_layout Itemize

\family typewriter
-f (--force):
\family default
 force the execution even if the generated job scripts have 
\family typewriter
$
\family default
 character.
\end_layout

\begin_layout Itemize

\family typewriter
key=val:
\family default
 additional subsitution key/value pair that will be used to replace 
\family typewriter
$key
\family default
 in the job scripts.
 Commonly used, or machine-specific, 
\family typewriter
key=val
\family default
 pairs can be defined in a configuration file 
\family typewriter
$HOME/.simuCluster
\family default
 with content like:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

command = 'bsub -J $name <'
\end_layout

\begin_layout Plain Layout

queue = 'batch'
\end_layout

\begin_layout Plain Layout

job_dir = '/scratch/jobs'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
job:
\family default
 a list of jobs, a simple form of regular expression can be used.
 Namely, 
\family typewriter
job1_3
\family default
 means 
\family typewriter
job1
\family default
, 
\family typewriter
job2
\family default
 and 
\family typewriter
job3
\family default
.
\end_layout

\begin_layout Standard
The list file can be any python script, that defines variables 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\family default
 after execution, where 
\family typewriter
script
\family default
 is a simple script with variables 
\family typewriter
$name
\family default
 or 
\family typewriter
${name}
\family default
.
 and 
\family typewriter
joblist
\family default
 is a string with lines of comma (can be other charater if you define a
 variable 
\family typewriter
separator
\family default
) separated fields, that will be used to replace 
\family typewriter
$0 (
\family default
also 
\family typewriter
$name
\family default
, the name of a job)
\family typewriter
, $1, $2, ...

\family default
 etc.
\end_layout

\begin_layout Standard
Then, what 
\family typewriter
simuCluster.py
\family default
 will do is process this list file, replace 
\family typewriter
$name, $var, $1, $2 ...

\family default
 etc with environmental variables, command line paramters, configuration
 file and joblist and generate job scripts.
 If 
\family typewriter
-r
\family default
 is given, the job will be submitted.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "joblist"

\end_inset

 gives a sample job list file.
 Command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ python scripts/simuCluster.py -l joblist.lst -a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will generate files 
\family typewriter
job1.pbs
\family default
, ...
 and if 
\family typewriter
-r
\family default
 option is given, these files will be submitted using 
\family typewriter
qsub job1
\family default
, unless you specify another 
\family typewriter
command
\family default
 variable.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "joblist.lst"
lstparams "caption={A sample job list file},label={joblist}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
simuUtil.py
\end_layout

\begin_layout Standard

\family typewriter
simuUtil.py
\family default
 is a standard part of simuPOP and is installed along with 
\family typewriter
simuPOP.py
\family default
 (other utility scripts are installed under 
\family typewriter
scripts
\family default
 directory).
 These function include
\end_layout

\begin_layout Enumerate
extra python operators, the two potentially useful ones are
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
tab
\end_layout

\begin_layout Itemize

\series bold
endl
\end_layout

\begin_layout Standard
These two operators output, as their names suggest, 
\family typewriter
'
\backslash
t'
\family default
 and 
\family typewriter
'
\backslash
n'
\family default
.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined demographic functions:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
constSize
\end_layout

\begin_layout Itemize

\family typewriter
LinearExpansion
\end_layout

\begin_layout Itemize

\family typewriter
ExponentialExpansion
\end_layout

\begin_layout Itemize

\family typewriter
InstantExpansion 
\end_layout

\begin_layout Standard
These functions return a demographic function with given event times.
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined migration rate functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
MigrIslandRates
\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates
\end_layout

\begin_layout Standard
These functions return a migration matrix of given migration model and parameter.
\end_layout

\end_deeper
\begin_layout Enumerate
Save and load from other formats
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
SaveFstat (saveFstat), LoadFstat
\end_layout

\begin_layout Itemize

\family typewriter
LoadGCData
\end_layout

\begin_layout Itemize

\family typewriter
SaveLinkage (saveLinkage), LoadLinkage
\end_layout

\begin_layout Itemize

\family typewriter
SaveQTDT
\end_layout

\begin_layout Itemize

\family typewriter
SaveCSV
\end_layout

\begin_layout Standard
These functions save and load simuPOP populations in various formats.
\end_layout

\end_deeper
\begin_layout Enumerate
Gene mapping functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
TDT_gh, LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
ChiSq_test
\end_layout

\begin_layout Itemize

\family typewriter
LOD_merlin, VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_TDT_gh, Sibpair_LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_LOD_merlin, QtraitSibs_Reg_Merlin, QtriatSibs_VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
LargePeds_Reg_merlin, LargePeds_VC_merlin
\end_layout

\begin_layout Standard
These functions call GENEHUNTER or MERLIN to map disease genes.
 Various parameters like penetrance, quantitative trait functions, sample
 size are needed.
 These functions are tested only under Linux and are subject to frequent
 changes.
\end_layout

\end_deeper
\begin_layout Standard
In general, these utility functions are provided as it is and you may need
 to read the source code to make it work should errors occur.
 Unit test will be added later when these functions are more or less stablized/s
tandardized.
\end_layout

\begin_layout Section
General simulation scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuCDCV.py
\end_layout

\begin_layout Standard
This script is used to simulate the evolution of allelic spectra (number
 and allele freqencies of alleles at a locus) for monogenic or polygenic,
 rare or common diseases.
 The goal of the simulations is to validate the common disease common variant
 hypothesis
\begin_inset CommandInset citation
LatexCommand citep
key "Lander1996"

\end_inset

.
 I used this script to verify two theoretical models proposed by Pritchard
 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Pritchard2001"

\end_inset

 and Reich and Lander 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Reich2001a"

\end_inset

.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuRecHotSpots.py
\end_layout

\begin_layout Standard
I wrote this script to simulate the evolution of a chromosome, subject to
 recombination of uniform recombination rate.
 Using this script, I would like to see how many recombination hotspots
 can be observed if there is no physical recombination hotspots, i.e.
 actual variation of recombination rate on the chromosome.
 The population is saved in LDhat format to be analyzed by LDhat 
\begin_inset CommandInset citation
LatexCommand citep
key "Myers2005"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuNeutralSNPs.py
\end_layout

\begin_layout Standard
This script is adapted from 
\family typewriter
simuRecHotSplots.py
\family default
, the main purpose is to observe the evolution of allele frequency under
 more complicated scenarios than classical population genetics theory can
 handle.
\end_layout

\begin_layout Section
Simulations of the evolution of complex human diseases
\end_layout

\begin_layout Subsection

\family typewriter
simuForward.py
\end_layout

\begin_layout Standard
This script presents my first attempt to simulate the evolution of complex
 human diseases in a forward-time manner and generate samples for gene mapping
 purposes.
 The script goes like this:
\end_layout

\begin_layout Itemize
initialize a small (likely 10K) founder population with a few haplotypes
\end_layout

\begin_layout Itemize
burn-in this founder population for a few thousands generations to break
 down linkage disequilibrium
\end_layout

\begin_layout Itemize
after this stage, the population starts to expand.
 It can be split into several subpopulations (simulate human subpopulations),
 with and/or without migration and be merged back to a single population.
\end_layout

\begin_layout Itemize
At the beginning of population expansion, several disease mutants are introduced
 to the population.
 Positive or negative selection is applied to individuals with disease mutants.
 We hope to harvest a final population with certain disease allele frequency.
\end_layout

\begin_layout Standard
This process is problematic in that
\end_layout

\begin_layout Itemize
The disease allele can get lost
\end_layout

\begin_layout Itemize
We can not control the disease allele frequency at the last generation
\end_layout

\begin_layout Standard
To solve the first problem, I re-introduce disease mutants if they get lost.
 I also apply, optionally, strong positive selection pressure during an
 disease-introduction stage to artificially boost the disease allele frequency,
 until it reach a designed range of allele frequencies.
 If the disease allele still get lost after the disease introduction stage,
 the simulation will be restarted.
 By manipulating parameters like designed allele frequency and population
 size, the impact of genetic drift can be moderate and give me a final populatio
n with designed disease allele frequency.
 This simulation scenario roughly follows that of Calafell et al 
\begin_inset CommandInset citation
LatexCommand citet
key "Calafell2001"

\end_inset

.
\end_layout

\begin_layout Standard
To save simulation time, population at the end of the burnin stage is reused
 if simulation gets restarted.
\end_layout

\begin_layout Subsection

\family typewriter
simuComplexDisease.py
\end_layout

\begin_layout Standard
The previous simulation scenario is not satisfactory in that
\end_layout

\begin_layout Itemize
The age of mutant is fixed, but they should be somehow random
\end_layout

\begin_layout Itemize
Mutants can get lost and the simulation needs to be restarted repeatedly.
 This problem can be severe if we simulate mutants under purifying selection.
\end_layout

\begin_layout Itemize
We still can not control the final disease allele frequency well.
 The variation of disease allele frequencies in the final generation makes
 fair comparison between gene mapping methods difficult.
\end_layout

\begin_layout Standard
Therefore, I propose a simulation method, which is still under review, that
\end_layout

\begin_layout Itemize
simulate, backward in time, the trajectory of disease allele frequencies.
 The age of mutant is determined by trajectory length, and is random.
\end_layout

\begin_layout Itemize
Then, the script simulate forward in time using a controlled random mating
 scheme that follow the pre-simulated disease allele trajectories.
 The resulting population will have exact designed allele frequency.
\end_layout

\begin_layout Standard
An obvious advantage of this approach is that the simulation does not have
 to be restarted, and the disease allele frequency at the last generation
 can be controlled exactly.
\end_layout

\begin_layout Subsection

\family typewriter
analComplexDisease.py
\end_layout

\begin_layout Standard
I use 
\family typewriter
simuComplexDiseas.py
\family default
 to simulate many population under various genetic and demographic models.
 The resulting populations are analyzed by this script.
 The analyses involved are
\end_layout

\begin_layout Itemize
merlin variance component method 
\begin_inset CommandInset citation
LatexCommand citep
key "Abecasis2002,Amos1994"

\end_inset


\end_layout

\begin_layout Itemize
merlin regression 
\begin_inset CommandInset citation
LatexCommand citep
key "sham2002"

\end_inset


\end_layout

\begin_layout Itemize
TDT 
\begin_inset CommandInset citation
LatexCommand citep
key "Spielman1993"

\end_inset


\end_layout

\begin_layout Itemize
Linkage, and
\end_layout

\begin_layout Itemize
Case control association study.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "simuPOP"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
