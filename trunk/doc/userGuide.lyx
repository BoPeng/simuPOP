#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.9.7 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand{\lstlistlistingname}{List of Examples}
\renewcommand{\lstlistingname}{Example}

\sloppy

\definecolor{TitleColor}{rgb}{0.126,0.263,0.361}
\definecolor{LinkColor}{rgb}{0.208,0.374,0.486}
\definecolor{VerbatimColor}{rgb}{0,0,0}
\definecolor{VerbatimBackgroundColor}{rgb}{0.98,0.941,0.902}
\definecolor{VerbatimBorderColor}{rgb}{0,0,0}
\definecolor{VerbatimStringColor}{rgb}{0,0.5,0}
\definecolor{VerbatimCommentColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimPromptColor}{rgb}{0.588,0.098,0.054}

\usepackage{sectsty}
\sectionfont{\color{TitleColor}}
\subsectionfont{\color{TitleColor}}
\subsubsectionfont{\color{TitleColor}}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "simuPOP User's Guide"
\pdf_author "Bo Peng"
\pdf_keywords "simuPOP"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=TitleColor,urlcolor=LinkColor"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "alsoletter={>.},backgroundcolor={\color{VerbatimBackgroundColor}},basicstyle={\small\ttfamily\color{VerbatimColor}},commentstyle={\color{VerbatimCommentColor}\slshape},emph={[2]>>>,...},emphstyle={[2]\color{VerbatimPromptColor}\bf},language=Python,otherkeywords={>>>,...},showspaces=false,showstringspaces=false,showtabs=false,stringstyle={\color{VerbatimStringColor}},xleftmargin=10pt"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{7.5in} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2008 Bo Peng 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
simuPOP is provided as a number of Python modules, which provide of a large
 number of Python objects and functions, including population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 bundled scripts that perform simulations ranging from implementation of
 basic population genetics models to generating datasets under complex evolution
ary scenarios.
 No knowledge about Python or simuPOP would be needed to run these simulations,
 if they happen to fit your need.
\end_layout

\begin_layout Abstract
This user's guide shows you how to install and use simuPOP using a large
 number of examples.
 It describes all important concepts and features of simuPOP and shows you
 how to use them in a simuPOP script.
 For a complete and detailed description about all simuPOP functions and
 classes, please refer to the 
\emph on
simuPOP Reference Manual
\emph default
.
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP:
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
 (18): 3686-3687
\end_layout

\begin_layout Quote
Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
 mating populations using simuPOP.
 
\emph on
bioinformatics
\emph default
, 
\series bold
24
\series default
 (11) 1408-1409.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 'runSampleCode.py splitMerge.py', and simuPOP_ref.tex generated by 'doxygen;
 cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard
simuPOP is an individual-based forward-time population genetics simulation
 environment based on Python, a dynamic object-oriented programming language
 that has been widely used in biological studies.
 simuPOP provides a large number of Python objects and functions, and a
 mechanism to evolve populations forward in time.
 It is the users’ responsibility to write a Python script to form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 built-in scripts so that users who are unfamiliar with Python and simuPOP
 can perform some pre-specified simulation processes.
 These scripts range from implementation of basic population genetics models
 to generating datasets under complex evolutionary scenarios.
 In addition, simuPOP modules and functions are provided to load and manipulate
 HapMap samples and to perform a number of popular gene-mapping methods.
\end_layout

\begin_layout Standard
Unlike other population genetics simulation applications that aim at specific
 evolutionary scenarios, simuPOP aims at providing a general purpose simulation
 program that can be used to write and study arbitrarily complex evolutionary
 scenarios.
 This makes simuPOP an ideal tool in a wide variety of applications ranging
 from demonstrating simple population genetics models to studying the evolution
 of complex human genetic diseases.
\end_layout

\begin_layout Section
An overview of simuPOP concepts
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
population
\series default
 consists of individuals of the same 
\series bold
genotype structure
\series default
, which include properties such as number of homologous sets of chromosomes
 (ploidy), number of chromosomes, and names and locations of markers on
 each chromosome.
 Individuals can be divided into 
\series bold
subpopulations
\series default
 that can be further divided into 
\series bold
virtual subpopulations
\series default
 according to individual properties such as sex, affection status, or arbitrary
 auxiliary information such as age.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:life-cycle"

\end_inset

A life cycle of an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/evolve.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
Illustration of the discrete-generation evolutionary model used by simuPOP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators
\series default
 are Python objects that act on a population.
 They can be applied to a population before or after mating during a life
 cycle of an evolutionary process (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), or to one or two parents during the production of each offspring.
 Arbitrary numbers of operators can be applied to an evolving population.
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
mating scheme
\series default
 is responsible for choosing parent or parents from a parental (virtual)
 subpopulation and for populating an offspring subpopulation.
 simuPOP provides a number of pre-defined mating schemes, such as random,
 consanguineous, monogamous, or polygamous mating, selfing, and haplodiploid
 mating in hymenoptera.
 More complicated nonrandom mating schemes such as mating in age-structured
 populations can be constructed using 
\series bold
heterogeneous mating schemes
\series default
.
 
\end_layout

\begin_layout Standard
simuPOP evolves a population generation by generation, following the evolutionar
y cycle depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

.
 Briefly speaking, a number of 
\series bold
pre-mating operators
\series default
 such as a 
\family typewriter
mutator
\family default
 are applied to a population before a mating scheme repeatedly chooses a
 parent or parents to produce offspring.
 
\series bold
During-mating operators
\series default
 such as 
\emph on
recombinator
\emph default
 can be used to adjust how offspring genotypes are formed from parental
 genotypes.
 After an offspring population is populated, 
\series bold
post-mating operators
\series default
 can be applied, for example, to calculate population statistics.
 The offspring population will then become the parental population of the
 next evolutionary cycle.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simpleExample.log"
lstparams "caption={A simple example},label={simple-example}"

\end_inset


\end_layout

\begin_layout Standard
These concepts are demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, where a standard diploid Wright-Fisher model with recombination is simulated.
 The first line imports the standard simuPOP module.
 The second line creates a diploid population with 1000 individuals, each
 having one chromosome with two loci.
 The third line creates a simulator with three replicates of this population.
 Random mating will be used to generate offspring but a 
\family typewriter
recombinator
\family default
 is used to recombine parental chromosomes with the given recombination
 rate 
\family typewriter
0.01
\family default
 during the generation of offspring.
 The last statement uses the 
\family typewriter
evolve()
\family default
 function to evolve the populations for 100 generations, subject to five
 operators.
\end_layout

\begin_layout Standard
The first operator 
\family typewriter
initByValue
\family default
 is applied to all populations before evolution.
 This operator initializes all individuals with the same genotype 
\family typewriter
12/21
\family default
.
 The other operators can be applied at every generation.
  
\family typewriter
stat
\family default
 calculates linkage disequilibrium between the first and second loci.
 The results of this operator are stored in a local variable space of each
 population.
 The last two operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOutput
\family default
 are applied at the end of every 10 generations.
 
\family typewriter
pyEval
\family default
 is applied to all replicates to output calculated linkage disequilibrium
 values with a trailing tab, and the last operator outputs a newline after
 the last replicate.
 The result is a table of three columns, representing the decay of linkage
 disequilibrium of each replicate at 10 generation intervals.
 The return value of the 
\family typewriter
evolve
\family default
 function, which is the number of evolved generations for each replicate,
 is also printed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
simuPOP offers a long list of features, many of which are unique among all
 forward-time population genetics simulation programs.
 The most distinguished features include:
\end_layout

\begin_layout Enumerate
simuPOP provides three types of modules that use 1, 8 or 32 bits to store
 an allele.
 The binary module (1 bit) is suitable for simulating a large number of
 SNP markers and the long module (32 bits) is suitable for simulating some
 population genetics models such as the infinite allele mutation model.
 simuPOP supports different types of chromosomes such as autosome, sex chromosom
es and mitochondrial, with arbitrary number of markers.
\end_layout

\begin_layout Enumerate
An arbitrary number of float numbers, called information fields, can be
 attached to individuals of a population.
 For example, information field father_idx and mother_idx are used to track
 an individual’s parents, and pack_year can be used to simulate an environmental
 factor associated with smoking.
\end_layout

\begin_layout Enumerate
simuPOP does not impose any limit on number of homologous sets of chromosomes,
 the size of the genome, or the number of individuals in a population.
 During an evolutionary process, a population can hold more than one most-recent
 generations.
 Pedigrees can be sampled from such multi-generation populations.
\end_layout

\begin_layout Enumerate
An operator can be native (implemented in C++) or hybrid (Python assisted).
 A hybrid operator calls a user-provided Python function to implement arbitrary
 genetic effects.
 For example, a hybrid mutator passes to-be-mutated alleles to a user-provided
 function and mutates these alleles according to the returned values.
\end_layout

\begin_layout Enumerate
simuPOP provides more than 70 operators that cover all important aspects
 of genetic studies.
 These include mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise and hybrid), migration (arbitrary,
 can create new subpopulation), recombination and gene conversion (uniform
 or nonuniform, sex-specific), quantitative trait (single, multilocus or
 hybrid), selection (single-locus, additive, multiplicative or hybrid multi-locu
s models), penetrance (single, multi-locus or hybrid), ascertainment (case–contr
ol, affected sibpairs, random, nuclear and large pedigree), statistics calculati
on (including but not limited to allele, genotype, haplotype, heterozygote
 number and frequency; expected heterozygosity; bi-allelic and multi-allelic
 , and linkage disequilibrium measures), pedigree tracing, visualization
 (using R or other Python modules) and load/save in simuPOP’s native format
 and many external formats such as Linkage.
\end_layout

\begin_layout Enumerate
Mating schemes and many operators can work on virtual subpopulations of
 a subpopulation.
 For example, positive assortative mating can be implemented by mating individua
ls with similar properties such as ancestry.
 The number of offspring per mating event can be fixed, or can follow a
 statistical distribution.
\end_layout

\begin_layout Standard
A number of forward-time simulation programs are available.
 If we exclude early forward-time simulation applications developed primarily
 for teaching purposes, notable forward-time simulation programs include
 
\emph on
easyPOP
\emph default
, 
\emph on
FPG
\emph default
, 
\emph on
Nemo
\emph default
 and 
\emph on
quantiNemo
\emph default
, 
\emph on
genoSIM
\emph default
 and 
\emph on
genomeSIMLA
\emph default
, 
\emph on
FreGene
\emph default
, 
\emph on
GenomePop
\emph default
, 
\emph on
ForwSim
\emph default
, and 
\emph on
ForSim
\emph default
.
 These programs are designed with specific applications and specific evolutionar
y scenarios in mind, and excel in what they are designed for.
 For some applications, these programs may be easier to use than simuPOP.
 For example, using a special look-ahead algorithm, 
\emph on
ForwSim
\emph default
 is among the fastest programs to simulate a standard Wright-Fisher process,
 and should be used if such a simulation is needed.
 However, these programs are not flexible enough to be applied to problems
 outside of their designed application area.
 For example, none of these programs can be used to study the evolution
 of a disease predisposing mutant, a process that is of great importance
 in statistical genetics and genetic epidemiology.
 Compared to such programs, simuPOP has the following advantages:
\end_layout

\begin_layout Itemize
The scripting interface gives simuPOP the flexibility to create arbitrarily
 complex evolutionary scenarios.
 For example, it is easy to use simuPOP to explicitly introduce a disease
 predisposing mutant to an evolving population, trace the allele frequency
 of them, and restart the simulation if they got lost due to genetic drift.
\end_layout

\begin_layout Itemize
The Python interface allows users to define customized genetic effects in
 Python.
 In contrast, other programs either do not allow customized effects or force
 users to modify code at a lower (e.g.
 C++) level.
\end_layout

\begin_layout Itemize
simuPOP is the only application that embodies the concept of virtual subpopulati
on that allows evolutions at a finer scale.
 This is required for realistic simulations of complex evolutionary scenarios.
\end_layout

\begin_layout Itemize
simuPOP allows users to examine an evolutionary process very closely because
 all simuPOP objects are Python objects that can be assessed using their
 member functions.
 For example, users can keep track of genotype at particular loci during
 evolution.
 In contrast, other programs work more or less like a black box where only
 limited types of statistics can be outputted.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
simuPOP is distributed under a GPL license and is hosted on
\family typewriter
 http://simupop.sourceforge.net
\family default
, the world's largest development and download repository of Open Source
 code and applications.
 simuPOP is available on any platform where Python is available, and is
 currently tested under both 32 and 64 bit versions of Windows (Windows
 2000 and later), Linux (Redhat), MacOS X and Sun Solaris systems.
 Different C++ compilers such as Microsoft Visual C++, gcc and Intel icc
 are supported under different operating systems.
 Standard installation packages are provided for Windows, Linux, MacOS X,
 and Sun Solaris systems.
\end_layout

\begin_layout Standard
If a binary distribution is unavailable for a specific platform, it is usually
 easy to compile simuPOP from source, following the standard 
\family typewriter

\begin_inset Quotes eld
\end_inset

python setup.py install
\begin_inset Quotes erd
\end_inset


\family default
 procedure.
 Besides a C++ compiler, several supporting tools and libraries are needed.
 Please refer to the 
\family typewriter
INSTALL
\family default
 file for further information.
\end_layout

\begin_layout Standard
Thanks to the ‘glue language’ nature of Python, it is easy to inter-operate
 Python with other applications within a simuPOP script.
 For example, users can call any R function from Python/simuPOP for the
 purposes of visualization and statistical analysis, using 
\series bold
R
\series default
 and a Python module 
\series bold
RPy
\series default
.
 This technique is widely used in simuPOP so it is highly recommended that
 you install R and rpy is your are familiar with R.
 In addition, although simuPOP uses the standard tkInter GUI toolkit when
 a graphical user interface is needed, it can make use of a 
\series bold
wxPython
\series default
 toolkit if it is available.
\end_layout

\begin_layout Section
Pythonic issues
\end_layout

\begin_layout Subsection

\family typewriter
from simuPOP import
\family default
 * v.s.
 
\family typewriter
import simuPOP
\end_layout

\begin_layout Standard
Generally speaking, it is recommended to use 
\family typewriter
import simuPOP
\family default
 rather than 
\family typewriter
from simuPOP import *
\family default
 to import a simuPOP module.
 That is to say, instead of using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuPOP import *
\end_layout

\begin_layout Plain Layout

pop = population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

simu = simulator(pop, randomMating())
\end_layout

\begin_layout Plain Layout

# use submodule simuPOP.utils directly
\end_layout

\begin_layout Plain Layout

utils.BackwardTrajectory(N=1000, endGen=100, endFreq=0.1)
\end_layout

\end_inset

it is recommended that you use simuPOP like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import simuPOP
\end_layout

\begin_layout Plain Layout

pop = simuPOP.population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

simu = simuPOP.simulator(pop, simuPOP.randomMating())
\end_layout

\begin_layout Plain Layout

# import and use submodule simuPOP.utils
\end_layout

\begin_layout Plain Layout

import simuPOP.utils
\end_layout

\begin_layout Plain Layout

simuPOP.utils.BackwardTrajectory(N=1000, endGen=100, endFreq=0.1)
\end_layout

\end_inset

The major problem with from 
\family typewriter
simuPOP import *
\family default
 is that it imports all simuPOP symbols to the global namespace and increases
 the chance of name clashes.
 For example, if you import a module 
\family typewriter
myModule
\family default
 after simuPOP, which happens to have a variable named 
\family typewriter
Male
\family default
, the following code might lead to a 
\family typewriter
TypeError
\family default
 indicating your input for parameter sex is wrong.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuPOP import *
\end_layout

\begin_layout Plain Layout

from myModule import *
\end_layout

\begin_layout Plain Layout

pop = population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

InitSex(pop, sex=[Male, Female])
\end_layout

\end_inset

It can be even worse if the definition of 
\family typewriter
Male
\family default
 is changed to a different value of the same type (e.g.
 to 
\family typewriter
Female
\family default
) and your simulation might produce erroranous result without a hint.
\end_layout

\begin_layout Standard
Although the 
\family typewriter
import simuPOP
\family default
 style is recommended, especially for large scripts that import a number
 of modules, all examples demonstrated in this user's guide use the 
\family typewriter
import *
\family default
 style for the sake of brevity.
 If you really dislike the omnipresence of the 
\family typewriter
simuPOP
\family default
 prefix, you could
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
from simuPOP import *
\family default
 style but import and refer all other modules by name.
\end_layout

\begin_layout Itemize
Use 
\family typewriter
import simuPOP as sim
\family default
, and use simuPOP like 
\family typewriter
sim.population()
\family default
.
\end_layout

\begin_layout Subsection
References and the 
\family typewriter
clone() 
\family default
member function
\end_layout

\begin_layout Standard
Assignment in Python only creates a new reference to an existing object.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop = population()
\end_layout

\begin_layout Plain Layout

pop1 = pop
\end_layout

\end_inset

will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well and the removal of 
\family typewriter
pop
\family default
 will invalidate 
\family typewriter
pop1
\family default
.
 For example, a reference to the first population in a simulator is returned
 from function 
\family typewriter
func()
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

.
 The subsequent use of this 
\family typewriter
pop
\family default
 object may crash simuPOP because the simulator 
\family typewriter
simu
\family default
 is destroyed, along with all its internal populations, after 
\family typewriter
func()
\family default
 is finished, leaving 
\family typewriter
pop
\family default
 referring to an invalid object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Reference-to-population"

\end_inset

Reference to a population in a simulator
\end_layout

\end_inset

def func():
\end_layout

\begin_layout Plain Layout

    simu = simulator(population(10), randomMating(), rep=5)
\end_layout

\begin_layout Plain Layout

    # return a reference to the first population in the simulator
\end_layout

\begin_layout Plain Layout

    return simu.population(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pop = func()
\end_layout

\begin_layout Plain Layout

# simuPOP will crash because pop refers to an invalid population.
\end_layout

\begin_layout Plain Layout

pop.popSize()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to have an independent copy of a population, you can use
 the 
\family typewriter
clone()
\family default
 member function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

 would behave properly if the 
\family typewriter
return
\family default
 statement is replaced by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.population(0).clone()
\end_layout

\end_inset

although in this specific case, extracting the first population from the
 simulator using the 
\family typewriter
extract
\family default
 function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.extract(0)
\end_layout

\end_inset

would be more efficient because we do not need to copy the first population
 from 
\family typewriter
simu
\family default
 if it will be destroyed soon.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
clone()
\family default
 function exists for all simuPOP classes (objects) such as 
\emph on
simulator
\emph default
, 
\emph on
mating schemes
\emph default
 and 
\emph on
operators
\emph default
.
 simuPOP also supports the standard Python shallow and deep copy operations
 so you can also make a cloned copy of 
\family typewriter
pop
\family default
 using the 
\family typewriter
deepcopy
\family default
 function defined in the Python 
\family typewriter
copy
\family default
 module
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy
\end_layout

\begin_layout Plain Layout

pop1 = copy.deepcopy(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zero-based indexes, absolute and relative indexes
\end_layout

\begin_layout Standard

\series bold
All arrays in simuPOP start at index 0
\series default
.
 This conforms to Python and C++ indexes.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the 
\emph on
absolute index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and the 
\emph on
relative index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 of a locus.
 The former index ignores chromosome structure.
 For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two chromosomes are (0, 1, 2, 3, 4), (5, 6, 7,
 8, 9, 10, 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3,
 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(idx)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 An individual can also be referred by its 
\emph on
absolute index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and 
\emph on
relative index
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 where 
\emph on
relative index
\emph default
 is the index in its subpopulation.
 Related member functions are 
\family typewriter
subPopIndPair(idx)
\family default
 and 
\family typewriter
absIndIndex(idx, subPop)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/absIndex.log"
lstparams "caption={Conversion between absolute and relative indexes},label={absIndex}"

\end_inset


\end_layout

\begin_layout Subsection
Ranges and iterators
\end_layout

\begin_layout Standard
Ranges in simuPOP also conform to Python ranges.
 That is to say, a range has the form of 
\family typewriter
[a,b) 
\family default
where 
\family typewriter
a 
\family default
belongs to the range, and 
\family typewriter
b 
\family default
does not.
 For example, 
\family typewriter
pop.chromBegin(1) 
\family default
refers to the index of the first locus on chromosome 1 (actually exists),
 and 
\family typewriter
pop.chromEnd(1) 
\family default
refers to the index of the last locus on chromosome 1 
\series bold
plus 1
\series default
, which might or might not be a valid index.
\end_layout

\begin_layout Standard
A number of simuPOP functions return Python iterators that can be used to
 iterate through an internal array of objects.
 For example, 
\family typewriter
population.individuals([subPop])
\family default
 returns an iterator that can be used to iterate through all individuals,
 or all individuals in a (virtual) subpoulation.
 
\family typewriter
simulator.populations()
\family default
 can be used to iterate through all populations in a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of ranges and iterators in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/iterator.log"
lstparams "caption={Ranges and iterators},label={iterator.log}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
carray
\family default
 datatype
\begin_inset CommandInset label
LatexCommand label
name "sub:carray-datatype"

\end_inset


\end_layout

\begin_layout Standard
simuPOP uses mostly standard Python types such as tuples, lists and dictionaries.
 However, for efficiency considerations, simuPOP defines and uses a new
 
\family typewriter
carray 
\family default
datatype to refer to an internal array of genotypes.
 Such an object can only be returned from 
\family typewriter
individual.genotype
\family default
 and 
\family typewriter
population.genotype
\family default
 functions.
 Instead of copying all genotypes to a Python tuple or list, these functions
 return a 
\family typewriter
carray 
\family default
object that directly reflect the underlying genotype.
 This object behaves like a regular Python list except that the underlying
 genotype will be changed if elements of this object are changed.
 In addition, elements in this array will be changed if the underlying genotype
 is changed using another method.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of this datatype.
 It also shows how to get an independent list of alleles using the 
\family typewriter
list()
\family default
 built-in function.
 Compare to 
\family typewriter
allele()
\family default
, 
\family typewriter
setAllele()
\family default
 and 
\family typewriter
setGenotype()
\family default
 functions, it is usually more efficient and more convenient to read and
 write genotypes using carray objects, although this usage is usually less
 readable.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/carray.log"
lstparams "caption={The carray datatype},label={carraydatatype}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
defdict
\family default
 datatype
\end_layout

\begin_layout Standard
simuPOP uses dictionaries to save statistics such as allele frequencies.
 For example, 
\family typewriter
alleleFreq[5]
\family default
 can be 
\family typewriter
{0:0.2, 3:0.8}
\family default
 meaning there are 20% allele 0 and 80% allele 3 at locus 5 in a population.
 However, because it is sometimes unclear whether or not a particular allele
 exists in a population, 
\family typewriter
alleleFreq[5][allele]
\family default
 can fail with a 
\family typewriter
KeyError
\family default
 exception if 
\family typewriter
alleleFreq[5]
\family default
 does not have key 
\family typewriter
allele
\family default
.
\end_layout

\begin_layout Standard
To address this problem, a special default dictionary type 
\family typewriter
defdict
\family default
 is used for dictionaries with keys determined from a population.
 This derived dictionary type works just like a regular dictionay, but it
 returns 0, instead of raising a 
\family typewriter
KeyError
\family default
 exception, when an invalid key is used.
 For example, subpopulations in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "defdictType"

\end_inset

 have different alleles.
 Although 
\family typewriter
pop.dvars(sp).alleleFreq[0]
\family default
 have only two keys for 
\family typewriter
sp=0
\family default
 or 
\family typewriter
1
\family default
, 
\family typewriter
pop.dvars(sp).alleleFreq[0][x]
\family default
 are used to print frequencies of alleles 
\family typewriter
0
\family default
, 
\family typewriter
1
\family default
 and 
\family typewriter
2
\family default
.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/defdict.log"
lstparams "caption={The defdict datatype},label={defdictType}"

\end_inset


\end_layout

\begin_layout Note
The standard 
\family typewriter
collections
\family default
 module of Python has a 
\family typewriter
defaultdict
\family default
 type that accepts a default factory function that will be used when an
 invalid key is encountered.
 The 
\family typewriter
defdict
\family default
 type is similar to 
\family typewriter
defaultdict(int)
\family default
 but with an important difference: when an invalid key is encountered, 
\family typewriter
d[key]
\family default
 with a default value will be inserted to a 
\family typewriter
defaultdict(int)
\family default
, but will not be inserted to a 
\family typewriter
defdict
\family default
.
 That is to say, it is safe to use 
\family typewriter
alleleFreq[loc].keys()
\family default
 to get available alleles after non-assignment 
\family typewriter
alleleFreq[loc][allele]
\family default
 operations.
\end_layout

\begin_layout Subsection
Parameter names and single and list input of parameters
\end_layout

\begin_layout Standard
simuPOP follows (at least tries to follow) the following naming convention:
\end_layout

\begin_layout Itemize
If a parameter only accept a single input, singular names such as 
\family typewriter
field
\family default
, 
\family typewriter
locus
\family default
, 
\family typewriter
value
\family default
, and 
\family typewriter
name
\family default
 are used.
\end_layout

\begin_layout Itemize
If a parameter accepts a list of values, plural names such as 
\family typewriter
fields
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
values
\family default
 and 
\family typewriter
names
\family default
 are used.
\end_layout

\begin_layout Itemize

\series bold
Plural form parameters usually accept single inputs.

\series default
 For example, 
\family typewriter
loci=1
\family default
 can be used as a shortcut for 
\family typewriter
loci=[1]
\family default
 and 
\family typewriter
infoFields='x'
\family default
 can be used as a shortcut for 
\family typewriter
infoFields=['x']
\family default
.
\end_layout

\begin_layout Standard
The same rules also hold for function names.
 For example, 
\family typewriter
population.addInfoFields()
\family default
 accept a list of information fields but 
\family typewriter
pop.addInfoFields('field')
\family default
 is also acceptable.
\end_layout

\begin_layout Subsection
Value 
\family typewriter
AllAvail
\family default
 for parameters 
\family typewriter
loci
\family default
, 
\family typewriter
reps
\family default
 and 
\family typewriter
subPops
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
loci
\family default
, 
\family typewriter
reps
\family default
 and 
\family typewriter
subPops
\family default
 are widely used in simuPOP to specify which loci, replicates or (virtual)
 subpulations a function or operator is applied to.
 These parameter accepts a list of values such as 
\family typewriter
[1, 2]
\family default
 and take single form inputs (e.g.
 
\family typewriter
loci=1
\family default
 is equivalent to 
\family typewriter
loci=[1]
\family default
).
 For example,
\end_layout

\begin_layout Itemize

\family typewriter
recombinator(loci=[])
\family default
 recombine at no locus, and
\end_layout

\begin_layout Itemize

\family typewriter
recombinator(loci=1)
\family default
 recombine at locus 1
\end_layout

\begin_layout Itemize

\family typewriter
recombinator(loci=[1,2,4])
\family default
 recombine at loci 1, 2, and 4
\end_layout

\begin_layout Standard
However, in the majority of the cases, these parameters take a default value
 
\family typewriter
AllAvail
\family default
 which applies the function or operator to all available loci, replicates
 or subpopulations.
 That is to say, 
\family typewriter
recombinator()
\family default
 or 
\family typewriter
recombinator(loci=AllAvail)
\family default
 will recombine at all applicable loci, which will vary from population
 to population.
\end_layout

\begin_layout Section
Getting help
\end_layout

\begin_layout Subsection
Online help system
\end_layout

\begin_layout Standard
Most of the help information contained in this document and 
\emph on
the simuPOP reference manual
\emph default
 is available from command line.
 For example, after you install and import the simuPOP module, you can use
 
\family typewriter
help(population.addInfoField) 
\family default
to view the help information of member function 
\family typewriter
addInfoField
\family default
 of class 
\family typewriter
population
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/help.log"
lstparams "caption={Getting help using the \\texttt{help()} function},keywordstyle={\\ttfamily}"

\end_inset


\end_layout

\begin_layout Standard
It is important that you understand that
\end_layout

\begin_layout Itemize
The constructor of a class is named 
\family typewriter
__init__
\family default
 in Python.
 That is to say, you should use the following command to display the help
 information of the constructor of class 
\family typewriter
population
\family default
: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> help(population.__init__)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some classes are derived from other classes and have access to member functions
 of their base classes.
 For example, class 
\family typewriter
population
\family default
 and 
\family typewriter
individual
\family default
 are both derived from class 
\family typewriter
GenoStruTrait
\family default
.
 Therefore, you can use all 
\family typewriter
GenoStruTrait
\family default
 member functions from these classes.
 
\end_layout

\begin_deeper
\begin_layout Standard
In addition, the constructor of a derived class also calls the constructor
 of its base class so you may have to refer to the base class for some parameter
 definitions.
 For example, parameters 
\family typewriter
begin, end, step, at 
\family default
etc are shared by all operators, and are explained in details only in class
 
\family typewriter
baseOperator.
\end_layout

\end_deeper
\begin_layout Subsection
Debug-related operators/functions
\end_layout

\begin_layout Standard
If your simuPOP session or script does not behave as expected, it might
 be helpful to let simuPOP print out some debug information.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is unclear why this simple command causes us trouble, instead of outputting
 the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Turn on/off debug information
\end_layout

\end_inset

>>> TurnOnDebug('DBG_POPULATION')
\end_layout

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\begin_layout Plain Layout

Constructor of population is called
\end_layout

\begin_layout Plain Layout

Destructor of population is called 
\end_layout

\begin_layout Plain Layout

Segmentation fault (core dumped)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
population(1, loci=[100])
\family default
 creates a temporary object that is destroyed right after the execution
 of the command.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is to create a persistent population object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> pop = population(1, loci=[100])
\end_layout

\begin_layout Plain Layout

>>> pop.individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can use 
\family typewriter
TurnOnDebug(code) 
\family default
and 
\family typewriter
TurnOffDebug(code) 
\family default
to turn on and off debug information where 
\family typewriter
code 
\family default
can be any debug code listed in 
\family typewriter
ListDebugCode
\begin_inset Index
status collapsed

\begin_layout Plain Layout
listDebugCode
\end_layout

\end_inset

()
\family default
.
 If you would like to turn on debugging during an evolutionary process,
 you can use operators 
\family typewriter
turnOnDebug 
\family default
and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Note
All debug information is written to Python 
\family typewriter
sys.stderr
\family default
.
 It is possible to redirect it to a file so that debug information is not
 mixed with regular output.
\end_layout

\begin_layout Subsection
Other help sources
\end_layout

\begin_layout Standard
If you are new to Python, it is recommended that you borrow a Python book,
 or at least go through the following online Python tutorials:
\end_layout

\begin_layout Enumerate
The Python tutorial (
\family typewriter
http://docs.python.org/tut/tut.html
\family default
)
\end_layout

\begin_layout Enumerate
Other online tutorials listed at 
\family typewriter
http://www.python.org/doc/
\end_layout

\begin_layout Standard
If you are new to simuPOP, please read this guide before you dive into 
\emph on
the simuPOP reference manual
\emph default
, which describes all the details of simuPOP but does not show you how to
 use it.
 The PDF versions of both documents are distributed with simuPOP.
 You can also get the latest version of the documents online, from the simuPOP
 subversion repository ( 
\family typewriter
http://simupop.sourceforge.net
\family default
, click
\family sans
 SF.net summary > Code > SVN Browse > trunk > doc
\family default
).
 However, because simuPOP is under active development, there may be discrepancie
s between your local simuPOP installation and these latest documents.
\end_layout

\begin_layout Standard
A number of bundled scripts are distributed with simuPOP.
 They range from simple demonstration of population genetics models to observing
 the evolution of complex human genetic diseases.
 These scripts can be a good source to learn how to write a simuPOP script.
 Of course, if any of these scripts happens to fit your need, you may be
 able to use them directly, with writing a line of code.
\end_layout

\begin_layout Standard
A 
\emph on
simuPOP cookbook
\emph default
 is under development.
 The goal of this book is to provide recipes of commonly used simulation
 scenarios.
 A number of recipes are currently available under the 
\family typewriter
doc/cookbook
\family default
 directory of a simuPOP distribution.
 This book might be made available online so that users can submit their
 own recipes.
\end_layout

\begin_layout Standard
If you cannot find the answer you need, or if you believe that you have
 located a bug, or if you would like to request a feature, please subscribe
 to the simuPOP mailinglist and send your questions there.
\end_layout

\begin_layout Section
How to read this user's guide
\end_layout

\begin_layout Standard
This user's guide describes all simuPOP features using a lot of examples.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Core-simuPOP-components"

\end_inset

 describes all classes in the simuPOP core.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:simuPOP-Operators"

\end_inset

 describes almost all simuPOP operators, divided largely by genetic models.
 Features listed in these two chapters are generally implemented at the
 C++ level and are provided through the 
\family typewriter
simuPOP
\family default
 module.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Utility-Modules"

\end_inset

 describes features that are provided by various simuPOP utility modules.
 These modules provide extensions to the simuPOP core that greatly improves
 the usability and userfriendliness of simuPOP.
 The next chapter (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

) demonstrates how to write a script to solve a real-world simulation problem.
 Because some sections describe advanced features that are only used in
 the construction of highly complex simulations, or implementation details
 that concern only advanced users, new simuPOP users can safely skip these
 sections.
 
\series bold
Sections that describe advanced topics are marked by one or two asterisks
 (*) after the section heads
\series default
.
\end_layout

\begin_layout Standard
simuPOP is a comprehensive forward-time population genetics simulation environme
nt with many unique features.
 If you are new to simuPOP, you can go through Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Core-simuPOP-components"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:simuPOP-Operators"

\end_inset

 quickly and understand what simuPOP is and what features it provide.
 Then, you can read Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

 and learn how to apply simuPOP in real-world problems.
 After you play with simuPOP for a while and start to write simple scripts,
 you can study relevant sections in details.
 The 
\emph on
simuPOP reference manual
\emph default
 will become more and more useful when the complexity of your scripts grow.
\end_layout

\begin_layout Standard
Before we dive into the details of simuPOP, it is helpful to know a few
 name conventions that simuPOP tries to follow.
 Generally speaking,
\end_layout

\begin_layout Itemize
All classes (e.g.
 
\family typewriter
population
\family default
()), member functions (e.g.
 
\family typewriter
population.vars
\family default
()) and parameter names start with small character and use capital character
 for the first character of each word afterward (e.g.
 
\family typewriter
population.subPopSize
\family default
(), 
\family typewriter
individual.setInfo
\family default
()).
\end_layout

\begin_layout Itemize
Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter
TurnOnDebug(DBG_POPULATION)
\family default
 is the function to turn on debug mode for population related functions
 and 
\family typewriter
turnOnDebug(DBG_POPULATION) 
\family default
will do nothing apparently, because it creates an operator.
 
\end_layout

\begin_layout Itemize
Constants start with Capital characters.
 Their names instead of their actual values should be used because those
 values can change without notice.
\end_layout

\begin_layout Itemize
simuPOP uses the abbreviated form of the following words in function and
 parameter names:
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
pos
\family default
 (position),  
\family typewriter
info
\family default
 (information), 
\family typewriter
migr
\family default
 (migration), 
\family typewriter
subPop
\family default
 (subpopulation and virtual subpopulation), 
\family typewriter
subPops
\family default
 (subpopulations and virtual subpopulations), 
\family typewriter
rep
\family default
 (replicate), 
\family typewriter
reps
\family default
 (replicates), 
\family typewriter
gen
\family default
 (generation), 
\family typewriter
ops
\family default
 (operators), 
\family typewriter
expr
\family default
 (expression), 
\family typewriter
stmts
\family default
 (statements).
\end_layout

\begin_layout Standard
It usually possible to guess whether or not a parameter accepts a single
 or a list of objects by its name.
 For example, 
\family typewriter
subPop
\family default
 accepts single subpopulation and 
\family typewriter
subPops
\family default
 accepts a list of subpopulations.
\end_layout

\end_deeper
\begin_layout Chapter
Core simuPOP components
\begin_inset CommandInset label
LatexCommand label
name "cha:Core-simuPOP-components"

\end_inset


\end_layout

\begin_layout Section
Loading a simuPOP module
\end_layout

\begin_layout Standard
simuPOP consists of a number of Python modules, documents, tests and examples.
 Using Linux as an example, simuPOP installs the following files to your
 operating system:
\end_layout

\begin_layout Itemize
Core simuPOP modules (
\family typewriter
simuPOP_XXX.py
\family default
, 
\family typewriter
_simuPOP_XXX.
\family default
so) and a number of utility modules (
\family typewriter
simuUtil.py, simuOpt.py
\family default
 etc) under 
\family typewriter
/usr/lib/python2X/site-packages
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/doc
\family default
: This directory contains the pdf version of this user's guide and the 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/test
\family default
: This directory contains all unit test cases.
 It is recommended that you test your simuPOP installation using these scripts
 if you compile simuPOP from source.
 
\end_layout

\begin_layout Itemize

\family typewriter
/usr/share/simuPOP/scripts
\family default
: This directory contains all the bundled scripts.
 It is worth noting that although these scripts are distributed with simuPOP,
 they are not tested as rigorously and as frequently as the simuPOP core.
 Please send an email to the simuPOP mailinglist if you notice any problem
 with them.
\end_layout

\begin_layout Subsection
Short, long and binary modules and their optimized versions
\end_layout

\begin_layout Standard
There are six flavors of the core simuPOP module: short, long and binary
 allele modules, and their optimized versions.
 The short allele modules use 8 bits to store each allele which limits the
 possible allele states to 256.
 This is enough most of the times but not so if you need to simulate models
 such as the infinite allele model.
 In those cases, you should use the long allele version of the modules,
 which use 32 bits for each allele and can have 
\begin_inset Formula $2^{32}$
\end_inset

 possible allele states.
 On the other hand, if you would like to simulate a large number of binary
 (SNP) markers, binary libraries can save you a lot of RAM because they
 use 1 bit for each allele.
 Despite of differences in internal memory layout, all these modules have
 the same interface.
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure a simulation executes correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time validation varies from case to case but can be
 high under some extreme circumstances.
 Because of this, optimized versions for all modules are provided.
 They bypass all parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confident
 that your simulation is running as expected.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 demonstrate the differences between standard and optimized modules, by
 executing two invalid commands.
 A standard module returns proper error messages, while an optimized module
 returns erroneous results and or simply crashes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/standard.log"
lstparams "caption={Use of standard simuPOP modules},keywords={from,import},label={lst:Use-of-standard-module}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Use-of-optimized-module"

\end_inset

Use of optimized simuPOP modules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

% python
\end_layout

\begin_layout Plain Layout

>>> from simuOpt import setOptions
\end_layout

\begin_layout Plain Layout

>>> setOptions(optimized=True, alleleType='long', quiet=True)
\end_layout

\begin_layout Plain Layout

>>> from simuPOP import *
\end_layout

\begin_layout Plain Layout

>>> pop = population(10, loci=[2])
\end_layout

\begin_layout Plain Layout

>>> pop.locusPos(10)
\end_layout

\begin_layout Plain Layout

1.2731974748756028e-313
\end_layout

\begin_layout Plain Layout

>>> pop.individual(20).setAllele(1, 0)
\end_layout

\begin_layout Plain Layout

Segmentation fault
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 also demonstrates how to use the 
\family typewriter
setOptions
\family default
 function in the 
\family typewriter
simuOpt
\family default
 module to control the choice of one of the six simuPOP modules.
 By specifying one of 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary 
\family default
for option 
\family typewriter
alleleType
\family default
, and setting
\family typewriter
 optimized
\family default
 to 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
, the right flavor of module will be chosen when simuPOP is loaded.
 In addition, option 
\family typewriter
quiet
\family default
 can be used suppress initial output.
 An alternative method is to set environmental variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
r
\end_layout

\end_inset

 to 
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
binary
\family default
 to use the standard short, long or binary module, and variable 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules.
 Command line options 
\family typewriter
--optimized
\family default
 can also be used.
\end_layout

\begin_layout Note
Please do not make use of exceptions raised by simuPOP functions to direct
 the logic of your script (e.g.
 use a 
\family typewriter
try ...
 except ...

\family default
 statement around function 
\family typewriter
infoIdx
\family default
 to find a valid information field).
 Because the optimized modules do not raise these exceptions, such a script
 may crash or yield invalid results when the optimized module is used.
\end_layout

\begin_layout Subsection
Random number generator *
\end_layout

\begin_layout Standard
When simuPOP is loaded, it creates a default random number generator (
\family typewriter
RNG
\family default
) of type 
\family typewriter
mt19937
\family default
 using a random seed from a system random number generator that guarantees
 random seeds for all instances of simuPOP even if they are initialized
 at the same time.
 After simuPOP is loaded, you can reset this system RNG with a different
 random number generator (c.f.
 
\family typewriter
AvailableRNGs()
\family default

\begin_inset Index
status open

\begin_layout Plain Layout
AvailableRNG
\end_layout

\end_inset

, 
\family typewriter
SetRNG(name, seed)
\family default
)
\begin_inset Index
status open

\begin_layout Plain Layout
SetRNG
\end_layout

\end_inset

.
 It is also possible to save the random seed of a simuPOP session (c.f.
 
\family typewriter
GetRNG().seed()
\family default
) and use it to replay the session later.
 
\end_layout

\begin_layout Note

\family typewriter
GetRNG().seed()
\family default
 returns the seed of the simuPOP random number generator.
 It can be used to replay your simulation if 
\family typewriter
GetRNG()
\family default
 is your only source of random number generator.
 If you also use the Python 
\family typewriter
random
\family default
 module, it is a good practise to set its seed using 
\family typewriter
random.seed(GetRNG().seed())
\family default
.
\end_layout

\begin_layout Subsection
Graphical user interface
\end_layout

\begin_layout Standard
There is no graphical user interface to simuPOP but various dialogs can
 be used for simple tasks.
 For example, a parameter input dialog can be constructed automatically
 from a parameter specification list, and be used to accept user input if
 class 
\family typewriter
simuOpt.simuOpt
\family default
 is used to handle parameters.
 Other examples include class 
\family typewriter
simuUtil.simuProgress
\family default
 that makes use of a progress dialog, and function 
\family typewriter
simuUtil.ViewVars
\family default
 that uses a dialog to display a large number of variables.
 Note that the 
\series bold
use of GUI in simuPOP is optional in the sense that all functionalities
 can be achieved without a GUI
\series default
.
 For examples, 
\family typewriter
simuOpt.getParam()
\family default
 will use a terminal to accept user input and 
\family typewriter
simuUtil.simuProgress
\family default
 turns to a text-based progress bar in the non-GUI mode.
\end_layout

\begin_layout Standard
The use of GUI can be controlled either globally or individually.
 More specifically,
\end_layout

\begin_layout Itemize
By default, a GUI is used whenever possible.
 All GUI-capable functions support 
\family typewriter
wxPython
\family default
 so a 
\family typewriter
wxPython
\family default
 dialog will be used if 
\family typewriter
wxPython
\family default
 is available.
 Otherwise, 
\family typewriter
tkInter
\family default
 based dialogs or text-mode will be used.
\end_layout

\begin_layout Itemize
If environmental variable 
\family typewriter
SIMUGUI
\family default
 is set to 
\family typewriter
False
\family default
, no GUI will be used.
 If it is set to 
\family typewriter
Tkinter
\family default
, 
\family typewriter
Tkinter
\family default
-based dialogs will be used even if 
\family typewriter
wxPython
\family default
 is available.
\end_layout

\begin_layout Itemize
The same parameters 
\family typewriter
True/False/wxPython/Tkinter
\family default
 at the script level using command line option 
\family typewriter
--gui.
 
\family default
Note that 
\family typewriter
--gui=False
\family default
 is commonly used to run scripts in batch mode.
\end_layout

\begin_layout Itemize
For each involved function or class, parameter 
\family typewriter
gui
\family default
 is usually provided.
 The same set of options apply.
\end_layout

\begin_layout Section
Genotypic structure
\begin_inset CommandInset label
LatexCommand label
name "sec:Genotypic-structure"

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
genotypic structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to structural information shared by all individuals
 in a population, including number of homologous copies of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidy
\end_layout

\end_inset

(), ploidyName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidyName
\end_layout

\end_inset

()
\family default
), chromosome types and names (c.f.
 
\family typewriter
numChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numChrom
\end_layout

\end_inset

(), chromType()
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromType
\end_layout

\end_inset

, chromName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromName
\end_layout

\end_inset

()
\family default
), position and name of each locus (c.f.
 
\family typewriter
numLoci
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numLoci
\end_layout

\end_inset

(ch),
\family default
 
\family typewriter
locusPos
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!locusPos
\end_layout

\end_inset

(loc),
\family default
 
\family typewriter
locusName(loc)
\family default
), and axillary information attached to each individual (c.f.
 
\family typewriter
infoField
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoField
\end_layout

\end_inset

(idx), infoFields
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoFields
\end_layout

\end_inset

()
\family default
).
 In addition to property access functions, a number of utility functions
 are provided to, for example, look up the index of a locus by its name
 (c.f.
 
\family typewriter
locusByName()
\family default
, 
\family typewriter
chromBegin()
\family default
, 
\family typewriter
chromLocusPair()
\family default
).
\end_layout

\begin_layout Standard
In simuPOP, locus is a (named) position and alleles are just different numbers
 at that position.
 
\series bold
A locus can be a gene, a nucleotide, or even a deletion, depending on how
 you define alleles and mutations
\series default
.
 For example, 
\end_layout

\begin_layout Itemize
A codon can be simulated as a locus with 64 allelic states, or three locus
 each with 4 allelic states.
 Alleles in the first case would be codons such as 
\family typewriter
AAC
\family default
 and a mutation event would mutate one codon to another (e.g.
 
\family typewriter
AAC
\family default
 -> 
\family typewriter
ACC
\family default
).
 Alleles in the second case would be 
\family typewriter
A
\family default
, 
\family typewriter
C
\family default
, 
\family typewriter
T
\family default
 or 
\family typewriter
G
\family default
, and a mutation event would mutate one nucleotide to another (e.g.
 
\family typewriter
A
\family default
 -> 
\family typewriter
G
\family default
).
\end_layout

\begin_layout Itemize
You can use 0 and 1 (and the binary module of simuPOP) to simulate SNP (single-n
ucleotide polymorphism) markers and ignore the exact meaning of 0 and 1,
 or use 0, 1, 2, 3 to simulate different nucleotide (A, C, T, or G) in these
 markers.
 The mutation model in the second case would be more complex.
\end_layout

\begin_layout Itemize
For microsatellite markers, alleles are usually interpreted as the number
 of tandem repeats.
 It would be difficult (though doable) to simulate the expansion and contraction
 of genome caused by the mutation of microsatellite markers.
\end_layout

\begin_layout Itemize
The infinite site and infinite allele mutation models could be simulated
 using either a continuous sequence of nucleotides with a simple 2-allele
 mutation model, or a locus with a large number of possible allelic states.
 It is also possible to simulate an empty region (without any locus) with
 loci introduced by mutation events.
\end_layout

\begin_layout Itemize
If you consider deletion as a special allelic state, you can simulate gene
 deletions without shrinking a chromosome.
 For example, a deletion mutation event can set the allelic state of one
 or more loci to 0, which can no longer be mutated.
\end_layout

\begin_layout Itemize
In an implementation of an infinite-sites model, 
\series bold
individual loci are used to store mutation events
\series default
.
 In this example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infiniteSites"

\end_inset

), 100 loci are allocated for each individual and they are used to store
 mutation events (location of a mutation) that happens in a 10Mb region.
 Whenever a mutation event happens, its location is stored as an allele
 of an individual.
 At the end of the evolution, each individual has a list of mutation events
 which can be readily translated to real alleles.
 Similar ideas could be used to simulate the accumulation of recombination
 events.
\end_layout

\begin_layout Standard
In summary, the exact meaning of loci and their alleles are user defined.
 With appropriate mutation model and mating scheme, it is even possible
 to simulate phenotypic traits using this mechanism, although it is more
 natual to use information fields for quatitative traits.
\end_layout

\begin_layout Standard
A genotypic structure can be retrieved from 
\emph on
individual
\emph default
 and 
\emph on
population
\emph default
 objects.
 Because a population consists of individuals of the same type, genotypic
 information can only be changed for all individuals at the population level.
 Populations in a simulator usually have the same genotypic structure because
 they are created by as replicates, but their structure may change during
 evolution.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to access genotypic structure functions at the population
 and individual levels.
 Note that 
\family typewriter
lociPos
\family default
 determines the order at which loci are arranged on a chromosome.
 Loci positions and names will be rearranged if given 
\family typewriter
lociPos
\family default
 is unordered.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genoStru.log"
lstparams "caption={Genotypic structure functions},label={genostructure}"

\end_inset


\end_layout

\begin_layout Note
simuPOP does not assume any unit for loci positions.
 Depending on your application, it can be basepair (bp), kilo-basepair (kb),
 mega base pair (mb) or even using genetic-map distance such as centiMorgan.
 It is your responsibility to interpret and use loci positions properly.
 For example, recombination rate between two adjacent markers can be specified
 as the product between their physical distance and a recombination intensity.
 The scale of this intensity will vary by the unit assumed.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Note
Names of loci, alleles and subpopulations are optional.
 Empty names will be used if they are not specified.
 Whereas 
\family typewriter
locusName
\family default
, 
\family typewriter
subPopName
\family default
 and 
\family typewriter
alleleName
\family default
 always return a value (empty string or specified value) for any locus,
 subpopulation or allele, respectively, 
\family typewriter
lociNames
\family default
, 
\family typewriter
subPopNames
\family default
 and 
\family typewriter
alleleNames
\family default
 only return specified values, which can be empty lists.
 
\end_layout

\begin_layout Subsection
Haploid, diploid and haplodiploid populations
\end_layout

\begin_layout Standard
simuPOP is most widely used to study human (diploid) populations.
 A large number of mating schemes, operators and population statistics are
 designed around the evolution of such a population.
 simuPOP also supports haploid and haplodiploid populations although there
 are fewer choices of mating schemes and operators.
 simuPOP can also support other types of populations such as triploid and
 tetraploid populations, but these features are largely untested due to
 their limited usage.
 It is expected that supports for these populations would be enhanced over
 time.
\end_layout

\begin_layout Standard
For efficiency considerations, simuPOP saves the same numbers of homologous
 sets of chromosomes even if some individuals have different numbers of
 homologous sets in a population.
 For example, in a haplodiploid population, because male individuals have
 only one set of chromosomes, their second homologous set of chromosomes
 are 
\emph on
unused
\emph default
, which are labeled as 
\family typewriter
'_'
\family default
, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploid.log"
lstparams "caption={An example of haplodiploid population},keywordstyle={\\ttfamily},label={haplodiploid}"

\end_inset


\end_layout

\begin_layout Subsection
Autosomes, sex chromosomes, and other types of chromosomes *
\end_layout

\begin_layout Standard
The default chromosome type is autosome, which is the 
\emph on
normal
\emph default
 chromosomes in diploid, and in haploid populations.
 simuPOP supports three other types of chromosomes, namely 
\emph on
ChromosomeX
\emph default
, 
\emph on
ChromosomeY
\emph default
 and 
\emph on
Customized
\emph default
.
 Sex chromosomes are only valid in haploid populations where chromosomes
 X and Y are used to determine the sex of an offspring.
 Customized chromosomes rely on user defined functions and operators to
 be passed from parents to offspring.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 shows how to specify different chromosome types, and how genotypes of these
 special chromosomes are arranged.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/chromType.log"
lstparams "caption={Different chromosome types},keywordstyle={\\ttfamily},label={chromtypes}"

\end_inset


\end_layout

\begin_layout Standard
The evolution of sex chromosomes follow the following rules
\end_layout

\begin_layout Itemize
There can be only one X chromosome and one Y chromosome.
 It is not allowed to have only one kind of sex chromosome.
\end_layout

\begin_layout Itemize
The Y chromosome of female individuals are ignored.
 The second homologous copy of the X chromosome and the first copy of the
 Y chromosome are ignored for male individuals.
\end_layout

\begin_layout Itemize
During mating, female parent pass one of her X chromosome to her offspring,
 male parent pass chromosome X or Y to his offspring.
 Recombination is allowed for the X chromosomes of females, but not allowed
 for males.
\end_layout

\begin_layout Itemize
The sex of offspring is determined by the types of sex chromosomes he/she
 inherits, XX for female, and XY for male.
\end_layout

\begin_layout Standard
As an advanced feature of simuPOP, chromosomes that do not follow the inheritanc
e patterns of autosomes or sex chromosomes can be handled separately (see
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Pre-defined-genotype-transmitters"

\end_inset

 for an Example).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:chromTypes"

\end_inset

 depicts the possible chromosome structure of two diploid parents, and how
 offspring chromosomes are formed.
 It uses two customized chromosomes to model multiple copies of mitochondrial
 chromosomes that are passed randomly from mother to offspring.
 The second homologous copy of customized chromosomes are unused in this
 example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chromTypes"

\end_inset

Inheritance of different types of chromosomes in a diploid population
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/chromType.png
	lyxscale 40
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
Individuals in this population have five chromosomes, one autosome (A),
 one X chromosome (X), one Y chromosome (Y) and two customized chromosomes
 (C).
 The customized chromosomes model multiple copies of mitochondrial chromosomes
 that are passed randomly from mother to offspring.
 Y chromosomes for the female parent, the second copy of chromosome X and
 the first copy of chromosome Y for the male parent, and the second copy
 of customized chromosomes are unused (gray chromosome regions).
 A male offspring inherits one copy of autosome from his mother (with recombinat
ion), one copy of autosome from his father (with recombination), an X chromosome
 from his mother (with recombination), a Y chromosome from his father (without
 recombination), and two copies of the first customized chromosome.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sub:stru-infoFields"

\end_inset


\end_layout

\begin_layout Standard
Different kinds of simulations require different kinds of individuals.
 Individuals with only genotype information are sufficient to simulate the
 basic Wright-Fisher model.
 Sex is needed to simulate such a model in diploid populations with sex.
 Individual fitness may be needed if selection is induced, and age may be
 needed if the population is age-structured.
 In addition, different types of quantitative traits or affection status
 may be needed to study the impact of genotype on individual phenotype.
 Because it is infeasible to provide all such information to an individual,
 simuPOP keeps genotype, sex (
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
) and affection status as 
\emph on
built-in properties
\emph default
 of an individual, and all others as optional 
\emph on
information fields
\emph default
 (float numbers) attached to each individual.
\end_layout

\begin_layout Standard
Information fields can be specified when a population is created, or added
 later using relevant function.
 They are essential for the function of many simuPOP operators.
 For example, all selection operators require information field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 Operator 
\family typewriter
migrator
\family default
 uses information field 
\family typewriter
migrate_to
\family default
 to store the ID of subpopulation an individual will migrate to.
 An error will be raised if these operators are applied to a population
 without needed information fields.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoField.log"
lstparams "caption={Basic usage of information fields},label={basicInfoFields}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicInfoFields"

\end_inset

 demonstrates the basic usage of information fields.
 In this example, a population with two information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 are created.
 It can hold one ancestral generations (
\family typewriter
ancGen=1
\family default
, see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details) so the most recent parental generations will be kept in a
 population object.
 After initializing each individual with two chromosomes with all zero and
 all one alleles respectively, the population evolves one generation, subject
 to recombination at rate 0.01.
 Parents of each individual are recorded, by operator 
\family typewriter
parentsTagger
\family default
, to information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 of each offspring
\family typewriter
.
\end_layout

\begin_layout Standard
After evolution, the population is extracted from the simulator, and the
 values of information field 
\family typewriter
mother_idx
\family default
 of all individuals are printed.
 The next several statements get the first individual from the population,
 and his mother from the parental generation using the index stored in this
 individual's information field.
 Genotypes at the first homologous copy of this individual's chromosome
 is printed, along with two parental chromosomes.
\end_layout

\begin_layout Standard

\series bold
Information fields can be accessed as attributes of individuals
\series default
.
 For example, 
\family typewriter
ind.info('father_idx')
\family default
 is equivalent to 
\family typewriter
ind.father_idx
\family default
 and 
\family typewriter
ind.setInfo(35, 'age')
\family default
 is equivalent to 
\family typewriter
ind.age = 35
\family default
.
\end_layout

\begin_layout Standard

\series bold
Information fields can only be set or added at the population level
\series default
 because all individuals need to have the same set of fields.
 Values of information fields could be accessed at individual or population
 levels, using functions such as 
\family typewriter
individual.info
\family default
, 
\family typewriter
individual.setInfo
\family default
, 
\family typewriter
population.indInfo
\family default
, 
\family typewriter
population.setIndInfo
\family default
.
 These functions will be introduced in their respective classes.
\end_layout

\begin_layout Note
Information fields can be located both by names and by indexes
\series bold
,
\series default
 the former provides better readability at a slight cost of performance
 because these names have to be translated into indexes each time.
 However, use of names are recommended in most cases for readability considerati
ons.
\end_layout

\begin_layout Section
Individual
\end_layout

\begin_layout Standard
Individuals are building blocks of populations.
 An individual object cannot be created independently, but references to
 inidividuals can be retrieved using member functions of a population object.
 In addition to structural information shared by all individuals in a population
, the individual class provides member functions to get and set 
\emph on
genotype
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
affection status
\emph default
 and 
\emph on
information fields
\emph default
 of an individual.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates how to access and modify individual sex, affection status
 and information fields.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual.log"
lstparams "caption={Access Individual properties},label={individuals}"

\end_inset


\end_layout

\begin_layout Standard
Genotypes of an individual are stored sequentially and can be accessed locus
 by locus, or in batch.
 The alleles are arranged by position, chromosome and ploidy.
 That is to say, the first allele on the first chromosome of the first homologou
s set is followed by alleles at other loci on the same chromosome, then
 markers on the second and later chromosomes, followed by alleles on the
 second homologous set of the chromosomes for a diploid individual.
 A consequence of this memory layout is that alleles at the same locus of
 a non-haploid individual are separated by 
\family typewriter
individual.totNumLoci()
\family default
 loci.
 The memory layout of a diploid individual with two chromosomes is illustrated
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:genotype-layout"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:genotype-layout"

\end_inset

Memory layout of individual genotype
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/genotype.png
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
simuPOP provides several functions to read/write individual genotype.
 It is worth noting that, instead of copying genotypes of an individual
 to a Python tuple or list, the return value of function 
\family typewriter
genotype([p, [ch]])
\family default
 is a special python carray object that reflects the underlying genotypes.
 Modifying elements of this array will change the genotype of an individual
 directly.
 Only 
\family typewriter
count
\family default
 and
\family typewriter
 index
\family default
 list functions can be used, but all comparison, assignment and slice operations
 are allowed.
 If you would like to copy the content of this 
\family typewriter
carray
\family default
 to a Python list, use the 
\family typewriter
list()
\family default
 function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates the use of these functions.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual_genotype.log"
lstparams "caption={Access individual genotype},label={individual_genotype}"

\end_inset


\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard
The 
\family typewriter
population
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population
\end_layout

\end_inset


\family default
 object is the most important object of simuPOP.
 It consists of one or more generations of individuals, grouped by subpopulation
s, and a local Python dictionary to hold arbitrary population information.
 This class provides a large number of functions to access and modify population
 structure, individuals and their genotypes and information fields.
 The following sections explain these features in detail.
\end_layout

\begin_layout Subsection
Access and change individual genotype
\end_layout

\begin_layout Standard
From a user's point of view, genotypes of all individuals in a population
 are arranged sequentially.
 Similar to functions 
\family typewriter
individual.genotype()
\family default
 and 
\family typewriter
individual.setGenotype()
\family default
, genotypes of a population can be accessed in batch using functions 
\family typewriter
population.genotype()
\family default
 and 
\family typewriter
population.setGenotype()
\family default
.
 However, because it is error prone to locate an allele of a particular
 individual in this long array, these functions are usually used to perform
 population-level genotype operations such as clearing all alleles (e.g.
 
\family typewriter
pop.setGenotype([0])
\family default
) or counting the number of a particular allele across all individuals (e.g.
 
\family typewriter
pop.genotype().count(1)
\family default
).
\end_layout

\begin_layout Standard
Another way to change alleles across the whole population is to recode existing
 alleles to other numbers.
 This is sometimes needed if you need to change allele states to conform
 with a particular mutation model, assumptions of other software applications
 or genetic samples.
 For example, if the dataset you obtained uses 1, 2, 3, 4 for A, C, T, G
 alleles, and you would like to use alleles 0, 1, 2 and 3 for A, C, G, T
 (a convention for simuPOP when nucleotide mutation models are involved),
 you can use
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.recodeAlleles([0, 0, 1, 3, 2], alleleNames=['A', 'C', 'G', 'T'])
\end_layout

\end_inset

to convert and rename the alleles (1 allele to 0, 2 allele to 1, etc).
 This operation will be applied to all subpopulations for all ancestral
 generations, but can be restricted to selected loci.
 
\end_layout

\begin_layout Subsection
Subpopulations
\end_layout

\begin_layout Standard
A simuPOP population consists of one or more subpopulations.
 
\series bold
If a population is not structured, it has one subpopulation that is the
 population itself.

\series default
 Subpopulations serve as barriers of individuals in the sense that mating
 only happens between individuals in the same subpopulation.
 A number of functions are provided to merge, remove, resize subpopulations,
 and move individuals between subpopulations (migration).
 You will rarely get a chance to use them directly because such operations
 are usually handled by operators.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to use subpopulation related functions.
 Of particular interest is the 
\family typewriter
setSubPopByIndInfo()
\family default
 function.
 This function takes an information field as parameter and rearrange individuals
 according to their values at this information field.
 Individuals with invalid (negative) values at this information field are
 removed.
 This is essentially how migration is implemented in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPop.log"
lstparams "caption={Manipulation of subpopulations},label={subPop}"

\end_inset


\end_layout

\begin_layout Standard
Some population operations change the IDs of subpopulations.
 For example, if a population has three subpopulations 0, 1, and 2, and
 subpopulation 1 is split into two subpouplations, subpopulation 2 will
 become subpopulation 3.
 Tracking the ID of a subpopulation can be problematic, especially when
 conditional or random subpopulation operations are involved.
 In this case, you can specify names to subpopulations.
 These names will follow their associated subpopulations during population
 operations so you can identify the ID of a subpopulation by its name.
 Note that simuPOP allows duplicate subpopulation names.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPopName.log"
lstparams "caption={Use of subpopulation names},label={subPopName}"

\end_inset


\end_layout

\begin_layout Subsection
Virtual subpopulations *
\end_layout

\begin_layout Standard
simuPOP subpopulations can be further divided into virtual subpopulations
 (VSP), which are groups of individuals who share certain properties.
 For example, all male individuals, all unaffected individuals, all individuals
 with information field age > 20, all individuals with genotype 0, 0 at
 a given locus, can form VSPs.
 VSPs do not have to add up to the whole subpopulation, nor do they have
 to be non-overlapping.
 Unlike subpopulations that have strict boundaries, VSPs change easily with
 the changes of individual properties.
\end_layout

\begin_layout Standard
VSPs are defined by virtual splitters.
 A splitter defines the same number of VSPs in all subpopulations, although
 sizes of these VSPs vary across subpopulations due to subpopulation differences.
 For example, a 
\family typewriter
sexSplitter()
\family default
 defines two VSPs, the first with all male individuals and the second with
 all female individuals, and a 
\family typewriter
infoSplitter(field='x', values=[1, 2, 4])
\family default
 defines three VSPs whose members have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 and 
\family typewriter
4
\family default
 at information field 
\family typewriter
x
\family default
, respectively.
 This operator also allows the use of cutoff values and ranges to define
 VSPs.
 If different types of VSPs are needed, a combined splitter can be used
 to combine VSPs defined by several splitters.
\end_layout

\begin_layout Standard
A VSP is represented by a 
\family typewriter
[spID, vspID]
\family default
 pair.
 Its name and size can be obtained using functions 
\family typewriter
subPopName()
\family default
 and 
\family typewriter
subPopSize()
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSplitter"

\end_inset

 demonstrates how to apply virtual splitters to a population, and how to
 check VSP names and sizes.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSplitter.log"
lstparams "caption={Define virtual subpopulations in a population},label={virtualSplitter}"

\end_inset


\end_layout

\begin_layout Standard
VSP provides an easy way to access groups of individuals in a subpopulation
 and allows finer control of an evolutionary process.
 For example, mating schemes can be applied to VSPs which makes it possible
 to apply different mating schemes to, for example, individuals with different
 ages.
 By applying migration, mutation etc to VSPs, it is easy to implement advanced
 features such as sex-biased migrations, different mutation rates for individual
s at different stages of a disease.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to initialize genotype and information fields to individuals
 in male and female VSPs.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSubPop.log"
lstparams "caption={Applications of virtual subpopulations},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Note
Current implementation of virtual subpopulation iterators does not allow
 nested use of VSP-related functions.
 For example:
\end_layout

\begin_layout Note
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for boy in pop.individuals([0, 0]):
\end_layout

\begin_layout Plain Layout

    for girl in pop.individuals([0, 1]):
\end_layout

\begin_layout Plain Layout

        ...
\end_layout

\end_inset

will yield unexpected results because 
\family typewriter
pop.individuals([0, 1])
\family default
 will override individuals selected for 
\family typewriter
pop.individuals([0, 0])
\family default
.
\end_layout

\begin_layout Subsection
Advanced virtual subpopulation splitters **
\end_layout

\begin_layout Standard
simuPOP provides a number of virtual splitters that can define VSPs using
 specified properties.
 For example, 
\family typewriter
infoSplitter(field='a', values=[1,2,3])
\family default
 defines three VSPs whose individuals have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, and 
\family typewriter
3
\family default
 at information field 
\family typewriter
a
\family default
, respectively; 
\family typewriter
sexSplitter()
\family default
 defines two VSPs of male and female individuals, respectively; and 
\family typewriter
rangeSplitter(ranges=[[0, 2000], [2000, 5000]])
\family default
 defines two VSPs using two blocks of individuals.
\end_layout

\begin_layout Standard
A 
\family typewriter
combinedSplitter
\family default
 can be used if your simulation needs more than one sets of VSPs.
 For example, you may want to split your subpopulations both by sex and
 by affection status.
 In this case, you can define a combined splitter using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

combinedSplitter(splitters=[sexSplitter(), affectionSplitter()])
\end_layout

\end_inset

This splitter simply stack VSPs defined in 
\family typewriter
affectionSplitter()
\family default
 after 
\family typewriter
sexSplitter()
\family default
 so that unaffected and affected VSPs are now VSPs 2 and 3 (0 and 1 are
 used for male and female VSPs).
\end_layout

\begin_layout Standard
There are also scenarios when you would like to define finer VSPs with individua
ls belonging to more than one VSPs.
 For example, you may want to have a look of frequencies of certain alleles
 in affected male vs affected females, or count the number of males and
 females with certain value at an information field.
 In this case, a 
\family typewriter
productSplitter
\family default
 can be used to define VSPs using interactions of several VSPs.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

productSplitter(splitters=[sexSplitter(), affectionSplitter()])
\end_layout

\end_inset

defines 4 subpopulations by splitting VSPs defined by 
\family typewriter
sexSplitter()
\family default
 with affection status.
 These four VSPs will then have unaffected male, affected male, unaffected
 female and affected female individuals, respectively.
\end_layout

\begin_layout Standard
If you view 
\family typewriter
productSplitter
\family default
 as an interaction splitter that defines new VSPs as intersections of existing
 VSPs, you may wonder how to define unions of VSPs.
 For example, you can make a case where you want to consider individuals
 with information field a < 0 or a > 100 together.
 A regular 
\family typewriter
infoSplitter(field='a', cutoff=[0, 100])
\family default
 cannot do that because it defines three VSPs with 
\begin_inset Formula $a<0$
\end_inset

, 
\begin_inset Formula $0\leq a<100$
\end_inset

 and 
\begin_inset Formula $a\geq100$
\end_inset

, respectively.
 The trick here is to use parameter 
\family typewriter
vspMap
\family default
 of a 
\family typewriter
combinedSplitter
\family default
.
 If this parameter is defined, multiple VSPs could be groups or reordered
 to define a new set of VSPs.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

combinedSplitter(splitters=[infoSplitter(field='a', cutoff=[0, 100])], vspMap=[[
0,2], [1]])
\end_layout

\end_inset

 defines two VSPs using VSPs 0 and 2, and VSP 1 defined by the 
\family typewriter
infoSplitter
\family default
 so that the first VSP contains individuals with 
\begin_inset Formula $a<0$
\end_inset

 or 
\begin_inset Formula $a\geq100$
\end_inset

.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "advancedVSP"

\end_inset

 demonstrates some advanced usages of virtual splitters.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/advancedVSP.log"
lstparams "caption={Advanced virtual subpopulation usages.},label={advancedVSP}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Individuals"

\end_inset

Access individuals and their properties
\end_layout

\begin_layout Standard
There are many ways to access individuals of a population.
 For example, function 
\family typewriter
population.individual(idx)
\family default
 returns a reference to the 
\family typewriter
idx
\family default
-th individual in a population.
 An optional parameter 
\family typewriter
subPop
\family default
 can be specified to return the 
\family typewriter
idx
\family default
-th individual in the 
\family typewriter
subPop
\family default
-th subpopulation.
\end_layout

\begin_layout Standard
If you would like to access a group of individuals, either from a whole
 population, a subpopulation, or from a virtual subpopulation, 
\family typewriter
population.individuals([subPop])
\family default
 is easier to use.
 This function returns a Python iterator that can be used to iterate through
 individuals.
 An advantage of this function is that 
\family typewriter
subPop 
\family default
can be a virtual subpopulation which makes it easy to iterate through individual
s with certain properties (such as all male individuals).
\end_layout

\begin_layout Standard
If more than one generations are stored in a population, function 
\family typewriter
ancestor(idx, [subPop], gen)
\family default
 can be used to access individual from an ancestral generation (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details).
 Because there is no group access function for ancestors, it may be more
 convenient to use 
\family typewriter
useAncestralGen
\family default
 to make an 
\emph on
ancestral
\emph default
 generation the 
\emph on
current
\emph default
 generation, and use 
\family typewriter
population.individuals
\family default
.
 Note that ancestor() function can always access individuals at a certain
 generation, regardless which generation the current generation is.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to use all these individual-access functions.
\end_layout

\begin_layout Standard
If an unique ID is assigned to all individuals in a population, you can
 look up individuals from their IDs using function 
\family typewriter
population.indByID()
\family default
.
 The information field to save individual ID is usually 
\family typewriter
ind_id
\family default
 and you can use operator 
\family typewriter
idTagger
\family default
 and its function form 
\family typewriter
TagID
\family default
 to set this field.
 Note that this function can be used to look up individuals in the present
 and all ancestral generations, although a parameter (
\family typewriter
ancGen
\family default
) can be used to limit the search to a specific generation if you know in
 advance which generation the individual locates.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/accessIndividual.log"
lstparams "caption={Access individuals of a population},label={accessIndividual}"

\end_inset


\end_layout

\begin_layout Standard
Although it is easy to access individuals in a population, it is often more
 efficient to access genotypes and information fields in batch mode.
 For example, functions 
\family typewriter
genotype()
\family default
 and
\family typewriter
 setGenotype()
\family default
 can read/write genotype of all individuals in a population or (virtual)
 subpopulation, functions 
\family typewriter
indInfo()
\family default
 and 
\family typewriter
setIndInfo()
\family default
 can read/write certain information fields in a population or (virtual)
 subpopulation.
 The write functions work in a circular manner in the sense that provided
 values are reused if they are not enough to fill all genotypes or information
 fields.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates the use of such functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/batchAccess.log"
lstparams "caption={Access individual properties in batch mode},label={batchAccess}"

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sec:Information-fields"

\end_inset


\end_layout

\begin_layout Standard
Information fields are usually set during population creation, using the
 
\family typewriter
infoFields
\family default
 parameter of the population constructor.
 It can also be set or added using functions 
\family typewriter
setInfoFields, addInfoField 
\family default
and 
\family typewriter
addInfoFields
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popInfo"

\end_inset

 demonstrates how to read and write information fields from an individual,
 or from a population in batch mode.
 Note that functions 
\family typewriter
population.indInfo
\family default
 and 
\family typewriter
population.setIndInfo
\family default
 can be applied to (virtual) subpopulation using a optional parameter subPop.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popInfo.log"
lstparams "caption={Add and use of information fields in a population},label={popInfo}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
A simuPOP population usually holds individuals in one generation.
 During evolution, an offspring generation will replace the parental generation
 and become the present generation (population), after it is populated from
 a parental population.
 The parental generation is discarded.
\end_layout

\begin_layout Standard
This is usually enough when only the present generation is of interest.
 However, parental generations can provide useful information on how genotype
 and other information are passed from parental to offspring generations.
 simuPOP provides a mechanism to store and access arbitrary number of ancestral
 generations in a population object.
 Applications of this feature include pedigree tracking, reconstruction,
 and pedigree ascertainments.
\end_layout

\begin_layout Standard
A parameter 
\family typewriter
ancGen
\family default
 is used to specify how many generations a population object 
\emph on
can
\emph default
 store (which is usually called the 
\emph on
ancestral depth
\emph default
 of a population).
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number 
\family typewriter
n
\family default
 to store n most recent generations; or -
\family typewriter
1
\family default
 to store all generations.
 Of course, storing all generations during an evolutionary process is likely
 to exhaust the RAM of your computer quickly.
\end_layout

\begin_layout Standard
Several member functions can be used to manipulate ancestral generations:
\end_layout

\begin_layout Itemize

\family typewriter
ancestralGens() 
\family default
returns the number of ancestral generations stored in a population.
\end_layout

\begin_layout Itemize

\family typewriter
setAncestralDepth(depth)
\family default
 resets the number of generations a population can store.
\end_layout

\begin_layout Itemize

\family typewriter
push(pop)
\family default
 will push population 
\family typewriter
pop
\family default
 into the current population.
 
\family typewriter
pop
\family default
 will become the current generation, and the current generation will either
 be removed (if ancGen == 0), or become the parental generation of pop.
 The greatest ancestral generation may be removed.
 This function is rarely used because populations with ancestral generations
 are usually created during an evolutionary process.
\end_layout

\begin_layout Itemize

\family typewriter
useAncestralGen(idx)
\family default
 set the present generation to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the parental generation, 
\family typewriter
2
\family default
 for grand-parental, ..., and 
\family typewriter
0
\family default
 for the present generation.
 This is useful because most population functions act on the 
\emph on
present
\emph default
 generation.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral generations.
 
\end_layout

\begin_layout Standard
A typical use of ancestral generations is demonstrated in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

.
 In this example, a population is created and is initialized with allele
 frequency 0.5.
 Its ancestral depth is set to 2 at the beginning of generation 18 so that
 it can hold parental generations at generation 18 and 19.
 The allele frequency at each generation is calculated and displayed, both
 during evolution using a 
\family typewriter
stat
\family default
 operator, and after evolution using the function form this operator.
 Note that setting the ancestral depth at the end of an evolutionary process
 is a common practice because we are usually only interested in the last
 few generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ancestralPop.log"
lstparams "caption={Ancestral populations},label={ancestralPop}"

\end_inset


\end_layout

\begin_layout Subsection
Add and remove loci
\end_layout

\begin_layout Standard
Several functions are provided to remove, add empty loci or chromosomes,
 and to merge loci or chromosomes from another population.
 They can be used to trim unneeded loci, expand existing population or merge
 two populations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates how to use these populations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/addRemoveLoci.log"
lstparams "caption={Add and remove loci and chromosomes},keywordstyle={\\ttfamily},label={addRemoveLoci}"

\end_inset


\end_layout

\begin_layout Subsection
Population extraction
\end_layout

\begin_layout Standard
Another import population member function is 
\family typewriter
population.extract(field=None, loci=None, info=None, ancGen=-1, ped=None)
\family default
.
 It is a powerful function that can extract subset of individuals, loci,
 information fields and ancestral generations from an existing population.
 This function is widely used in ascertainment operators where individuals
 or pedigrees are extracted from an existing population and form a sample.
 This function works as follows:
\end_layout

\begin_layout Itemize
If all default parameters are used, this function is equivalent to 
\family typewriter
population.clone()
\family default
.
\end_layout

\begin_layout Itemize
If a list of loci are given to parameter 
\family typewriter
loci
\family default
, only specified loci will be copied to the extracted population.
 Loci in parameter 
\family typewriter
loci
\family default
 do not have to be in order but loci in the extracted population will keep
 their original positions, and thus in their original order.
\end_layout

\begin_layout Itemize
If a list of information fields are given to parameter 
\family typewriter
info
\family default
, only specified information fields will be copied to the extracted population.
 
\end_layout

\begin_layout Itemize
If a positive 
\family typewriter
ancGen
\family default
 is given, only generations 
\family typewriter
0
\family default
 -
\family typewriter
 ancGen
\family default
 will be extracted.
\end_layout

\begin_layout Itemize
Subset of individuals is specified differently.
 Instead of a list of individuals that will be extracted, an information
 field is expected.
 This information field should hold the new subpopulation ID to which each
 individual will belong in the extracted population.
 Individuals with negative values (invalid subpopulation ID) at this information
 field will not be extracted.
 If another population (or pedigree, parameter 
\family typewriter
ped
\family default
) with the same number of individuals is given, the information field from
 that population is used.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates the use of this powerful function.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/extract.log"
lstparams "caption={Extract individuals, loci and information fields from an existing population},keywordstyle={\\ttfamily},label={extract}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Each simuPOP population has a Python dictionary that can be used to store
 arbitrary Python variables.
 These variables are usually used by various operators to share information
 between them.
 For example, the 
\family typewriter
stat
\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!stat
\end_layout

\end_inset


\family default
 operator calculates population statistics and stores the results in this
 Python dictionary.
 Other operators such as the 
\family typewriter
pyEval
\family default
 and 
\family typewriter
terminateIf 
\family default
read from this dictionary and act upon its information.
\end_layout

\begin_layout Standard
simuPOP provides two functions, namely 
\family typewriter
population.vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!vars
\end_layout

\end_inset

()
\family default
 and 
\family typewriter
population.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!population
\end_layout

\end_inset

dvars()
\family default
 to access a population dictionary.
 These functions return the same dictionary object but 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is equivalent to 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 Because dictionary 
\family typewriter
subPop[spID]
\family default
 is frequently used by operators to store variables related to a particular
 (virtual) subpopulation, function 
\family typewriter
pop.vars(subPop)
\family default
 is provided as a shortcut to 
\family typewriter
pop.vars()['subPop'][spID]
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popVars"

\end_inset

 demonstrates how to set and access Population variables.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popVars.log"
lstparams "caption={Population variables},label={popVars}"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that this dictionary forms a 
\series bold
local namespace
\series default
 in which Python expressions can be evaluated.
 This is the basis of how expression-based operators work.
 For example, the 
\family typewriter
pyEval 
\family default
operator in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

 evaluates expression 
\family typewriter
``'%.2f
\backslash
t' % LD[0][1]''
\family default
 in each population's local namespace when it is applied to that population.
 This yields different results for different population because their LD
 values are different.
 In addition to Python expressions, Python statements can also be executed
 in the local namespace of a population, using the 
\family typewriter
stmts
\family default
 parameter of the 
\family typewriter
pyEval
\family default
 or 
\family typewriter
pyExec
\family default
 operator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates the use of a simuPOP terminator, which terminates the evolution
 of a population when its expression is evaluated as 
\family typewriter
True
\family default
.
 Note that The 
\family typewriter
evolve() 
\family default
function of this example does not specify how many generations to evolve
 so it will stop only after all replicates stop.
 The return value of this function indicates how many generations each replicate
 has evolved.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/expression.log"
lstparams "caption={Expression evaluation in the local namespace of a population},label={expression}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and load a population
\end_layout

\begin_layout Standard
simuPOP populations can be saved to and loaded from disk files using 
\family typewriter
population.save
\begin_inset Index
status open

\begin_layout Plain Layout
population!save
\end_layout

\end_inset

(file)
\family default
 member function and global function 
\family typewriter
LoadPopulation
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
function!LoadPopulation
\end_layout

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 because 
\family typewriter
LoadPopulation
\family default
 is a global function.).
 
\series bold
Virtual splitters are not saved
\series default
 because they are considered as runtime definitions.
 Although files in any extension can be used, extension 
\family typewriter
.pop
\family default
 is recommended.
 
\end_layout

\begin_layout Standard
The native simuPOP format is not human readable and is not recognized by
 other applications.
 Other formats such as the one used by the popular 
\family typewriter
FSTAT 
\family default
software is supported.
 They are implemented in Python in a Python utility module 
\family typewriter
simuUtil.py
\family default
.
 simuPOP cannot use one of such formats because none of them can handle
 huge populations that simuPOP can handle, and unique features such as populatio
n variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to save and load a population in the native simuPOP format.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePop.log"
lstparams "caption={Save and load a population},label={savePop}"

\end_inset


\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They can be used in the following ways:
\end_layout

\begin_layout Itemize
Operators are usually passed to the 
\family typewriter
ops
\family default
, 
\family typewriter
preOps 
\family default
and 
\family typewriter
postOps
\family default
 parameters of the 
\family typewriter
evolve
\family default
 function of a simulator.
 The simulator will apply these operators before (
\family typewriter
preOps
\family default
), after (
\family typewriter
postPos
\family default
) or during (
\family typewriter
ops
\family default
) an evolutionary process.
 Depending on parameters of an operator, it can be applied before, during,
 and/or after mating in a life cycle of a generation (parameter 
\family typewriter
stage
\family default
, see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), to a subset of generations (parameters 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
), a subset of populations in a simulator (parameter 
\family typewriter
rep
\family default
), a subset of (virtual) subpopulations in each replicate (parameter 
\family typewriter
subPop
\family default
).
\end_layout

\begin_layout Itemize
During-mating operators are used by mating schemes to transmit parental
 genotype (and sometimes information fields) to offspring.
 Applicability parameters such as 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
rep
\family default
 are ignored.
\end_layout

\begin_layout Itemize
Most of the operators can be applied to a population directly, using their
 function forms.
 Applicability parameters are ignored.
\end_layout

\begin_layout Standard
The following sections will introduce common features of all operators.
 The next chapter will explain some of the operators in detail.
\end_layout

\begin_layout Subsection
Applicable generations
\end_layout

\begin_layout Standard
A simuPOP life cycle (a 
\emph on
generation
\emph default
) can be divided into 
\emph on
pre-mating
\emph default
, 
\emph on
during-mating
\emph default
 and 
\emph on
post-mating
\emph default
.
 In the pre-mating stage, the present generation is the parental generation.
 In the during-mating stage, an offspring generation is populated from the
 parental generation.
 In the post-mating stage, the offspring generation has become the present
 generation.
 Operators specified in the 
\family typewriter
preOps
\family default
, 
\family typewriter
duringOps
\family default
 and 
\family typewriter
postOps
\family default
 parameters of the 
\family typewriter
simulator.evolve
\family default
 function are applied, respectively, at these stages.
\end_layout

\begin_layout Standard
Operators that are passed to the 
\family typewriter
simulator.evolve
\family default
 function are, by default, applied to all generations during an evolutionary
 process.
 This can be changed using the 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
 parameters.
 As their names indicate, these parameters control the starting generation
 (
\family typewriter
begin
\family default
), ending generation (
\family typewriter
end
\family default
), generations between two applicable generations (
\family typewriter
step
\family default
), and an explicit list of applicable generations (
\family typewriter
at
\family default
, a single generation number is also acceptable).
 Other parameters will be ignored if 
\family typewriter
at
\family default
 is specified.
 It is worth noting that, if the simulator has an ending generation, negative
 generations numbers are allowed.
 They are counted backward from the ending generation.
\end_layout

\begin_layout Standard
For example, if a simulator starts at generation 
\family typewriter
0
\family default
, and the 
\family typewriter
evolve
\family default
 function has parameter 
\family typewriter
gen=10
\family default
, the simulator will stop at the 
\emph on
beginning
\emph default
 of generation 
\family typewriter
10
\family default
.
 Generation 
\family typewriter
-1
\family default
 refers to generation 
\family typewriter
9
\family default
, and generation 
\family typewriter
-2
\family default
 refers to generation 
\family typewriter
8
\family default
, and so on.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 demonstrates how to set applicable generations of an operator.
 In this example, a population is initialized before evolution using a 
\family typewriter
initByFreq
\family default
 operator.
 allele frequency at locus 
\family typewriter
0
\family default
 is calculated at generation 
\family typewriter
80
\family default
, 
\family typewriter
90
\family default
, but not 
\family typewriter
100
\family default
 because the evolution stops at the beginning of generation 
\family typewriter
100
\family default
.
 A 
\family typewriter
pyEval
\family default
 operator outputs generation number and allele frequency at the end of generatio
n 
\family typewriter
80
\family default
 and 
\family typewriter
90
\family default
.
 Another 
\family typewriter
pyEval
\family default
 operator outputs similar information at generation 
\family typewriter
90
\family default
 and 
\family typewriter
99
\family default
, before and after mating.
 Note, however, because allele frequencies are only calculated twice, the
 pre-mating allele frequency at generation 
\family typewriter
90
\family default
 is actually calculated at generation 
\family typewriter
80
\family default
, and the allele frequencies display for generation 
\family typewriter
99
\family default
 are calculated at generation 
\family typewriter
90
\family default
.
 At the end of the evolution, the population is saved to a file using a
 
\family typewriter
savePopulation
\family default
 operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/applicableGen.log"
lstparams "caption={Applicable generations of an operator.},label={applicableGen}"

\end_inset


\end_layout

\begin_layout Subsection
Applicable populations
\end_layout

\begin_layout Standard
A simulator can evolve multiple replicates of a population simultaneously.
 Different operators can be applied to different replicates of this population.
 This allows side by side comparison between simulations.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
reps
\family default
 is used to control which replicate(s) an operator can be applied to.
 This parameter can be a list of replicate numbers or a single replicate
 number.
 Negative index is allowed where 
\family typewriter
-1
\family default
 refers to the last replicate.
 This technique has been widely used to produce table-like output where
 a 
\family typewriter
pyOutput
\family default
 outputs a newline when it is applied to the last replicate of a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to use this 
\family typewriter
reps
\family default
 parameter.
 It is worth noting that negative indexes are 
\emph on
dynamic
\emph default
 indexes relative to number of active populations.
 For example, 
\family typewriter
rep=-1
\family default
 will refer to a previous population if the last population has stopped
 evolving.
 Use a non-negative replicate number if this is not intended.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/replicate.log"
lstparams "caption={Apply operators to a subset of populations},label={replicate}"

\end_inset


\end_layout

\begin_layout Standard
An operator can also be applied to specified (virtual) subpopulations.
 For example, an 
\family typewriter
initializer
\family default
 can be applied to male individuals in the first subpopulation, and everyone
 in the second subpopulation using parameter 
\family typewriter
subPops=[(0,0)
\family default
, 1], if a virtual subpopulation is defined by individual sex.
 Generally speaking,
\end_layout

\begin_layout Itemize

\family typewriter
subPops=[]
\family default
 applies the operator to all subpopulation.
 This is usually the default value of an operator.
\end_layout

\begin_layout Itemize

\family typewriter
subPops=[vsp1, vsp2,...]
\family default
 applies the operator all specified (virtual) subpopulations.
 (e.g.
 
\family typewriter
subPops=[(0,0)
\family default
, 1]).
\end_layout

\begin_layout Itemize

\family typewriter
subPops=sp
\family default
 is an abbreviation for 
\family typewriter
subPops=[sp]
\family default
.
 If 
\family typewriter
sp
\family default
 is virtual, it has to be written as 
\family typewriter
[sp]
\family default
 because 
\family typewriter
subPops=(0, 1)
\family default
 is intepreted as two non-virtual subpopulation.
\end_layout

\begin_layout Standard
However, not all operators support this parameter, and even if they do,
 their interpretations of parameter input may vary.
 Please refer to documentation for individual operators in 
\emph on
the simuPOP reference manual
\emph default
 for details.
\end_layout

\begin_layout Subsection
Operator output *
\end_layout

\begin_layout Standard
All operators we have seen, except for the 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

, write their output to the standard output, namely your terminal window.
 However, it would be much easier for bookkeeping and further analysis if
 these output can be redirected to disk files.
 Parameter 
\family typewriter
output
\family default
 is designed for this purpose.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
output
\family default
 can take the following values:
\end_layout

\begin_layout Itemize

\family typewriter
''
\family default
 (an empty string): No output.
\end_layout

\begin_layout Itemize

\family typewriter
'>'
\family default
: Write to standard output.
\end_layout

\begin_layout Itemize

\family typewriter
'filename'
\family default
 or 
\family typewriter
'>filename'
\family default
: Write the output to a file named filename.
 If multiple operators write to the same file, or if the same operator writes
 to the file file several times, only the last write operation will succeed.
\end_layout

\begin_layout Itemize

\family typewriter
'>>filename'
\family default
: Append the output to a file named filename.
 The file will be opened at the beginning of 
\family typewriter
evolve
\family default
 function and closed at the end.
 An existing file will be cleared.
\end_layout

\begin_layout Itemize

\family typewriter
'>>>filename'
\family default
: This is similar to the 
\family typewriter
'>>'
\family default
 form but the file will not be cleared at the beginning of the 
\family typewriter
evolve
\family default
 function.
\end_layout

\begin_layout Itemize

\family typewriter
'!expr'
\family default
: 
\family typewriter
expr
\family default
 is considered as a Python expression that will be evaluated at a population's
 local namespace whenever an output string is needed.
 For example, 
\family typewriter
'!
\begin_inset Quotes erd
\end_inset

%d.txt
\begin_inset Quotes erd
\end_inset

 % gen'
\family default
 would return 
\family typewriter
0.txt
\family default
, 
\family typewriter
1.txt
\family default
 etc at generation 
\family typewriter
0
\family default
, 
\family typewriter
1
\family default
, ....
\end_layout

\begin_layout Itemize
A Python function that can accept a string as its only parameter (
\family typewriter
func(msg)
\family default
).
 When an operator outputs a message, this function will be called with this
 message.
\end_layout

\begin_layout Standard
Because a table output such as the one in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 is written by several operators, it is clear that all of them need to use
 the 
\family typewriter
'>>'
\family default
 output format.
\end_layout

\begin_layout Standard
The 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 write to file 
\family typewriter
sample.pop
\family default
.
 This works well if there is only one replicate but not so when the operator
 is applied to multiple populations.
 Only the last population will be saved successfully! In this case, the
 expression form of parameter 
\family typewriter
output
\family default
 should be used.
\end_layout

\begin_layout Standard
The expression form of this parameter accepts a Python expression.
 Whenever a filename is needed, this expression is evaluated against the
 local namespace of the population it is applied to.
 Because the 
\family typewriter
evolve
\family default
 function automatically sets variables 
\family typewriter
gen
\family default
 and 
\family typewriter
rep
\family default
 in a population's local namespace, such information can be used to produce
 an output string.
 Of course, any variable in this namespace can be used so you are not limited
 to these two variable.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates the use of these two parameters.
 In this example, a table is written to file 
\family typewriter
LD.txt
\family default
 using 
\family typewriter
output='>>LD.txt'
\family default
.
 Similar operation to 
\family typewriter
output='R2.txt'
\family default
 fails because only the last 
\begin_inset Formula $R^{2}$
\end_inset

 value is written to this file.
 The last operator writes output for each replicate to their respective
 output file such as 
\family typewriter
LD_0.txt
\family default
, using an expression that involves variable 
\family typewriter
rep
\family default
.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/output.log"
lstparams "caption={Use the output and outputExpr parameters},label={output}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "outputFunc"

\end_inset

 demonstrates an advanced usage of the 
\family typewriter
output
\family default
 parameter.
 In this example, a logging object is created to write to a logfile as well
 as the standard output.
 The 
\family typewriter
info
\family default
 and 
\family typewriter
debug
\family default
 functions of this object are assigned to two operators so that their outputs
 can be sent to both a logfile and to the console window.
 One of the advantages of using a logging mechanism is that debugging output
 could be suppressed easily by adjusting the logging level of the logging
 object.
 Note that function 
\family typewriter
logging.info()
\family default
 automatically adds a new line to its input messages before it writes them
 to an output.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/outputFunc.log"
lstparams "caption={Output to a Python function},label={outputFunc}"

\end_inset


\end_layout

\begin_layout Subsection
During-mating operators
\end_layout

\begin_layout Standard
All operators in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "replicate"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 are applied before or after mating.
 There is, however, a hidden during-mating operator that is called by 
\family typewriter
randomMating()
\family default
.
 This operator is called 
\family typewriter
mendelianGenoTransmitter()
\family default
 and is responsible for transmitting genotype from parents to offspring
 according to Mendel's laws.
 All pre-defined mating schemes (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Mating-Schemes"

\end_inset

) use a special kind of during-mating operator to transmit genotypes.
 They are called 
\series bold
genotype transmitters
\series default
 just to show the kind of task they perform.
\end_layout

\begin_layout Standard
During mating operators could be used in two ways:
\end_layout

\begin_layout Itemize
In the 
\family typewriter
ops
\family default
 parameter of a mating scheme (or an offspring generator if you are defining
 your own mating scheme).
 
\series bold
Operators specified in this way will replace the default operator a mating
 scheme uses
\series default
.
\end_layout

\begin_layout Itemize
In the 
\family typewriter
ops
\family default
 parameter of the 
\family typewriter
simulator.evolve
\family default
 function.
 
\series bold
These operators will be applied after an offspring is created using operators
 of a mating scheme
\series default
.
\end_layout

\begin_layout Standard
In another word,
\end_layout

\begin_layout Itemize
If you would like to change how genotypes are transmitted, replace the genotype
 transmitter of a mating scheme with your own ones.
 For example, 
\family typewriter
recombinator
\family default
 should generally be used in a mating scheme.
\end_layout

\begin_layout Itemize
If you would like to modify individual property after his or her genotypes
 are transmitted, use them in the 
\family typewriter
simulator.evolve
\family default
 function.
 A good example is operator 
\family typewriter
parentsTagger
\family default
 that record the indexes of an offspring's parents in the parental generation.
\end_layout

\begin_layout Standard
There are some subtleties involved in the use of during-mating operators.
 For example,
\end_layout

\begin_layout Itemize
During-mating operators do not support parameter 
\family typewriter
subPops
\family default
.
 If you would like to apply different during-mating operators to different
 (virtual) subpopulations, you can use a heterogeneous mating scheme that
 applies different homogeneous mating schemes with different operators to
 different (virtual) subpopulations.
\end_layout

\begin_layout Itemize
Operators used in a mating scheme honor applicability parameters 
\family typewriter
begin
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
at
\family default
 and 
\family typewriter
reps
\family default
 although they do not support negative population and replicate indexes.
 It is therefore possible to apply different during-mating operators at
 different generations.
 For example, a 
\family typewriter
recombinator
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "transmitter"

\end_inset

 to transmit parental genotypes to offspring after generation 30 while the
 
\family typewriter
mendelianGenoTransmitter
\family default
 is applied before that.
\end_layout

\begin_layout Itemize
Operators used in 
\family typewriter
simulator.evolve
\family default
 are applied after an individual is created.
 If something needs to be done before the default genotype transmitter is
 used, you have to replace the default genotype transmitter with a list
 of operators which will be called by the mating scheme in the order at
 which operators are specified.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/transmitter.log"
lstparams "caption={Genotype transmitters},label={transmitter}"

\end_inset


\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Pre-defined-genotype-transmitters"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Genotype-transmitters"

\end_inset

 list all genotype transmitters, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Customized-genotype-transmitter"

\end_inset

 demonstrates how to define your own genotype transmitter.
\end_layout

\begin_layout Subsection
Hybrid operators
\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a 
\emph on
hybrid operator
\emph default
.
\end_layout

\begin_layout Standard
A 
\emph on
hybrid operator
\emph default
 is an operator that calls a user-defined function when its applied to a
 population.
 The number and meaning of input parameters and return values vary from
 operator to operator.
 For example, a hybrid mutator sends a to-be-mutated allele to a user-defined
 function and use its return value as a mutant allele.
 A hybrid selector uses the return value of a user defined function as individua
l fitness.
 Such an operator handles the routine part of the work (e.g.
 scan through a chromosome and determine which allele needs to be mutated),
 and leave the creative part to users.
 Such a mutator can be used to implement complicated genetic models such
 as an asymmetric stepwise mutation model for microsatellite markers.
\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset CommandInset citation
LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (parameter 
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability that this individual will become
 affected.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/hybrid.log"
lstparams "caption={Use a hybrid operator},keywordstyle={\\ttfamily},label={hybridOperator}"

\end_inset


\end_layout

\begin_layout Subsection
Python operators *
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can always resort
 to a pure-Python operator 
\family typewriter
pyOperator
\family default
.
 This operator has full access to the evolving population (or parents and
 offspring when 
\family typewriter
stage=DuringMating
\family default
), and can therefore perform arbitrary operations.
\end_layout

\begin_layout Standard
A pre- or post-mating 
\family typewriter
pyOperator
\family default
 expects a function in the form of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

func(pop [, param])
\end_layout

\end_inset

where 
\family typewriter
param
\family default
 is optional, depending on whether or not a parameter is passed to the 
\family typewriter
pyOperator()
\family default
 constructor.
 Function 
\family typewriter
func
\family default
 can perform arbitrary action to 
\family typewriter
pop
\family default
 and must return 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
.
 
\series bold
The evolution of pop will be stopped if this function returns False.

\series default
 This is essentially how operator 
\family typewriter
terminateIf
\family default
 works.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 defines such a function.
 It accepts a cutoff value and two mutation rates as parameters.
 It then calculate the frequency of allele 1 at each locus and apply a two-allel
e model at high mutation rate if the frequency is lower than the cutoff
 and a low mutation rate otherwise.
 The 
\family typewriter
KamMutate
\family default
 function is the function form of a mutator 
\family typewriter
kamMutator
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Function-form"

\end_inset

 for details).
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.py"
lstparams "caption={A frequency dependent mutation operator},label={pyOperator},lastline=15"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 demonstrates how to use this operator.
 It first initializes the population using two 
\family typewriter
initByFreq
\family default
 operators that initialize loci with different allele frequencies.
 It applies a 
\family typewriter
pyOperator 
\family default
with function 
\family typewriter
dynaMutator
\family default
 and a tuple of parameters.
 Allele frequencies at all loci are printed at generation 
\family typewriter
0
\family default
, 
\family typewriter
10
\family default
, 
\family typewriter
20
\family default
, and 
\family typewriter
30
\family default
.
 Note that this 
\family typewriter
pyOperator
\family default
 is applied at to the parental generation so allele frequencies have to
 be recalculated to be used by post-mating operator 
\family typewriter
pyEval
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.log"
lstparams "caption={Use a pyOperator during evolution},firstline=16,label={usePyOperator}"

\end_inset


\end_layout

\begin_layout Standard
An 
\family typewriter
pyOperator
\family default
 can also be applied during-mating.
 They can be used to filter out unwanted offspring (by returning 
\family typewriter
False
\family default
 in a user-defined function), modify offspring, calculate statistics, or
 pass additional information from parents to offspring.
 Depending on parameter 
\family typewriter
param
\family default
 and 
\family typewriter
offspringOnly
\family default
, such an operator accepts a function in the form of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

func(pop, dad, mom, off [, param])  # if offspringOnly=False (default)
\end_layout

\begin_layout Plain Layout

func(off [, param])                 # if offspringOnly=True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "duringMatingPyOperator"

\end_inset

 demonstrates the use of a during-mating Python operator.
 This operator rejects an offspring if it has allele 1 at the first locus
 of the first homologous chromosome, and results in an offspring population
 without such individuals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyDuringMatingOperator.log"
lstparams "caption={Use a during-mating pyOperator},label={duringMatingPyOperator}"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is the most powerful operator in simuPOP and has been widely used, for
 example, to calculate statistics and is not supported by the 
\family typewriter
stat()
\family default
 operator, to examine population property during evolution, or prepare populatio
ns for a special mating scheme.
 However, because 
\family typewriter
pyOperator 
\family default
works in the Python interpreter, it is expected that it runs slower than
 operators that are implemented at the C/C++ level.
 If performance becomes an issue, you can re-implement part or all the operator
 in C++.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Using-C++"

\end_inset

 describes how to do this.
\end_layout

\begin_layout Subsection
Define your own operators **
\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 is a Python class so you can derive your own operator from this operator.
 The tricky part is that the constructor of the derived operator needs to
 call the 
\family typewriter
__init__
\family default
 function of 
\family typewriter
pyOperator
\family default
 will proper functions.
 This technique has been used by simuPOP in a number of occasions.
 For example, the 
\family typewriter
varPlotter
\family default
 operator defined in 
\family typewriter
plotter.py
\family default
 is derived from 
\family typewriter
pyOperator
\family default
.
 This class encapsulates several different plot class that uses 
\family typewriter
rpy
\family default
 to plot python expressions.
 One of the plotters is passed to the func parameter of 
\family typewriter
pyOperator.__init__
\family default
 so that it can be called when this operator is applied.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 rewrites the 
\family typewriter
dynaMutator
\family default
 defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 into a derived operator.
 The parameters are now passed to the constructor of 
\family typewriter
dynaMutator
\family default
 and are saved as member variables.
 A member function 
\family typewriter
mutate
\family default
 is defined and is passed to the constructor of 
\family typewriter
pyOperator
\family default
.
 Other than making 
\family typewriter
dynaMutator
\family default
 look like a real simuPOP operator, this example does not show a lot of
 advantage over defining a function.
 However, when the operator gets complicated (as in the case for 
\family typewriter
varPlotter
\family default
), the object oriented implementation will prevail.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/newOperator.log"
lstparams "caption={Define a new Python operator},label={newOperator}"

\end_inset


\end_layout

\begin_layout Standard
New during-mating operators can be defined similarly.
 They are usually used to define customized genotype transmitters.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Customized-genotype-transmitter"

\end_inset

 will describe this feature in detail.
\end_layout

\begin_layout Subsection
Function form of an operator
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-form"

\end_inset


\end_layout

\begin_layout Standard
Operators are usually applied to populations through a simulator but they
 can also be applied to a population directly.
 For example, it is possible to create an 
\family typewriter
initByFreq
\family default
 operator and apply to a population as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initByFreq([.3, .2, .5]).apply(pop)
\end_layout

\end_inset

Similarly, you can apply the hybrid penetrance model defined in Example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 to a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyPenetrance(func=myPenetrance, loci=[10, 30, 50]).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This usage is used so often that it deserves some simplification.
 Equivalent functions are defined for most operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/funcInitByFreq.log"
lstparams "caption={The function form of operator \\texttt{initByFreq}},label={funcInitByFreq}"

\end_inset


\end_layout

\begin_layout Standard
These functions are called function form of operators.
 Using these functions, the above two example can be written as 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InitByFreq(pop, [.3, .2, .5])
\end_layout

\end_inset

and 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyPenetrance(pop, func=myPenetrance, loci=[10, 30, 50])
\end_layout

\end_inset

respectively.
 Note that applicability parameters such as 
\family typewriter
begin
\family default
 and 
\family typewriter
end
\family default
 can still be passed, but they are ignored by these functions.
\end_layout

\begin_layout Note
Whereas output files specified by 
\family typewriter
'>'
\family default
 are closed immediately after they are written, those specified by 
\family typewriter
'>>'
\family default
 and 
\family typewriter
'>>>'
\family default
 are not closed after the operator is applied to a population.
 This is not a problem when operators are used in a simulator because 
\family typewriter
simulator.evolve
\family default
 closes all files opened by operators, but can cause trouble when the operator
 is applied directly to a population.
 For example, multiple calls to 
\family typewriter
Dump(pop, output='>>file')
\family default
 will dump pop to 
\family typewriter
file
\family default
 repeatedly but 
\family typewriter
file
\family default
 will not be closed afterward.
 In this case, 
\family typewriter
CloseOutput('file')
\family default
 should be used to explicitly close the file.
\end_layout

\begin_layout Section
Mating Schemes
\begin_inset CommandInset label
LatexCommand label
name "sec:Mating-Schemes"

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mating schemes are responsible for populating an offspring generation from
 the parental generation.
 There are currently three types of mating schemes
\end_layout

\begin_layout Itemize
A 
\series bold
homogeneous mating scheme
\series default
 is the most flexible and most frequently used mating scheme and is the
 center topic of this section.
 A homogeneous mating is composed of a 
\emph on
parent chooser
\emph default
 that is responsible for choosing parent(s) from a (virtual) subpopulation
 and an 
\emph on
offspring generator
\emph default
 that is used to populate all or part of the offspring generation.
 During-mating operators are used to transmit genotypes from parents to
 offspring.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:homogeneous-mating-scheme"

\end_inset

 demonstrates this process.
\end_layout

\begin_layout Itemize
A 
\series bold
heterogeneous mating scheme
\series default
 applies several homogeneous mating scheme to different (virtual) subpopulations.
 Because the division of virtual subpopulations can be arbitrary, this mating
 scheme can be used to simulate mating in heterogeneous populations such
 as populations with age structure.
\end_layout

\begin_layout Itemize
A 
\series bold
pedigree mating scheme
\series default
 that follows a recorded evolutionary scenario.
 The selection of parents and the production of offspring are controlled
 by a pedigree.
 This mating scheme does not support virtual subpopulation.
\end_layout

\begin_layout Standard
This section describes some standard features of mating schemes and most
 pre-defined mating schemes.
 The next section will demonstrate how to build complex nonrandom mating
 schemes from scratch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:homogeneous-mating-scheme"

\end_inset

A homogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/HomoMatingScheme.png
	lyxscale 20
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
A homogeneous mating scheme is responsible to choose parent(s) from a subpopulat
ion or a virtual subpopulation, and population part or all of the corresponding
 offspring subpopulation.
 A parent chooser is used to choose one or two parents from the parental
 generation, and pass it to an offspring generator, which produces one or
 more offspring.
 During mating operators such as taggers and recombinator can be applied
 when offspring is generated.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Control the size of the offspring generation
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-size"

\end_inset


\end_layout

\begin_layout Standard
A mating scheme goes through each subpopulation and populates the subpopulations
 of an offspring generation sequentially.
 The number of offspring in each subpopulation is determined by the mating
 scheme, following the following rules:
\end_layout

\begin_layout Itemize
A simuPOP mating scheme, by default, produces an offspring generation that
 has the same subpopulation sizes as the parental generation.
 This does not guarantee a constant population size because some operators,
 such as a migrator, can change population or subpopulation sizes.
\end_layout

\begin_layout Itemize
If fixed subpopulation sizes are given to parameter 
\family typewriter
subPopSize
\family default
.
 A mating scheme will generation an offspring generation with specified
 sizes even if an operator has changed parental population sizes.
\end_layout

\begin_layout Itemize
A demographic function can be specified to parameter 
\family typewriter
subPopSize
\family default
.
 This function should take two parameters: the generation number and the
 current parental population, and return an array of new subpopulation sizes.
 A single number can be returned if there is only one subpopulation.
\end_layout

\begin_layout Standard
The following examples demonstrate these cases.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrSize"

\end_inset

 uses a default 
\family typewriter
randomMating()
\family default
 scheme that keeps parental subpopulation sizes.
 Because migration between two subpopulations are asymmetric, the size of
 the first subpopulation increases at each generation, although the overall
 population size keeps constant.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrSize.log"
lstparams "caption={Free change of subpopulation sizes},label={migrSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrFixedSize"

\end_inset

 uses the same migrator to move individuals between two subpopulations.
 Because a constant subpopulation size is specified, the offspring generation
 always has 500 and 1000 individuals in its two subpopulations.
 Note that operators 
\family typewriter
stat
\family default
 and 
\family typewriter
pyEval
\family default
 are applied both before and after mating.
 It is clear that subpopulation sizes changes before mating as a result
 of migration, although the pre-mating population sizes vary because of
 uncertainties of migration.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrFixedSize.log"
lstparams "caption={Force constant subpopulation sizes},label={migrFixedSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "polygamous"

\end_inset

 uses a demographic function to control the subpopulation size of the offspring
 generation.
 This example implements a linear population expansion model but arbitrarily
 complex demographic model can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoFunc.log"
lstparams "caption={Use a demographic function to control population size},label={demoFunc}"

\end_inset


\end_layout

\begin_layout Standard
The parental population passed to a demographic function is usually used
 to determine offspring population size from parental population size.
 Although it is techniquely allowed to modify the parental population in
 preparation for mating (e.g.
 remove some individuals), such operation should generally be performed
 by an operator.
\end_layout

\begin_layout Subsection
Determine the number of offspring during mating
\begin_inset CommandInset label
LatexCommand label
name "sub:number-of-offspring"

\end_inset


\end_layout

\begin_layout Standard
simuPOP by default produces only one offspring per mating event.
 Because more parents are involved in the production of offspring, this
 setting leads to larger effective population sizes than mating schemes
 that produce more offspring at each mating event.
 However, various situations require a larger family size or even varying
 family sizes.
 In these cases, parameter 
\family typewriter
numOffspring
\family default
 can be used to control the number of offspring that are produced at each
 mating event.
 This parameter takes the following types of inputs
\end_layout

\begin_layout Itemize
If a single number is given, 
\family typewriter
numOffspring
\family default
 offspring are produced at each mating event.
\end_layout

\begin_layout Itemize
If a Python function is given, this function will be called each time when
 a mating event happens.
 Generation number will be passed to this function, which allows different
 numbers of offspring at different generations.
\end_layout

\begin_layout Itemize
If a tuple (or list) with more than one numbers is given, the first number
 must be one of 
\family typewriter
GeometricDistribution
\family default
, 
\family typewriter
PoissonDistribution
\family default
, 
\family typewriter
BinomialDistribution
\family default
 and 
\family typewriter
UniformDistribution
\family default
, with one or two additional parameters.
 The number of offspring will then follow a specific statistical distribution.
 Note that all these distributions are adjusted so that the minimal number
 of offspring is 1.
\end_layout

\begin_layout Standard
More specifically, 
\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(GeometricDistribution, p)
\family default
: The number of offspring for each mating event follows a geometric distribution
 with mean 
\begin_inset Formula $1/p$
\end_inset

 and variance 
\begin_inset Formula $\left(1-p\right)/p^{2}$
\end_inset

: 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(PoissonDistribution, p)
\family default
: The number of offspring for each mating event follows a shifted Poisson
 distribution with mean 
\begin_inset Formula $p+1$
\end_inset

 (you need to specify, for example, 2, if you want a mean family size of
 3) and variance 
\begin_inset Formula $p$
\end_inset

.
 The distribution is
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=p^{k-1}\frac{e^{-p}}{\left(k-1\right)!}\;\textrm{ for}k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(BinomialDistribution, p, n): 
\family default
The number of offspring for each mating event follows a shifted Binomial
 distribution with mean 
\begin_inset Formula $(n-1)p+1$
\end_inset

 and variance 
\begin_inset Formula $\left(n-1\right)p\left(1-p\right)$
\end_inset

.
 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}+1\;\textrm{ for }n\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(UniformDistribution, a, b):
\family default
 The number of offspring for each mating event follows a discrete uniform
 distribution with lower bound 
\begin_inset Formula $a$
\end_inset

 and upper bound 
\begin_inset Formula $b$
\end_inset

.
 
\begin_inset Formula \[
\mbox{Pr}\left(k\right)=\frac{1}{b-a+1}\;\textrm{ for }b\geq k\geq a\]

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "numOff"

\end_inset

 demonstrates how to use parameter 
\family typewriter
numOffspring
\family default
.
 In this example, a function 
\family typewriter
checkNumOffspring
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 30 individuals.
 After evolving a population for one generation, parental indexes are used
 to identify siblings, and then the number of offspring per mating event.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/numOff.log"
lstparams "caption={Control the number of offspring per mating event.},label={numOff}"

\end_inset


\end_layout

\begin_layout Subsection
Determine offspring sex
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-sex"

\end_inset


\end_layout

\begin_layout Standard
Because sex can influence how genotypes are transmitted (e.g.
 sex chromosomes, haplodiploid population), simuPOP determines offspring
 sex before it passes an offspring to a 
\emph on
genotype transmitter
\emph default
 (during-mating operator) to transmit genotype from parents to offspring.
 The default 
\family typewriter
sexMode
\family default
 in almost all mating schemes is 
\family typewriter
RandomSex
\family default
, in which case simuPOP assign 
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
 to offspring with equal probability.
\end_layout

\begin_layout Standard
Other sex determination methods are also available:
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=NoSex
\family default
: Sex is not simulated so everyone is Male.
 This is the default mode where offspring can be Male or Female with equal
 probability.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(ProbOfMale, prob)
\family default
: Produce males with given probability.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NumOfMale, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Male
\family default
.
 If the number of offspring at a mating event is less than or equal to 
\family typewriter
n
\family default
, all offspring will be male.
 
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NumOfFemale, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Female
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
NumOfMale
\family default
 and 
\family typewriter
NumOfFemale
\family default
 are useful in theoretical studies where the sex ratio of a population needs
 to be controlled strictly, or in special mating schemes, usually for animal
 populations, where only a certain number of male or female individuals
 are allowed in a family.
 It worth noting that a genotype transmitter can override specified offspring
 sex.
 This is the case for 
\family typewriter
cloneGenoTransmitter
\family default
 where an offspring inherits both genotype and sex from his/her parent.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexMode"

\end_inset

 demonstrates how to use parameter 
\family typewriter
sexMode
\family default
.
 In this example, a function 
\family typewriter
checkSexMode
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 40 individuals.
 After evolving a population for one generation, sexes of all offspring
 are returned as a string.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexMode.log"
lstparams "caption={Determine the sex of offspring},label={sexMode}"

\end_inset


\end_layout

\begin_layout Subsection
Monogamous mating
\end_layout

\begin_layout Standard
Monogamous mating (monogamy) in simuPOP refers to mating schemes in which
 each parent mates only once.
 In an asexual setting, this implies parents are chosen without replacement.
 In sexual mating schemes, this means that parents are chosen without replacemen
t, they have only one spouse during their life time so that all siblings
 have the same parents (no half-sibling).
\end_layout

\begin_layout Standard
simuPOP provides a diploid sexual monogamous mating scheme 
\family typewriter
monogamousMating
\family default
.
 However, without careful planning, this mating scheme can easily stop working
 due to the lack of parents.
 For example, if a population has 40 males and 55 females, only 40 successful
 mating events can happen and result in 40 offspring in the offspring generation.
 
\family typewriter
monogamousMating
\family default
 will exit if the offspring generation is larger than 40.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "monogamous"

\end_inset

 demonstrates one scenario of using a monogamous mating scheme where sex
 of parents and offspring are strictly specified so that parents will not
 be exhausted.
 The sex initializer 
\family typewriter
initSex
\family default
 assigns exactly 10 males and 10 females to the initial population.
 Because of the use of 
\family typewriter
numOffspring=2, sexMode=(NumOfMale, 1)
\family default
, each mating event will produce exactly one male and one female.
 Unlike a random mating scheme that only about 80% of parents are involved
 in the production of an offspring population with the same size, this mating
 scheme makes use of all parents.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/monogamous.log"
lstparams "caption={Sexual monogamous mating},label={monogamous}"

\end_inset


\end_layout

\begin_layout Subsection
Polygamous mating
\end_layout

\begin_layout Standard
In comparison to monogamous mating, parents in a polygamous mate with more
 than one spouse during their life-cycle.
 Both 
\emph on
polygany
\emph default
 (one man has more than one wife) and 
\family typewriter
\emph on
polyandry
\family default
\emph default
 (one woman has more than one husband) are supported.
\end_layout

\begin_layout Standard
Other than regular parameters such as 
\family typewriter
numOffspring
\family default
, mating scheme 
\family typewriter
polygamousMating
\family default
 accepts parameters 
\family typewriter
polySex
\family default
 (default to 
\family typewriter
Male
\family default
) and 
\family typewriter
polyNum
\family default
 (default to 1).
 During mating, an individual with 
\family typewriter
polySex
\family default
 is selected and then mate with 
\family typewriter
polyNum
\family default
 randomly selected spouse.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "polygamous"

\end_inset

 demonstrates the use of this mating schemes.
 Note that this mating scheme support natural selection, but does not yet
 handle varying 
\family typewriter
polyNum
\family default
 and selection of parents without replacement.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/polygamous.log"
lstparams "caption={Sexual polygamous mating},label={polygamous}"

\end_inset


\end_layout

\begin_layout Subsection
Asexual random mating
\end_layout

\begin_layout Standard
Mating scheme 
\family typewriter
randomSelection
\family default
 implements an asexual random mating scheme.
 It randomly select parents from a parental population (with replacement)
 and copy them to an offspring generation.
 Both genotypes and sex of the parents are copied because genotype and sex
 are sometimes related.
 This mating scheme can be used to simulate the evolution of haploid sequences
 in a standard haploid Wright-Fisher model.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomSelection"

\end_inset

 applies a 
\family typewriter
randomSelection
\family default
 mating scheme to a haploid population with 100 sequences.
 A 
\family typewriter
parentTagger
\family default
 is used to track the parent of each individual.
 Although sex information is not used in this mating scheme, individual
 sexes are initialized and passed to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomSelection.log"
lstparams "caption={Asexual random mating},label={randomSelection}"

\end_inset


\end_layout

\begin_layout Subsection
Mating with alpha individuals *
\end_layout

\begin_layout Standard
The 
\family typewriter
alphaMating
\family default
 mating scheme is intended to simulate animal populations in which only
 individuals with alpha status have the power to mate.
 In this mating scheme, a number of alpha individuals with specified sex
 (
\family typewriter
alphaSex
\family default
) are determined, either randomly (
\family typewriter
alphaNum
\family default
) or according to values at an information field (
\family typewriter
alphaField
\family default
).
 During mating, only individuals from this alpha group can be selected to
 mate.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "alphaMating"

\end_inset

 gives a simple evolutionary scenario where two alpha males are chosen according
 to individual fitness values at each generation.
 The fitness value of each individual is determined by his/her genotype
 at the first locus, 
\family typewriter
0.8
\family default
, 
\family typewriter
0.8
\family default
, and 
\family typewriter
1
\family default
 for genotype 
\family typewriter
AA
\family default
, 
\family typewriter
Aa
\family default
, and 
\family typewriter
aa
\family default
 respectively.
 Because individuals having mutant 
\family typewriter
a
\family default
 have a high probability to be selected, and become the alpha male in this
 population, the frequency of this mutant tend to increase in this population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/alphaMating.log"
lstparams "caption={Random mating with alpha individuals},label={alphaMating}"

\end_inset


\end_layout

\begin_layout Subsection
Mating in haplodiploid populations
\end_layout

\begin_layout Standard
Male individuals in a haplodiploid population are derived from unfertilized
 eggs and thus have only one set of chromosomes.
 Mating in such a population is handled by a special mating scheme called
 
\family typewriter
haplodiplodMating
\family default
.
 This mating scheme chooses a pair of parents randomly and produces some
 offspring.
 It transmit maternal chromosomes and paternal chromosomes (the only copy)
 to female offspring, and only maternal chromosomes to male offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "haplodiploidMating"

\end_inset

 demonstrates how to use this mating scheme.
 It uses three initializers because sex has to be initialized before two
 other intializers can initialize genotype by sex.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploidMating.log"
lstparams "caption={Random mating in haplodiploid populations},label={haplodiploidMating}"

\end_inset


\end_layout

\begin_layout Standard
Note that this mating scheme does not support recombination and the standard
 recombinator does not work with haplodiploid populations.
 Please refer to the next Chapter for how to define a customized genotype
 transmitter to handle such a situation.
\end_layout

\begin_layout Subsection
Self-fertilization
\end_layout

\begin_layout Standard
Some plant populations evolve through self-fertilization.
 That is to say, a parent fertilizes with itself during the production of
 offspring (seeds).
 In a 
\family typewriter
selfMating
\family default
 mating scheme, parents are chosen randomly (one at a time), and are used
 twice to produce two homologous sets of offspring chromosomes.
 The standard recombinator can be used with this mating scheme.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selfMating"

\end_inset

 initializes each chromosome with different alleles to demonstrate how these
 alleles are transmitted in this population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selfMating.log"
lstparams "caption={Selfing mating scheme},label={selfMating}"

\end_inset


\end_layout

\begin_layout Subsection
Heterogeneous mating schemes *
\end_layout

\begin_layout Standard
Different groups of individuals in a population may have different mating
 patterns.
 For example, individuals with different properties can have varying fecundity,
 represented by different numbers of offspring generated per mating event.
 This can be extended to aged populations in which only adults (may be defined
 by age > 20 and age < 40) can produce offspring, where other individuals
 will either be copied to the offspring generation or die.
\end_layout

\begin_layout Standard
A heterogeneous mating scheme (
\family typewriter
heteroMating
\family default
) accepts a list of mating schemes that are applied to different subpopulation
 or virtual subpopulations.
 If multiple mating schemes are applied to the same subpopulation, each
 of them only population part of the offspring subpopulation.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heterogenous-mating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heterogenous-mating"

\end_inset

Illustration of a heterogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/MatingScheme.png
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
A heterogeneous mating scheme that applies homogeneous mating schemes MS0,
 MS0.0, MS0.1, MS1, MS2.0 and MS2.1 to subpopulation 0, the first and second
 virtual subpopulation in subpopulation 0, subpopulation 1, the first and
 second virtual subpopulation in subpopulation 2, respectively.
 Note that VSP 0 and 1 in subpopulation 0 overlap, and do not add up to
 subpopulation 0.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingSP"

\end_inset

 applies two random mating schemes to two subpopulations.
 The first mating scheme produces two offspring per mating event, and the
 second mating scheme produces four.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingSP.log"
lstparams "caption={Applying different mating schemes to different subpopulations },label={hateroMatingSP}"

\end_inset


\end_layout

\begin_layout Standard
The real power of heterogeneous mating schemes lies on their ability to
 apply different mating schemes to different virtual subpopulations.
 For example, due to different micro-environmental factors, plants in the
 same population may exercise both self and cross-fertilization.
 Because of the randomness of such environmental factors, it is difficult
 to divide a population into self and cross-mating subpopulations.
 Applying different mating schemes to groups of individuals in the same
 subpopulation is more appropriate.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingVSP"

\end_inset

 applies two mating schemes to two VSPs defined by proportions of individuals.
 In this mating scheme, 20% of individuals go through self-mating and 80%
 of individuals go through random mating.
 This can be seen from the parental indexes of individuals in the offspring
 generation: individuals whose 
\family typewriter
mother_idx
\family default
 are 
\family typewriter
-1
\family default
 are genetically only derived from their fathers.
 
\end_layout

\begin_layout Standard
It might be surprising that offspring resulted from two mating schemes mix
 with each other so the same VSPs in the next generation include both selfed
 and cross-fertilized offspring.
 If this not desired, you can set parameter 
\family typewriter
shuffleOffspring=False
\family default
 in 
\family typewriter
heteroMating
\family default
().
 Because the number of offspring that are produced by each mating scheme
 is proportional to the size of parental (virtual) subpopulation, the first
 20% of individuals that are produced by self-fertilization will continue
 to self-fertilize.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingVSP.log"
lstparams "caption={Applying different mating schemes to different virtual subpopulations },label={hateroMatingVSP}"

\end_inset


\end_layout

\begin_layout Standard
Because there is no restriction on the choice of VSPs, mating schemes can
 be applied to overlapped (virtual) subpopulations.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        selfMating(subPop=(0, 0)),
\end_layout

\begin_layout Plain Layout

        randomMating(subPop=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will apply selfMating to the first 20% individuals, and randomMating will
 be applied to all individuals.
 Similarly,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        selfMating(subPop=0),
\end_layout

\begin_layout Plain Layout

        randomMating(subPop=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will allow all individuals to be involved in both 
\family typewriter
selfMating
\family default
 and 
\family typewriter
randomMating
\family default
.
\end_layout

\begin_layout Standard
This raises the question of how many offspring each mating scheme will produce.
 By default, the number of offspring produced will be proportional to the
 size of parental (virtual) subpopulations.
 In the last example, because both mating schemes are applied to the same
 subpopulation, half of all offspring will be produced by selfing and the
 other half will be produced by random mating.
\end_layout

\begin_layout Standard
This behavior can be changed by a weighting scheme controlled by parameter
 
\family typewriter
weight
\family default
 of each homogeneous mating scheme.
 Briefly speaking, a positive weight will be compared against other mating
 schemes.
 a negative weight is considered proportional to the existing (virtual)
 subpopulation size.
 Negative weights are considered before position or zero weights.
\end_layout

\begin_layout Standard
This weighting scheme is best explained by an example.
 Assuming that there are three mating schemes working on the same parental
 subpopulation
\end_layout

\begin_layout Itemize
Mating scheme A works on the whole subpopulation of size 1000
\end_layout

\begin_layout Itemize
Mating scheme B works on a virtual subpopulation of size 500
\end_layout

\begin_layout Itemize
Mating scheme C works on another virtual subpopulation of size 800
\end_layout

\begin_layout Standard
Assuming the corresponding offspring subpopulation has 
\begin_inset Formula $N$
\end_inset

 individuals, 
\end_layout

\begin_layout Itemize
If all weights are 0, the offspring subpopulation is divided in proportion
 to parental (virtual) subpopulation sizes.
 In this example, the mating schemes will produce 
\begin_inset Formula $\frac{10}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{5}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{8}{23}N$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Itemize
If all weights are negative, they are multiplied to their parental (virtual)
 subpopulation sizes.
 For example, weight (-1, -2, -0.5) will lead to sizes (1000, 1000, 400)
 in the offspring subpopulation.
 If 
\begin_inset Formula $N\ne2400$
\end_inset

 in this case, an error will be raised.
\end_layout

\begin_layout Itemize
If all weights are positive, the number of offspring produced from each
 mating scheme is proportional to these weights.
 For example, weights (1, 2, 3) will lead to 
\begin_inset Formula $\frac{1}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{2}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{1}{3}N$
\end_inset

 individuals respectively.
 In this case, 0 weights will produce no offspring.
\end_layout

\begin_layout Itemize
If there are mixed positive and negative weights, the negative weights are
 processed first, and the rest of the individuals are divided using non-negative
 weights.
 For example, three mating schemes with weights (-0.5, 2, 3) will produce
 500, 
\begin_inset Formula $\frac{2}{5}\left(N-500\right)$
\end_inset

, 
\begin_inset Formula $\frac{3}{5}\left(N-500\right)$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Standard
The last case is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMatingWeight"

\end_inset

 where three random mating schemes are applied to subpopulation 
\family typewriter
0
\family default
, virtual subpopulation
\family typewriter
 (0, 0)
\family default
 and virtual subpopulation 
\family typewriter
(0, 1)
\family default
, with weights 
\family typewriter
-
\family default
0.5, 
\family typewriter
2
\family default
, and 
\family typewriter
3
\family default
 respectively.
 This example uses an advanced features that will be described in the next
 section.
 Namely, three during-mating Python operators are passed to each mating
 scheme to mark their offspring with different numbers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMatingWeight.log"
lstparams "caption={A weighting scheme used by heterogeneous mating schemes.},label={heteroMatingWeight}"

\end_inset


\end_layout

\begin_layout Section
Non-random and customized mating schemes *
\end_layout

\begin_layout Subsection
The structure of a homogeneous mating scheme *
\end_layout

\begin_layout Standard
A 
\emph on
homogeneous mating scheme
\emph default
 populates an offspring generation as follows:
\end_layout

\begin_layout Enumerate
Create an empty offspring population (generation) with appropriate size.
 Parental and offspring generation can differ in size but they must have
 the same number of subpopulations.
\end_layout

\begin_layout Enumerate
For each subpopulation, repeatedly choose a parent or a pair of parents
 from the parental generation.
 This is done by a simuPOP object called a 
\series bold
parent chooser
\series default
.
\end_layout

\begin_layout Enumerate
One or more offspring are produced from the chosen parent(s) and are placed
 in the offspring population.
 This is done by a simuPOP 
\series bold
offspring generator
\series default
.
\end_layout

\begin_layout Enumerate
A offspring generator uses one or more during-mating operators to transmit
 parental genotype to offspring.
 These operators are call 
\series bold
genotype transmitters
\series default
.
\end_layout

\begin_layout Enumerate
After the offspring generation is populated, it will replace the parental
 generation and becomes the present generation of a population.
\end_layout

\begin_layout Standard
A simuPOP mating scheme uses a particular set of parent chooser, offspring
 generator, and genotype transmitters.
 For example, a 
\family typewriter
selfingMating
\family default
 mating scheme uses a 
\family typewriter
randomParentChooser
\family default
 to choose a parent randomly from a population, possibly according to individual
 fitness, it uses a standard 
\family typewriter
offspringGenerator
\family default
 that uses a 
\family typewriter
selfingOffspringGenerator
\family default
 to transmit genotype.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomMating"

\end_inset

 demonstrates how the most commonly used mating scheme, the diploid sexual
 
\family typewriter
randomMating
\family default
 mating scheme is defined in 
\family typewriter
simuPOP.py
\family default
.
 The following sections basically explain how you can construct your own
 mating scheme from scratch, using stocked or customized parent chooser,
 offspring generator and genotype transmitters.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomMating.py"
lstparams "caption={Define a random mating scheme},firstline=4,label={randomMating}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
homoMating
\family default
 mating scheme *
\end_layout

\begin_layout Standard

\family typewriter
homoMating
\family default
 is used to define all pre-defined homogeneous mating schemes.
 It takes five parameters: 
\family typewriter
chooser
\family default
 (a 
\emph on
parent chooser
\emph default
 that is responsible for choosing one or two parents from the parental generatio
n), 
\family typewriter
generator
\family default
 (an 
\emph on
offspring generator
\emph default
 that is responsible for generating a number of offspring from the chosen
 parents), 
\family typewriter
subPopSize
\family default
 (parameter to control offspring subpopulation sizes), 
\family typewriter
subPop
\family default
 (applicable subpopulation or virtual subpopulation), and 
\family typewriter
weight
\family default
 (weighting parameter when used in a heterogeneous mating scheme).
 When this mating scheme is applied to the whole population, 
\family typewriter
subPopSize
\family default
 is used to determine the subpopulation sizes of the offspring generation
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

 for details), parameters 
\family typewriter
subPop
\family default
 and 
\family typewriter
weight
\family default
 are ignored.
 Otherwise, the number of offspring this mating scheme will produce is determine
d by the heterogeneous mating scheme.
 Figure 
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
subPopSize
\family default
, 
\family typewriter
subPop
\family default
 and 
\family typewriter
weight
\family default
 are more or less standard but different parent choosers and offspring generator
s can be combined to define a large number of homogeneous mating schemes.
 For example, the standard 
\family typewriter
selfMating
\family default
 mating scheme uses a 
\family typewriter
randomParentChooser
\family default
 but you can easily use a 
\family typewriter
sequentialParentChooser
\family default
 to choose parents sequentially and self-fertilize parents one by one.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sequentialSelfing.log"
lstparams "caption={Define a sequential selfing mating scheme},label={sequentialSelfing}"

\end_inset


\end_layout

\begin_layout Standard
The simuPOP reference manual lists all pre-defined parent choosers and offspring
 generators.
 They may or may not work together depending on the number of parents a
 parent chooser produces, and the number of parents an offspring generator
 can handle.
 You can also define your own parent choosers and offspring generators,
 as shown below.
\end_layout

\begin_layout Subsection
Offspring generators *
\end_layout

\begin_layout Standard
An 
\family typewriter
offspringGenerator
\family default
 accepts a parameters 
\family typewriter
ops
\family default
 (a list of during-mating operators), 
\family typewriter
numOffspring
\family default
 (control number of offspring per mating event) and 
\family typewriter
sexMode
\family default
 (control offspring sex).
 We have examined the last two parameters in detail in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:number-of-offspring"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-sex"

\end_inset

.
 
\end_layout

\begin_layout Standard
The most tricky parameter is the 
\family typewriter
ops
\family default
 parameter.
 It accepts a list of during mating operators that are used to transmit
 genotypes from parent(s) to offspring and/or set individual information
 fields.
 The standard 
\family typewriter
offspringGenerator
\family default
 does not have any default operator so no genotype will be transmitted by
 default.
 All stock mating schemes use a default genotype transmitter.
 (e,g, a 
\family typewriter
mendelianGenoTransmitter
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomMating"

\end_inset

 is passed to the offspring generator used in 
\family typewriter
randomMating
\family default
.
 If you add some operators to a mating scheme, please do not forget to specify
 the genotype transmitter.
 (see Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMatingWeight"

\end_inset

).
\end_layout

\begin_layout Standard
Another offspring generator is provided in simuPOP.
 This 
\family typewriter
controlledOffspringGenerator 
\family default
is used to control an evolutionary process so that the allele frequencies
 at certain loci follows some pre-simulated 
\emph on
frequency trajectories
\emph default
.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

 for rationals behind such an offspring generator and its applications in
 the simulation of complex human diseases.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

 demonstrates the use of such a controlled offspring generator.
 Instead of using a realistic frequency trajectory function, it forces allele
 frequency at locus 5 to increase linearly.
 In contrast, the allele frequency at locus 15 on the second chromosome
 oscillates as a result of genetic drift.
 Note that the random mating version of this mating scheme is defined in
 simuPOP as 
\family typewriter
controlledRandomMating
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/controlledOffGenerator.log"
lstparams "caption={A controlled random mating scheme},label={controlledOffGenerator}"

\end_inset


\end_layout

\begin_layout Subsection
Pre-defined genotype transmitters *
\begin_inset CommandInset label
LatexCommand label
name "sub:Pre-defined-genotype-transmitters"

\end_inset


\end_layout

\begin_layout Standard
Although any during mating operators can be used in parameter 
\family typewriter
ops 
\family default
of an offspring generator, those that transmit genotype from parents to
 offspring are customarily called 
\series bold
genotype transmitters
\series default
.
 simuPOP provides a number of genotype transmitters including clone, Mendelian,
 selfing, haplodiploid, genotype transmitter, and a recombinator.
 They are usually used implicitly in a mating scheme, but they can also
 be used explicitly.
\end_layout

\begin_layout Standard
All genotype transmitters only handle known chromosome types such as Autosome,
 ChromosomeX and ChromosomeY.
 Customized chromosomes are left untouched because simuPOP does not know
 how they should be transmitted from parents to offspring.
 In case that Customized chromosomes are treated as mitochondrial chromosomes,
 a 
\family typewriter
mitochondrialGenoTransmitter
\family default
 can be used to transmit Customized chromosomes randomly from mother to
 offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mitochondrial.log"

\end_inset

 demonstrates the use of a 
\family typewriter
recombinator
\family default
 to recombine an autosome and two sex chromosomes, and a 
\family typewriter
mitochondrialGenoTransmitter
\family default
 to transmit mitochondrial chromosomes.
 Note that the default 
\family typewriter
mendelianGenoTransmitter
\family default
 is replaced by these two operators.
 It will be (wastefully) applied if the new during-mating operators are
 used in the 
\family typewriter
simulator.evolve
\family default
 function.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mitochondrial.log"
lstparams "caption={Transmission of mitochondrial chromosomes},label={mitochondrial.log}"

\end_inset


\end_layout

\begin_layout Subsection
Customized genotype transmitter **
\begin_inset CommandInset label
LatexCommand label
name "sub:Customized-genotype-transmitter"

\end_inset


\end_layout

\begin_layout Standard
Although simuPOP provides a number of genotype transmitters, they may still
 be cases where customized genotype transmitter is needed.
 For example, a recombinator can be used to recombine parental chromosomes
 but it is well known that male and female individuals differ in recombination
 rates.
 How can you apply two different recombinators to male and female individuals
 separately?
\end_layout

\begin_layout Standard
An immediate thought can be the use of virtual subpopulations.
 If you apply two random mating schemes to two virtual subpopulations defined
 by sex, 
\family typewriter
randomParentsChooser
\family default
 will not work because no opposite sex can be found in each virtual subpopulatio
n.
 In this case, a customized genotype transmitter can be used.
\end_layout

\begin_layout Standard
A customized genotype transmitter is only a Python during-mating operator.
 Although it is possible to define a function and use a pyOperator directly
 (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

), it is much better to derive an operator from pyOperator, as the case
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "newOperator"

\end_inset

.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoChooser"

\end_inset

 defines a 
\family typewriter
sexSpecificRecombinator
\family default
 that uses, internally, two different recombinators to recombine male and
 female parents.
 The key statement is the 
\family typewriter
pyOperator.__init__
\family default
 line which initializes a Python operator with given function 
\family typewriter
self.transmitGenotype
\family default
.
\end_layout

\begin_layout Standard
The actual function to transmit parental genotype is 
\family typewriter
self.transmitGenotype
\family default
.
 This function initializes two recombinators if they have not been initialized
 and uses them to transmit parental genotypes.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 outputs the population in two generations.
 You should notice that paternal chromosome are not recombined when they
 are transmitted to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexSpecificRec.log"
lstparams "caption={A customized genotype transmitter for sex-specific recombination},label={sexSpecificRec}"

\end_inset


\end_layout

\begin_layout Subsection
Pre-define parent choosers *
\end_layout

\begin_layout Standard
Parent choosers are responsible for choosing one or two parents from a parental
 (virtual) subpopulation.
 simuPOP defines a few parent choosers that choose parent(s) sequentially,
 randomly (with or without replacement), or with additional conditions.
 Some of these parent choosers support natual selection.
 Please refer to the simuPOP reference manual for details about these objects.
\end_layout

\begin_layout Standard
We have seen sequential and random parent choosers in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

.
 A less-used parent chooser is 
\family typewriter
infoParentsChooser
\family default
, which chooses a parent randomly, and his/her spouse from indexes stored
 in his/her information fields.
 This parent chooser is usually used in a consanguineous mating scheme where
 certain types of relatives of each individual are stored in his/her information
 fields, and used during the selection of spouses.
 For example, a 
\family typewriter
consanguineousMating
\family default
 mating scheme in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoChooser"

\end_inset

 produces a male and a female offspring at each mating event.
 Before mating, a function is called to record every individual's sibling
 in his/her information field 
\family typewriter
sibling
\family default
.
 During mating, a parent is chosen randomly, and mates with his/her sibling.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoChooser.log"
lstparams "caption={A consanguineous mating scheme.},label={infoChooser}"

\end_inset


\end_layout

\begin_layout Standard
This example does not make such sense because consanguineous mating usually
 happens between first and second degree relatives, and represents only
 a small fraction of total parents in a population.
 
\family typewriter
doc/cook/Mating_consanguineous.py
\family default
 gives a more realistic example in which certain proportion of offspring
 are produced by random mating, and others are results of marriages between
 first-degree cousins.
\end_layout

\begin_layout Subsection
A Python parent chooser *
\end_layout

\begin_layout Standard
A parent choosing scheme can be quite complicated in reality.
 For example, salamanders along a river may mate with their neighbors and
 form several subspecies.
 This behavior cannot be readily simulated using any pre-define parent choosers
 so a hybrid parent chooser 
\family typewriter
pyParentsChooser()
\family default
 should be used.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyParentsChooser
\family default
 accepts a user-defined Python generator function, instead of a normal python
 function, that returns a parent, or a pair of parents repeatedly.
 Briefly speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when this iterator iterates, this function resumes where it was
 stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,5$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 sequentially.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator.log"
lstparams "caption={A sample generator function},label={generator}"

\end_inset


\end_layout

\begin_layout Standard
A 
\family typewriter
pyParentsChooser
\family default
 accepts a parent generator function, which takes a population and a subpopulati
on index as parameters.
 When this parent chooser is applied to a subpopulation, it will call this
 generator function and ask the generated generator object repeated for
 either a parent, or a pair of parents (
\emph on
references to individual objects or indexes relative to a subpopulation
\emph default
).
 Note that 
\family typewriter
pyParentsChooser
\family default
 does not support virtual subpopulation but you can mimic the effect by
 returning only parents from certain virtual subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyParentsChooser"

\end_inset

 implements a hybrid parent chooser that chooses parents with equal social
 status (
\family typewriter
rank
\family default
).
 In this parent chooser, all males and females are categorized by their
 sex and social status.
 A parent is chosen randomly, and then his/her spouse is chosen from females/mal
es with the same social status.
 The rank of their offspring can increase or decrease randomly.
 It becomes obvious now that whereas a python function can return random
 male/female pair, the generator interface is much more efficient because
 the identification of sex/status groups is done only once.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyParentsChooser.log"
lstparams "caption={A hybrid parent chooser that chooses parents by their social status},label={pyParentsChooser}"

\end_inset


\end_layout

\begin_layout Subsection
Using C++ to implement a parent chooser **
\begin_inset CommandInset label
LatexCommand label
name "sub:Using-C++"

\end_inset


\end_layout

\begin_layout Standard
A user defined parent chooser can be fairly complex and computationally
 intensive.
 For example, if a parent tends to find a spouse in his/her vincinity, geometric
 distances between all qualified individuals and a chosen parent need to
 be calculated for each mating event.
 If the optimization of the parent chooser can speed up the simulation significa
ntly, it may be worthwhile to write the parent chooser in C++.
 
\end_layout

\begin_layout Standard
Although it is feasible, and sometimes easier to derive a class from class
 
\family typewriter
parentChooser
\family default
 in mating.h (.cpp), modifying simuPOP source code is not recommended because
 you would have to modify a new version of simuPOP whenever you upgrade
 your simuPOP distribution.
 Implementing your parent choosing algorithm in another Python module is
 preferred.
\end_layout

\begin_layout Standard
The first step is to write your own parent chooser in C/C++.
 Basically, you will need to pass all necessary information to the C++ level
 and implement an algorithm to choose parents randomly.
 Although simple function based solutions are possible, a C++ level class
 such as the 
\family typewriter
myParentsChooser 
\family default
class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 is recommended.
 This class is initialized with indexes of male and female individuals and
 use a function 
\family typewriter
chooseParents
\family default
 to return a pair of parents randomly.
 This parent chooser is very simple but more complicated parent selection
 scenarios can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.h"
lstparams "caption={Implement a parent chooser in C++},label={parentChooseHeader},language=C"

\end_inset


\end_layout

\begin_layout Standard
The second step is to wrap your C++ functions and classes to a Python module.
 There are many tools available but SWIG (
\family typewriter
www.swig.org
\family default
) is arguably the most convenient and powerful one.
 To use SWIG, you will need to prepare an interface file, which basically
 tells SWIG which functions and classes you would like to expose and how
 to pass parameters between Python and C++.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserInterface"

\end_inset

 lists an interface file for the C++ class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

.
 Please refer to the SWIG reference manual for details.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.i"
lstparams "caption={An interface file for the myParentsChooser class},label={parentsChooserInterface},language=Awk"

\end_inset


\end_layout

\begin_layout Standard
The exact procedure to generate and compile a wrapper file varies from system
 to system, and from compiler to compiler.
 Fortunately, the standard Python module setup process supports SWIG.
 All you need to do is to write a Python 
\family typewriter
setup.py
\family default
 file and let the 
\family typewriter
distutil
\family default
 module of Python handle all the details for you.
 A typical 
\family typewriter
setup.py
\family default
 file is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserSetup"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/setup.py"
lstparams "caption={Building and installing the myParentsChooser module},label={parentsChooserSetup}"

\end_inset


\end_layout

\begin_layout Standard
You parent chooser can now be compiled and installed using the standard
 Python 
\family typewriter
setup.py
\family default
 commands such as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to the Python reference manual for other building and installation
 options.
 Note that Python 2.4 and earlier do not support option swig_opts well so
 you might have to pass these options using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py build_ext --swig-opts=
\begin_inset Quotes erd
\end_inset

-O -templatereduce 
\backslash

\end_layout

\begin_layout Plain Layout

    -shadow -c++ -keyword -nodefaultctor
\begin_inset Quotes erd
\end_inset

 install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 demonstrates how to use such a C++ parents chooser in your simuPOP script.
 It uses the same Python parent chooser interface as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyParentsChooser"

\end_inset

, but leaves all the (potentially) computationally intensive parts to the
 C++ level 
\family typewriter
myParentsChooser
\family default
 object.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/cppParentChooser.py"
lstparams "caption={Implement a parent chooser in C++},label={cppParentChooser}"

\end_inset


\end_layout

\begin_layout Subsection
The pedigree mating scheme *
\end_layout

\begin_layout Standard
This feature is still under major revision.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
A simuPOP simulator evolves one or more copies of a population forward in
 time, subject to various operators.
 Although simulators have been used extensively in the previous chapters,
 it is worthwhile to have a detailed look at this object.
\end_layout

\begin_layout Subsection
Number of generations to evolve
\end_layout

\begin_layout Standard
A simulator usually evolves a specific number of generations according to
 parameter 
\family typewriter
gen
\family default
 of the 
\family typewriter
evolve
\family default
 function.
 A generation number is used to track the number of generations a simulator
 has evolved.
 Because a new simulator has generation number 0, a simulator would be at
 the beginning of generation 
\begin_inset Formula $n$
\end_inset

 after it evolves 
\begin_inset Formula $n$
\end_inset

 generations.
 The generation number would increase if the simulator continues to evolve.
 During evoluting, variables 
\family typewriter
rep
\family default
 (replicate number) and 
\family typewriter
gen
\family default
 (current generation number) are set to each population's local namespace.
\end_layout

\begin_layout Standard
It is not always possible to know in advance the number of generations to
 evolve.
 For example, you may want to evolve a population until a specific allele
 gets fixed or lost in the population.
 In this case, you can let the simulator run indefinitely (do not set the
 
\family typewriter
gen
\family default
 parameter) and depend on a 
\emph on
terminator 
\emph default
to terminate the evolution of a population.
 The easiest method to do this is to use population variables to track the
 status of a population, and use a 
\family typewriter
terminateIf
\family default
 operator to terminate the evolution according to the value of an expression.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simuGen"

\end_inset

 demonstrates the use of such a terminator, which terminates the evolution
 of a population if allele 0 at locus 5 is fixed or lost.
 It also shows the application of an interesting operator 
\family typewriter
ifElse
\family default
, which applies an operator, in this case 
\family typewriter
pyEval
\family default
, only when an expression returns 
\family typewriter
True
\family default
.
 Note that this example calls the 
\family typewriter
evolve
\family default
 function twice so the second part starts at generation 5.
 You can also use 
\family typewriter
simu.setGen(0)
\family default
 to reset the generation number if you would like to have a fresh start
 for the second 
\family typewriter
evolve()
\family default
 call.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuGen.log"
lstparams "caption={Generation number of a simulator},keywordstyle={\\ttfamily},label={simuGen}"

\end_inset


\end_layout

\begin_layout Subsection
Population access and other simulator operations
\end_layout

\begin_layout Standard
Function 
\family typewriter
population()
\family default
 and 
\family typewriter
populations()
\family default
 are provided to access populations within a simulator.
 Similar to functions 
\family typewriter
individual()
\family default
 and 
\family typewriter
individuals()
\family default
 for a population
\family typewriter
,population(rep)
\family default
 returns a reference to the 
\family typewriter
rep
\family default
th population in a simulator and 
\family typewriter
populations()
\family default
 returns an Python iterator that can be used to iterate through all populations.
 Modifying these references will change the corresponding populations within
 the simulator.
 An independent copy of a population can be made using the 
\family typewriter
clone()
\family default
 function of a population (e.g.
 
\family typewriter
simu.population(0).clone()
\family default
).
\end_layout

\begin_layout Standard
Populations in a simulator can be added or removed using functions 
\family typewriter
add()
\family default
 and 
\family typewriter
extract()
\family default
.
 The
\series bold
 newly added populations do not have to have the same genotypic structure
 as existing populations
\series default
.
 However, because the same operators will be applied to all populations,
 it is your responsibility to make sure that the operators can be applied
 to these populations.
\end_layout

\begin_layout Standard
Just like populations, a simulator can be cloned, saved and loaded.
 This makes it easy to stop a simulator, take a snapshot and resume evolution.
 It is even easy to save a simlator, transfer it to another machine and
 resume the evolution over there.
 Because 
\series bold
virtual splitters are not saved with populations
\series default
, you will have to re-assign splitters to populations if they are needed
 for subsequent simulations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuFunc.log"
lstparams "caption={Clone, save and load a simulator},label={simuFunc}"

\end_inset


\end_layout

\begin_layout Subsection
Modifying populations and mating scheme *
\end_layout

\begin_layout Standard
Although a standard Wright-Fisher random mating scheme is usually preferred
 because it leads to a larger effective population size than other mating
 schemes, it is difficult to ascertain pedigrees from a random mating population
 because there will be very few siblings in such a population.
 In addition, because we usually only sample from the last few generations,
 it would be more efficient to keep tract of pedigree information only for
 these generations.
 Such considerations lead to the popularity of a two stage evolutionary
 scenario where the standard random mating scheme is used in the first stage
 and another mating scheme that is more suitable for pedigree ascertainment
 is used in the second stage.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "twoStage"

\end_inset

 demonstrates the implementation of such a scenario.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/twoStage.log"
lstparams "caption={A two-stage evolutionary process},label={twoStage}"

\end_inset


\end_layout

\begin_layout Subsection
Change genotypic structure during evolution **
\end_layout

\begin_layout Standard
Most operators do not change the genotypic structure of populations during
 evolution.
 However, it is possible to change the structure of a population, such as
 adding or removing information fields, loci or chromosomes during evolution.
 The only restriction is that all individual in a population needs to have
 the same genotypic structure.
 That is to say, if you are inserting a new locus to an individual, all
 individuals in this population should have it.
 This is why there is no individual-level structure-modification functions.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "changeStru"

\end_inset

 gives an example of a dynamic mutator.
 This mutator is not a conventional mutator in that it does not mutate any
 existing loci.
 It assumes a chromosome region that originally has no polymorphic markers.
 When a mutation happens, a monomorphic marker that is not simulated becomes
 polymorphic and is inserted to the chromosome.
 If the region is long enough, this example effectively simulates an infinite
 allele mode.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/changeStru.log"
lstparams "caption={A Python mutator that adds new loci to populations.},label={changeStru}"

\end_inset


\end_layout

\begin_layout Section
Pedigrees
\end_layout

\begin_layout Standard
This feature is still under major revision.
\end_layout

\begin_layout Chapter
simuPOP Operators
\begin_inset CommandInset label
LatexCommand label
name "cha:simuPOP-Operators"

\end_inset


\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 80 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), gene conversion,
 quantitative trait, selection, penetrance (single or multi-locus, hybrid),
 ascertainment (case-control, affected sibpairs, random), statistics calculation
 (allele, genotype, haplotype, heterozygote number and frequency; expected
 heterozygosity; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules).
 This chapter covers the basic and some not-so-basic usages of these operators,
 organized roughly by genetic factors.
\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
simuPOP provides three operators to initialize individual sex and genotype.
 A number of parameter are provided to cover most commonly used initialization
 scenarios.
 A Python operator can be used to intialize a population explicitly if none
 of the operators fits your need.
 
\end_layout

\begin_layout Subsection
Initialize individual sex (operator 
\family typewriter
initSex
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initSex()
\family default
 and function 
\family typewriter
InitSex()
\family default
 initialize individual sex either randomly or using a given sequence.
 In the first case, individuals are assigned 
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
 with equal probability unless parameter 
\emph on
maleFreq
\emph default
 is used to specify the probability of having a male individual.
 Alternatively, parameter 
\emph on
maleProp
\emph default
 can be used to specify exact proportions of male individuals.
 In the second case, a sequence of sex (
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
) is assigned to individuals succesively.
 The list will be reused if needed.
 If a list of (virtual) subpopulations are given, this operator will only
 initialize individuals in these (virtual) subpopulations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initSex"

\end_inset

 uses two 
\family typewriter
initSex
\family default
 operators to initialize two subpopulations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initSex.log"
lstparams "caption={Initialize individual sex},label={initSex}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize by allele frequency (operator 
\family typewriter
initByFreq
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initByFreq
\family default
 (and its function form 
\family typewriter
InitByFreq
\family default
) initialize individual genotype by 
\series bold
allelic spectrum
\series default
, which is the number and frequency of alleles at a locus.
 For example, 
\family typewriter
alleleFreq=(0, 0.2, 0.4, 0.2)
\family default
 will yield allele 0, 1, 2, and 3 with probability 0, 0.2, 0.4 and 0.2 respectively.
 Parameter 
\family typewriter
loci
\family default
 and 
\family typewriter
ploidy
\family default
 can be used to specify a subset of loci and homologous sets of chromosomes
 to initialize, and parameter 
\family typewriter
subPops
\family default
 can be used to specify subsets of individuals to initialize.
 In the latter case, a list of allelic spectra can be given to assign different
 genotype with different allele frequency for each (virtual) subpopulation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByFreq.log"
lstparams "caption={Initialize by allele frequency},label={initByFreq}"

\end_inset


\end_layout

\begin_layout Standard
It is sometimes desired to create identical individuals with random genotype.
 Parameter 
\family typewriter
identicalInds
\family default
 can be used for this purpose.
 When this parameter is set to true, a random individual will be created
 for each subpopulation (using different allele frequencies if a list of
 allelic spectra are given), and be copied to all other individuals in the
 subpopulation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByFreqIdenticalInds"

\end_inset

 demonstrates this usage.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByFreqIdenticalInds.log"
lstparams "caption={Initialize by allele frequency with identical individuals in each subpopulation},label={initByFreqIdenticalInds}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize by haplotype (operator 
\family typewriter
initByValue
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initByValue
\family default
 (and its function form 
\family typewriter
InitByValue
\family default
) initializes individual genotypes using given haplotypes.
 The simplest form of this operator is to specify genotype on one or all
 homologous sets of chromosomes.
 For example, all individuals in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByValue"

\end_inset

 get the same genotype using such an operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByValue.log"
lstparams "caption={initialize by haplotype},label={initByValue}"

\end_inset


\end_layout

\begin_layout Standard
A number of parameters are provided to initialize individual genotype at
 a finer scale.
 More specifically, you can apply the operator to specified loci (parameter
 
\emph on
loci
\emph default
), (virtual) subpopulations (parameter 
\family typewriter
subPops
\family default
), homologous sets of chromosomes (parameter 
\family typewriter
ploidy
\family default
).
 If multiple haplotypes are given, you can specify the proportions at which
 each haplotype will be used using parameter 
\family typewriter
proportions
\family default
, or by frequencies using parameter 
\family typewriter
frequencies
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initByValueProp"

\end_inset

 demonstrates the use of these parameters.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initByValueProp.log"
lstparams "caption={initialize by haplotypes with given proportion},label={initByValueProp}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize information fields (operator 
\family typewriter
initInfo
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
initInfo
\family default
 and its function form 
\family typewriter
InitInfo
\family default
 initialize one or more information fields of all individuals or individuals
 in selected (virtual) subpopulations using either a list of values or a
 Python function.
 If a value or a list of value is given, it will be used repeatedly to assign
 values of specified information fields of all applicable individuals.
 For example, 
\family typewriter
InitInfo(pop, values=1, infoFields='x')
\family default
 will assign value 
\family typewriter
1
\family default
 to information field 
\family typewriter
x
\family default
 of all individuals, and 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InitInfo(pop, values=[1, 2, 3], infoFields='x', subPops=[(0,1)])
\end_layout

\end_inset

will assign values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
3
\family default
, 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
3
\family default
...
 to information field 
\family typewriter
x
\family default
 of individuals in the second virtual subpopulation of subpopulation 0.
\end_layout

\begin_layout Standard
The 
\family typewriter
values
\family default
 parameter also accepts a Python function.
 This feature is usually used to assign random values to an information
 field.
 For example, 
\family typewriter
values=random.random
\family default
 would assign a random value between 0 and 1.
 If a function takes parameters, a lambda function can be used.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InitInfo(pop, lambda : random.randint(2, 5), infoFields=['x', 'y'])
\end_layout

\end_inset

 assigns random integers between 2 and 5 to information fields 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 of all individuals in 
\emph on
pop
\emph default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "initInfo"

\end_inset

 demonstrates these usages.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/initInfo.log"
lstparams "caption={initialize information fields},label={initInfo}"

\end_inset


\end_layout

\begin_layout Section
Expressions and statements
\end_layout

\begin_layout Subsection
Output a Python string (operator 
\family typewriter
pyOutput
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyOutput
\family default
 is a simple operator that prints a Python string when it is applied to
 a population.
 It is commonly used to print the progress of a simulation (e.g.
 
\family typewriter
pyOutput('start migration
\backslash
n', at=200)
\family default
) or output separators to beautify outputs from 
\family typewriter
pyEval
\family default
 outputs (e.g.
 
\family typewriter
pyOutput('
\backslash
n', rep=-1)
\family default
.
\end_layout

\begin_layout Subsection
Execute Python statements (operator 
\family typewriter
pyExec
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyExec
\family default
 executes Python statements in a population's local namespace when it is
 applied to that population.
 This operator is designed to execute short Python statements but multiple
 statements separated by newline characters are allowed.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyExec"

\end_inset

 uses two 
\family typewriter
pyExec
\family default
 operators to create and use a variable 
\family typewriter
traj
\family default
 in each population's local namespace.
 The first operator initialize this variable as an empty list.
 During evolution, the frequency of allele 1 at locus 0 is calcuated (operator
 
\family typewriter
stat
\family default
) and appended to this variable (operator 
\family typewriter
pyExec
\family default
).
 The result is a trajectory of allele frequencies during evolution.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyExec.log"
lstparams "caption={Execute Python statements during evolution},label={pyExec}"

\end_inset


\end_layout

\begin_layout Subsection
Evaluate and output Python expressions (operator 
\family typewriter
pyEval
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pyEval
\family default
 evaluate a given Python expression in a population's local namespace and
 output its return value.
 This operator has been widely used (e.g.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "ancestralPop"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

) to output statistics of populations and report progress.
\end_layout

\begin_layout Standard
Two additional features of this operator may become handy from time to time.
 First, an optional Python statements (parameter 
\emph on
stmts
\emph default
) can be specified which will be executed before the expression is evaluated.
 Second, the population being applied can be exposed in its own namespace
 as a variable (parameter 
\emph on
exposePop
\emph default
).
 This makes it possible to access properties of a population other than
 its variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyEval"

\end_inset

 demonstrates both features.
 In this example, two statements are executed to count the number of unique
 parents in an offspring population and save them as variables 
\family typewriter
numFather
\family default
 and 
\family typewriter
numMother
\family default
.
 The operator outputs these two variables alone with a generation number.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyEval.log"
lstparams "caption={Evaluate a expression and statements in a population's local namespace.},label={pyEval}"

\end_inset


\end_layout

\begin_layout Standard
Note that the function form of this operator (
\family typewriter
PyEval
\family default
) returns the result of the expression rather than writting it to an output.
\end_layout

\begin_layout Subsection
Expression and statement involving individual information fields (operator
 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
) *
\end_layout

\begin_layout Standard
Operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyExec
\family default
 work at the population level, using the local namespace of populations.
 Operator 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
, on the contraray, work at the individual level, using individual information
 fields.
\end_layout

\begin_layout Standard
Because there is no individual-specific namespace, these two operators make
 use of either a temporary namespace for every individual, or the population
 namespace (parameter 
\emph on
usePopVars
\emph default
).
 In the first case, a namespace is created for each invidividual, with variables
 being the information fields of this individual.
 In the second case, individual information fields are copied to the population
 namespace one by one.
 Expressions and statements can make use of population variables in this
 case.
 Optionally, the individual object can be exposed to these namespace using
 a user-specified name (parameter 
\emph on
exposeInd
\emph default
).
\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoEval
\family default
 evaluates an expression and outputs its value.
 Operator 
\family typewriter
infoExec
\family default
 executes one or more statements and does not produce any output.
 The major difference between them is that 
\family typewriter
infoEval
\family default
 does not change individual information fields while 
\family typewriter
infoExec
\family default
 update individual information fields from the namespace after the statements
 are executed.
\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoEval
\family default
 is usually used to output individual information fields and properties
 in batch mode.
 It is faster and sometimes easier to use than corresponding for loop plus
 individual level operations.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
infoEval(r'
\begin_inset Quotes erd
\end_inset

%.2f
\backslash
t
\begin_inset Quotes erd
\end_inset

 % a')
\family default
 outputs the value of information field a for all individuals, separated
 by tabs.
\end_layout

\begin_layout Itemize

\family typewriter
infoEval('ind.sexChar()', exposeInd='ind')
\family default
 outputs the sex of all individuals using an exposed individual object 
\family typewriter
ind
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
infoEval('a+b**2')
\family default
 outputs 
\begin_inset Formula $a+b^{2}$
\end_inset

 for information fields 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 for all individuals.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoEval"

\end_inset

 demonstrates the use of this operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoEval.log"
lstparams "caption={Evaluate expressions using individual information fields},label={infoEval}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
infoExec
\family default
 is usually used to set individual information fields.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('age += 1')
\family default
 increases the age of all individuals by one.
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('risk = 2 if packPerYear > 10 else 1.5')
\family default
 sets information field 
\family typewriter
risk
\family default
 to 
\family typewriter
2
\family default
 if 
\family typewriter
packPerYear
\family default
 is greater than 
\family typewriter
10
\family default
, and 
\family typewriter
1.5
\family default
 otherwise.
 Note that conditional expression is only available for Python version 2.5
 or later.
\end_layout

\begin_layout Itemize

\family typewriter
infoExec('a = b*c')
\family default
 sets the value of information field 
\family typewriter
a
\family default
 to the product of 
\family typewriter
b
\family default
 and 
\family typewriter
c
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoExec"

\end_inset

 demonstrates the use of this operator, using its function form 
\family typewriter
InfoExec
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoExec.log"
lstparams "caption={Execute statements using individual information fields},label={infoExec}"

\end_inset


\end_layout

\begin_layout Note
Except for the local (temporary) namespace, operator 
\family typewriter
infoEval
\family default
 and 
\family typewriter
infoExec
\family default
 can also access variables and functions in a global namespace, which is
 the module namespace of your script.
 However, use of global variables in these operators are strongly discouraged.
\end_layout

\begin_layout Section
Demographic changes
\end_layout

\begin_layout Standard
A mating scheme controls the size of an offspring generation using parameter
 
\family typewriter
subPopSize
\family default
.
 This parameter has been described in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

.
 In summary,
\end_layout

\begin_layout Itemize
The subpopulation sizes of the offspring generation will be the same as
 the parental generation if subPopSize is not set.
\end_layout

\begin_layout Itemize
The offspring generation will have a fixed size if 
\family typewriter
subPopSize
\family default
 is set to a number (no subpopulation) or a list of subpopulation sizes.
 
\end_layout

\begin_layout Itemize
The subpopulation sizes of an offspring generation will be determined by
 the return value of a demographic function if 
\family typewriter
subPopSize
\family default
 is set to such a function (a function that returns subpopulation sizes
 at each generation).
\end_layout

\begin_layout Note
Parameter 
\family typewriter
subPopSize
\family default
 only controls subpopulation sizes of an offspring generation immediately
 after it is generated.
 Population or subpopulation sizes could be changed by other operators.
\end_layout

\begin_layout Standard
During mating, a mating scheme goes through each parental subpopulation
 and populates its corresponding offspring subpopulation.
 This implies that
\end_layout

\begin_layout Itemize
Parental and offspring populations should have the same number of subpopulations.
\end_layout

\begin_layout Itemize
Mating happens strictly within each subpopulation.
\end_layout

\begin_layout Standard
This section will introduce several operators that allow you to move individuals
 across the boundary of subpopulations (migration), and change the number
 of subpopulations during evolution (split and merge).
\end_layout

\begin_layout Subsection
Migration (operator 
\family typewriter
migrator
\family default
)
\end_layout

\begin_layout Subsubsection
Migration by probability
\end_layout

\begin_layout Standard
Operator 
\family typewriter
migrator
\family default
 (and its function form 
\family typewriter
Migrate
\family default
) migrates individuals from one subpopulation to another.
 The key parameters are
\end_layout

\begin_layout Itemize

\emph on
from
\emph default
 subpopulations (parameter 
\family typewriter
subPops
\family default
).
 A list of subpopulations from which individuals migrate.
 Default to all subpopulations.
\end_layout

\begin_layout Itemize

\emph on
to
\emph default
 subpopulations (parameter 
\family typewriter
toSubPops
\family default
).
 A list of subpopulations to which individuals migrate.
 Default to all subpopulations.
 
\series bold
A new subpopulation ID can be specified to create a new subpopulation from
 migrants.
\end_layout

\begin_layout Itemize
A migration rate matrix (parameter 
\family typewriter
rate
\family default
).
 A 
\begin_inset Formula $m$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 matrix ( a nested list in Python) that specifies migration rate from each
 source to each destination subpopulation.
 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are determined by the number of 
\emph on
from
\emph default
 and 
\emph on
to
\emph default
 subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByProb"

\end_inset

 demonstrate the use of a 
\family typewriter
migrator
\family default
 to migrate individuals between three subpopulations.
 Note that 
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
migrator
\family default
 relies on an information field 
\family typewriter
migrate_to
\family default
 (configurable) to record destination subpopulation of each individual so
 this information field needs to be added to a population befor migration.
\end_layout

\begin_layout Itemize
Migration rates to subpopulation themselves are determined automatically
 so they can be left unspecified.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateByProb.log"
lstparams "caption={Migration by probability},label={migrateByProb}"

\end_inset


\end_layout

\begin_layout Subsubsection
Migration by proportion and counts
\end_layout

\begin_layout Standard
Migration rate specified in the rate parameter in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByProb"

\end_inset

 is intepreted as probabilities.
 That is to say, a migration rate 
\begin_inset Formula $r_{m,n}$
\end_inset

 is interpreted as the probability at which any individual in subpopulation
 
\begin_inset Formula $m$
\end_inset

 migrates to subpopulation 
\begin_inset Formula $n$
\end_inset

.
 The exact number of migrants are randomly distributed.
\end_layout

\begin_layout Standard
If you would like to specify exactly how many migrants migrate from a subpopulat
ion to another, you can specify parameter 
\family typewriter
mode
\family default
 of operator 
\family typewriter
migrator
\family default
 to 
\family typewriter
ByProportion
\family default
 or 
\family typewriter
ByCount
\family default
s.
 The 
\family typewriter
ByProportion
\family default
 mode interpret 
\begin_inset Formula $r_{m,n}$
\end_inset

 as proportion of individuals who will migrate from subpopulation 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 so the number of 
\begin_inset Formula $m\rightarrow n$
\end_inset

 migrant will be exactly 
\begin_inset Formula $r_{m,n}\times$
\end_inset

subPopSize(m).
 In the 
\family typewriter
ByCounts
\family default
 mode, 
\begin_inset Formula $r_{m,n}$
\end_inset

 is interpretted as number of migrants, regardless the size of subpopulation
 
\begin_inset Formula $m$
\end_inset

.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByPropAndCount"

\end_inset

 demonstrates these two migration modes, as well as the use of parameters
 
\family typewriter
subPops
\family default
 and 
\family typewriter
toSubPops.

\family default
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateByPropAndCount.log"
lstparams "caption={Migration by proportion and count},label={migrateByPropAndCount}"

\end_inset


\end_layout

\begin_layout Subsubsection
Theoretical migration models
\end_layout

\begin_layout Standard
To facilitate the use of widely used theoretical migration models, a few
 functions are defined in module 
\family typewriter
simuUtil.
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset

for a traditional island model where individuals have equal probability
 of migrating to any other subpopulations.
\end_layout

\begin_layout Itemize

\family typewriter
MigrHierarchicalIslandRates(r1, r2, n)
\family default
 models a hierarchical island model in which local populations are grouped
 into neighborhoods within which there is considerable gene flow and between
 which there is less gene flow.
 
\begin_inset Formula $n$
\end_inset

 should be a list of group size.
 
\begin_inset Formula $r_{1}$
\end_inset

 is the within-group migration rate and 
\begin_inset Formula $r_{2}$
\end_inset

 is the cross-group migration rate.
 That is to say, an individual in an island has probability 
\begin_inset Formula $1-r_{1}-r_{2}$
\end_inset

 to say, 
\begin_inset Formula $r_{1}$
\end_inset

 to be a migratant to other islands in the group (migration rate depending
 on the size of group), and 
\begin_inset Formula $r_{2}$
\end_inset

 to be a migrant to other islands in another group (migration rate depending
 on the number of islands in other groups).
 Both 
\begin_inset Formula $r_{1}$
\end_inset

 and 
\begin_inset Formula $r_{2}$
\end_inset

 can vary across groups of islands.
 For example, 
\family typewriter
MigrHierarchicalIslandRates([r11, r12], r2, [3, 2])
\family default
 returns a 
\begin_inset Formula $5\times5$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r_{11}-r_{2} & \frac{r_{11}}{2} & \frac{r_{11}}{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{11}}{2} & 1-r_{11}-r_{2} & \frac{r_{11}}{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{11}}{2} & \frac{r_{11}}{2} & 1-r_{11}-r_{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{2}}{3} & \frac{r_{2}}{3} & \frac{r_{2}}{3} & 1-r_{12}-r_{2} & r_{12}\\
\frac{r_{2}}{3} & \frac{r_{2}}{3} & \frac{r_{2}}{3} & r_{12} & 1-r_{12}-r_{2}\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates(r, n, circular=False)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Many more migration models have been proposed and studied, sometimes under
 different names with slightly different definitions.
 Please refer to the 
\emph on
operators
\emph default
 section of the simuPOP online cookbook for the implementation of more migration
 models.
 If you cannot find your model there, it should not be too dificult to construct
 a migration rate matrix for it and please consider adding your model to
 the cookbook.
\end_layout

\begin_layout Subsubsection
Migrate from virtual subpopulations *
\end_layout

\begin_layout Standard
Under a realistic eco-social settings, individuals in a subpopulation rarely
 have the same probability to migrate.
 Genetic evidence has shown that female has a higher migrate rate than male
 in humans, perhaps due to migration patterns related to inter-population
 marriages.
 Such sex-biased migration also happens in other large migration events
 such as slave trade.
\end_layout

\begin_layout Standard
It is easy to simulate most of such complex migration models by migrating
 from virtual subpopulations.
 For example, if you define virtual subpopulations by sex, you can specify
 different migration rates for males and females and control the proportion
 of males among migrants.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateVSP"

\end_inset

 demonstrate a sex-biased migration model where males dominate migrants
 from subpopulation 0.
\end_layout

\begin_layout Standard
To avoid confusing, this example uses the proportion migration mode.
 At the beginning of the first generation, there are 500 males and 500 females
 in each subpopulation.
 A 10% male migration rate and 5% female migration rate leads to 50 male
 migrants and 25 female migrants.
 Subpopulation sizes and number of males in each subpopulation before mating
 are therefore:
\end_layout

\begin_layout Itemize
Subpopulation 0: male 500-50, female 500-25, total 925
\end_layout

\begin_layout Itemize
Subpopulation 1: male 500+50, female 500+25, total 1075
\end_layout

\begin_layout Standard
Note that the unspecified 
\emph on
to
\emph default
 subpopulations are subpopulation 0 and 1, which cannot be virtual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateVSP.log"
lstparams "caption={Migration from virtual subpopulations},label={migrateVSP}"

\end_inset


\end_layout

\begin_layout Subsubsection
Arbitrary migration models **
\end_layout

\begin_layout Standard
If none of the described migration mothods fits your need, you can always
 resort to manual migration.
 One such example is when you need to mimick an existing evolutionary scenario
 so you know exactly which subpopulation each individual will migrate to.
\end_layout

\begin_layout Standard
Manual migration is actually very easy.
 All you need to do is specifying the destination subpopulation of all individua
ls in the 
\emph on
from
\emph default
 subpopulations (parameter 
\family typewriter
subPops
\family default
), using an information field (usually 
\family typewriter
migrate_to
\family default
).
 You can then call the 
\family typewriter
migrator
\family default
 using 
\family typewriter
mode=ByIndInfo
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "manualMigration"

\end_inset

 shows how to manually move individuals around.
 This example uses the function form of 
\family typewriter
migrator
\family default
.
 You usually need to use a Python operator to set destination subpopulations
 if you would like to manually migrate individuals during an evolutionary
 process.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/manualMigration.log"
lstparams "caption={Manual migration},label={manualMigration}"

\end_inset


\end_layout

\begin_layout Note
Individuals with an invalid destination subpopulation ID (e.g.
 an negative number) will be discarded silently.
 Although not recommended, this feature can be used to remove individuals
 from a subpopulation.
\end_layout

\begin_layout Subsection
Split subpopulations (operators 
\family typewriter
splitSubPops
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
splitSubPops
\begin_inset Index
status collapsed

\begin_layout Plain Layout
splitSubPops
\end_layout

\end_inset


\family default
 splits one or more subpopulations into finer subpopulations.
 It can be used to simulate populations that originate from the same founder
 population.
 For example, a population of size 1000 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitBySize"

\end_inset

 is split into three subpopulations of sizes 300, 300 and 400 respectively,
 after evolving as a single population for two generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitBySize.log"
lstparams "caption={Split subpopulations by size},label={splitBySize}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
splitSubPops
\family default
 splits a subpopulation by sizes of the resulting subpopulations.
 It is often easier to do so with proportions.
 In addition, if a demographic function is used, you should make sure that
 the number of subpopulations will be the same before and after mating at
 any generation, namely apply a 
\family typewriter
splitSubPops
\family default
 operator at the right generation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByProp"

\end_inset

 demonstrates such an evolutionary scenario.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitByProp.log"
lstparams "caption={Split subpopulations by proportion},label={splitByProp}"

\end_inset


\end_layout

\begin_layout Standard
Either by 
\emph on
sizes
\emph default
 or by 
\emph on
proportions
\emph default
, individuals in a subpopulation are divided randomly.
 It is, however, also possible to split subpopulations according to individual
 information fields.
 In this case, individuals with different values at a given information
 field will be split into different subpopulations.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByInfo"

\end_inset

 where the function form of operator 
\family typewriter
splitSubPops
\family default
 is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitByInfo.log"
lstparams "caption={Split subpopulations by individual information field},label={splitByInfo}"

\end_inset


\end_layout

\begin_layout Subsection
Merge subpopulations (operator 
\family typewriter
mergeSubPops
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
mergeSubPops
\family default
 merges specified subpopulations into a single subpopulation.
 This operator can be used to simulate admixed populations where two or
 more subpopulations merged into one subpopulation and continue to evolve
 for a few generations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mergeSubPops"

\end_inset

 simulates such an evolutionary scenario.
 A demographic model could be added similar to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByProp"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mergeSubPops.log"
lstparams "caption={Merge multiple subpopulations into a single subpopulation},label={mergeSubPops}"

\end_inset


\end_layout

\begin_layout Subsection
Resize subpopulations (operator 
\family typewriter
resizeSubPops
\family default
)
\end_layout

\begin_layout Standard
Whenever possible, it is recommended that subpopulation sizes are changed
 naturally, namely through the population of an offspring generation.
 However, it is sometimes desired to change the size of a population forcefully.
 Examples of such applications include immediate expansion of a small population
 before evolution, and the simulation of sudden population size change caused
 by natural disaster.
 By default, new individuals created by such sudden population expansion
 get their genotype from existing individuals.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "resizeSubPops"

\end_inset

 shows a scenario where two subpopulations expand instantly at generation
 3.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/resizeSubPops.log"
lstparams "caption={Resize subpopulation sizes},label={resizeSubPops}"

\end_inset


\end_layout

\begin_layout Section
Genotype transmitters
\begin_inset CommandInset label
LatexCommand label
name "sec:Genotype-transmitters"

\end_inset


\end_layout

\begin_layout Subsection
Generic genotype transmitters (operators 
\family typewriter
genoTransmitter
\family default
, 
\family typewriter
cloneGenoTransmitter
\family default
, 
\family typewriter
mendelianGenoTransmitter
\family default
, 
\family typewriter
selfingGenoTransmitter
\family default
, 
\family typewriter
haplodiploidGenoTransmitter
\family default
, and 
\family typewriter
mitochondrialGenoTransmitter
\family default
) *
\end_layout

\begin_layout Standard
A number of during-mating operators are defined to transmit genotype from
 parent(s) to offspring.
 They are rarely used or even seen directly because they are used as genotype
 transmitters of mating schemes.
\end_layout

\begin_layout Itemize

\family typewriter
genoTransmitter
\family default
: This genotype transmitter is usually used by customized genotype transmitters
 because it provides some utility functions that are more efficient than
 their Pythonic counterparts.
\end_layout

\begin_layout Itemize

\family typewriter
cloneGenoTransmitter
\family default
: Copy all genotype from a parent to an offspring.
 It also copies parental sex to the offspring because sex can be genotype
 determined.
 This genotype transmitter is used by mating scheme 
\family typewriter
cloneMating
\family default
.
 This genotype transmitter can be applied to populations of 
\series bold
any ploidy
\series default
 type.
\end_layout

\begin_layout Itemize

\family typewriter
mendelianGenoTransmitter
\family default
: Copy genotypes from two parents (a Male and a Female) to an offspring
 following Mendel's laws, used by mating scheme 
\family typewriter
randomMating.
\family default
This genotype transmitter can only be applied to 
\series bold
diploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
selfingGenoTransmitter
\family default
: Copy genotypes from one parent to an offspring using self-fertilization,
 used by mating scheme 
\family typewriter
selfMating
\family default
.
 This genotype transmitter can only be applied to 
\series bold
diploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
haplodiploidGenoTransmitter
\family default
: Set genotype to male and female offspring differently in a haplodiploid
 population, used by mating scheme 
\family typewriter
haplodiploidMating
\family default
.
 This genotype transmitter can only be applied to 
\series bold
haplodiploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
mitochondrialGenoTransmitter
\family default
: Treat all customized chromosomes or specified chromosomes as mitochondrial
 chromosomes and transmit maternal mitochondrial chromosomes randomly to
 an offspring.
 This genotype transmitter can be applied to populations of 
\series bold
any ploidy
\series default
 type.
 It trasmits the first homologous copy of chromosomes maternally and clears
 alleles on other homologous copies of chromosomes of an offspring.
 
\end_layout

\begin_layout Subsection
Recombination (Operator 
\family typewriter
recombinator
\family default
)
\end_layout

\begin_layout Standard
The generic genotype transmitters do not handle genetic recombination.
 A genotype transmitter 
\family typewriter
recombinator
\family default
 is provided for such purposes, and can be used with 
\family typewriter
randomMating
\family default
 and 
\family typewriter
selfMating
\family default
 (replace 
\family typewriter
mendelianGenoTransmitter
\family default
 and 
\family typewriter
selfingGenoTransmitter
\family default
 used in these mating schemes).
\end_layout

\begin_layout Standard
Recombination rate is implemented 
\series bold
between adjacent markers
\series default
.
 There can be only one recombination event between adjacent markers no matter
 how far apart they are located on a chromosome.
 In practise, a 
\family typewriter
recombinator
\family default
 goes along chromosomes and determine, between each adjacent loci, whether
 or not a recombination happens.
\end_layout

\begin_layout Standard
Recombination rates could be specified in the following ways:
\end_layout

\begin_layout Enumerate
If a single recombination rate is specified through paramter 
\family typewriter
rate
\family default
s, it will be the recombination rate between all adjacent loci, regardless
 of loci position.
\end_layout

\begin_layout Enumerate
If recombination happens only after certain loci, you can specify these
 loci using parameter 
\family typewriter
loci
\family default
.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

recombinator(rates=0.1, loci=[2, 5])
\end_layout

\end_inset

recombines a chromosome only 
\series bold
after
\series default
 loci 2 (between 2 and 3) and 5 (between 5 and 6).
\end_layout

\begin_layout Enumerate
If parameter 
\family typewriter
loci
\family default
 is given, different recombination rate can be given to each of them.
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

recombinator(rates=[0.1, 0.05], loci=[2, 5])
\end_layout

\end_inset

uses two different recombination rates after loci 2 and 5.
\end_layout

\begin_layout Enumerate
If recombination rates vary across your chromosomes, a long list of 
\family typewriter
rate
\family default
 and 
\family typewriter
loci
\family default
 may be needed to specify recombination rates one by one.
 An alternative method is to specify a 
\series bold
recombination intensity
\series default
.
 Recombination rate between two adjacent loci is calculated as the product
 of this intensity and distance between them.
 For example, if you apply operator
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

recombinator(intensity=0.1)
\end_layout

\end_inset

to a population
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

population(size=100, loci=[4], lociPos=[0.1, 0.2, 0.4, 0.8])
\end_layout

\end_inset

The recombination rates between adjacent markers will be 
\family typewriter
0.1*0.1
\family default
, 
\family typewriter
0.1*0.2
\family default
 and 
\family typewriter
0.1*0.4
\family default
 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/recRate.log"
lstparams "caption={Genetic recombination at all and selected loci},label={recRate}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "recRate"

\end_inset

 demonstrates how to specify recombination rates for all loci or for specified
 loci.
 In this example, two replicates of a population are evolved, subject to
 two different recombinators.
 The first recombinator applies the same recombination rate between all
 adjacent loci, and the second recombinator recombines only after loci 50
 - 59.
 Because there is no recombination event between loci 60 and 70 for the
 second replicate, linkage disequilibrium values between these two loci
 does not decrease as what happens in the first replicate.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/recIntensity.log"
lstparams "caption={Genetic recombination rates specified by intensity},label={recIntensity}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "recIntensity"

\end_inset

 demonstrates the use of the 
\family typewriter
intensity
\family default
 parameter.
 In this example, the distances between the first two loci and the latter
 two loci are 1 and 0.1 respectively.
 This leads recombination rates 0.01 and 0.001 respectively with a recombination
 intensity 0.01.
 Consequently, LD between the first two loci decay much faster than the
 latter two.
\end_layout

\begin_layout Standard
If more advanced recombination model is desired, a customized genotype transmitt
er can be used.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 uses two recombinators to implement sex-specific recombination.
\end_layout

\begin_layout Note
Both loci positions and recombination intensity are unitless.
 You can assume different unit for loci position and recombination intensity
 as long as the resulting recombination rate makes sense.
\end_layout

\begin_layout Subsection
Gene conversion (Operator 
\family typewriter
recombinator
\family default
) *
\end_layout

\begin_layout Standard
simuPOP uses the Holliday junction model to simulate gene conversion.
 This model treats recombination and conversion as a unified process.
 The key features of this model is
\end_layout

\begin_layout Itemize
Two (out of four) chromatids pair and a single strand cut is made in each
 chromatid
\end_layout

\begin_layout Itemize
Strand exchange takes place between the chromatids
\end_layout

\begin_layout Itemize
Ligation occurs yielding two completely intact DNA molecules
\end_layout

\begin_layout Itemize
Branch migration occurs, giving regions of heteroduplex DNA
\end_layout

\begin_layout Itemize
Resolution of the Holliday junction gives two DNA molecules with heteroduplex
 DNA.
 Depending upon how the holliday junction is resolved, we either observe
 no exchange of flanking markers, or an exchange of flanking markers.
 The former forms a conversion event, which can be considered as a double
 recombination.
\end_layout

\begin_layout Standard
In practise, gene conversion can be considered as a double recombination
 event.
 That is to say, when a recombination event happens, it has certain probability
 to trigger a second recombination event along the chromosome.
 The distance between the two locations where recombination events happen
 is the tract length of this conversion event.
\end_layout

\begin_layout Standard
The probability at which gene conversion happens, and how tract length is
 determined is specify using parameter 
\family typewriter
convMode
\family default
 of a recombinator.
 This parameter can be
\end_layout

\begin_layout Itemize

\family typewriter
NoConversion
\family default
 No gene conversion.
 (default)
\end_layout

\begin_layout Itemize

\family typewriter
(NumMarkers, prob, N)
\family default
 Convert a fixed number 
\family typewriter
N
\family default
 of markers at probability 
\family typewriter
prob
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
(TractLength, prob, N)
\family default
 Convert a fixed length 
\family typewriter
N
\family default
 of chromosome regions at probability 
\family typewriter
prob
\family default
.
 This can be used when markers are not equally spaced on chromosomes.
\end_layout

\begin_layout Itemize

\family typewriter
(GeometricDistribution, prob, p)
\family default
 When a conversion event happens at probability 
\family typewriter
prob
\family default
, convert a random number of markers, with a geometric distribution with
 parameter 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
(ExponentialDistribution, prob, p)
\family default
 When a conversion event happens at probability 
\family typewriter
prob
\family default
, convert a random length of chromosome region, using an exponential distributio
n with parameter 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
If tract length is determined by length (
\family typewriter
TractLength
\family default
 or 
\family typewriter
ExponentialDistribution
\family default
), the starting point of the flanking region is uniformly distributed between
 marker 
\begin_inset Formula $i-1$
\end_inset

 and 
\begin_inset Formula $i$
\end_inset

, if the recombination happens at marker 
\begin_inset Formula $i$
\end_inset

.
 That is to say, it is possible that no marker is converted with a positive
 tract length.
\end_layout

\begin_layout Itemize
A conversion event will act like a recombination event if its flanking region
 exceeds the end of a chromosome, or if another recombination event happens
 before the end of the flanking region.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "conversion"

\end_inset

 compares two recombinators.
 The first recombinator is a regular recombinator that recombine between
 loci 50 and 51.
 The second recombinator is a conversion operator because every recombination
 event will become a conversion event (prob=1).
 Because a second recombination event will surely happen between loci 60
 and 61, there will be either no or double recombination events between
 loci 40, 70.
 LD between these two loci therefore does not decrease, although LD between
 locus 55 and these two loci will decay.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/conversion.log"
lstparams "caption={Gene conversion},label={conversion}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking all recombination events **
\end_layout

\begin_layout Standard
To understand the evolutionary history of a simulated population, it is
 sometimes needed to track down all ancestral recombination events.
 In order to do that, you will first need to give an unique ID to each individua
l so that you could make sense of the dumped recombination events.
 Although this is routinely done using operator 
\family typewriter
idTagger
\family default
 (see example 
\begin_inset CommandInset ref
LatexCommand ref
reference "idTagger"

\end_inset

 for details), it is a little tricky here because you need to place the
 during-mating 
\family typewriter
idTagger
\family default
 before a 
\family typewriter
recombinator
\family default
 in the 
\family typewriter
ops
\family default
 parameter of a mating scheme so that offspring ID could be set and outputted
 correctly.
\end_layout

\begin_layout Standard
After setting the name of the ID field (usually 
\family typewriter
ind_id
\family default
) to the 
\family typewriter
infoField
\family default
 parameter of a 
\family typewriter
recombinator
\family default
, it can dump a list of recombinatin events (loci after which recombinatin
 events happened) for each set of homologous chromosomes of an offspring.
 Each line is in the format of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

offspringID parentID startingPloidy rec1 rec2 ....
\end_layout

\end_inset

Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "trackRec"

\end_inset

 gives an example how the output looks like.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/trackRec.log"
lstparams "caption={Tracking all recombination events},label={trackRec}"

\end_inset


\end_layout

\begin_layout Section
Mutation
\end_layout

\begin_layout Standard
A mutator (a mutation operator) mutates alleles at certain loci from one
 allele to another.
 Because alleles are simple non-nagative numbers that can be intrepreted
 as nucleotides, codons, squences of nucleotides or even genetic deletions,
 appropriate mutation models have to be chosen for different types of loci.
 Please refer to Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Genotypic-structure"

\end_inset

 for a few examples.
\end_layout

\begin_layout Standard
A mutator will mutate alleles at all loci unless parameter 
\family typewriter
loci
\family default
 is used to specify a subset of loci.
 Different mutators have different concepts and forms of mutation rates.
 If a mutator accepts only a single mutation rate (which can be in the form
 of a list or a matrix), it uses parameter 
\family typewriter
rate
\family default
 and applies the same mutation rate to all loci.
 If a mutator accepts a list of mutation rates (each of which is a single
 number), it uses parameter 
\family typewriter
rates
\family default
 and applies different mutation rates to different loci if multiple loci
 are specified.
 Note that parameter 
\family typewriter
rates
\family default
 also accepts single form inputs (e.g.
 
\family typewriter
rates=0.01
\family default
) in which case the same mutation rate will be applied to all loci.
\end_layout

\begin_layout Subsection
Mutation models specified by rate matrixes (
\family typewriter
matrixMutator
\family default
) 
\end_layout

\begin_layout Standard
A mutation model can be defined as a 
\series bold
mutation rate matrix
\series default
 
\begin_inset Formula $\left(p_{ij}\right)_{n\times n}$
\end_inset

 where 
\begin_inset Formula $p_{ij}$
\end_inset

 is the probability that an allele 
\begin_inset Formula $i$
\end_inset

 mutates to 
\begin_inset Formula $j$
\end_inset

 per generation per locus.
 Although mathematical formulation of 
\begin_inset Formula $p_{ij}$
\end_inset

 are sometimes unscaled, simuPOP assumes 
\begin_inset Formula $\sum_{j=0}^{n-1}p_{ij}=1$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

 and requires such rate matrixes in the specification of a mutation model.
 
\begin_inset Formula $p_{ii}$
\end_inset

 of such a matrix are ignored because they are automatically calculated
 from 
\begin_inset Formula $p_{ii}=1-\sum_{j\ne i}p_{ij}$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\family typewriter
matrixMutator
\family default
 is defined to mutate between alleles 0, 1, ..., 
\begin_inset Formula $n-1$
\end_inset

 according to a given rate matrix.
 Conceptually speaking, this mutator goes through each mutable allele and
 mutates it to allele 
\begin_inset Formula $0,1,..,n-1$
\end_inset

 according to probabilities 
\begin_inset Formula $p_{ij}$
\end_inset

, 
\begin_inset Formula $j=0,...,n-1$
\end_inset

.
 Most alleles will be kept intact because mutations usually happen at low
 probability (with 
\begin_inset Formula $p_{ii}$
\end_inset

 close to 1).
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "matrixMutator"

\end_inset

 simulates a locus with 3 alleles.
 Because the rate at which allele 2 mutats to alleles 0 and 1 is higher
 than the rate alleles 0 and 2 mutate to allele 2, the frequency of allele
 2 decreases over time.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/matrixMutator.log"
lstparams "caption={General mutator specified by a mutation rate matrix},label={matrixMutator}"

\end_inset


\end_layout

\begin_layout Subsection
k-allele mutation model (
\family typewriter
kamMutator
\family default
)
\end_layout

\begin_layout Standard
A 
\begin_inset Formula $k$
\end_inset

-allele model assumes 
\begin_inset Formula $k$
\end_inset

 alleles 
\begin_inset Formula $\left(0,...,k-1\right)$
\end_inset

 at a locus and mutate between them using rate matrix 
\begin_inset Formula \[
p_{ij}=\left(\begin{array}{cccc}
1-\mu & \frac{\mu}{k-1} & \cdots & \frac{\mu}{k-1}\\
\frac{\mu}{k-1} & 1-\mu & \cdots & \frac{\mu}{k-1}\\
\vdots & \vdots & \ddots & \vdots\\
\frac{\mu}{k-1} & \frac{\mu}{k-1} & \cdots & 1-\mu\end{array}\right)\]

\end_inset

The only parameter 
\begin_inset Formula $\mu$
\end_inset

 is the mutation rate, which is the rate at which an allele mutates to any
 other allele with equal probability.
\end_layout

\begin_layout Standard
This mutation model is a special case of the 
\family typewriter
matrixMutator
\family default
 but a specialized 
\family typewriter
kamMutator
\family default
 is recommended because it provides better performance, especially when
 
\begin_inset Formula $k$
\end_inset

 is large.
 In addition, this operator allows different mutation rates at different
 loci.
 When 
\begin_inset Formula $k$
\end_inset

 is not specified, it is assumed to be the number of allowed alleles (e.g.
 2 for binary modules).
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "kamMutator"

\end_inset

 desmonstrates the use of this operator where parameters 
\family typewriter
rate
\family default
 and 
\family typewriter
loci
\family default
 are used to specify different mutation rates for different loci.
 Because this operator treats all alleles equally, all alleles will have
 the same allele frequency in the long run.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/kamMutator.log"
lstparams "caption={A k-allele mutation model},label={kamMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Diallelic mutation models (
\family typewriter
snpMutator
\family default
)
\end_layout

\begin_layout Standard

\family typewriter
matrixMutator
\family default
 and 
\family typewriter
kamMutator
\family default
 are general purpose mutators in the sense that they do not assume a type
 for the mutated alleles.
 This and the following sections describe mutation models for specific types
 of alleles.
\end_layout

\begin_layout Standard
If there are only two alleles at a locus, a diallelic mutation model should
 be used.
 Because single nucleotide polymorphisms (SNPs) are the most widely avaiable
 diallelic markers, a 
\family typewriter
snpMutator
\family default
 is provided to mutate such markers using a mutate rate matrix
\end_layout

\begin_layout Standard
\begin_inset Formula \[
R=\left(\begin{array}{cc}
1-u & u\\
v & 1-v\end{array}\right).\]

\end_inset


\end_layout

\begin_layout Standard
Despite of its name, this mutator can be used in many theoretical models
 assuming 
\begin_inset Formula $\mbox{Pr}\left(A\rightarrow a\right)=u$
\end_inset

 and 
\begin_inset Formula $\mbox{Pr}\left(a\rightarrow A\right)=v$
\end_inset

.
 If 
\begin_inset Formula $v=0$
\end_inset

, mutations will be directional.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "snpMutator"

\end_inset

 applies such a directional mutaton model to two loci, but with a purifying
 selection applied to the first locus.
 Because of the selection pressure, the frequency of allele 1 at the first
 locus does not increase indefinitely as allele 1 at the second locus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/snpMutator.log"
lstparams "caption={A diallelic directional mutation model},label={snpMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Nucleotide mutation models (
\family typewriter
acgtMutator
\family default
)
\end_layout

\begin_layout Standard
Mutations in these models assume alleles 0, 1, 2, 3 as nucleotides A, C,
 G, and T.
 The operator is named 
\family typewriter
acgtMutator
\family default
 to remind you the alphabetic order of these nucleotides.
 This mutation model is specified by a rate matrix
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula \[
\begin{array}{ccccc}
 & A & C & G & T\\
A & - & x_{1} & x_{2} & x_{3}\\
C & x_{4} & - & x_{5} & x_{6}\\
G & x_{7} & x_{8} & - & x_{9}\\
T & x_{10} & x_{11} & x_{12} & -\end{array}\]

\end_inset


\end_layout

\begin_layout Standard
\align left
which is determined by 12 parameters.
 However, several simpler models with fewer parameters can be used.
 In addition to parameters shared by all mutation operators, a nucleotide
 mutator is specified by a parameter list and a model name.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

acgtMutator(rate=[1e-5, 0.5], model='K80')
\end_layout

\end_inset

specifies a nucleotide mutator using Kimura's 2-parameter model with 
\begin_inset Formula $\mu=10^{-5}$
\end_inset

 and 
\begin_inset Formula $\kappa=0.5$
\end_inset

.
 Because multiple parameters could be involved for a particular mutation
 model, 
\series bold
the definition of a mutation rate and other paramters are model dependent
 and may varying with different mathematical representation of the models
\series default
.
\end_layout

\begin_layout Standard
The names and acceptable parameters of acceptable models are listed below:
\end_layout

\begin_layout Enumerate
Jukes and Cantor 1969 model: model='JC69', rate=[
\begin_inset Formula $\mu$
\end_inset

 ]
\end_layout

\begin_deeper
\begin_layout Standard
The Jukes and Cantor model is similar to a 
\begin_inset Formula $4$
\end_inset

-allele model but its definition of 
\begin_inset Formula $\mu$
\end_inset

 is different.
 More specifically, when a mutation event happens at rate 
\begin_inset Formula $\mu$
\end_inset

, an allele will have equal probability to mutate to any of the 4 allelic
 states.
 
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \frac{\mu}{4} & \frac{\mu}{4} & \frac{\mu}{4}\\
\frac{\mu}{4} & - & \frac{\mu}{4} & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4} & - & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4} & \frac{\mu}{4} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Kimura's 2-parameter 1980 model: model='K80', rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
Kimura 's model distinguishes transitions (
\begin_inset Formula $A\longleftrightarrow G$
\end_inset

, and 
\begin_inset Formula $C\leftrightarrow T$
\end_inset

 namely 
\begin_inset Formula $0\longleftrightarrow2$
\end_inset

 and 
\begin_inset Formula $1\longleftrightarrow3$
\end_inset

 with probability 
\begin_inset Formula $\frac{\mu}{4}\kappa$
\end_inset

) and transversions (others) with probability 
\begin_inset Formula $\frac{\mu}{4}$
\end_inset

.
 It would be a Jukes and Cantor model if 
\begin_inset Formula $\kappa=1$
\end_inset

.
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \frac{\mu}{4} & \frac{\mu}{4}\kappa & \frac{\mu}{4}\\
\frac{\mu}{4} & - & \frac{\mu}{4} & \frac{\mu}{4}\kappa\\
\frac{\mu}{4}\kappa & \frac{\mu}{4} & - & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4}\kappa & \frac{\mu}{4} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Felsenstein 1981 model: model='F81', rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

].
 
\end_layout

\begin_deeper
\begin_layout Standard
This model assumes different base frequencies but the same probabilities
 for transitions and transversions.
 
\begin_inset Formula $\pi_{T}$
\end_inset

 is calculated from 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

 and 
\begin_inset Formula $\pi_{G}$
\end_inset

.
 
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\pi_{C} & \mu\pi_{G} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Hasegawa, Kishino and Yano 1985 model: model='HKY85', rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model replaces 1/4 frequency used in the Kimura's 2-parameter model
 with nucleotide-specific frequencies.
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\kappa\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\kappa\pi_{T}\\
\mu\kappa\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\kappa\pi_{C} & \mu\pi_{G} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Tamura 1992 model: model='T92', rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\pi_{GC}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model is a HKY85 model with 
\begin_inset Formula $\pi_{G}=\pi_{C}=\pi_{GC}/2$
\end_inset

 and 
\begin_inset Formula $\pi_{A}=\pi_{T}=\pi_{AT}/2=\left(1-\pi_{GC}\right)/2$
\end_inset

,
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \frac{1}{2}\mu\pi_{GC} & \frac{1}{2}\mu\nu\pi_{GC} & \frac{1}{2}\mu\pi_{AT}\\
\frac{1}{2}\mu\pi_{AT} & - & \frac{1}{2}\mu\pi_{GC} & \frac{1}{2}\mu\nu\pi_{AT}\\
\frac{1}{2}\mu\nu\pi_{AT} & \frac{1}{2}\mu\pi_{GC} & - & \frac{1}{2}\mu\pi_{AT}\\
\frac{1}{2}\mu\pi_{AT} & \frac{1}{2}\mu\nu\pi_{GC} & \frac{1}{2}\mu\pi_{GC} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Tamura and Nei 1993 model: model='TN93', rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa_{1}$
\end_inset

, 
\begin_inset Formula $\kappa_{2}$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model extends the HKY1985 model by distinguishing 
\begin_inset Formula $A\longleftrightarrow G$
\end_inset

 transitions (namely 
\begin_inset Formula $0\longleftrightarrow2$
\end_inset

) and 
\begin_inset Formula $C\leftrightarrow T$
\end_inset

 transitions (
\begin_inset Formula $1\longleftrightarrow3$
\end_inset

) with different 
\begin_inset Formula $\kappa$
\end_inset

.
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\kappa_{1}\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\kappa_{2}\pi_{T}\\
\mu\kappa_{1}\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\kappa_{2}\pi_{C} & \mu\pi_{G} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Generalized time reversible model: model='GTR', rate=[
\begin_inset Formula $x_{1}$
\end_inset

, 
\begin_inset Formula $x_{2}$
\end_inset

, 
\begin_inset Formula $x_{3}$
\end_inset

, 
\begin_inset Formula $x_{4}$
\end_inset

, 
\begin_inset Formula $x_{5}$
\end_inset

, 
\begin_inset Formula $x_{6}$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
The generalized time reviersible model is the most general neutral, indepdendent
, finite-sites, time-reversible model possible.
 It is specified by six parameters and base frequencies.
 Its rate matrix is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & \frac{\pi_{A}x_{1}}{\pi_{C}} & \frac{\pi_{A}x_{2}}{\pi_{G}} & \frac{\pi_{A}x_{3}}{\pi_{T}}\\
x_{1} & - & \frac{\pi_{C}x_{4}}{\pi_{G}} & \frac{\pi_{C}x_{5}}{\pi_{T}}\\
x_{2} & x_{4} & - & \frac{\pi_{G}x_{6}}{\pi_{T}}\\
x_{3} & x_{5} & x_{6} & -\end{array}\right)\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
General model: model='general' (default), rate=[
\begin_inset Formula $x_{1}$
\end_inset

, 
\begin_inset Formula $x_{2}$
\end_inset

, 
\begin_inset Formula $x_{3}$
\end_inset

, 
\begin_inset Formula $x_{4}$
\end_inset

, 
\begin_inset Formula $x_{5}$
\end_inset

, 
\begin_inset Formula $x_{6}$
\end_inset

, 
\begin_inset Formula $x_{7}$
\end_inset

, 
\begin_inset Formula $x_{8}$
\end_inset

, 
\begin_inset Formula $x_{9}$
\end_inset

, 
\begin_inset Formula $x_{10}$
\end_inset

, 
\begin_inset Formula $x_{11}$
\end_inset

, 
\begin_inset Formula $x_{12}$
\end_inset

].
\end_layout

\begin_deeper
\begin_layout Standard
This is the most general model with 12 parameters:
\begin_inset Formula \[
R=\left(\begin{array}{cccc}
- & x_{1} & x_{2} & x_{3}\\
x_{4} & - & x_{5} & x_{6}\\
x_{7} & x_{8} & - & x_{9}\\
x_{10} & x_{11} & x_{12} & -\end{array}\right)\]

\end_inset

It is not surprising that all other models are implemented as special cases
 of this model.
\end_layout

\end_deeper
\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "acgtMutator"

\end_inset

 applies a Kimmura's 2-parameter mutation model to a population with a single
 nucleotide marker.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/acgtMutator.log"
lstparams "caption={A Kimura's 2 parameter mutation model},label={acgtMutator}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Amino acid mutation models (
\family typewriter
aminoAcidMutator
\family default
, not yet implemented)
\end_layout

\begin_layout Plain Layout
Amino acid mutation models assume alleles 0, 1, 2, 3, ..., 19 as 20 amino acids
 C, S, T, P, A, G, N, D, E, Q, H, R, K, M, I, L, V, F, Y, and W.
 This mutation model is specified by a 20 by 20 rate matrix.
 The mutator should work similarly to 
\family typewriter
acgtMutator
\family default
 but it is more tedious.
 I will implement popular mutation matrixes if there is a demonstrated need
 for such an operator (an email to the simuPOP mailing list should be enough.
 :-).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mutation model for microsatellite markers (
\family typewriter
smmMutator
\family default
)
\end_layout

\begin_layout Standard
The 
\series bold
stepwise mutation model
\series default
 (SMM) was proposed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Ohta1973"

\end_inset

 to model the mutation of Variable Number Tandem Repeat (VNTR), which consists
 of tandem repeat of sequences.
 VNTR markers consisting of short sequences (e.g.
 5 basepair or less) are also called microsatellite markers.
 A mutation event of a VNTR marker either increase of decrease the number
 of repeats, as a result of slipped-strand mispairing or unequal sister
 chromatid exchange and genetic recombination.
\end_layout

\begin_layout Standard
A 
\family typewriter
smmMutator
\family default
 assumes that alleles at a locus are the number of tandem repeats and mutates
 them by increasing or decreasing the number of repeats during a mutation
 event.
 By adjusting parameters 
\family typewriter
incProb
\family default
, 
\family typewriter
maxAllele
\family default
 and 
\family typewriter
mutStep
\family default
, this operator can be used to simulate the standard neutral stepwise mutation
 model and a number of 
\series bold
generalized stepwise mutation models
\series default
.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "smmMutator"

\end_inset

 uses two 
\family typewriter
smmMutator
\family default
 to mutate two microsatellite markers, using a standard and a generalized
 model where a geometric distribution is used to determine the number of
 steps.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/smmMutator.log"
lstparams "caption={A standard and a generalized stepwise mutation model},label={smmMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Simulating arbitrary mutation models using a hybrid mutator (
\family typewriter
pyMutator
\family default
)*
\end_layout

\begin_layout Standard
A hybrid mutator 
\family typewriter
pyMutator
\family default
 mutates random alleles at selected loci (parameter 
\family typewriter
loci
\family default
), replicates (parameter 
\family typewriter
loci
\family default
), subpopulations (parameter 
\family typewriter
subPop
\family default
) with specified mutation rate (parameter 
\family typewriter
rate
\family default
).
 Instead of mutating the alleles by itself, it passes the alleles to a user-defi
ned function and use it return values as the mutated alleles.
 Arbitrary mutation models could be implemented using this operator.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyMutator"

\end_inset

 applies a simple mutation model where an allele is increased by a random
 number between 1 and 5 when it is mutated.
 Two different mutation rates are used for two different loci so average
 alleles at these two loci are different.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyMutator.log"
lstparams "caption={A hybrid mutation model},label={pyMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Mixed mutation models (
\family typewriter
mixedMutator
\family default
) **
\end_layout

\begin_layout Standard
Mixed mutation models are sometimes used to model real data.
 For example, a 
\begin_inset Formula $k$
\end_inset

-allele model can be used to explain extremely large or small number of
 tandem repeats at a microsatellite marker which are hard to justify using
 a standard stepwise mutation model.
 A mixed mutation model would apply two or more mutation models at pre-specified
 probabilities.
\end_layout

\begin_layout Standard
A 
\family typewriter
mixedMutator
\family default
 is constructed by a list of mutators and their respective probabilities.
 It accepts regular mutator parameters such as 
\family typewriter
rates
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
subPops
\family default
, 
\family typewriter
mapIn and mapOut
\family default
 and mutates aleles at specified rate.
 When a mutation event happens, it calls one of the mutators to mutate the
 allele.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mixedMutator"

\end_inset

 applies a mixture of 
\begin_inset Formula $k$
\end_inset

-allele model and stepwise model to mutate a micosatellite model.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mixedMutator.log"
lstparams "caption={A mixed k-allele and stepwise mutation model},label={mixedMutator}"

\end_inset


\end_layout

\begin_layout Standard
When a mutation event happens, mutators in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mixedMutator"

\end_inset

 mutate the allele with probability (mutation rate) 1.
 If different mutation rates are specified, the overall mutation rates would
 be the product of mutation rate of 
\family typewriter
mixedMutator
\family default
 and the passed mutators.
 However, it is extremely important to understand that although 
\family typewriter
mixedMutator(rates=mu)
\family default
 with 
\family typewriter
smmMutator(rates=1)
\family default
 and 
\family typewriter
mixedMutator(rates=1) 
\family default
with 
\family typewriter
smmMutator(rates=mu)
\family default
 mutate alleles at the same mutation rate, the former is much more efficient
 because it triggers far less mutation events.
\end_layout

\begin_layout Subsection
Context-dependent mutation models (
\family typewriter
contextMutator
\family default
)**
\end_layout

\begin_layout Standard
All mutation models we have seen till now are context independent.
 That is to say, how an allele is mutated depends only on the allele itself.
 However, it is understood that DNA and amino acid substitution rates are
 highly sequence context-dependent, e.g., C 
\begin_inset Formula $\rightarrow$
\end_inset

 T substitutions in vertebrates may occur much more frequently at CpG sites.
 To simulate such models, a mutator must consider the context of a mutated
 allele, e.g.
 certain number of alleles to the left and right of this allele, and mutate
 the allele accordingly.
\end_layout

\begin_layout Standard
A 
\family typewriter
contextMutator
\family default
 can be used to mutate an allele depending on its surrounding loci.
 This mutator is constructed by a list of mutators and their respective
 contexts.
 It accepts regular mutator parameters such as 
\family typewriter
rates
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
subPops
\family default
, 
\family typewriter
mapIn and mapOut
\family default
 and mutates aleles at specified rate.
 When a mutation event happens, it checks the context of the mutaed allele
 and choose a corresponding mutator to mutate the allele.
 An additional mutator can be specified to mutate alleles with unknown context.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "contextMutator"

\end_inset

 applies two 
\family typewriter
snpMutator
\family default
 at different rates under different contexts.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/contextMutator.log"
lstparams "caption={A context-dependent mutation model},label={contextMutator}"

\end_inset

Note that although 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

contextMutator(mutators=[
\end_layout

\begin_layout Plain Layout

    snpMutator(u=0.1),
\end_layout

\begin_layout Plain Layout

    snpMutator(u=1)],
\end_layout

\begin_layout Plain Layout

    contexts=[(0, 0), (1, 1)],
\end_layout

\begin_layout Plain Layout

    rates=0.01
\end_layout

\begin_layout Plain Layout

)    
\end_layout

\end_inset

and 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

contextMutator(mutators=[
\end_layout

\begin_layout Plain Layout

    snpMutator(u=0.001),
\end_layout

\begin_layout Plain Layout

    snpMutator(u=0.01)],
\end_layout

\begin_layout Plain Layout

    contexts=[(0, 0), (1, 1)],
\end_layout

\begin_layout Plain Layout

    rates=1
\end_layout

\begin_layout Plain Layout

)    
\end_layout

\end_inset

both apply two 
\family typewriter
snpMutator
\family default
 at mutation rates 
\family typewriter
0.001
\family default
 and 
\family typewriter
0.01
\family default
, the former is more efficient because it triggers less mutation events.
\end_layout

\begin_layout Standard
Context-dependent mutator can also be implemented by a 
\family typewriter
pyMutator
\family default
.
 When a non-zero parameter 
\family typewriter
context
\family default
 is specified, this mutator will collect 
\family typewriter
context
\family default
 number of alleles to the left and right of a mutated allele and pass them
 as a second parameter of the user-provided mutation function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyContextMutator"

\end_inset

 applies the same mutation model as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "contextMutator"

\end_inset

 using a 
\family typewriter
pyMutator
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyContextMutator.log"
lstparams "caption={A hybrid context-dependent mutation model},label={pyContextMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Manually-introduced mutations (
\family typewriter
pointMutator
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
pointMutator
\family default
 is different from all other mutators in that it mutates specified alleles
 of specified individuals.
 It is usually used to manually introduce one or more mutants to a population.
 Although it is not a recommended method to introduce a disease predisposing
 allele, the following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointMutator"

\end_inset

) demonstrates an evolutionary process where mutants are repeatedly introduced
 and raised by positive selection until it reaches an appreciable allele
 frequency.
 This example uses two 
\family typewriter
ifElse
\family default
 operators.
 The first one introduces a mutant when there is no mutant in the population,
 and the second one terminate the evolution when the frequency of the mutant
 reaches 0.05.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pointMutator.log"
lstparams "caption={Use a point mutator to introduce a disease predisposing allele},label={pointMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Apply mutation to (virtual) subpopulations *
\end_layout

\begin_layout Standard
A mutator is usually applied to all individuals in a population.
 However, you can restrict its use to specified subpopulations and/or virtual
 subpopulations using parameter 
\family typewriter
subPop
\family default
.
 For example, you can use 
\family typewriter
subPop=[0, 2]
\family default
 to apply the mutator only to individuals in subpopulations 0 and 2.
\end_layout

\begin_layout Standard
Virtual subpopulations can also be specified in this parameter.
 For example, you can apply different mutation models to male and female
 individuals, to unaffected or affected individuals, to patients at different
 stages of a cancer.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mutatorVSP"

\end_inset

 demonstrate a mutation model where individuals with more tandem repeats
 at a disease predisposing locus are more likely to develop a disease (e.g.
 fragile-X).
 Affected individuals are then subject to a non-neutral mutation model at
 an accerlerated mutation rate.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mutatorVSP.log"
lstparams "caption={Applying mutation to virtual subpopulations.},label={mutatorVSP}"

\end_inset


\end_layout

\begin_layout Standard
At the beginning of a simulation, all individuals have 50 copies of a tandem
 repeat and the mutation follows a standard neutral stepwise mutation model.
 Individuals with more than 50 repeats will have an increasing probability
 to develop a disease (
\begin_inset Formula $\mbox{Pr}\left(\mbox{affected}\mid n\right)=\left(n-50\right)*0.05$
\end_inset

) for 
\begin_inset Formula $50\le n\le70$
\end_inset

).
 The averge repeat number therefore increases for affected individuals.
 In contrast, the mean number of repeats at locus 1 on a separate chromosome
 oscillate around 50.
\end_layout

\begin_layout Subsection
Allele mapping **
\end_layout

\begin_layout Standard
If alleles in your simulation do not follow the convention of a mutation
 model, you may want to use the 
\family typewriter
pop.recodeAlleles()
\family default
 function to recode your alleles so that appropriate mutation models could
 be applied.
 If this is not possible, you can use a general mutation model with your
 own mutation matrix, or an advanced feature called 
\series bold
allele mapping
\series default
.
 
\end_layout

\begin_layout Standard
Allele mapping is done through two parameters 
\emph on
mapIn
\emph default
 and 
\emph on
mapOut
\emph default
, which map alleles in your population to and from alleles assumed in a
 mutation model.
 For example, an 
\family typewriter
acgtMutator
\family default
 mutator assumes alleles 
\family typewriter
A
\family default
, 
\family typewriter
C
\family default
, 
\family typewriter
G
\family default
 and 
\family typewriter
T
\family default
 for alleles 0, 1, 2, and 3 respectively.
 If for any reason the alleles in your application does not follow this
 order, you will need to map these alleles to the alleles assumed in the
 mutator.
 For example, if you assumes 
\family typewriter
C
\family default
, 
\family typewriter
G
\family default
, 
\family typewriter
A
\family default
, 
\family typewriter
T
\family default
 for alleles 0, 1, 2, and 3 respectively, you can use parameters
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mapIn=[1, 2, 0, 3], mapOut=[2, 0, 1, 3]
\end_layout

\end_inset

to map your alleles (
\family typewriter
C(0)->C(1)
\family default
, 
\family typewriter
G(1)->G(2)
\family default
, 
\family typewriter
A(2)->A(0)
\family default
, 
\family typewriter
T(3)->T(3)
\family default
) to alleles 
\family typewriter
acgtMutator
\family default
 assumes, and then map mutated alleles (
\family typewriter
A(0)->A(2)
\family default
, 
\family typewriter
C(1)->C(0)
\family default
, 
\family typewriter
G(2)->G(1)
\family default
, 
\family typewriter
T(3)->T(3)
\family default
) back.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "alleleMapping"

\end_inset

 gives another example where alleles 4, 5, 6 and 7 are mutated using a 4-allele
 model.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/alleleMapping.log"
lstparams "caption={Allele mapping for mutation operators},label={alleleMapping}"

\end_inset


\end_layout

\begin_layout Standard
These two parameters also accept Python functions which should return correspond
ing mapped-in or out allele for a given allele.
 These two functions can be used to explore very fancy mutation models.
 For example, you can categorize a large number of alleles into alleles
 assumed in a mutation model, and emit random alleles from a mutated allele.
\end_layout

\begin_layout Subsection
Mutation rate and transition matrix of a 
\family typewriter
matrixMutator 
\family default
**
\end_layout

\begin_layout Standard
A 
\family typewriter
matrixMutator
\family default
 is specified by a mutation rate matrix.
 Although mutation rates of this mutator is typically allele-dependent,
 the 
\family typewriter
matrixMutator
\family default
 is implemented as a two-step process where mutation events are triggered
 independent to allelic states.
 This section describes these two steps which can be useful if you need
 to use a 
\family typewriter
maxtrixMutator
\family default
 in a 
\family typewriter
mixedMutator
\family default
 or 
\family typewriter
contextMutator
\family default
, and would like to factor out an allele-independent mutation rate to the
 wrapper mutator.
\end_layout

\begin_layout Standard
Because alleles usually have different probabilities of mutating to other
 alleles, 
\series bold
a mutation process is usually allele dependent
\series default
.
 Given a mutation model 
\begin_inset Formula $\left(p_{ij}\right)$
\end_inset

, it is obviously inefficient to go through all mutable alleles and determine
 whether or not to mutate it using 
\begin_inset Formula $p_{ij},$
\end_inset

 
\begin_inset Formula $j=0,...,1-n$
\end_inset

.
 simuPOP uses a two step procedure to mutate a large number of alleles.
 More specifically, for each mutation model, we determine 
\begin_inset Formula $\mu=\max_{i=0}^{n-1}\left(1-p_{ii}\right)$
\end_inset

 as the overall mutation rate, and then
\end_layout

\begin_layout Enumerate
For each allele, trigger a mutation event with probability 
\begin_inset Formula $\mu$
\end_inset

.
 Because 
\begin_inset Formula $\mu$
\end_inset

 is usually very small and is the same for all alleles, this step can be
 implemented efficiently.
\end_layout

\begin_layout Enumerate
When a mutation event happens, mutation allele 
\begin_inset Formula $i$
\end_inset

 to allele 
\begin_inset Formula $j$
\end_inset

 with probability 
\begin_inset Formula \[
\mbox{Pr}\left(i\rightarrow j\right)=\begin{cases}
1-\frac{1}{\mu}\left(1-p_{ii}\right) & \mbox{if }i=j\\
\frac{p_{ij}}{\mu} & \mbox{if }i\ne j\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Because steps 1 and 2 are independent, it is easy to verify that
\begin_inset Formula \[
p_{ij}=\mu\mbox{Pr}\left(i\rightarrow j\right)\]

\end_inset

if 
\begin_inset Formula $i\ne j$
\end_inset

 and 
\begin_inset Formula \[
p_{ii}=\left(1-\mu\right)+\mu\mbox{Pr}\left(i\rightarrow i\right)\]

\end_inset

where the first and second items are probabilities of no-mutation at steps
 1 and 2.
 
\begin_inset Formula $\mu$
\end_inset

 was chosen as the smallest 
\begin_inset Formula $\mu$
\end_inset

 that makes 
\begin_inset Formula $0\leq\mbox{Pr}\left(i\rightarrow i\right)\leq1$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
For example, for a 
\begin_inset Formula $k$
\end_inset

-allele model with 
\begin_inset Formula \[
p_{ij}=\left(\begin{array}{cccc}
1-\mu & \frac{\mu}{k-1} & \cdots & \frac{\mu}{k-1}\\
\frac{\mu}{k-1} & 1-\mu & \cdots & \frac{\mu}{k-1}\\
\vdots & \vdots & \ddots & \vdots\\
\frac{\mu}{k-1} & \frac{\mu}{k-1} & \cdots & 1-\mu\end{array}\right)\]

\end_inset


\begin_inset Formula $\mu$
\end_inset

 is directly 
\begin_inset Formula $\mu$
\end_inset

 for the first step and 
\begin_inset Formula \[
\mbox{Pr}\left(i\rightarrow j\right)=\begin{cases}
0 & \mbox{if }i=j\\
\frac{1}{k-1} & \mbox{if }i\ne j\end{cases}\]

\end_inset

for the second step.
 Therefore, mutation rate 
\begin_inset Formula $\mu$
\end_inset

 in a 
\begin_inset Formula $k$
\end_inset

-allele model could be interpreted as the probability of mutation, and a
 mutation event would mutate an allele to any other allele with equal probabilit
y.
\end_layout

\begin_layout Standard
For a classical mutation model with 
\begin_inset Formula $P\left(A\rightarrow a\right)=u$
\end_inset

 and 
\begin_inset Formula $P\left(a\rightarrow A\right)=v$
\end_inset

, 
\begin_inset Formula \[
p_{ij}=\left(\begin{array}{cc}
1-u & u\\
v & 1-v\end{array}\right)\]

\end_inset

if 
\begin_inset Formula $u=0.001$
\end_inset

 and 
\begin_inset Formula $v=0.0005$
\end_inset

, 
\begin_inset Formula $\mu=\max\left(u,v\right)=0.001$
\end_inset

,
\begin_inset Formula \[
\mbox{Pr}\left(i\rightarrow j\right)=\left(\begin{array}{cc}
0 & 1\\
\frac{v}{u}=0.5 & 1-\frac{v}{u}=0.5\end{array}\right)\]

\end_inset

That is to say, we would mutate at a mutation rate 
\begin_inset Formula $u=0.001$
\end_inset

, mutate allele 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

 with probability 1 and mutate allele 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

 with probability 0.5.
\end_layout

\begin_layout Subsection
Infinite-sites model and other simulation techniques **
\end_layout

\begin_layout Standard
Infinite-sites and infinite-alleles models have some similarities.
 In some cases, you can treat a long chromosomal region as a locus and use
 the infinite-alleles model, actually a 
\begin_inset Formula $k$
\end_inset

-allele model with large 
\begin_inset Formula $k$
\end_inset

, to mimic the infinite-site model.
 Because there is supposed to be only one mutant at each site, you can assign
 a unique 
\emph on
location
\emph default
 for each allele of an infinite-allele model and convert multi-allelic datasets
 simulated by an infinite-allele model to sequences of diallelic markers.
 It worth noting that mutation rates are interpreted differently for these
 two models, and there is no way to recombine in such a region because it
 is reprsented as a single allele.
\end_layout

\begin_layout Standard
If specific location of such a mutation is needed, it is possible to record
 the location of mutations during an evolution and minic an infinite-sites
 model.
 For example, alleles in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infiniteSites"

\end_inset

 are used to store location of a mutation event.
 When a mutation event happens, the location of the new allele (rather the
 allele itself) is recorded on the chromosome (actually list of mutation
 events) of an individual.
 The transmission of chromosomes proceed normally and effectively transmit
 mutants from parents to offspring.
 At the end of the simulation, each individual accumulates a number of mutation
 events and they are essentially alleles at their respective locations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infiniteSites.log"
lstparams "caption={Mimicking an infinite-sites model using mutation events as alleles},label={infiniteSites}"

\end_inset


\end_layout

\begin_layout Standard
All mutation models in simuPOP apply to existing alleles at pre-specified
 loci.
 However, if the location of loci cannot be determined beforehand, it is
 sometimes desired to create new loci as a result of mutation.
 A customized operator can be used for this purpose (see Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "newOperator"

\end_inset

), but extra attention is needed to make sure that other operators are applied
 to the correct loci because loci indexes will be changed with the insertion
 of new loci.
 This technique could also be used to simulate mutations over long sequences.
\end_layout

\begin_layout Section
Statistics calculation (operator 
\family typewriter
stat
\family default
)
\end_layout

\begin_layout Subsection
How statistics calculation works
\end_layout

\begin_layout Standard
A 
\family typewriter
stat
\family default
 operator calculates specified statistics of a population when it is applied
 to this population.
 This operator can be applied to specified replicates (parameter 
\emph on
rep
\emph default
) at specified generations (parameter 
\emph on
begin
\emph default
, 
\emph on
end
\emph default
, 
\emph on
step
\emph default
, and 
\emph on
at
\emph default
).
 This operator does not produce any output (ignore parameter 
\emph on
output
\emph default
) after statistics are calculated.
 Instead, it stores results in the local namespace of the population being
 applied.
 Other operators can retrieve these variables or evalulate expression directly
 in this local namespace.
\end_layout

\begin_layout Standard
The 
\family typewriter
stat
\family default
 operator is usually used in conjunction with a 
\family typewriter
pyEval
\family default
 or 
\family typewriter
pyExec
\family default
 operator which execute Python statements and/or expressions in a population's
 local namespace.
 For example, operators 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ops = [
\end_layout

\begin_layout Plain Layout

    stat(alleleFreq=[0]),
\end_layout

\begin_layout Plain Layout

    pyEval("'%.2f' % alleleFreq[0][0]")
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset

in the 
\family typewriter
ops
\family default
 parameter of the 
\family typewriter
simulator.evolve
\family default
 function will be applied to populations during evolution.
 The first operator calculates allele frequency at the first locus and store
 the results in each population's local namespace.
 The second operator formats and outputs one of the variables.
 Because of the flexiblity of the 
\family typewriter
pyEval
\family default
 operator, you can output statistics, even simple derived statistics, in
 any format.
 For example, you can output expected heterozygosity (
\begin_inset Formula $1-\sum p_{i}^{2}$
\end_inset

) using calculated allele frequencies as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval("'H_exp=%.2f' % (1-sum([x*x for x in alleleFreq[0].values()]))")
\end_layout

\end_inset

Note that 
\family typewriter
alleleFreq[0]
\family default
 is a dictionary.
\end_layout

\begin_layout Standard
You can also retrieve variables in a population directly using functions
 
\family typewriter
population.vars()
\family default
 or 
\family typewriter
population.dvars()
\family default
.
 The only difference between these functions is that 
\family typewriter
vars()
\family default
 returns a dictionary and 
\family typewriter
dvars()
\family default
 returns a Python object that uses variable names as attributes (
\family typewriter
vars()['alleleFreq']
\family default
 is equivalent to 
\family typewriter
dvars().alleleFreq
\family default
).
 This method is usually used when the function form of the 
\family typewriter
stat
\family default
 operator is used.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(pop, alleleFreq=[0])
\end_layout

\begin_layout Plain Layout

H_exp = 1 - sum([x*x for x in pop.dvars().alleleFreq[0].values()])
\end_layout

\end_inset

uses the 
\family typewriter
Stat
\family default
 function (note the capital S) to count frequencies of alleles for a given
 population and calculates expected heterozygosity using these variables.
\end_layout

\begin_layout Subsection
Support for virtual subpopulations
\end_layout

\begin_layout Standard
The 
\family typewriter
stat
\family default
 operator supports parameter 
\emph on
subPops
\emph default
 and can calculate statistics in specified subpopulations.
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0], subPops=[(0, 0), (1, 0)])
\end_layout

\end_inset

will calculate the frequencies of alleles at locus 0, among individuals
 in two virtual subpopulations.
 If the virtual subpopulation is defined by sex (using a 
\family typewriter
sexSplitter
\family default
), the above operator will calculate allele frequency among all males in
 the first and second subpopulations.
 If 
\family typewriter
subPops
\family default
 is not specified, allele frequency of the whole population (all subpopulations)
 will be calculated.
\end_layout

\begin_layout Standard
Although many statistics could be calculated and outputted, the 
\family typewriter
stat
\family default
 operator by default outputs a selected number of variables for each statisic
 calculated.
 Other statistics could be calculated and outputted if their names are specified
 in parameter 
\family typewriter
vars
\family default
.
 Variable names ending with 
\family typewriter
_sp
\family default
 is interpreted as variables that will be calculated and outputted in all
 or specified (virtual) subpopulations.
 For example, parameter 
\family typewriter
vars
\family default
 in  
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0], subPops=[0, (1, 0)], vars=['alleleFreq_sp', 'alleleNum_sp']
)
\end_layout

\end_inset

tells this operator to output numbers and frequencies of alleles at locus
 
\family typewriter
0
\family default
 in subpopulation 
\family typewriter
0
\family default
 and virtual subpopulation 
\family typewriter
(1,0)
\family default
.
 These variables will be saved in dictionaries 
\family typewriter
subPop[sp]
\family default
 of the local namespace.
 For example, the above operator will write variables such as 
\family typewriter
subPop[0]['alleleFreq'], subPop[(1,0)]['alleleFreq'] and subPop[(1,0)]['alleleNu
m']
\family default
.
 Functions 
\family typewriter
population.vars(sp)
\family default
 and 
\family typewriter
population.dvars(sp)
\family default
 are provided as shortcuts to access these variables but the full variable
 names have to be specified if these variables are used in expressions.
\end_layout

\begin_layout Standard
By default, the same variables will be set for a statistic, regardless of
 the values of the 
\family typewriter
subPops
\family default
 parameter.
 This can be a problem if multiple 
\family typewriter
stat
\family default
 operators are used to calculate the same statistics for different sets
 of subpopulations.
 To avoid name conflict, you can use parameter 
\emph on
suffix
\emph default
 to add a suffix to all variables outputted by a stat operator.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statSuffix"

\end_inset

 uses 4 
\family typewriter
stat
\family default
 operators to calculate overall and pairwise 
\begin_inset Formula $F_{ST}$
\end_inset

 values for three subpopulations.
 Different suffixes are used for pairwise 
\begin_inset Formula $F_{ST}$
\end_inset

 estimators so that variables set by these operators will not override each
 other.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statSuffix.log"
lstparams "caption={Add suffixes to variables set by multiple stat operators},label={statSuffix}"

\end_inset


\end_layout

\begin_layout Note
The 
\family typewriter
stat
\family default
 opeartor accepts overlapping or even duplicate virtual subpopulations.
 During the calculation of summary statistics, these subpopulations are
 treated as separate subpopulations so some individuals can be counted more
 than once.
 For example, individuals in virtual subpopulation (0, 1) will be counted
 twice during the calculation of allele frequency and population size in
 operator 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0], popSize=True, subPops=[0, (0, 1)])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Counting individuals by sex and affection status
\end_layout

\begin_layout Standard
Parameters 
\emph on
popSize
\emph default
, 
\emph on
numOfMale
\emph default
 and 
\emph on
numOfAffected
\emph default
 provide basic individual counting statistics.
 They count the number of all, male/female, affected/unaffected individuals
 in all or specified (virtual) subpopulations, and set variables such as
 
\family typewriter
popSize
\family default
, 
\family typewriter
numOfMale
\family default
, 
\family typewriter
numOfFemale
\family default
, 
\family typewriter
numOfAffected
\family default
, 
\family typewriter
numOfUnaffected
\family default
.
 Proportions and statistics for  subpopulations are available if variables
 such as 
\family typewriter
propOfMale
\family default
, 
\family typewriter
numOfAffected_sp
\family default
 are specified in parameter vars.
 Another variable 
\family typewriter
subPopSize
\family default
 is defined for parameter 
\family typewriter
popSize=True
\family default
.
 It is a list of sizes of all or specified subpopulations and is easier
 to use than referring to variable 
\family typewriter
popSize
\family default
 from individual subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statCount"

\end_inset

 demonstrates how to use these parameters in operator 
\family typewriter
stat
\family default
.
 It defines four VSPs by sex and affection status (using a 
\family typewriter
stackedSplitter
\family default
) and count individuals by sex and affection status.
 It is worth noting that 
\family typewriter
pop.dvars().popSize
\family default
 in the first example is the total number of individuals in two virtual
 subpopulations 
\family typewriter
(0,0)
\family default
 and 
\family typewriter
(0,2)
\family default
, which are all male indiviudals, and all unaffected individuals.
 Because these two VSPs overlap, this variable can be larger than actual
 population size.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statCount.log"
lstparams "caption={Count individuals by sex and/or affection status},label={statCount}"

\end_inset


\end_layout

\begin_layout Subsection
Allele count and frequency
\end_layout

\begin_layout Standard
Parameter 
\emph on
alleleFreq
\emph default
 accepts a list of markers at which allele frequencies in all or specified
 (virtual) subpopulations will be calculated.
 This statistic sets variables 
\family typewriter
alleleFreq[loc][allele]
\family default
 and 
\family typewriter
alleleNum[loc][allele]
\family default
 which are frequencies and numbers of allele 
\family typewriter
allele
\family default
 at locus 
\family typewriter
loc
\family default
, respectively.
 If variables 
\family typewriter
alleleFreq_sp
\family default
 and 
\family typewriter
alleleNum_sp
\family default
 are specified in parameter 
\emph on
vars
\emph default
, these variables will be set for all or specified (virtual) subpopulations.
 
\series bold
At the Python level, these variables of dictionaries of default dictionaries.

\series default
 That is to say, 
\family typewriter
alleleFreq[loc]
\family default
 at a unspecified locus will raise a 
\family typewriter
KeyError
\family default
 exception, and 
\family typewriter
alleleFreq[loc][allele]
\family default
 of an invalid allele will return 0.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statAlleleFreq"

\end_inset

 demonstrates an advanced usage of allele counting statistic.
 In this example, two virtual subpopulations are defined by individual affection
 status.
 During evolution, a multi-allele penetrance operator is used to determine
 individual affection status and a 
\family typewriter
stat
\family default
 operator is used to calculate allele frequencies in these two virtual subpopula
tions, and in the whole population.
 Because the simulated disease is largely caused by the existence of allele
 1 at the first locus, it is expected that the frequency of allele 1 is
 higher in the case group than in the control group.
 It is worth noting that 
\family typewriter
alleleFreq[0][1]
\family default
 in this example is the frequency of allele 1 in the whole population because
 these two virtual subpopulations add up to the whole population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statAlleleFreq.log"
lstparams "caption={Calculate allele frequency in affected and unaffected individuals},label={statAlleleFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Genotype count and frequency
\end_layout

\begin_layout Standard
Parameter 
\emph on
genoFreq
\emph default
 accepts a list of loci at which genotype counts and frequencies are calculated
 and outputted.
 A genotype is represented as a tuple of alleles at a locus.
 The length of the tupples
\series bold
 
\series default
is determined by the number of homologous copy of chromosomes in a population.
 For example, genotypes in a diploid population are ordered pairs such as
 
\family typewriter
(1, 2)
\family default
 where 1 and 2 are alleles at a locus on, respectively, the first and second
 homologous copies of chromosomes.
 
\family typewriter
(1, 2)
\family default
 and 
\family typewriter
(2, 1)
\family default
 are different genotypes.
 This statistic sets dictionaries (with locus indexes as keys) of default
 dictionaries (with genotypes as keys) 
\family typewriter
genoFreq
\family default
 and 
\family typewriter
genoNum
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statGenoFreq"

\end_inset

 creates a small population and initializes a locus with rare alleles 0,
 1 and a common allele 2.
 A function 
\family typewriter
Stat
\family default
 (the function form of operator 
\family typewriter
stat
\family default
) is used to count the available genotypes.
 Note that 
\family typewriter
pop.dvars().genoFreq[0][(i,j)]
\family default
 can be used to print frequencies of all genotypes even when not all genotypes
 are available in the population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statGenoFreq.log"
lstparams "caption={Counting genotypes in a population},label={statGenoFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Homozygote and heterozygote count and frequency
\end_layout

\begin_layout Standard
In a diploid population, a heterozygote is a genotype with two different
 alleles and a homozygote is a genotype with two identical alleles.
 Parameter 
\family typewriter
heteroFreq
\family default
 accepts a list of loci and outputs variables 
\family typewriter
heteroFreq
\family default
 which is a dictionary of heterozygote frequencies at specfied loci.
 Optional variables 
\family typewriter
heteroNum
\family default
, 
\family typewriter
homoFreq
\family default
 and 
\family typewriter
homoNum
\family default
 can be outputted for all and each (virtual) subpopulations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHeteroFreq"

\end_inset

 demonstrates the decay of heterozygosity of a locus due to genetic drift.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHeteroFreq.log"
lstparams "caption={Counting homozygotes and heterozygotes in a population},label={statHeteroFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Haplotype count and frequency
\end_layout

\begin_layout Standard
Haplotypes refer to alleles on the same homologous copy of a chromosome
 at specified loci.
 For example, an diploid individual can have haplotypes 
\family typewriter
(0, 2, 1)
\family default
 and 
\family typewriter
(0, 1, 1)
\family default
 at loci 
\family typewriter
(2, 3, 5)
\family default
 if he or she has genotype 
\family typewriter
(0, 0)
\family default
, 
\family typewriter
(2, 1)
\family default
 and 
\family typewriter
(1,1)
\family default
 at loci 2, 3 and 5 respectively.
 Parameter 
\emph on
haploFreq
\emph default
 accept one or more lists of loci specifying one or more haplotype sites
 (e.g.
 
\family typewriter
haploFreq=[(0,1,2), (2,3)]
\family default
 specifies two haplotype sites).
 The results are saved to dictionaries (with haplotype site as keys) of
 default dictionaries (with haplotype as keys).
 For example, 
\family typewriter
haploFreq[(0,1,2)][(0,1,1)]
\family default
 will be the frequency of haplotype 
\family typewriter
(0, 1, 1)
\family default
 at loci 
\family typewriter
(0, 1, 2)
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHaploFreq"

\end_inset

 prints the numbers of genotypes and haplotypes at loci 0, 1 and 2 of a
 small population.
 Note that the 
\family typewriter
ViewVars
\family default
 function defined in module 
\family typewriter
simuUtil
\family default
 can make use of a wxPython window to view all variables if it is called
 in GUI mode.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHaploFreq.log"
lstparams "caption={Counting haplotypes in a population},label={statHaploFreq}"

\end_inset


\end_layout

\begin_layout Note

\emph on
haploFreq
\emph default
 does not check if loci in a haplotype site belong to the same chromosome,
 or if loci are duplicated or in order.
 It faithfully assemble alleles at specified loci as haplotypes although
 these haplotypes might not be biologically meaningful.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Note
Counting a large number of haplotypes on long haplotype sites may exhaust
 the RAM of your computer.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Summary statistics of information fields
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
sumOfInfo
\family default
, 
\family typewriter
meanOfInfo
\family default
, 
\family typewriter
varOfInfo
\family default
, 
\family typewriter
maxOfInfo
\family default
 and 
\family typewriter
minOfInfo
\family default
 are used to calculate the sum, mean, sample variance (
\begin_inset Formula $\frac{1}{n-1}\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$
\end_inset

), max and min of specified information fields of individuals in all or
 specified (virtual) subpopulations.
 The results are saved in dictionaries 
\family typewriter
sumOfInfo
\family default
, 
\family typewriter
meanOfInfo
\family default
, 
\family typewriter
varOfInfo
\family default
, 
\family typewriter
maxOfInfo
\family default
 and 
\family typewriter
minOfInfo
\family default
 with information fields as keys.
 For example, parameter  
\family typewriter
meanOfInfo='age'
\family default
 calculates the mean age of all individuals and set variable 
\family typewriter
meanOfInfo['age']
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statInfo"

\end_inset

 demonstrates a mixing process of two populations.
 The population starts with two types of individuals with ancestry values
 0 or 1 (information field 
\family typewriter
anc
\family default
).
 During the evolution, parents mate randomly and the ancestry of offspring
 is the mean of parental ancestry values.
 A 
\family typewriter
stat
\family default
 operator is used to calculate the mean and variance of individual ancestry
 values, and the number of individuals in five ancestry groups.
 It is not surprising that whereas population mean ancestry does not change,
 more and more people have about the same number of ancestors from each
 group and have an ancestry value around 0.5.
 The variance of ancestry values therefore decreases gradually.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statInfo.log"
lstparams "caption={Calculate summary statistics of information fields},label={statInfo}"

\end_inset


\end_layout

\begin_layout Subsection
Linkage disequilibrium
\end_layout

\begin_layout Standard
Parameter 
\emph on
LD
\emph default
 accepts a list of loci-pairs (e.g.
 
\family typewriter
LD=[(0,1),(2,3)]
\family default
) with optional primary alleles at two loci (e.g.
 
\family typewriter
LD=[(0,1,0,0),(2,3)]
\family default
).
 For each pair of loci, this operator calculates linkage disequilibrium
 and optional association measures between them.
 
\end_layout

\begin_layout Standard
Assuming that two loci are both diallelic, one with alleles 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

, and the other with alleles 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

.
 If we denote 
\begin_inset Formula $P_{x}$
\end_inset

, 
\begin_inset Formula $P_{xy}$
\end_inset

 as allele and haplotype frequencies for allele 
\begin_inset Formula $x$
\end_inset

 and haplotype 
\begin_inset Formula $xy$
\end_inset

, respectively, the linkage disequilibrium measures 
\series bold
with respect to primaries alleles
\series default
 
\emph on
A
\emph default
 and 
\emph on
B
\emph default
 are
\end_layout

\begin_layout Itemize
Basic LD measure 
\begin_inset Formula $D$
\end_inset

: 
\begin_inset Formula \[
D=P_{AB}-P_{A}P_{B}\]

\end_inset


\emph on
D
\emph default
 ranges from -0.25 to 0.25.
 The sign depends on the choice of alleles (
\emph on
A
\emph default
 and 
\emph on
B
\emph default
) at two loci.
\end_layout

\begin_layout Itemize
Lewontin's 
\begin_inset Formula $D'=D/D_{max}$
\end_inset

 where 
\begin_inset Formula \[
D_{max}=\begin{cases}
\min\left(P_{A}\left(1-P_{B}\right),\left(1-P_{A}\right)P_{B}\right) & \textrm{if }D>0\\
\min\left(P_{A}P_{B},\left(1-P_{A}\right)\left(1-P_{B}\right)\right) & \textrm{if }D<0\end{cases}\]

\end_inset


\emph on

\begin_inset Formula $D'$
\end_inset


\emph default
 ranges from -1 to 1.
 The sign depends on the choice of alleles (
\emph on
A
\emph default
 and 
\emph on
B
\emph default
) at two loci.
\end_layout

\begin_layout Itemize
\begin_inset Formula $r^{2}$
\end_inset

 (
\begin_inset Formula $\Delta^{2}$
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand citet
key "Devlin1995"

\end_inset

) 
\begin_inset Formula \[
r^{2}=\frac{D^{2}}{P_{A}\left(1-P_{A}\right)P_{B}\left(1-P_{B}\right)}\]

\end_inset


\end_layout

\begin_layout Standard
If one or both loci have more than 2 alleles, or if no primary allele is
 specified, the LD measures are calculated as follows:
\end_layout

\begin_layout Itemize
If primary alleles are specified, all other alleles are considered as minor
 alleles with combined frequency (e.g.
 
\begin_inset Formula $1-P_{A}$
\end_inset

).
 The same formulas apply which lead to signed 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize
If primary alleles are not specified, these LD measures are calculated as
 the average of the absolute value of diallelic measures of all allele pairs.
 For example, the multi-allele version of 
\begin_inset Formula $r^{2}$
\end_inset

 is
\begin_inset Formula \[
r^{2}=\sum_{i}\sum_{j}P_{i}P_{j}\left|r_{ij}^{2}\right|=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{\left(1-P_{i}\right)\left(1-P_{j}\right)}\]

\end_inset

where 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 iterate through all alleles at the two loci.
 
\series bold
In the diallelic case, LD measures will be the absolute value of the single
 measures
\series default
 because 
\begin_inset Formula $D_{ij}$
\end_inset

 and 
\begin_inset Formula $D'_{ij}$
\end_inset

 only differ by signs.
\end_layout

\begin_layout Standard
In another word,
\end_layout

\begin_layout Itemize

\family typewriter
LD=[loc1, loc2]
\family default
 will yield positive 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize

\family typewriter
LD=[loc1, loc2, allele1, allele2]
\family default
 will yield signed 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize
In the diallelic case, both cases yield identical results except for signs
 of 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

.
\end_layout

\begin_layout Itemize
In the multi-allelic case, the results can be different because 
\family typewriter
LD=[loc1, loc2, allele1, allele2]
\family default
 combines non-primary alleles and gives a single diallelic measure.
\end_layout

\begin_layout Note
A large number of linkage disequilibrium measures have been used in different
 disciplines but not all of them are well-accepted.
 Requests of adding a particular LD measure will be considered when a reliable
 reference is provided.
\end_layout

\begin_layout Standard
Association tests between specified loci could also be calculated using
 a 
\begin_inset Formula $m$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 table of haplotype frequencies.
 If primary alleles are specified, non-primary alleles are combined to form
 a 2 by 2 table (
\begin_inset Formula $m=n=2$
\end_inset

).
 Otherwise, 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are respective numbers of alleles at two loci.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\chi^{2}$
\end_inset

 and its 
\begin_inset Formula $p$
\end_inset

-value (variable 
\family typewriter
LD_ChiSq
\family default
 and 
\family typewriter
LD_ChiSq_p
\family default
, respectively).
 A one-side 
\begin_inset Formula $\chi^{2}$
\end_inset

 test with 
\begin_inset Formula $\left(m-1\right)\times\left(n-1\right)$
\end_inset

 degrees of freedom will be used.
\end_layout

\begin_layout Itemize
Cramer V statistic (variable 
\family typewriter
CramerV
\family default
): 
\begin_inset Formula \[
V=\sqrt{\frac{\chi^{2}}{N\times\mbox{min}\left(m-1,n-1\right)}}\]

\end_inset

where 
\begin_inset Formula $N$
\end_inset

 equals the total number of haplotypes (
\begin_inset Formula $2\times\mbox{popSize}$
\end_inset

 for autosomes in diploid populations).
\end_layout

\begin_layout Standard
This statistic sets variables 
\family typewriter
LD
\family default
, 
\family typewriter
LD_prime
\family default
, 
\family typewriter
R2
\family default
, and optionally 
\family typewriter
ChiSq
\family default
, 
\family typewriter
ChiSq_p
\family default
 and 
\family typewriter
CramerV
\family default
.
 Subpopulation specific variables can be calculated by specifying variables
 such as 
\family typewriter
LD_sp
\family default
 and 
\family typewriter
R2_sp
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statLD"

\end_inset

 demonstrates how to calculate various LD measures and output selected variables.
 Note that the significant overall LD between two loci is an artifact of
 population structure because loci are in linkage equilibrium in each subpopulat
ion.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statLD.log"
lstparams "caption={Linkage disequilibrium measures},label={statLD}"

\end_inset


\end_layout

\begin_layout Subsection
Genetic association
\end_layout

\begin_layout Standard
Genetic association refers to association between individual genotype (alleles
 or genotype) and phenotype (affection status).
 There are a large number of statistics tests based on different study designs
 (e.g.
 case-control, pedigree, longitudinal) with different covariate variables.
 Although specialized software applications should be used for sophisticated
 statistical analysis, simuPOP provides a number of simple genetic association
 tests for convenience.
 These tests
\end_layout

\begin_layout Itemize
Are single-locus tests that test specified loci separately.
\end_layout

\begin_layout Itemize
Are based on individual affection status.
 Associations between genotype and quantitative traits are currently unsupported.
\end_layout

\begin_layout Itemize
Apply to all individuals in specified (virtual) subpopulations.
 Because a population usually has much more unaffected individuals than
 affected ones, it is a common practice to draw certain types of samples
 (e.g.
 a case-control sample with the same number of cases and controls) before
 statistical tests are applied.
\end_layout

\begin_layout Standard
simuPOP currently supports the following tests:
\end_layout

\begin_layout Itemize

\series bold
Allele-based Chi-square test
\series default
: This is the basic allele-based 
\begin_inset Formula $\chi^{2}$
\end_inset

 test that can be applied to diploid as well as haploid populations.
 Basically, a 2 by 
\begin_inset Formula $n$
\end_inset

 contigency table is set up for each locus with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of alleles 
\begin_inset Formula $j$
\end_inset

 in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A 
\begin_inset Formula $\chi^{2}$
\end_inset

 test is applied to each locus and set variables 
\family typewriter
Allele_ChiSq
\family default
 and 
\family typewriter
Allele_ChiSq_p
\family default
 to the 
\begin_inset Formula $\chi^{2}$
\end_inset

 statistic and its two-sided 
\begin_inset Formula $p$
\end_inset

 value (with degrees freedom 
\begin_inset Formula $n-1$
\end_inset

).
 Note that genotype information is not preserved in such a test.
\end_layout

\begin_layout Itemize

\series bold
Genotype-based Chi-square test
\series default
: This is the genotype-based 
\begin_inset Formula $\chi^{2}$
\end_inset

 test for diploid populations.
 Basically, a 2 by 
\begin_inset Formula $n$
\end_inset

 contigency table is set up for each locus with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of genotype 
\begin_inset Formula $j$
\end_inset

 (unordered pairs of alleles) in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A 
\begin_inset Formula $\chi^{2}$
\end_inset

 test is applied to each locus and set variables 
\family typewriter
Geno_ChiSq
\family default
 and 
\family typewriter
Geno_ChiSq_p
\family default
 to the 
\begin_inset Formula $\chi^{2}$
\end_inset

 statistic and its two-sided 
\begin_inset Formula $p$
\end_inset

 value (with degrees freedom 
\begin_inset Formula $n-1$
\end_inset

).
 This test is usually applied to diallelic loci with 3 genotypes (
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
) but it can be applied to loci with more than two alleles as well.
\end_layout

\begin_layout Itemize

\series bold
Genotype-based trend test
\series default
: This Cochran-Armitage test can only be applied to diallelic loci in diploid
 populations.
 For each locus, a 2 by 3 contigency table is set up with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of genotype 
\begin_inset Formula $j$
\end_inset

 (
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
 with 
\emph on
A
\emph default
 being the wildtype allele) in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A Cochran-Armitage trend test is applied to each locus and set variables
 
\family typewriter
Armitage_p
\family default
 to its two-sided 
\begin_inset Formula $p$
\end_inset

 value.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statAssociation"

\end_inset

 demonstrates how to apply a penetrance model, draw a case-control sample
 and apply genetic association tests to an evolving population.
 In this example, a penetrance model is applied to a locus (locus 3).
 A Python operator is then used to draw a case-control sample from the populatio
n and test genetic association at two surrounding loci.
 Because these two loci are tightly linked to the disease predisposing locus,
 they are in strong association with the disease initially.
 However, because of recombination, such association decays with time at
 rates depending on their genetic distances to the disease predisposing
 locus.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statAssociation.log"
lstparams "caption={Genetic association tests},label={statAssociation}"

\end_inset


\end_layout

\begin_layout Subsection
Population structure
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
structure
\family default
 measures the structure of a population using the following statistics:
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $G_{ST}$
\end_inset

 statistic developed by Nei 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Nei1973"

\end_inset

.
 This statistic is equivalent to Wright's fixation index 
\begin_inset Formula $F_{ST}$
\end_inset

 in the diallelic case so it can be considered as the multi-allele and multi-loc
us extension of Wright's 
\begin_inset Formula $F_{ST}$
\end_inset

.
 It assumes known genotype frequency so it can be used to calculate true
 
\begin_inset Formula $F_{ST}$
\end_inset

 of a population when all genotype information is available.
 This statistic sets a dictionary of locus level 
\begin_inset Formula $G_{ST}$
\end_inset

 (variable 
\family typewriter
g_st
\family default
) and a summary statistics for all loci (variable 
\family typewriter
G_st
\family default
).
\end_layout

\begin_layout Itemize
Wright's fixation index 
\begin_inset Formula $F_{ST}$
\end_inset

 calculated using an algorithm developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Weir1984"

\end_inset

.
 This statistic considers existing populations as random samples from an
 infinite pool of populations with the same ancestral population so it is
 best to be applied to random samples where true genotype frequencies are
 unknown.
 This statistic sets dictionaries of locus level 
\begin_inset Formula $F_{ST}$
\end_inset

, 
\begin_inset Formula $F_{IT}$
\end_inset

 and 
\begin_inset Formula $F_{IS}$
\end_inset

 (variables 
\family typewriter
f_st
\family default
, 
\family typewriter
f_is
\family default
 and 
\family typewriter
f_it
\family default
), and summary statistics for all loci (variables 
\family typewriter
F_st
\family default
, 
\family typewriter
F_is
\family default
 and 
\family typewriter
F_it
\family default
) .
\end_layout

\begin_layout Standard
These statistics by default uses all existing subpopulations, but it can
 also be applied to a subset of subpopulations, or even virtual subpopulations
 using parameter 
\emph on
subPops
\emph default
.
 That is to say, you can measure the genetic difference between males and
 females using 
\family typewriter
subPops=[(0,0), (0,1)]
\family default
 if a sexSplitter is used to define two virtual subpopulations with male
 and female individuals respectively.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statStructure"

\end_inset

 demonstrate a simulation with two replicates.
 In the first replicate, three subpopulations evolve separately without
 migration and become more and more genetically distinct.
 In the second replicate, a low level migration is applied between subpopulation
s so the population structure is kept at a low level.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statStructure.log"
lstparams "caption={Measure of population structure},label={statStructure}"

\end_inset


\end_layout

\begin_layout Subsection
Hardy-Weinberg equilibrium test
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
HWE
\family default
 accepts a list of loci at which exact Hardy Weinberg equilibrium tests
 are applied.
 The 
\emph on
p
\emph default
-values of the tests are assigned to a dictionary 
\family typewriter
HWE
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHWE"

\end_inset

 demonstrates how Hardy Weinberg equilibrium is reached in one generation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHWE.log"
lstparams "caption={Hardy Weinberg Equilibrium test},label={statHWE}"

\end_inset


\end_layout

\begin_layout Subsection
Other statistics
\end_layout

\begin_layout Standard
If you need other statistics, a popular approach is to define them using
 Python operators.
 If your statistics is based on existing statistics such as allele frequency,
 it is a good idea to calculate existing statistics using a 
\family typewriter
Stat
\family default
 function and derive your statistics from population variables.
 Please refer to the last chapter of this guide on an example.
\end_layout

\begin_layout Standard
If performance becomes a problem, you might want to have a look at the source
 code of simuPOP and implement your statistics at the C++ level.
 If you believe that your statistics are popular enough, please send your
 implementation to the simuPOP mailinglist for possible inclusion of your
 statistics into simuPOP.
\end_layout

\begin_layout Section
Tagging operators
\end_layout

\begin_layout Standard
In simuPOP, tagging refers to the action of setting various information
 fields of offspring, usually using various parental information during
 the production of offspring.
 simuPOP provides a number of tagging operators (called taggers) for various
 purposes.
 Because tagging operators are during-mating operators, they do not support
 parameter 
\family typewriter
subPops
\family default
.
 If you would like to apply different  taggers to different (virtual) subpopulat
ions, you can use them in the homogeneous mating schemes of a heterogeneous
 mating scheme.
\end_layout

\begin_layout Subsection
Inheritance tagger (operator 
\family typewriter
inheritTagger
\family default
)
\end_layout

\begin_layout Standard
An inheritance tagger passes values of parental information field(s) to
 the corresponding offspring information field(s).
 Depending on the parameters, an inheritTagger can 
\end_layout

\begin_layout Itemize
For asexual mating schemes, pass one or more information fields from parent
 to offspring.
\end_layout

\begin_layout Itemize
Pass one or more information fields from father to offspring (
\family typewriter
mode=Paternal
\family default
).
\end_layout

\begin_layout Itemize
Pass one or more information fields from mother to offspring (
\family typewriter
mode=Maternal
\family default
).
\end_layout

\begin_layout Itemize
Pass the maximal, minimal, sum, multiplcation or average of values of one
 or more information fields of both parents (
\family typewriter
mode=Maximum
\family default
, 
\family typewriter
Minimum
\family default
, 
\family typewriter
Addition, Multiplication
\family default
 or 
\family typewriter
Average
\family default
).
\end_layout

\begin_layout Standard
This can be used to track the spread of certain information during evolution.
 For example, Example
\begin_inset CommandInset ref
LatexCommand ref
reference "inheritTagger"

\end_inset

 tags the first individuals of ten subpopulations of size 1000.
 Individuals in the offspring generation inherits the maximum value of field
 
\family typewriter
x
\family default
 from his/her parents so 
\family typewriter
x
\family default
 is inherited regardless of the sex of parents.
 A stat operator is used to calculate the number of offspring having this
 tag in each subpopulation.
 The results show that some tagged ancestors have many offspring, and some
 have none.
 If you run this simulation long enough, you can see that all ancestors
 become the ancestor of either none or all indiviudals in a population.
 Note that this simulation only considers genealogical inheritance and ancestors
 do not have to pass any genotype to the last generation.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/inheritTagger.log"
lstparams "caption={Use an inherit tagger to track offspring of individuals},label={inheritTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Summarize parental informatin fields (operator 
\family typewriter
summaryTagger)
\end_layout

\begin_layout Standard
A 
\family typewriter
summaryTagger
\family default
 summarize values of one or more parental information fields and place the
 result in an offspring information field.
 If mating is sexual, two sets of values will be involved.
 Summarization methods include 
\family typewriter
Mean
\family default
, 
\family typewriter
Minimum
\family default
, 
\family typewriter
Miximum
\family default
,
\family typewriter
 Summation
\family default
 and 
\family typewriter
Multiplication
\family default
.
 The operator is usually used to summarize certain characteristic of parents
 of each offspring.
 For example, a 
\family typewriter
summaryTagger
\family default
 is used in  Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "summaryTagger"

\end_inset

 to calculate the mean fitness of parents during each  mating event.
 The results are saved in the 
\family typewriter
avgFitness
\family default
 field of offspring.
 Because allele 1 at locus 0 is under purifying selection, the allele frequency
 of this allele decreases.
 In the mean time, fitness of parents increases because less and less parents
 have this allele.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/summaryTagger.log"
lstparams "caption={Using a summary tagger to calculate mean fitness of parents.},label={summaryTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking parents (operator 
\family typewriter
parentsTagger
\family default
)
\end_layout

\begin_layout Standard
A parents tagger is used to record the indexes of parents (in the parental
 population) in the information fields (default to 
\family typewriter
father_idx
\family default
, 
\family typewriter
mother_idx
\family default
) of their offspring.
 These indexes provide a way to track down an individuals parents, offspring
 and consequently all relatives in a multi-generation population.
 Because this operator has been extensively used in this guide, please refer
 to other sections for an Example (e.g.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicInfoFields"

\end_inset

).
\end_layout

\begin_layout Standard
As long as parental generations do not change after the offspring generation
 is created, recorded parental indexes can be used to locate parents of
 an individual.
 However, in certain applications when parental generations change (e.g.
 to draw a pedigree from a large population), or when individuals can not
 be looked up easily using indexes (e.g.
 after individuals are saved to a file), giving every individual an unique
 ID and refer to them using ID will be a better choice.
\end_layout

\begin_layout Subsection
Assign unique IDs to individuals (operator 
\family typewriter
idTagger
\family default
)
\end_layout

\begin_layout Standard
Although it is possible to use generation number and individual indexes
 to locate individuals in an evolving population, an unique I D makes it
 much easier to identify individuals when migration is involved, and to
 analyze an evolutionary process outside of simuPOP.
 An operator 
\family typewriter
idTagger
\family default
 (and its function form 
\family typewriter
TagID
\family default
) is provided by simuPOP to assign an unique ID to all individuals during
 evolution.
\end_layout

\begin_layout Standard
The IDs of individuals are usually stored in an information field named
 
\family typewriter
ind_id
\family default
.
 To ensure uniqueness across populations, a single source of ID is used
 for this operator.
 Individual IDs are assigned consecutively starting from 0.
 If you would like to reset the sequence or start from a different number,
 you can call the 
\family typewriter
reset(startID)
\family default
 function of any 
\family typewriter
idTagger
\family default
.
\end_layout

\begin_layout Standard
An 
\family typewriter
idTagger
\family default
 is usually used during-mating to assign ID to each offspring.
 However, if it is applied directly to a population, it will assign unique
 IDs to all individuals in this population.
 This property is usually used in the 
\family typewriter
preOps
\family default
 parameter of function 
\family typewriter
simulator.evolve
\family default
 to assign initial ID to a population.
 For example, three 
\family typewriter
idTagger
\family default
 operators are used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "idTagger"

\end_inset

 to assign IDs to individuals before, during and after evolution.
 Although different operators are used, different IDs are assigned to individual
s.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/idTagger.log"
lstparams "caption={Assign unique IDs to individuals},label={idTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking pedigrees (operator 
\family typewriter
pedigreeTagger
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
pedigreeTagger
\family default
 is similar to a 
\family typewriter
parentsTagger
\family default
 in that it records parental information in offspring's information fields.
 However, instead of indexes of parents, this operator records an unique
 ID of each parent to make it easier to study and reconstruct a complete
 pedigree of a whole evolutionary process.
 The default information fields are 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
.
\end_layout

\begin_layout Standard
By default, the 
\family typewriter
pedigreeTagger
\family default
 does not produce any output.
 However, if a valid output string (or function) is specified, it will output
 the ID of offspring and all available parents.
 Such information is enough to reconstruct the complete pedigree of an evolution
ary process.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pedigreeTagger"

\end_inset

 demonstrates how to output the complete pedigree of an evolutionary process.
 Note that 
\family typewriter
idTagger
\family default
 has to be applied before 
\family typewriter
pedigreeTagger
\family default
 so that IDs of offspring could be assigned before they are outputted.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pedigreeTagger.log"
lstparams "caption={Output a complete pedigree of an evolutionary process},label={pedigreeTagger}"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
A hybrid tagger (operator 
\family typewriter
pyTagger
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
pyTagger
\family default
 uses a user-defined function to pass parental information fields to offspring.
 When a mating event happens, this operator collect values of specified
 information fields of parents, pass them to a user-provided function, and
 use the return values to set corresponding offspring information fields.
 A typical usage of this operator is to set random environmental factors
 that are affected by parental values.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyTagger"

\end_inset

 demonstrates such an example where the location of each offspring (x, y)
 is randomly assigned around the middle position of his or her parents.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyTagger.log"
lstparams "caption={Use of a hybrid tagger to pass parental information to offspring},label={pyTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tagging that involves other parental information
\end_layout

\begin_layout Standard
If the way how parental information fields pass to their offspring is affected
 by parental genotype, sex, or affection status, you could use a Python
 operator (
\family typewriter
pyOperator
\family default
) during mating to explicitly obtain parental information and set offspring
 information fields.
\end_layout

\begin_layout Standard
Alternatively, you can add another information field, translate needed informati
on to this field and pass the genotype information in the form of information
 field.
 Operator 
\family typewriter
infoExec
\family default
 could be helpful in this case.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "otherTagging"

\end_inset

 demonstrates such an example where the number of affected parents are recorded
 in an information field.
 Before mating happens, a penetrance operator is used to assign affection
 status to parents.
 The affection status is then copied to an information field affected so
 that operator 
\family typewriter
summaryTagger
\family default
 could be used to count the number of affected parents.
 Two 
\family typewriter
maPenetrance
\family default
 operators are used both before and after mating to assign affection status
 to both parental and offspring generations.
 This helps dividing the offspring generation into affected and unaffected
 virtual subpopulations.
 Not surprisingly, the average number of affected parents is larger for
 affected individuals than unaffected individuals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/otherTagging.log"
lstparams "caption={Tagging that involves other parental information},label={otherTagging}"

\end_inset


\end_layout

\begin_layout Section
Miscellaneous operators
\end_layout

\begin_layout Subsection
An operator that does nothing (operator 
\family typewriter
noneOp
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
noneOp
\family default
 does nothing when it is applied to a population.
 It provides a placeholder when an operator is needed but no action is required.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "noneOp"

\end_inset

 demonstrates a typical usage of this operator
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "noneOp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if hasSelection:
\end_layout

\begin_layout Plain Layout

    sel = mapSelector(loci=[0], fitness=[1, 0.99, 0.98])
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    sel = noneOp()
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    ops = [sel], # and other operators
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dump the content of a population (operator 
\family typewriter
dumper
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
dumper
\family default
 and its function form 
\family typewriter
Dump
\family default
 has been used extensively in this guide.
 They are prefect for demonstration and debugging purposes because they
 display all properties of a population in a human readable format.
 They are, however, rarely used in realistic settings because outputting
 a large population to your terminal can be disastrous.
\end_layout

\begin_layout Standard
Even with modestly-sized populations, it is a good idea to dump only parts
 of the population that you are interested.
 For example, you can use parameter 
\family typewriter
genotype=False
\family default
 to stop outputting individual genotype, 
\family typewriter
structure=False
\family default
 to stop outtputing genotypic and population structure information, 
\family typewriter
loci=range(5)
\family default
 to output genotype only at the first five loci, 
\family typewriter
max=N
\family default
 to output only the first 
\family typewriter
N
\family default
 individuals (default to 
\family typewriter
100
\family default
), 
\family typewriter
subPops=[(0, 0)]
\family default
 to output, for example, only the first virtual subpopulation in subpopulation
 0.
 This operator by default only dump the present generation but you can set
 
\family typewriter
ancGen
\family default
 to a positive number or 
\family typewriter
-1
\family default
 to dump part or all ancestral generations.
 Finally, if there are more than 10 alleles, you can set the 
\family typewriter
width
\family default
 at which each allele will be printed.
 The following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "dumper"

\end_inset

) presents a rather complicated usage of this operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/dumper.log"
lstparams "caption={Dump the content of a population},label={dumper}"

\end_inset


\end_layout

\begin_layout Subsection
Save a population during evolution (operator 
\family typewriter
savePopulation
\family default
)
\end_layout

\begin_layout Standard
Because it is usually not feasible to store all parental generations of
 an evolving population, it is a common practise to save snapshots of a
 population during an evolutionary process for further analysis.
 Operator 
\family typewriter
savePopulation
\family default
 is designed for this purpose.
 When it is applied to a population, it will save the population to a file
 specified by parameter 
\family typewriter
output
\family default
.
\end_layout

\begin_layout Standard
The tricky part is that populations at different generations need to be
 saved to different filenames so the expression version of parameter 
\family typewriter
output
\family default
 needs to be used (see operator 
\family typewriter
baseOperator
\family default
 for details).
 For example, expression 
\family typewriter
'snapshot_%d_%d.pop' % (rep, gen)
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "savePopulation"

\end_inset

 to save population to files such as 
\family typewriter
snapshot_5_20.pop
\family default
 during the evolution.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePopulation.log"
lstparams "caption={Save snapshots of an evolving population},label={savePopulation}"

\end_inset


\end_layout

\begin_layout Subsection
Change ancestral depth of populations (operator 
\family typewriter
setAncestralDepth
\family default
)
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "twoStage"

\end_inset

 describes a two-stage evolutionary process where a random mating scheme
 is used in the first stage and another mating scheme is used in the second
 stage to prepare for pedigree ascertainment.
 The ancestral depth of each population is changed to 1 before the second
 
\family typewriter
simulator.evolve
\family default
 call.
 This step can also be done using a 
\family typewriter
setAncestralDepth
\family default
 operator, which simply set the ancestral depth of each population to a
 given depth (please refer to class 
\family typewriter
population
\family default
 for a detailed explanation for 
\emph on
ancetral depth
\emph default
).
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "setAncDepth"

\end_inset

 demonstrates a tpical usage of this operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/setAncDepth.log"
lstparams "caption={Change ancestral depth during the evolution},label={setAncDepth}"

\end_inset


\end_layout

\begin_layout Subsection
Conditional operator (operator 
\family typewriter
ifElse
\family default
) *
\end_layout

\begin_layout Standard
Operator 
\family typewriter
ifElse
\family default
 provides a simple way to conditionally apply an operator.
 For example, you can re-introduce a mutant if it gets lost in the population,
 output a warning when certain condition is met, or record the occurance
 of certain events in a population.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ticToc"

\end_inset

 records the number of generations the frequency of an allele goes below
 0.4 and beyong 0.6 before it gets lost or fixed in the population.
 Note that an else-operator can also be executed when the condition is not
 met.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ifElse.log"
lstparams "caption={A conditional opeartor},label={ifElse}"

\end_inset


\end_layout

\begin_layout Standard
If more complicated logic is involved, a Python operator (
\family typewriter
pyOperator
\family default
) should be used.
\end_layout

\begin_layout Subsection
Conditionally terminate an evolutionary process (operator 
\family typewriter
terminateIf
\family default
)
\end_layout

\begin_layout Standard
Operator terminateIf has been described and used in several examples such
 as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simuGen"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "expression"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "ifElse"

\end_inset

.
 This operator accept an Python expression and terminate the evolution of
 the population being applied if the expression is evaluated to be 
\family typewriter
True
\family default
.
 This operator is well suited for situations where the number of generations
 to evolve cannot be determined in advance.
\end_layout

\begin_layout Standard
If a 
\family typewriter
terminateIf
\family default
 operator is applied to the offspring generation (post-mating, default),
 the evolutionary cycle is considered to be completed.
 If the evolution is terminated before mating, the evolutionary cycle is
 condered to be imcomplete.
 Such a difference can be important if the number of generations that have
 been involved is important for your analysis.
\end_layout

\begin_layout Standard
A less-known feature of operator 
\family typewriter
terminateIf
\family default
 is its ability to terminate the evolution of all replicates, using parameter
 
\family typewriter
stopAll=True
\family default
.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "terminateIf"

\end_inset

 terminates the evolution of all populations when one of the populations
 gets fixed.
 The return value of 
\family typewriter
simu.evolve
\family default
 shows that some populations have evolved one generation less than the populatio
n being fixed.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/terminateIf.log"
lstparams "caption={Terminate the evolution of all populations in a simulator},label={terminateIf}"

\end_inset


\end_layout

\begin_layout Subsection
Turn on and off debugging mode (operator 
\family typewriter
turnOnDebug
\family default
 and 
\family typewriter
turnOffDebug
\family default
) *
\end_layout

\begin_layout Standard
Debug information can be useful when something looks suspicious.
 By turnning on certain debug code, simuPOP will print out some internal
 information before and during evolution.
 The usually way to turn on and off debug information is to use functions
 
\family typewriter
TurnOnDebug(code)
\family default
 and 
\family typewriter
TurnOffDebug(code)
\family default
, or setting environmental variable 
\family typewriter
SIMUDEBUG=code
\family default
 where 
\family typewriter
code
\family default
 is one of the debug codes listed by function 
\family typewriter
ListDebugCodes
\family default
.
 Note that debug information is only available in standard modules.
\end_layout

\begin_layout Standard
However, the amount of output can be overwhelming in some cases which makes
 it necessary to limit the debug information to certain generations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "debug"

\end_inset

 demonstrates how to turn on debug information conditionally and turn it
 off afterwards, using operators 
\family typewriter
turnOnDebug
\family default
 and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/debug.log"
lstparams "caption={Turn on and off debug information during evolution.},label={debug},lastline=17"

\end_inset


\end_layout

\begin_layout Subsection
Pause and resume an evolutionary process (operator 
\family typewriter
pause
\family default
) *
\end_layout

\begin_layout Standard
If you are presenting an evolutinary process in public, you might want to
 temporarily stop the evolution so that your audience can have a better
 look at intermediate results or figures.
 If you have an exceptionally long evolutionary process, you might want
 to examine the status of the evolution process from time to time.
 These can be done using a 
\family typewriter
pause
\family default
 operator.
\end_layout

\begin_layout Standard
The 
\family typewriter
pause
\family default
 operator can stop the evolution at specified generations, or when you press
 a key.
 In the first case, you usually specify the generations to pause (e.g.
 
\family typewriter
pause(step=1000)
\family default
) so that you can examine the status of a simulation from time to time.
 In the second case, you can apply the operator at each generation and pause
 the simulation when you press a key (e.g.
 
\family typewriter
pause(stopOnKeyStroke=True)
\family default
).
 A specific key can be specified so that you can use different keys to stop
 different populations, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pause"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pause.log"
lstparams "caption={Pause the evolution of a simulation},label={pause}"

\end_inset


\end_layout

\begin_layout Standard
When a simulation is paused, you are given the options to resume evolution,
 stop the evolution of the paused population or all populations, or enter
 an interactive Python shell to examine the status of a population, which
 will be available in the Python shell as 
\family typewriter
pop_X_Y
\family default
 where 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 are generation and replicate number of the population, respectively.
 The evolution will resume after you exit the Python shell.
\end_layout

\begin_layout Subsection
Measuring execution time of operators (operator 
\family typewriter
ticToc
\family default
) *
\end_layout

\begin_layout Standard
The 
\family typewriter
ticToc
\family default
 operator can be used to measure the time between two events during an evolution
ary process.
 It outputs the elapsed time since the last time it is called, and the overall
 time since the operator is created.
 It is very flexible in that you can measure the time spent for mating in
 an evolutionary cycle if you apply it before and after mating, and you
 can measure time spent for several evolutionary cycles using generation
 applicability parameters such as 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
.
 The latter usage is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ticToc"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ticToc.log"
lstparams "caption={Monitor the performance of operators},label={ticToc}"

\end_inset


\end_layout

\begin_layout Section
Selection
\end_layout

\begin_layout Subsection
Natural selection through the selection of parents
\end_layout

\begin_layout Standard
In the simplest scenario, natural selection is implemented in two steps:
\end_layout

\begin_layout Itemize
Before mating happens, an operator (called a 
\series bold
selector
\series default
) goes through a populations and assign each individual a fitness value.
 The fitness values are stored in an information field called 
\family typewriter
fitness
\family default
.
\end_layout

\begin_layout Itemize
When mating happens, parents are chosen with probabilities that are proportional
 to their fitness values.
 For example, assuming that a parental population consists of four individuals
 with fitness values 1, 2, 3, and 4, respectively, the probability that
 they are picked to produce offspring are 
\begin_inset Formula $1/\left(1+2+3+4\right)=0.1$
\end_inset

, 
\begin_inset Formula $0.2$
\end_inset

, 
\begin_inset Formula $0.3$
\end_inset

, and 
\begin_inset Formula $0.4$
\end_inset

 respectively.
 As you can image, if the offspring population has 10 individuals, the four
 parents will on average parent 1, 2, 3 and 4 offspring.
\end_layout

\begin_layout Standard
Because parents with lower fitness values have less chance to be produce
 offspring, their genotypes have less chance to be passed to an offspring
 generation.
 If the decreased fitness is caused by the presence of certain mutant (e.g.
 a mutant causing a serious disease), individuals with that mutant will
 have less change to survive and effecitively reduce or eleminate that mutant
 from the population.
\end_layout

\begin_layout Standard
Although the underlying mechanisms are the same, more complicated selection
 schemes could be simulated in simuPOP.
 For example
\end_layout

\begin_layout Itemize
Individuals are chosen in their own groups.
 For example, in sexual random mating, relative fitness values of fathers
 and mothers are calculated separately.
\end_layout

\begin_layout Itemize
In the diploid case, the same allele can be protective in heterozygotes
 (
\emph on
Aa
\emph default
) and detrimental in homozygotes (
\emph on
aa
\emph default
) so a mutant (
\emph on
a
\emph default
) could be maintained in a population in the form of heterozygotes.
\end_layout

\begin_layout Itemize
Individual fitness could be determined by multiple disease predisposing
 loci and their interacting with environmental factors.
\end_layout

\begin_layout Itemize
Although individual fitness is usually determined by individual genotype,
 it can be caused purely by environmental factors.
 For example, if geographical distributions of individuals are simulated,
 individuals located in the north may have lower fitness values and produce
 less offspring than individual located in the south.
\end_layout

\begin_layout Itemize
Not all mating schemes support natural selection.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 gives an example of natural selection.
 In this example, a 
\family typewriter
mapSelector
\family default
 is used to explicitly assign fitness value to genotypes at the first locus.
 The fitness values are 
\family typewriter
1
\family default
, 
\family typewriter
0.98
\family default
, 
\family typewriter
0.97
\family default
 for genotypes 
\family typewriter
00
\family default
, 
\family typewriter
01
\family default
 and 
\family typewriter
11
\family default
 respectively.
 The selector set individual fitness values to information field 
\family typewriter
fitness
\family default
 before mating happens.
 The 
\family typewriter
randomMating
\family default
 mating scheme then selects parents according to parental fitness values.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selectParents.log"
lstparams "caption={Natural selection through the selection of parents},label={selectParents}"

\end_inset


\end_layout

\begin_layout Subsection
Natural selection through the selection of offspring **
\end_layout

\begin_layout Standard
Natural selection can also be implemented as selection of offspring.
 Remember that an individual will be discarded if one of the during-mating
 operators fails (return 
\family typewriter
False
\family default
), 
\series bold
a
\series default
 
\series bold
during-mating selector
\series default
 
\series bold
discards offspring according to fitness values of offspring
\series default
.
 Instead of relative fitness that will be compared against other individuals
 during the selection of parents, 
\series bold
fitness values of a during-mating selector are considered as absolute fitness
 which are probabilities to survive
\series default
 and have to be between 0 and 1.
\end_layout

\begin_layout Standard
A during-mating selector works as follows:
\end_layout

\begin_layout Enumerate
During evolution, parents are chosen randomly to produce one or more offspring.
 (Nothing prevents you from choosing parents according to their fitness
 values, but it is rarely justifiable to apply natural selection to both
 parents and offspring.)
\end_layout

\begin_layout Enumerate
A selection operator is applied to each offspring during mating and determines
 his or her fitness value.
 
\end_layout

\begin_layout Enumerate
The fitness value is considered as probability to survive so an offspring
 will be discarded (operator returns 
\family typewriter
False
\family default
) if the fitnessvalue is larger than an uniform random number.
\end_layout

\begin_layout Enumerate
Repeat steps 1, 2 and 3 until the offspring generation is populated.
\end_layout

\begin_layout Standard
Because many offspring will be generated and discarded, especially when
 offspring fitness values are low, selection through offspring is less efficient
 than selection through parents.
 In addition, absolute fitness is usually more difficult to estimate than
 relative fitness.
 So, unless there are compelling reasons (e.g.
 simulating realistic scenarios of survival competition among offspring),
 selection through parents are recommended.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectOffspring"

\end_inset

 gives an example of natural selection through the selection of offspring.
 This example looks almost identical to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 but the underlying selection mechanism is quite different.
 Note that selection through offspring does not need an information field
 to hold fitness values.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selectOffspring.log"
lstparams "caption={Natural selection through the selection of offspring},label={selectOffspring}"

\end_inset


\end_layout

\begin_layout Subsection
Are two selection scenarios equivalent? **
\end_layout

\begin_layout Standard
If you look closely at Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectOffspring"

\end_inset

, you will notice that their results are quite similar.
 This is actually what you should expect in most cases.
 Let us look at the theoretical consequence of selection through parents
 or offspring in a simple case with asexual mating.
\end_layout

\begin_layout Standard
Assuming a diallelic marker with three genotypes 
\begin_inset Formula $g_{AA}$
\end_inset

, 
\begin_inset Formula $g_{Aa}$
\end_inset

 and 
\begin_inset Formula $g_{aa}$
\end_inset

, with frequencies 
\begin_inset Formula $P_{AA}$
\end_inset

, 
\begin_inset Formula $P_{Aa}$
\end_inset

 and 
\begin_inset Formula $P_{aa}$
\end_inset

, and relative fitness values 
\begin_inset Formula $w_{AA}$
\end_inset

, 
\begin_inset Formula $w_{Aa}$
\end_inset

, and 
\begin_inset Formula $w_{22}$
\end_inset

 respectively.
 If we select through offspring, the proportion of genotype 
\begin_inset Formula $g_{AA}$
\end_inset

 etc., should be
\end_layout

\begin_layout Standard
\begin_inset Formula \[
P_{AA}'=\frac{P_{AA}w_{AA}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}\]

\end_inset


\begin_inset Formula \[
P_{Aa}'=\frac{P_{Aa}w_{Aa}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}\]

\end_inset


\begin_inset Formula \[
P_{aa}'=\frac{P_{aa}w_{aa}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}\]

\end_inset

because offspring genotypes are randomly drawn from the parental generation,
 and each offspring has certain probability to survive.
\end_layout

\begin_layout Standard
Now, if we select through parents, the proportion of parents with genotype
 
\begin_inset Formula $AA$
\end_inset

 will be the number of 
\begin_inset Formula $AA$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{AA}\frac{w_{AA}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, exactly 
\begin_inset Formula \[
n_{AA}\frac{w_{AA}}{\sum_{n=1}^{N}w_{n}}=\frac{n_{AA}w_{AA}}{n_{AA}w_{AA}+n_{Aa}w_{Aa}+n_{aa}w_{aa}}=\frac{P_{AA}w_{AA}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}=P_{AA}'\]

\end_inset

which corresponds to the proportion of offspring with such genotype.
 That is to say, in this simple case, 
\series bold
two types of selection scenarios yield identical results
\series default
.
\end_layout

\begin_layout Standard
These two types of selection scenarios do not have to always yield identical
 results.
 Exceptions may be found in cases with more than one offspring or sexual
 mating with sex-specific survival rate.
 simuPOP provides both selection implementations and you should choose one
 of them for your particular simulation.
\end_layout

\begin_layout Subsection
Map selector
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
Selector only set information field and mark subpopulations as selection
 ready.
 However, how these information are used to select parents can vary from
 mating scheme to mating scheme.
 As a matter of fact, some mating schemes do not support selection at all.
\end_layout

\begin_layout Itemize
Selector has to be applied to the parental generation (e.g.
 used in the 
\family typewriter
preOps
\family default
 parameter of function 
\family typewriter
simulator.evolve
\family default
).
\end_layout

\begin_layout Standard
The example for 
\family typewriter
class mapSelector
\family default
 is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if 
\begin_inset Formula $s_{1}=w_{12}-w_{11}$
\end_inset

 and 
\begin_inset Formula $s_{2}=w_{12}-w_{22}$
\end_inset

, the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mapSelector.log"
lstparams "caption={A selector that uses pre-defined fitness value},label={mapSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-allele selector (operator 
\family typewriter
maOperator
\family default
)
\end_layout

\begin_layout Standard
A multi-allele selector divides alleles into two groups, wildtype 
\emph on
A
\emph default
 and mutants 
\emph on
a
\emph default
, and treat alleles within each group as the same.
 The fitness model is therefore simplified to three fitness values: fitness
 for genotype 
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
.
 The most widely used model treat allele 0 as wildtype and any other alleles
 as mutants.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/maSelector.log"
lstparams "caption={A multi-allele selector},label={maSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-loci selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mlSelector.log"
lstparams "caption={A multi-loci selector},label={mlSelector}"

\end_inset


\end_layout

\begin_layout Subsection
A hybrid selector
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pySelector.log"
lstparams "caption={A hybrid selector},label={pySelector}"

\end_inset


\end_layout

\begin_layout Subsection
Support for virtual subpopulations *
\end_layout

\begin_layout Standard
Support for virtual subpopulations allows you to use different selectors
 for different (virtual) subpopulations.
 However, because virtual subpopulations may overlap, and they do not have
 to cover all individuals in a subpopulation, it is important to remember:
\end_layout

\begin_layout Itemize
If virtual subpopulations overlap, the fitness value set by the last selector
 will be used.
\end_layout

\begin_layout Itemize
If an individual is not included in any of the virtual subpopulation, its
 fitness value is undefined.
 In most cases, these individuals will have zero fitness values which prevent
 them from producing any offspring.
\end_layout

\begin_layout Subsection
Natural selection in a heterogeneous mating scheme **
\end_layout

\begin_layout Standard
Multiple mating schemes could be applied to the same subpopulation in a
 heterogeneous mating scheme (
\family typewriter
heteroMating
\family default
).
 These mating schemes may or may not support natural selection, and they
 may see individuals differently in terms of individual fitness.
 Parameter 
\family typewriter
fitnessField
\family default
 of a mating scheme could be used to handle such cases.
 More specifically,
\end_layout

\begin_layout Itemize
You can turn off the natural selection support of a mating scheme by setting
 
\family typewriter
fitnessField=''
\family default
.
\end_layout

\begin_layout Itemize
If a mating scheme uses a different set of fitness values, you can add an
 information field (e.g.
 
\family typewriter
fitness1
\family default
), setting individual fitness to this information field using a selector
 (with parameter 
\family typewriter
infoFields='fitness1'
\family default
) and tells a mating scheme to look in this information field for fitness
 values (using parameter 
\family typewriter
fitnessField='fitness1'
\family default
).
\end_layout

\begin_layout Section
Penetrance (under revision)
\end_layout

\begin_layout Subsection
Map penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mapPenetrance.log"
lstparams "caption={A penetrance model that uses pre-defined fitness value},label={mapPenetrance}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-loci penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mlPenetrance.log"
lstparams "caption={A multi-loci penetrance model},label={mlPenetrance}"

\end_inset


\end_layout

\begin_layout Subsection
Hybrid penetrance model
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyPenetrance.log"
lstparams "caption={A hybrid penetrance model},label={pyPenetrance}"

\end_inset


\end_layout

\begin_layout Chapter
Utility Modules 
\begin_inset CommandInset label
LatexCommand label
name "cha:Utility-Modules"

\end_inset


\end_layout

\begin_layout Section
Module 
\family typewriter
simuOpt
\family default
 (function 
\family typewriter
simuOpt.setOptions
\family default
)
\end_layout

\begin_layout Standard
Module 
\family typewriter
simuOpt
\family default
 handles options to specify which simuPOP module to load and how this module
 should be loaded, using function 
\family typewriter
simuOpt.setOptions 
\family default
with parameters 
\emph on
alleleType
\emph default
 (
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
, or 
\family typewriter
binary
\family default
 ), 
\emph on
optimized
\emph default
 (
\family typewriter
standard
\family default
 or 
\family typewriter
optimized
\family default
), 
\emph on
gui
\emph default
 (whether or not use a graphical user interface and which graphical toolkit
 to use), 
\emph on
revision
\emph default
 
\family typewriter
(
\family default
minimal required version/revision), 
\emph on
quiet
\emph default
 (with or without banner message, and 
\emph on
debug
\emph default
 (which debug code to turn on).
 These options have been discussed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 and other related sections.
 Note that 
\series bold
most options can be set by environmental variables and command line options
\series default
 which are sometimes more versatile to use.
\end_layout

\begin_layout Subsection
Class 
\family typewriter
simuOpt.simuParam
\end_layout

\begin_layout Standard
The 
\family typewriter
simuOpt
\family default
 module also provides a class 
\family typewriter
simuParam
\family default
 to help users handle and manage script parameters.
 There are many other standard or third-party parameter handling modules
 in Python but this class is designed to help users run a simuPOP script
 in both batch and GUI modes, using a combination of parameter determination
 methods.
 More specifically, if a script uses the 
\family typewriter
simuOpt.simuParam
\family default
 class to handle parameters,
\end_layout

\begin_layout Itemize
By default, a parameter input dialog is used to accept user input if the
 script is executed directly.
 Default values are given to each parameter and users are allowed to edit
 them using standard parameter input widgets (on/off button, edit box, dropdown
 list etc).
 Detailed explanations to parameters are available as tooltips of corresponding
 input widgets.
 A help button is provided that will display the usage of the script when
 clicked.
\end_layout

\begin_layout Itemize
If a configuration file is saved for a previous simulation, command line
 option 
\family typewriter
--config configFile
\family default
 can be used to load all parameters from that configuration file.
 The parameter input dialog is still used to review and modify parameters.
\end_layout

\begin_layout Itemize
Each parameter can also be set using command line options.
 Command line inputs will override values read from a configuration file.
\end_layout

\begin_layout Itemize
If command line option 
\family typewriter
--gui=False
\family default
 is given, the script will work in batch mode.
 If the value of a parameter cannot be determined through command line or
 a configuration file, and is set not to use its default value, users will
 be asked to enter its value interactively.
 For example, 
\family typewriter
myscript.py --gui=False --config configFile
\family default
 will execute a previous simulation directly.
\end_layout

\begin_layout Standard
The following sections describes how to use the 
\family typewriter
simuOpt
\family default
 class in a simuPOP script.
\end_layout

\begin_layout Subsection
Define a parameter specification list.
\end_layout

\begin_layout Standard
A 
\family typewriter
simuParam
\family default
 object is created from a list of parameter specification dictionaries,
 and optional short and long descriptions of a script.
 Each parameter specification dictionary consits of mandatory fields 
\family typewriter
longarg
\family default
 (long command line argument) and 
\family typewriter
default
\family default
 (default value for this parameter) and optional fields such as 
\family typewriter
label
\family default
 (label to display in the parameter input dialog and as prompt for user
 input), 
\family typewriter
description
\family default
 (a detailed description), 
\family typewriter
allowedTypes
\family default
 (allowed types of input parameter), 
\family typewriter
validate
\family default
 (a function that return tells if a user input is valid), 
\family typewriter
chooseOneOf
\family default
 (tells the parameter input dialog to allow users to choose one of the provided
 values) and 
\family typewriter
chooseFrom
\family default
 (tells the parameter input dialog to allow users to choose one or more
 values from the provided values).
 Although it can be lengthy to describe a parameter in this way, it is a
 self-documentary process from which your users and even yourself will benefit.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 shows a parameter specification list that defines parameter 
\family typewriter
help
\family default
, 
\family typewriter
rate
\family default
, 
\family typewriter
rep
\family default
 and 
\family typewriter
pops
\family default
.
 What is special about each parameter is that 
\family typewriter
help
\family default
 will not be listed in the parameter input dialog (no 
\family typewriter
label
\family default
) and setting 
\family typewriter
help
\family default
 to 
\family typewriter
True
\family default
 during interactive parameter input will ignore all other options (
\family typewriter
jump
\family default
); 
\family typewriter
rate
\family default
 has to be between 0 and 1 (using a validation function 
\family typewriter
valueBetween
\family default
), 
\family typewriter
rep
\family default
 has to be a positive integer, and 
\family typewriter
pops
\family default
 can be one of the three HapMap populations.
 Please refer to the simuPOP reference manual for details about each dictionary
 key.
 The 
\family typewriter
description
\family default
 of parameter 
\family typewriter
pop
\family default
 demonstrates a special rule in the formatting of such description texts,
 namely 
\series bold
lines with symbol '|' as the first non-space/tab character are outputed
 as a separate line without the leading '|' character.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.py"
lstparams "caption={A sample parameter specification list},label={paramSpec},lastline=34"

\end_inset


\end_layout

\begin_layout Subsection
Get parameters (function 
\family typewriter
simuParam.getParam
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
simuParam
\family default
 object can be created from a parameter specification list.
 A few member functions are immediately usable.
 For example, 
\family typewriter
simuParam.usage()
\family default
 returns a detailed usage message about the script and all its parameters
 (although the usage message will be displayed automatically if command
 line option 
\family typewriter
-h
\family default
 or 
\family typewriter
--help
\family default
 is detected).
 The parameters become attributes of this object using 
\family typewriter
longarg
\family default
 names so that you can access them easily (e.g.
 
\family typewriter
par.rate
\family default
).
 Not surprosingly, all parameters now have the default value you assigned
 to them.
\end_layout

\begin_layout Standard
Function 
\family typewriter
simuParam.saveConfig(filename)
\family default
 saves current values of parameters to a configuraiton file 
\family typewriter
filename
\family default
.
 Parameters that do not have a label are ignored.
 This configuration file can be loaded later using command line option 
\family typewriter
--config filename
\family default
, perhaps with option 
\family typewriter
--gui=False
\family default
 to run the script in batch mode.
 A less noticed feature of this function is that it also writes a complete
 command that specifies the same parameters using command line options.
 This can be handy if you would like to use real parameter definitions instead
 of 
\family typewriter
--config filename
\family default
 in a batch file.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
params.simuParam
\family default
 class provides a number of member functions that allow you to acquire user
 input in a number of ways.
 For example 
\family typewriter
simuParam.loadConfig
\family default
 reads a configuration file, 
\family typewriter
simuParam.processArgs
\family default
 checks commandline options, 
\family typewriter
simuParam.termGetParam
\family default
 asks user input interactively, and 
\family typewriter
simuParam.guiGetParam
\family default
 generates and uses a parameter input dialog.
 These functions can be used several times, on different sets of parameters.
 In addition, new options could be added programmatically using function
 
\family typewriter
simuParam.addOption
\family default
 and allows further flexibility on how parameters are generated.
 Please refer to 
\emph on
the simuPOP reference manual
\emph default
 on how to use these functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Get prameters using function getParam},firstline=36,keywordstyle={\\small\\ttfamily},label={getParam},lastline=69"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 lists some methods to determine parameter values but the last function,
 
\family typewriter
simuParam.getParam()
\family default
, will be used most of the time.
 This function processes each parameter in the following order:
\end_layout

\begin_layout Itemize
If a short or a long command line argument exists, use the command line
 argument.
\end_layout

\begin_layout Itemize
If a configuration file is specified from command line (
\family typewriter
--config configFile
\family default
), look in this configuration file for a value.
\end_layout

\begin_layout Itemize
If 
\family typewriter
useDefault
\family default
 is specified, assign a default value to this parameter.
\end_layout

\begin_layout Itemize
If 
\family typewriter
--gui=False
\family default
 is specified, and the value of the parameter has not be determined, ask
 users interactively for a value.
 Otherwise, a parameter input dialog is displayed.
 A 
\emph on
Tkinter
\emph default
 dialog is usually used but a 
\emph on
wxPython
\emph default
 dialog will be used if 
\emph on
wxPython
\emph default
 is available (unless parameter 
\family typewriter
--gui=Tkinter
\family default
 is set).
\end_layout

\begin_layout Standard

\family typewriter
simuParam.getParam
\family default
 returns 
\family typewriter
False
\family default
 if this process fails (e.g.
 users click cancel in the parameter input dialog).
 The parameter input dialog for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parameter-input-dialog"

\end_inset

.
\end_layout

\begin_layout Note
If 
\family typewriter
simuParam.valueValidFile()
\family default
 or 
\family typewriter
simuParam.valueValidDir()
\family default
 is used to validate a parameter, 
\series bold
double click
\series default
 the input textbox of this parameter will open a file or directory browse
 dialog.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:parameter-input-dialog"

\end_inset

A sample parameter input dialog
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/getParam.png
	width 50line%

\end_inset


\end_layout

\begin_layout Plain Layout
A parameter input dialog for a script that uses the same parameter specification
 list as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

.
 The command line is 
\family typewriter
simu.py --pop=YRI
\family default
.
 The first parameter is in red because its input is invalid.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Access, manipulate and extract parameters
\end_layout

\begin_layout Standard
If 
\family typewriter
simuOpt.getParam
\family default
 runs successfully, the 
\family typewriter
simuOpt
\family default
 object should have valid value for each parameter.
 They can be retrieved as attributes (such as 
\family typewriter
par.rate
\family default
) and manipulated easily.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "useSimuOpt"

\end_inset

 demonstrates how to extend parameter 
\family typewriter
par.rate
\family default
 to have the same length as 
\family typewriter
par.rep
\family default
.
 
\end_layout

\begin_layout Standard
When there are a large number of parameters, passing this 
\family typewriter
simuParam
\family default
 object, instead of tens of parameters, is a good way to provide clean interface
s.
 Alternatively, you can get a list or a dictionary of parameters using member
 functions 
\family typewriter
simuParam.asList()
\family default
 and 
\family typewriter
simuParam.asDict()
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Use the simuOpt object},firstline=70,label={useSimuOpt}"

\end_inset


\end_layout

\begin_layout Standard
It is easy to set 
\series bold
additional attributes
\series default
 to a 
\family typewriter
simuParam
\family default
 object, using either 
\family typewriter
par.name = value
\family default
 statement or additional 
\family typewriter
name=value
\family default
 pairs in the constructor of a 
\family typewriter
simuOpt
\family default
 object.
 These attributes are not considered as parameters of an 
\family typewriter
simuOpt
\family default
 object (e.g.
 they are not returned by function 
\family typewriter
simuParam.asDict()
\family default
) but could be used just like regular parameters.
 Note that the same operations for 
\family typewriter
simuOpt
\family default
 parameters change the value of these parameters.
\end_layout

\begin_layout Standard
Additional attributes can be used to create a 
\family typewriter
simuOpt
\family default
 object without user interaction.
 For example, objects 
\family typewriter
par1
\family default
 and 
\family typewriter
par2
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "useSimuOpt"

\end_inset

 are created easily with needed attributes.
 They can be passed to functions where a 
\family typewriter
simuParam
\family default
 object is needed, although some of the attributes are not real parameters
 (in the sense that they are not created by a parameter specification dictionary
 and will not be used to handle user input).
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.utils
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.utils
\family default
 module provides a few utility functions and classes.
 They do not belong to the simuPOP core but are distributed with simuPOP
 because they are frequently used and play an important role in some specialized
 simulation techniques.
 Please refer to the simuPOP online cookbook (
\family typewriter
http://simupop.sourceforge.net/cookbook
\family default
) for more utility modules and functions.
 
\end_layout

\begin_layout Subsection
Trajectory simulation (classes 
\family typewriter
trajectory
\family default
 and 
\family typewriter
trajectorySimulator
\family default
)
\end_layout

\begin_layout Standard
A forward-time simulation, by its nature, is directly influenced by random
 genetic drift.
 Starting from the same parental generation, allele frequencies in the offspring
 generation would vary from simulation to simulation, with perhaps a predictable
 mean frequency which is determined by factors such as parental allele frequency
, natural selection, mutation and migration.
\end_layout

\begin_layout Standard
Genetic drift is unavoidable and is in many cases the target of theoretical
 and simulation studies.
 However, in certain types of studies, there is often a need to control
 the frequencies of certain alleles in the present generation.
 For example, if we are studying a particular penetrance model with pre-specifie
d frequencies of disease predisposing alleles, the simulated populations
 would better have consistent allele frequencies at the disease predisposing
 loci, and consequently consistent disease prevalence.
\end_layout

\begin_layout Standard
simuPOP provides a special offspring generator 
\family typewriter
controlledOffspringGenerator
\family default
 and an associated mating scheme called 
\family typewriter
controlledRandomMating
\family default
 that can be used to generate offspring generations conditioning on frequencies
 of one or more alleles.
 This offspring generator essentially uses a reject-sampling algorithm to
 select (or reject) offspring according to their genotypes at specified
 loci.
 A detailed description of this algorithm is given in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

.
\end_layout

\begin_layout Standard
The controlled random mating scheme accepts a user-defined trajectory function
 that tells the mating scheme the desired allele frequencies at each generation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

 uses a manually defined function that raises the frequency of an allele
 steadily.
 However, given known demographic and genetic factors, 
\series bold
a trajectory should be simulated randomly so that it represents a random
 sample from all possible trajectories that match the allele frequency requireme
nt
\series default
.
 If such a condition is met, the controlled evolutionary process can be
 considered as a random process conditioning on allele frequencies at the
 present generation.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

 for a detailed discussion about the theoretical requirements of a valid
 trajectory simulator.
\end_layout

\begin_layout Standard
The 
\family typewriter
simuUtil
\family default
 module provides functions and classes that implement two trajectory simulation
 methods that can be used in different situations.
 The first class is 
\family typewriter
trajectorySimulator
\family default
 which takes a demographic model and a selection model as its input and
 simulates allele frequency trajectories using a forward or backward algorithm.
 The demographic model is given by parameter 
\family typewriter
N
\family default
, which can be a constant (e.g.
 
\family typewriter
N=1000
\family default
) for constant population size, a list of subpopulation sizes (e.g.
 
\family typewriter
N=[1000, 2000]
\family default
) for a structured population with constant size, or a demographic function
 that returns population or subpopulation sizes at each generation.
 In the last case, subpopulations can be split or merged with the constrait
 that subpopulations can be merged into one, from split from one population.
\end_layout

\begin_layout Standard
A fitness model specifies the fitness of genotypes at one or more loci using
 parameter 
\family typewriter
fitness
\family default
.
 It can be a list of three numbers (e.g.
 
\family typewriter
fitness=[1, 1.001, 1.003]
\family default
), repsenting the fitness of genotype 
\family typewriter
AA
\family default
, 
\family typewriter
Aa
\family default
 and 
\family typewriter
aa
\family default
 at one or more loci; or different fitness for genotypes at each locus (e.g.
 
\family typewriter
fitness=[1, 1.001, 1.003, 1, 1, 1.002]
\family default
), or for each combination or genotype (interaction).
 In the last case, 
\begin_inset Formula $3^{n}$
\end_inset

 values are needed for each genotype if there are 
\begin_inset Formula $n$
\end_inset

 loci.
 This trajectory simulator also accepts generation-specific fitness values
 by accepting a function that returns fitness values at each generation.
\end_layout

\begin_layout Standard
The simulator then simulates trajectories of allele frequencies and return
 them as objects of class 
\family typewriter
trajectory
\family default
.
 This object can be used provide a trajectory function that can be used
 directly in a 
\family typewriter
controlledRandomMating
\family default
 mating scheme (function 
\family typewriter
trajectory.func()
\family default
) or provide a list of 
\family typewriter
pointMutator
\family default
 to introduce mutants at appropriate generations (function 
\family typewriter
trajectory.mutators()
\family default
).
 If a simulation failed after specified number of attempts, a 
\family typewriter
None
\family default
 object will be returned.
\end_layout

\begin_layout Subsubsection
Forward-time trajectory simulations (function 
\family typewriter
ForwardTrajectory
\family default
)
\end_layout

\begin_layout Standard
A forward simulation starts from a specified generation with specified allele
 frequencies at one or more loci.
 The simulator simulates allele frequencies forward-in-time, until it reaches
 a specified ending generation.
 A trajectory object will be returned if the simulated allele frequencies
 fall into specified ranges.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "forwardTrajectory"

\end_inset

 demonstrates how to use this simulation method to obtain and use a simulated
 trajectory, for two unlinked loci under different selection pressure.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/forwardTrajectory.log"
lstparams "caption={Simulation and use of forward-time simulated trajectories.},label={forwardTrajectory}"

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:forwardTrajectory"

\end_inset

 plots simulated trajectories of one locus in two subpopulations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:forwardTrajectory"

\end_inset

Simulated trajectories of one locus in two subpopulations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/forwardTrajectory.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Backward-time trajectory simulations (function 
\family typewriter
BackwardTrajectory
\family default
).
\end_layout

\begin_layout Standard
A backward simulation starts from specified frequencies at the present generatio
n.
 In the single-allele case, the simulations goes backward-in-time until
 an allele gets lost.
 The length of such a trajectory is random, which is usually a desired property
 because the age of a mutant in the present generation is usually unknown
 and is assumed to be random.
\end_layout

\begin_layout Standard
This trajectory simulation technique is usually used as follows:
\end_layout

\begin_layout Enumerate
Determine a demographic and a natural selection model using which a forward-time
 simulation will be performed.
\end_layout

\begin_layout Enumerate
Given current disease allele frequencies, simulate trajectories of allele
 frequencies at each DSL using a backward approach.
\end_layout

\begin_layout Enumerate
Evolve a population forward-in-time, using designed demographic and selection
 models.
 A 
\family typewriter
controlledRandomMating
\family default
 scheme instead of the usual 
\family typewriter
randomMating
\family default
 scheme should be used.
 
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:backTrajectory"

\end_inset

 plots simulated trajectories of two unlinked loci.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:backTrajectory"

\end_inset

Simulated trajectories of two unlinked loci
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/backTrajectory.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The trajectory is used in a 
\family typewriter
controlledRandomMating
\family default
 scheme in the following evolutionary scenario:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/backTrajectory.log"
lstparams "caption={Simulation and use of backward-time simulated trajectories.},label={backTrajectory}"

\end_inset


\end_layout

\begin_layout Subsection
Progress bar
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.plotter
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.plotter
\family default
 module defines a few utility functions and Python operators that help you
 plot variables and information fields during evolution.
 A number of operators are defined that
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.varPlotter
\family default
: Plot a dynamically evaluated expression with its history.
 Each expression and its history form a line in the plot.
 Multiple lines will be plotted for multiple replicates and/or for each
 element of the expression (if the evaluated value of the expression is
 a sequence), with options to separate lines to different subplots.
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.scatterPlotter
\family default
: Plot individuals in specified (virtual) subpopulations using values at
 two information fields as x and y axes.
 Individuals belonging to different (virtual) subpopulations will be plotted
 with different colors and shapes.
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.infoPlotter
\family default
: Using a R function such as 
\family typewriter
hist
\family default
 and 
\family typewriter
qqnorm
\family default
 to plot one or more information fields of individuala in one or more (virtual)
 subpopulations.
 Two specialized operators 
\family typewriter
plotter.histPlotter
\family default
 and 
\family typewriter
plotter.qqPlotter
\family default
 are provided to plot the histograms and qq plots.
 Other functions could also be used, and it is even possible to draw a figure
 completely by your own (with stratified data provided to you by this operator).
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.boxPlotter
\family default
: This operator uses R function 
\family typewriter
boxplot
\family default
 to plot boxplots of data of one or more information fields of individuals
 in one ore more (virtual) subpopulations.
 The whiskers could be grouped by information field or subpopulations.
\end_layout

\begin_layout Standard
These operators are derived from class 
\family typewriter
pyOperator
\family default
 and call R plot functions when they are applied to a population.
 For example, operator 
\family typewriter
plotter.varPlotter
\family default
 collects expression values and use functions 
\family typewriter
plot
\family default
 and 
\family typewriter
lines
\family default
 to plot the data, with help from other functions such as 
\family typewriter
par
\family default
 (device property), 
\family typewriter
dev.print
\family default
 (save figure to files) and 
\family typewriter
legend
\family default
 (add legend).
 Some functions are called multiple times for different replicate, subpopulation
 or information fields.
\end_layout

\begin_layout Subsection
Derived keyword arguments *
\end_layout

\begin_layout Standard
One of the most interesting feature of this module is its use of derived
 keyword parameters to send arbitrary parameters to the underlying R functions,
 which usually accept a large number of parameters to customize every aspect
 of a figure.
 A 
\series bold
derived keyword argument
\series default
 is an argument that is prefixed with a function name and/or suffixed by
 an iterator name.
 The former specifies to which underlying R function this parameter will
 be passed to; the latter allows the users to specify a list of values that
 will be passed, for example, to lines representing different replicates.
 For example, parameter 
\family typewriter
par_mar=[1]*4
\family default
 will pass 
\family typewriter
mar=[1]*4
\family default
 to R function 
\family typewriter
par
\family default
, and 
\family typewriter
lty_rep=[1, 2, 3]
\family default
 will pass 
\family typewriter
lty=1
\family default
, 
\family typewriter
lty=2
\family default
 and 
\family typewriter
lty=3
\family default
 to different replicates.
 A class usually has one or two default functions (such as 
\family typewriter
plot
\family default
, 
\family typewriter
lines
\family default
) to which keyword aguments without function prefix will be sent.
\end_layout

\begin_layout Standard
In addition, the values of these keyword arguments could vary during evolution.
 More specifically, if the value is a string with a leading exclamation
 mark (
\family typewriter
!
\family default
), the remaining string will be considered as an expression.
 This expression will be evaluated against the current population during
 evolution and the return value will become the value of the parameter at
 that generation.
 For example, keyword parameter  
\family typewriter
main=
\begin_inset Quotes erd
\end_inset

!'Allele frequency at generation %d' % gen
\begin_inset Quotes erd
\end_inset


\family default
 will become 
\family typewriter
main='Allele frequency at generation 10'
\family default
 at generation 10.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Plot of expressions and their histories (operator 
\family typewriter
plotter.varPlotter
\family default
)
\end_layout

\begin_layout Standard
Class 
\family typewriter
plotter.varPlotter
\family default
 plots the current and historical values of a Python expression (
\family typewriter
expr
\family default
), which are evalulated (against each population's local namespace) and
 saved during evolution.
 The return value of the expression can be a number or a sequence, but should
 have the same type and length across all replicates and generations.
 Histories of each value (or each item in the returned sequence) of each
 replicate form a line, with generation numbers as its x-axis.
 Number of lines will be the number of replicates multiplied by dimension
 of the expression.
 Although complete histories are usually saved, you can use parameter 
\family typewriter
win
\family default
 to save histories only within the last 
\family typewriter
win
\family default
 generations.
 
\end_layout

\begin_layout Standard
Except for the first generation where no line could be drawn, a figure will
 be drawn after this operator is applied to the last specified replicate
 (parameter 
\family typewriter
reps
\family default
 could be used to specify a subset of replicates).
 For example, although linkage disequilibrium values between the first two
 loci are evaluated and saved at the end of generations 0, 5, 10, ..., (
\family typewriter
step=5
\family default
) figures are only drawn at generations 40 and 80 (
\family typewriter
update=40
\family default
) in Exampe 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpy"

\end_inset

.
 This example also demonstrates the use of parameters 
\family typewriter
saveAs
\family default
 and 
\family typewriter
legend
\family default
.
 By given a filename 
\family typewriter
rpy.png
\family default
 to parameter 
\family typewriter
saveAs
\family default
, this operator will save figures (named 
\family typewriter
rpy_40.png
\family default
 and 
\family typewriter
rpy_80.png
\family default
) after they are drawn.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/varPlotter.log"
lstparams "caption={Use rpy to plot an expression},label={rpy}"

\end_inset


\end_layout

\begin_layout Standard
Parameters after 
\family typewriter
legend
\family default
 (
\family typewriter
xlab
\family default
, 
\family typewriter
ylab
\family default
, 
\family typewriter
ylim
\family default
, 
\family typewriter
main
\family default
, ...) deserve more attention here.
 These parameters are derived keyword arguments because they are not defined
 by 
\family typewriter
varPlotter.

\family default
 Parameters without prefix are passed directly to the R functions 
\family typewriter
plot
\family default
 and 
\family typewriter
line
\family default
.
 They could be used to customize line type (
\family typewriter
lty
\family default
), color (
\family typewriter
col
\family default
), title (
\family typewriter
main
\family default
), limits of x and y axes (
\family typewriter
xlim
\family default
 and 
\family typewriter
ylim
\family default
) and many other graphical features (see R manual for details).
 If multiple lines are drawn, a list of values could be applied to these
 lines if you add 
\family typewriter
_rep
\family default
 (for each replicate) or 
\family typewriter
_dim
\family default
 (for each item of a sequence) after the name of the parameter.
 For example, 
\family typewriter
lty_rep=[1, 2, 3]
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpy"

\end_inset

 to pass parameters 
\family typewriter
lty=1
\family default
, 
\family typewriter
lty=2
\family default
 and 
\family typewriter
lty=3
\family default
 to lines for three replicates.
 Suffix 
\family typewriter
_repdim
\family default
 can also be used to specify values for every replication and dimension.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpy"

\end_inset

 displayed 
\family typewriter
rpy_80.png
\family default
 that is saved at generation 80 for this example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpy"

\end_inset

rpy_80.png saved at generation 80 for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpy"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/rpy_80.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the expression is multidimensional, the number of lines can be large
 and it is often desired to separate these lines into subplots.
 This can be done by parameters 
\family typewriter
byRep
\family default
 or 
\family typewriter
byDim
\family default
.
 The former plots lines replicate by replicate and the latter does it dimension
 by dimension.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByRep"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByDim"

\end_inset

 both have three replicates and the expression has allele frequency for
 four loci.
 The total number of lines is therefore 12.
 In Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByRep"

\end_inset

, these lines are separated to three subplots, replicate by replicate, with
 different titles (parameter 
\family typewriter
main_rep
\family default
).
 In each subplot, allele frequency trajectories (histories) for different
 loci are plotted in different color (parameter 
\family typewriter
col_dim
\family default
).
 The last saved figure (
\family typewriter
rpy_byRep_90.png
\family default
) is displayed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpyByRep"

\end_inset

.
 In Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByDim"

\end_inset

, these lines are separated to four subplots, locus by locus, with different
 titles (parameter 
\family typewriter
main_dim
\family default
).
 In each subplot, allele frequency trajectories (histories) for different
 loci are plotted in different color (parameter 
\family typewriter
col_rep
\family default
) and line type (parameter 
\family typewriter
lty_rep
\family default
).
 The last saved figure (
\family typewriter
rpy_byDim_90.png
\family default
) is displayed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpyByDim"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/rpyByRep.log"
lstparams "caption={Separate figures by replicate},label={rpyByRep}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpyByRep"

\end_inset

Allele frequency trajectories separated by replicates
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/rpy_byRep_90.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByDim"

\end_inset

 also demonstrates some advanced features of this plotter that allow further
 customization of the figures.
 More specifically,
\end_layout

\begin_layout Itemize
Function-specific parameters can be passed to the underlying R function
 by prefixing function names to parameter names.
 For example, 
\family typewriter
plot_axis=False
\family default
 is used to pass 
\family typewriter
axis=False
\family default
 to the 
\family typewriter
r.plot
\family default
 function (and not to function 
\family typewriter
lines
\family default
 which does not accept this parameter).
\end_layout

\begin_layout Itemize
Several hook function can be defined and passed to parameters 
\family typewriter
preHook
\family default
, 
\family typewriter
postHook
\family default
 and 
\family typewriter
plotHook
\family default
, which will be called, respectively, before a figure is drawn, after a
 figure is drawn, and after each 
\family typewriter
r.plot
\family default
 call.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "rpyByDim"

\end_inset

 uses a 
\family typewriter
plotHook
\family default
 function to draw axes of the plots and call 
\family typewriter
mtext
\family default
 to add texts to the margins.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/rpyByDim.log"
lstparams "caption={Separate figures by Dimension},label={rpyByDim}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpyByDim"

\end_inset

Allele frequency trajectories separated by loci
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/rpy_byDim_90.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scatter plots (operator 
\family typewriter
plotter.scatterPlotter
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
plotter.scatterPlotter
\family default
 plots individuals in all or selected (virtual) subpopulations in a 2-D
 plot, using values at two information fields as their x- and y-axis.
 In the most simplified form,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

infoPlotter(infoFields=['x', 'y'])
\end_layout

\end_inset

will plot all individuals according their values of information fields 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
.
 Additional parameters such as pch, 
\family typewriter
col
\family default
, and 
\family typewriter
cex
\family default
 can be used to control the shape, color and size of the points.
\end_layout

\begin_layout Standard
What makes this operator useful is its ability to differentiate points (individu
als) by (virtual) subpopulations (VSPs).
 If a list of VSPs are given, points representing individuals from these
 VSPs will be plotted with different colors and shapes.
 Because simulations that keep track of multiple information fields are
 usually complicated, let us simulate something interesting and examine
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "scatterPlotter"

\end_inset

 in details.
\end_layout

\begin_layout Standard
At the beginning of this example, all individuals are scattered randomly
 with 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 being their physical locations.
 We use 
\family typewriter
anc
\family default
 to record individual ancestry and assign 0 and 1 each to half of the population.
 During evolution,
\end_layout

\begin_layout Itemize
Offspring ancestry values are the average of their parents.
\end_layout

\begin_layout Itemize
Offspring with higher ancestry value tend to move to the right.
 More specifically, locations of an offspring will be 
\begin_inset Formula \[
\frac{\left(x_{1}+x_{2}\right)}{2}+N\left(\frac{a_{1}+a_{2}}{2}-0.5,0.1\right),\frac{\left(y_{1}+y_{2}\right)}{2}+N\left(0,0.1\right)\]

\end_inset

where 
\begin_inset Formula $\left(x_{1},y_{1}\right)$
\end_inset

 and 
\begin_inset Formula $\left(x_{2},y_{2}\right)$
\end_inset

 are locations of parents, 
\begin_inset Formula $a_{1}$
\end_inset

 and 
\begin_inset Formula $a_{2}$
\end_inset

 are ancestry values of the parents, and 
\begin_inset Formula $N\left(a,b\right)$
\end_inset

 are a random number with normal distribution.
\end_layout

\begin_layout Standard
An 
\family typewriter
scatterPlotter
\family default
 is used to plot the physical location of all individuals.
 Individual ancestries are divided into five regions (0, 0.2, 0.4, 0.6, 0.8,
 1) indicated by small to larger points.
 Male and female individuals are plotted by different symbol.
 This scripts uses the following techniques:
\end_layout

\begin_layout Itemize
Set individual information fields randomly using 
\family typewriter
setIndInfo
\family default
.
\end_layout

\begin_layout Itemize
Define virtual subpopulations using a 
\family typewriter
infoSplitter
\family default
.
\end_layout

\begin_layout Itemize
Use 
\family typewriter
pyTagger
\family default
 to calculate offspring information fields from parental fields.
\end_layout

\begin_layout Itemize
Mark individuals in different VSPs using parameters 
\family typewriter
col_sp
\family default
 and 
\family typewriter
cex_sp
\family default
.
\end_layout

\begin_layout Itemize
Use 
\family typewriter
plot_axes=False
\family default
 and 
\family typewriter
par_mar=[0, 0, 2, 0]
\family default
 to pass parameters 
\family typewriter
axes=False
\family default
 and 
\family typewriter
mar=[0, 0, 2, 0]
\family default
 to functions 
\family typewriter
plot
\family default
 and 
\family typewriter
par
\family default
 respectively.
\end_layout

\begin_layout Standard
VSPs 0 and 4 appear at the beginning of generation 0, VSP 2 appears at the
 end of generation 0, and VSP 1 and 3 appear at the end of generation 1.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:scatterPlotter"

\end_inset

 displays a figure at the begging of generation 2.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/scatterPlotter.log"
lstparams "caption={Use scatterPlotter to plot ancestry of individuals with geographic information.},label={scatterPlotter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:scatterPlotter"

\end_inset

Plot of individuals with ancestry marked by different colors
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/scatterPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Histograms, QQ plots and boxplots (operator 
\family typewriter
plotter.infoPlotter
\family default
, 
\family typewriter
plotter.histPlotter
\family default
, 
\family typewriter
plotter.qqPlotter
\family default
).
\end_layout

\begin_layout Standard
Class 
\family typewriter
plotter.infoPlotter
\family default
 can be used to draw figures for information fields of individuals in one
 or more subpopulations.
 
\family typewriter
plotter.histPlotter
\family default
 and 
\family typewriter
plotter.qqPlotter
\family default
 are two special cases of this class that uses functions 
\family typewriter
hist
\family default
 and 
\family typewriter
qqnorm
\family default
 respectively.
 Although an 
\family typewriter
infoPlotter
\family default
 using a 
\family typewriter
boxplot
\family default
 function could be used, a specialized 
\family typewriter
plotter.boxPlotter
\family default
 is defined so that mutliple boxplot whiskers could be drawn in the same
 plot.
\end_layout

\begin_layout Standard
Using the same evolutionary process as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "scatterPlotter"

\end_inset

, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "histPlotter"

\end_inset

 uses a 
\family typewriter
histPlotter
\family default
 to plot the histograms (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:histPlotter"

\end_inset

), a 
\family typewriter
qqPlotter
\family default
 to plot QQ plot (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:qqPlotter"

\end_inset

), and a 
\family typewriter
boxPlotter
\family default
 to plot the boxplots (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:boxPlotter"

\end_inset

) of individual ancestry values.
 By defining two virtual subpopulations by sex, the 
\family typewriter
histPlotter
\family default
 and 
\family typewriter
qqPlotter
\family default
 plots two histograms and two QQ plots, one for males and one for females.
 Different colors are used for these figures.
 Note that these plots use the special expression value for parameter 
\family typewriter
main
\family default
 so that generation number can appear in the titles.
 The same technique is used in the 
\family typewriter
dev_print_file
\family default
 parameter of the 
\family typewriter
boxPlotter
\family default
, which overrides the default filename derived from parameter 
\family typewriter
saveAs
\family default
.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/histPlotter.log"
lstparams "caption={Use histPlotter to plot the histogram of individual ancestries.},label={histPlotter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:histPlotter"

\end_inset

Histogram of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/histPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:qqPlotter"

\end_inset

QQ plot of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/qqPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:boxPlotter"

\end_inset

Boxplot of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/Gen2.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
A real world example
\begin_inset CommandInset label
LatexCommand label
name "cha:A-real-example"

\end_inset


\end_layout

\begin_layout Standard
Previous chapters use a lot of examples to demonstrate individual simuPOP
 features.
 However, it might not be clear how to integrate these features in longer
 scripts that address real world problems, which may involve larger populations,
 more complex genetic and demographic models and may run thousands of replicates
 with different parameters.
 This chapter will show you, step by step, how to write a complete simuPOP
 script that has been used in a real-world research topic.
\end_layout

\begin_layout Section
Simulation scenario
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
This example is a simplified version of the 
\family typewriter
simuCDCV.py
\family default
 script that simulates this evolution process and observe the allelic spectra
 of both types of diseases.
 The complete script is available at 
\begin_inset CommandInset href
LatexCommand href
name "the simuPOP online cookbook"
target "http://simupop.sourceforge.net/cookbook"

\end_inset

.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Section
Demographic model
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Reich2001a"

\end_inset

 used a very simple instant population growth model.
 Under the model assumption, a population with an initial population size
 
\begin_inset Formula $N_{0}$
\end_inset

 would evolve 
\begin_inset Formula $G_{0}$
\end_inset

 generations, instantly expand its population size to 
\begin_inset Formula $N_{1}$
\end_inset

 and evolve another 
\begin_inset Formula $G_{1}$
\end_inset

 generations.
 Such a model can be easily implemented as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ins_expansion(gen, oldsize=[]):
\end_layout

\begin_layout Plain Layout

    'An instant population growth model'
\end_layout

\begin_layout Plain Layout

    if gen < G0:
\end_layout

\begin_layout Plain Layout

        return N0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        return N1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other demographic models could be implemented similarly.
 For example, an exponential population growth model that expand the population
 size from 
\begin_inset Formula $N_{0}$
\end_inset

 to 
\begin_inset Formula $N_{1}$
\end_inset

 in 
\begin_inset Formula $G_{1}$
\end_inset

 generations could be defined as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def exp_expansion(gen, oldsize=[]):
\end_layout

\begin_layout Plain Layout

    'An exponential population growth model'
\end_layout

\begin_layout Plain Layout

    if gen < G0:
\end_layout

\begin_layout Plain Layout

        return N0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        rate = (math.log(N1) - math.log(N0))/G1
\end_layout

\begin_layout Plain Layout

        return int(N0 * math.exp((gen - G0) * rate))
\end_layout

\end_inset

That is to say, we first solve 
\begin_inset Formula $r$
\end_inset

 from 
\begin_inset Formula $N_{1}=N_{0}\exp\left(rG_{1}\right)$
\end_inset

 and then calculate 
\begin_inset Formula $N_{t}=N_{0}\exp\left(rG\right)$
\end_inset

 for a given generation.
\end_layout

\begin_layout Standard
There is a problem here: the above definitions treat 
\family typewriter
N0
\family default
, 
\family typewriter
G0
\family default
, 
\family typewriter
N1
\family default
 and 
\family typewriter
G1
\family default
 as global variables.
 This is OK for small scripts but is certainly not a good idea for larger
 scripts especially when different parameters will be used.
 A better way is to wrap these functions by another function that accept
 
\family typewriter
N0
\family default
, 
\family typewriter
G0
\family default
, 
\family typewriter
N1
\family default
 and 
\family typewriter
G1
\family default
 as parameters.
 That is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichDemo"

\end_inset

 where a function 
\family typewriter
demo_model
\family default
 is defined to return either an instant or an exponential population growth
 demographic function.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichDemo.log"
lstparams "caption={A demographic function producer},label={reichDemo}"

\end_inset


\end_layout

\begin_layout Note
The defined demographic functions return the total population size (a number)
 at each generation beacuse no subpopulation is considered.
 A list of subpopulation sizes should be returned if there are more than
 one subpopulations.
\end_layout

\begin_layout Section
Mutation and selection models
\end_layout

\begin_layout Standard
The thoretical model empolyees an infinite allele model where there is a
 single wild type allele and an infinite number of disease alleles.
 Each mutation would introduce a new disease allele and there is no back
 mutation (mutation from disease allele to wild type allele).
\end_layout

\begin_layout Standard
This mutation model can be mimicked by a 
\begin_inset Formula $k$
\end_inset

-allele model with resaonably large 
\begin_inset Formula $k$
\end_inset

.
 We initialize all alleles to 0 which is the wild type (
\begin_inset Formula $A$
\end_inset

) and all other alleles are considered as disease alleles (
\begin_inset Formula $a$
\end_inset

).
 Because an allele in a 
\begin_inset Formula $k-$
\end_inset

allele mutation model can mutate to any other allele with equal probability,
 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more disease alleles than the wild type allele.
 If we choose a smaller 
\begin_inset Formula $k$
\end_inset

 (e.g.
 
\begin_inset Formula $k=20$
\end_inset

), recurrent and back mutations can on longer be ignored but it would be
 interesting to simulate such cases because they are more realistic than
 the infinite allele model in some cases.
\end_layout

\begin_layout Standard
A 
\begin_inset Formula $k$
\end_inset

-allele model can be simulated using the 
\family typewriter
kamMutator
\family default
 operator which accepts a mutation rate and a maximum allelic state as parameter
s.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kamMutator(rate=mu, maxAllele=k)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because there are many possible disease alleles, a multi-allelic selector
 (
\family typewriter
maSelector
\family default
) could be used to select against the disease alleles.
 This operator accept a single or a list of wild type alleles (
\family typewriter
[0]
\family default
 in this case) and treat all other alleles as disease alleles.
 A penetrance table is needed which specified the fitness of each individual
 when they have 0, 1 or 2 disease alleles respectively.
 In this example, we assume a recessive model in which only genotype 
\begin_inset Formula $aa$
\end_inset

 causes genetic disadvantages.
 If we assume a selection pressure parameter 
\begin_inset Formula $s$
\end_inset

, the operator to use is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(loci=0, wildtype=0, penetrance=[1, 1, 1-s])
\end_layout

\end_inset

Note that the use of this selector requires a population information field
 
\family typewriter
fitness
\family default
.
\end_layout

\begin_layout Standard
This example uses a single-locus selection model but the complete script
 allows the use of different kinds of multi-locus selection model.
 If we assume a multiplicative multi-locus selection model where fitness
 values at different loci are combined (multiplied), a multi-locus selection
 model (
\family typewriter
mlSelector
\family default
) could be used as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mlSelector([
\end_layout

\begin_layout Plain Layout

    maSelector(locus=loc1, fitness=[1,1,1-s1], wildtype=[0]),
\end_layout

\begin_layout Plain Layout

    maSelector(locus=loc2, fitness=[1,1,1-s2], wildtype=[0])],
\end_layout

\begin_layout Plain Layout

    mode=Multiplicative
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These multi-locus model treat disease alleles at different loci more or
 less independently.
 If more complex multi-locus models (e.g.
 models involve gene - gene and/or gene - interaction) are involved, a multi-loc
us selector that uses a multi-locus penetrance table could be used.
\end_layout

\begin_layout Section
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy because 
\family typewriter
stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use a 
\family typewriter
stat()
\family default
 operator to calculate allele frequency and get the result from population
 variable 
\family typewriter
alleleFreq
\family default
.
 Because allele frequcies add up to one, we can get the total disease allele
 frequency using the allele frequency of the wild type allele 0 (
\begin_inset Formula $\sum_{i=1}^{\infty}f_{i}=1-f_{0}$
\end_inset

).
 The actual code would look more or less like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0,1]),
\end_layout

\begin_layout Plain Layout

pyEval(r'"%.2f" % (1-alleleFreq[0][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are also interested in the effective number of alleles 
\begin_inset CommandInset citation
LatexCommand citep
key "Reich2001a"

\end_inset

 at a locus.
 Because simuPOP does not provide an operator or function to calculate this
 statistic, we will have to calculate it manually.
 Fortunately, this is not difficult because effective number of alleles
 can be calculated from existing allele frequencies, using formula
\begin_inset Formula \[
n_{e}=\left(\sum_{i=1}^{\infty}\left(\frac{f_{i}}{1-f_{0}}\right)^{2}\right)^{-1}\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
A quick-and-dirty way to output 
\begin_inset Formula $n_{e}$
\end_inset

 at a locus (e.g.
 locus 0) can be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval('1./sum([(alleleFreq[0][x]/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0].
keys() if x != 0])')
\end_layout

\end_inset

but this expression looks complicated and does not handle the case when
 
\begin_inset Formula $f_{0}=1$
\end_inset

.
 A more robust method would involve the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(stmts='''if alleleFreq[0][0] == 1:
\end_layout

\begin_layout Plain Layout

    ne = 0
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    freq = [freq[0][x] for x in alleleFreq[0].keys() if x != 0]
\end_layout

\begin_layout Plain Layout

    ne = 1./sum([(f/(1-alleleFreq[0][0])**2 for x in freq])
\end_layout

\begin_layout Plain Layout

''', expr=r'"%.3f" % ne')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this piece of code does not look nice with the multi-line string,
 and the operator is not really reusable (only valid for locus o).
 It makes sense to define a function to calculate 
\begin_inset Formula $n_{e}$
\end_inset

 generally:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ne(pop, loci):
\end_layout

\begin_layout Plain Layout

    ' calculate effective number of alleles at given loci'
\end_layout

\begin_layout Plain Layout

    Stat(pop, alleleFreq=loci)
\end_layout

\begin_layout Plain Layout

    ne = {}
\end_layout

\begin_layout Plain Layout

    for loc in loci:
\end_layout

\begin_layout Plain Layout

        freq = [y for x,y in pop.dvars().alleleFreq[loc].iteritems() if x !=
 0]
\end_layout

\begin_layout Plain Layout

        sumFreq = 1 - pop.dvars().alleleFreq[loc][0]
\end_layout

\begin_layout Plain Layout

        if sumFreq == 0:
\end_layout

\begin_layout Plain Layout

            ne[loc] = 0
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            ne[loc] = 1.
 / sum([(x/sumFreq)**2 for x in freq])
\end_layout

\begin_layout Plain Layout

    # save the result to the population.
\end_layout

\begin_layout Plain Layout

    pop.dvars().ne = ne
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When it is needed to calculate effective number of alleles, a Python operator
 that uses this function can be used.
 For example, operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(func=ne, param=[0], step=5)
\end_layout

\begin_layout Plain Layout

pyEval(r'"%.3f" % ne[0]', step=5)
\end_layout

\end_inset

would calculate effective number of alleles at locus 0 and output it.
 
\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOperator
\family default
 is that 
\family typewriter
pyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the variables explicitly using the 
\family typewriter
pop.dvars()
\family default
 function, and the results have to be explicitly saved to the population's
 local namespace.
\end_layout

\begin_layout Standard
The final implementation, as a way to demonstrate how to define a new statistics
 that hides all the details, defines a new operator by inheriting a class
 from 
\family typewriter
pyOperator
\family default
.
 The resulting operator could be used as a regular operator (e.g., 
\family typewriter
ne(loci=[0])
\family default
).
 A function 
\family typewriter
Ne
\family default
 is also defined as the function form of this operator.
 The code is listed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichStat"

\end_inset

 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichStat.log"
lstparams "caption={A customized operator to calculate effective number of alleles},label={reichStat}"

\end_inset


\end_layout

\begin_layout Section
Initialize and evolve the population
\end_layout

\begin_layout Standard
With appropriate operators to perform mutation, selection and output statistics,
 it is relatively easy to write a simulator to perform a simulation.
 This simulator would create a population, initialize alleles with an initial
 allic spectrum, and then evolve it according to specified demographic model.
 During the evolution, mutation and selection will be applied, statistics
 will be calculated and outputed.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichEvolve.log"
lstparams "caption={Evolve a population subject to mutation and selection},label={reichEvolve}"

\end_inset


\end_layout

\begin_layout Section
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to 
\end_layout

\begin_layout Enumerate
Run more simulations with different parameters such as initial population
 size and mutaion rate.
 This requires the script to get its parameters from command line (or a
 configuration file) and executes in batch mode, perhaps on a cluster system.
\end_layout

\begin_layout Enumerate
Allow users who are not familiar with the script to run it.
 This would better be achieved by a graphical user interface.
\end_layout

\begin_layout Enumerate
Allow other Python scripts to import your script and run the simulation
 function directly.
\end_layout

\begin_layout Standard
Although a number of Python modules such as 
\family typewriter
getopt
\family default
 are available, the simuPOP 
\family typewriter
simuOpt
\family default
 module is especially designed to allow a simuPOP script to be run both
 in batch and in GUI mode, in standard and optimized mode.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich"

\end_inset

 makes use of this module.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuCDCV.py"
lstparams "caption={A complete simulation script},label={reich}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich"

\end_inset

 uses a programming style that is used by almost all simuPOP scripts.
 I highly recommend this style because it makes your script seld-documentary
 and work well under a variety of environments.
 A script written in this style follows the following order:
\end_layout

\begin_layout Enumerate
First comment block
\end_layout

\begin_deeper
\begin_layout Standard
The first line of the script should always be 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\end_inset

This line tells a Unix shell which program should be used to process this
 script if the script to set to be executable.
 This line is ignored under windows.
 It is customary to put author and date information at the top of a script
 as Python comments.
\end_layout

\end_deeper
\begin_layout Enumerate
Module doc string
\end_layout

\begin_deeper
\begin_layout Standard
The first string in a script is the module docstring, which can be referred
 by variable 
\family typewriter
__doc__
\family default
 in the script.
 It is a good idea to describe what this script does in detail here.
 As you will see later, this docstring will be used in the 
\family typewriter
simuOpt.getParam()
\family default
 function and be outputed in the usage information of the script.
\end_layout

\end_deeper
\begin_layout Enumerate
Loading simuPOP and other Python modules
\end_layout

\begin_deeper
\begin_layout Standard
simuPOP and other modules are usually imported after module docstring.
 This is where you specify which simuPOP module to use.
 Although a number of parameters could be used, usually only 
\family typewriter
alleleType
\family default
 is specified because other parameters such as 
\family typewriter
gui
\family default
 and 
\family typewriter
optimized
\family default
 should better be controlled from command line.
\end_layout

\end_deeper
\begin_layout Enumerate
Parameter description list
\end_layout

\begin_deeper
\begin_layout Standard
A list of parameter description dictionaries are given here.
 This list specifies what parameters will be used in this script and describes
 the type, default value, name of command line option, label of the parameter
 in the parameter input dialog in detail.
 Although some directionary items can be ignored, it is a good practice
 to give detailed information about each parameter here.
\end_layout

\end_deeper
\begin_layout Enumerate
Helper functions and classes
\end_layout

\begin_deeper
\begin_layout Standard
Helper functions and classes are given before the main simulation function.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation function
\end_layout

\begin_deeper
\begin_layout Standard
The main simulation function preforms the main functionality of the whole
 script.
 It is written as a function so that it can be imported and executed by
 another script.
 The parameter processing part of the script would be ignored in this case.
\end_layout

\end_deeper
\begin_layout Enumerate
Script execution part conditioned by 
\family typewriter
__name__ == '__main__'
\end_layout

\begin_deeper
\begin_layout Standard
The execution part of a script should always be inside of a 
\family typewriter
if __name__ == '__main__'
\family default
 block so that the script will not be executed when it is imported by another
 script.
 The first few lines of this execution block are almost always
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

par = simuOpt.simuOpt(options, __doc__)
\end_layout

\begin_layout Plain Layout

if not par.getParam():
\end_layout

\begin_layout Plain Layout

    sys.exit(1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which creates a simuOpt object and tries to get parameters from command
 line option, a configuration file, a parameter input dialog or interactive
 user input, depending on how this script is executed.
 Optionally, you can use
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

par.saveConfig('file.cfg')
\end_layout

\end_inset

to save the current configuration to a file so that the same parameters
 could be retrieved later using parameter 
\family typewriter
--config file.cfg
\family default
.
\end_layout

\begin_layout Standard
After simply parameter validation, the main simulation function can be called.
 This example uses 
\family typewriter
simuCDCV(*par.asList())
\family default
 because the parameter list in the 
\family typewriter
par
\family default
 object match the parameter list of function 
\family typewriter
simuCDCV
\family default
 exactly.
 If there are a large number of parameters, it may be better to pass the
 
\family typewriter
simuOpt
\family default
 object directly in the main simulation function.
\end_layout

\end_deeper
\begin_layout Standard
The script written in this style could be executed in a number of ways.
\end_layout

\begin_layout Enumerate
If a user executes the script directly, a Tkinter or wxPython dialog will
 be displayed for users to input parameters.
 This parameter is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simuCDCV-dialog"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:simuCDCV-dialog"

\end_inset

Parameter input dialog of the simuCDCV script
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/simuCDCV.png
	lyxscale 40
	width 5in

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The help message of this script could be displayed using the Help button
 of the parameter input dialog, or using command 
\family typewriter
simuCDCV.py -h
\family default
.
 The help message is displayed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichHelp"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuCDCV.hlp"
lstparams "caption={Help information for the simuCDCV script},label={reichHelp}"

\end_inset


\end_layout

\begin_layout Enumerate
Using parameter 
\family typewriter
--gui=False
\family default
, the script will be run in batch mode.
 You can specify parameters using
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuCDCV.py --gui=False --config file.cfg
\end_layout

\end_inset

if a parameter file is available, or use command line options such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuCDCV.py --gui=False --demo='instant' --N0=10000 --N1=100000 
\backslash

\end_layout

\begin_layout Plain Layout

    --G0=500 --G1=500 --spec='[0.9]+[0.02]*5' --s=0.01 
\backslash

\end_layout

\begin_layout Plain Layout

    --mu='1e-4' --k=200
\end_layout

\end_inset

Note that parameters with 
\family typewriter
useDefault
\family default
 set to 
\family typewriter
True
\family default
 can be ignored if the default parameter is used.
 In addition, parameter 
\family typewriter
--optimized
\family default
 could be used to load the optimized version of a simuPOP module.
 For this particular configuration, the optimized module is 30% faster (62s
 vs.
 40s) than the standard module.
\end_layout

\begin_layout Enumerate
The simulation function could be imported to another script as follows
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuCDCV import simuCDCV
\end_layout

\begin_layout Plain Layout

simuCDCV(model='instant', N0=10000, N1=10000, G0=500, G1=500,
\end_layout

\begin_layout Plain Layout

    spec=[0.9]+[0.02]*5, s=0.01, mu=1e-4, k=200)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "simuPOP"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
