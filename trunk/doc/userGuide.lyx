#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 1.1.2 (\mbox{Rev: 4827})}
% file revision $Rev: 3372$
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand{\lstlistlistingname}{List of Examples}
\renewcommand{\lstlistingname}{Example}

\sloppy

\definecolor{TitleColor}{rgb}{0.126,0.263,0.361}
\definecolor{LinkColor}{rgb}{0.208,0.374,0.486}
\definecolor{VerbatimColor}{rgb}{0,0,0}
\definecolor{VerbatimBackgroundColor}{rgb}{0.98,0.941,0.902}
\definecolor{VerbatimBorderColor}{rgb}{0,0,0}
\definecolor{VerbatimStringColor}{rgb}{0,0.5,0}
\definecolor{VerbatimCommentColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimPromptColor}{rgb}{0.588,0.098,0.054}

\usepackage{sectsty}
\sectionfont{\color{TitleColor}}
\subsectionfont{\color{TitleColor}}
\subsubsectionfont{\color{TitleColor}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter beramono
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 70

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "simuPOP User's Guide"
\pdf_author "Bo Peng"
\pdf_keywords "simuPOP"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=TitleColor,urlcolor=LinkColor"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "alsoletter={>.},backgroundcolor={\color{VerbatimBackgroundColor}},basicstyle={\ttfamily\color{VerbatimColor}},commentstyle={\small\color{VerbatimCommentColor}\slshape},emph={[2]>>>,...},emphstyle={[2]\color{VerbatimPromptColor}\bf},language=Python,otherkeywords={>>>,...},showspaces=false,showstringspaces=false,showtabs=false,stringstyle={\color{VerbatimStringColor}},xleftmargin=10pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{7.5in} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2008 Bo Peng 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a general-purpose individual-based forward-time population genetics
 simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and Population/subpopulation size
 changes.
 In contrast to competing applications that use command-line options or
 configuration files to direct the execution of a limited number of predefined
 evolutionary scenarios, users of simuPOP’s scripting interface could make
 use of many of its unique features, such as customized chromosome types,
 arbitrary nonrandom mating schemes, virtual subpopulations, information
 fields and Python operators, to construct and study almost arbitrarily
 complex evolutionary scenarios.
 
\end_layout

\begin_layout Abstract
simuPOP is provided as a number of Python modules, which consist of a large
 number of Python objects and functions, including population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, an increasing number of functions and scripts
 contributed by simuPOP users is available in the online simuPOP cookbook.
 They provide useful functions for different applications (e.g.
 load and manipulate HapMap samples, import and export files from another
 application) and allow users who are unfamiliar with simuPOP to perform
 a large number of simulations ranging from basic population genetics models
 to generating datasets under complex evolutionary scenarios.
\end_layout

\begin_layout Abstract
This user's guide shows you how to install and use simuPOP using a large
 number of examples.
 It describes all important concepts and features of simuPOP and demonstrates
 how to use them in a simuPOP script.
 Although the new Python 3.x releases are incompatible with Python 2.x, examples
 in this book are written in a style that is compatible with both versions
 of Python.
 For a complete and detailed description about all simuPOP functions and
 classes, please refer to the 
\emph on
simuPOP Reference Manual
\emph default
.
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP:
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
 (18): 3686-3687
\end_layout

\begin_layout Quote
Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
 mating populations using simuPOP.
 
\emph on
bioinformatics
\emph default
, 
\series bold
24
\series default
 (11) 1408-1409.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
All examples and some figures of this documents are generated from doc/userGuide.
py using command 'runSampleCode.py userGuide.py'.
 Individual examples and their session files are available in directory
 doc/log.
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard
simuPOP is a 
\series bold
general-purpose individual-based forward-time population genetics simulation
 environment
\series default
 based on Python, a dynamic object-oriented programming language that has
 been widely used in biological studies.
 More specifically,
\end_layout

\begin_layout Itemize
simuPOP is a 
\series bold
population genetics simulator
\series default
 that simulates the evolution of populations.
 It uses a discrete generation model although overlapping generations could
 be simulated using nonrandom mating schemes.
 
\end_layout

\begin_layout Itemize
simuPOP explicitly models 
\series bold
populations with individuals
\series default
 who have their own genotype, sex, and auxiliary information such as age.
 The evolution of a population is modeled by populating an offspring population
 from parents in the parental population.
\end_layout

\begin_layout Itemize
Unlike coalescent-based programs, simuPOP evolves populations 
\series bold
forward in time
\series default
, subject to arbitrary number of genetic and environmental forces such as
 mutation, recombination, migration and Population/subpopulation size changes.
\end_layout

\begin_layout Itemize
simuPOP is a 
\series bold
general-purpose
\series default
 simulator that is designed to simulate arbitrary evolutionary processes.
 In contrast to competing applications that use command-line options or
 configuration files to direct the execution of a limited number of predefined
 evolutionary scenarios, users of simuPOP’s scripting interface could make
 use of many of its unique features, such as customized chromosome types,
 arbitrary nonrandom mating schemes, virtual subpopulations, information
 fields and Python operators, to construct and study almost arbitrarily
 complex evolutionary scenarios.
 In addition, because simuPOP provides a large number of functions to manipulate
 populations, it can be used as an data manipulatation and analysis tool.
\end_layout

\begin_layout Standard
simuPOP is provided as a number of Python modules, which consist of a large
 number of Python objects and functions, including Population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, an increasing number of functions and scripts
 contributed by simuPOP users is available in the online simuPOP cookbook
 (
\family typewriter
http://simupop.sourceforge.net/cookbook
\family default
).
 They provide useful functions for different applications (e.g.
 load and manipulate HapMap samples, import and export files from another
 application) and allow users who are unfamiliar with simuPOP to perform
 a large number of simulations ranging from basic population genetics models
 to generating datasets under complex evolutionary scenarios.
\end_layout

\begin_layout Section
An overview of simuPOP concepts
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
population
\series default
 consists of 
\series bold
individuals
\series default
 of the same 
\series bold
genotype structure
\series default
, which includes properties such as number of homologous sets of chromosomes
 (ploidy), number of chromosomes, and names and locations of markers on
 each chromosome.
 In addition to basic information such as genotypes and sex, individuals
 can have arbitray auxillary values as 
\series bold
information fields
\series default
.
 Individuals in a population can be divided into 
\series bold
subpopulations
\series default
 that can be further grouped into 
\series bold
virtual subpopulations
\series default
 according to individual properties such as sex, affection status, or arbitrary
 auxiliary information such as age.
 Whereas subpopulations define boundaries of individuals that restrict the
 flow of individuals and their genotypes (mating happens within subpopulations),
 virtual subpopulations are groups of individuals who share the same properties,
 with membership of individuals change easily with change of individual
 properties.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:life-cycle"

\end_inset

A life cycle of an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/evolve.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Illustration of the discrete-generation evolutionary model used by simuPOP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators
\series default
 are Python objects that act on a population.
 They can be applied to a population before or after mating during a life
 cycle of an evolutionary process (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), or to parents and offspring during the production of each offspring.
 Arbitrary numbers of operators can be applied to an evolving population.
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
mating scheme
\series default
 is responsible for choosing parent or parents from a parental (virtual)
 subpopulation and for populating an offspring subpopulation.
 simuPOP provides a number of pre-defined 
\series bold
homogeneous mating schemes
\series default
, such as random, monogamous or polygamous mating, selfing, and haplodiploid
 mating in hymenoptera.
 More complicated nonrandom mating schemes such as mating in age-structured
 populations can be constructed using 
\series bold
heterogeneous mating schemes
\series default
, which applies multiple homogeneous mating schemes to different (virtual)
 subpopulations.
\end_layout

\begin_layout Standard
simuPOP evolves a population generation by generation, following the evolutionar
y cycle depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

.
 Briefly speaking, a number of 
\series bold
operators
\series default
 such as a 
\family typewriter
KAlleleMutator
\family default
 are applied to a population before a mating scheme repeatedly chooses a
 parent or parents to produce offspring.
 
\series bold
During-mating operators
\series default
 such as 
\family typewriter
Recombinator
\family default
 can be applied by a mating scheme to transmit parental genotype to offspring.
 After an offspring population is populated, other 
\series bold
operators
\series default
 can be applied, for example, to calculate and output population statistics.
 The offspring population will then become the parental population of the
 next evolutionary cycle.
 Many simuPOP operators can be applied in different stages so the type of
 an operator is determined by the stage at which it is applied.
 Several populations, or replicates of a single population, could form a
 
\series bold
simulator
\series default
 and evolve together.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simpleExample.log"
lstparams "caption={A simple example},label={simple-example}"

\end_inset


\end_layout

\begin_layout Standard
Some of these concepts are demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, where a standard diploid Wright-Fisher model with recombination is simulated.
 The first line imports the standard simuPOP module.
 The second line creates a diploid population with 1000 individuals, each
 having one chromosome with two loci.
 The 
\family typewriter
evolve()
\family default
 function evolves the population using a random mating scheme and four operators.
\end_layout

\begin_layout Standard
Operators 
\family typewriter
InitSex
\family default
 and 
\family typewriter
InitGenotype
\family default
 are applied at the beginning of the evolutionary process.
 Operator 
\family typewriter
InitSex
\family default
 initializes individual sex randomly and 
\family typewriter
InitGenotype
\family default
 initializes all individuals with the same genotype 
\family typewriter
12/21
\family default
.
 The populations are then evolved for 100 generations.
 A random mating scheme is used to generate offspring.
 Instead of using the default Mendelian genotype transmitter, a 
\family typewriter
Recombinator
\family default
 (during-mating operator) is used to recombine parental chromosomes with
 the given recombination rate 
\family typewriter
0.01
\family default
 during the generation of offspring.
 The other operators are applied to the offspring generation (post-mating)
 at every 10 generations (parameter 
\family typewriter
step
\family default
).
 Operator 
\family typewriter
Stat
\family default
 calculates linkage disequilibrium between the first and second loci.
 The results of this operator are stored in a local variable space of the
 Population.
 The last operator 
\family typewriter
PyEval
\family default
 outputs calculated linkage disequilibrium values with a trailing new line.
 The result represents the decay of linkage disequilibrium of this population
 at 10 generation intervals.
 The return value of the 
\family typewriter
evolve
\family default
 function, which is the number of evolved generations, is also printed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
simuPOP offers a long list of features, many of which are unique among all
 forward-time population genetics simulation programs.
 The most distinguishing features include:
\end_layout

\begin_layout Enumerate
simuPOP provides three types of modules that use 1, 8 or 32/64 bits to store
 an allele.
 The binary module (1 bit) is suitable for simulating a large number of
 SNP markers, and the long module (32 or 64 bits depending on platform)
 is suitable for simulating some population genetics models such as the
 infinite allele mutation model.
\end_layout

\begin_layout Enumerate
[NEW in simuPOP 1.0.7] simuPOP provides modules to store a large number of
 rare variants in a compressed manner (the mutant module), and to store
 origin of each allele so that it is easy to track allelic lineage during
 evolution.
\end_layout

\begin_layout Enumerate
The core of simuPOP is implemented in C++ which is heavily optimized for
 large-scale simulations.
 simuPOP can be executed in multiple threads with boosted performance on
 modern multi-core CPUs.
 
\end_layout

\begin_layout Enumerate
In addition to autosomes and sex chromosomes, simuPOP supports arbitrary
 types of chromosomes through customizable genotype transmitters.
 Random maternal transmission of mitochondrial DNAs is supported as a special
 case of this feature.
\end_layout

\begin_layout Enumerate
An arbitrary number of float numbers, called 
\series bold
information fields
\series default
, can be attached to individuals of a population.
 For example, information field 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 can be used to track an individual’s parents, and 
\family typewriter
pack_year
\family default
 can be used to simulate an environmental factor associated with smoking.
\end_layout

\begin_layout Enumerate
simuPOP does not impose a limit on the number of homologous sets of chromosomes,
 the size of the genome or populations.
 The size of your simulation is only limited by the physical memory of your
 computer.
\end_layout

\begin_layout Enumerate
During an evolutionary process, a population can hold more than one most-recent
 generation.
 Pedigrees can be sampled from such multi-generation populations.
\end_layout

\begin_layout Enumerate
An operator can be native (implemented in C++) or hybrid (Python-assisted).
 A hybrid operator calls a user-provided Python function to implement arbitrary
 genetic effects.
 For example, a hybrid mutator passes to-be-mutated alleles to a function
 and mutates these alleles according to the returned values.
 
\end_layout

\begin_layout Enumerate
simuPOP provides more than 60 operators that cover all important aspects
 of genetic studies.
 These include mutation (
\emph on
e.g.
 k
\emph default
-allele, stepwise, generalized stepwise and context-sensitive mutation models),
 migration (arbitrary, can create new subpopulation), recombination and
 gene conversion (uniform or nonuniform), selection (single-locus, additive,
 multiplicative or hybrid multi-locus models, support selection of both
 parents and offspring), penetrance (single, multi-locus or hybrid), ascertainme
nt (case–control, affected sibpairs, random, nuclear and large Pedigrees),
 statistics calculation (including but not limited to allele, genotype,
 haplotype, heterozygote number and frequency; linkage disequilibrium measures,
 Hardy-Weinberg test), pedigree tracing, visualization (using R or other
 Python modules) and load/save in simuPOP’s native format and many external
 formats such as Linkage.
\end_layout

\begin_layout Enumerate
Mating schemes can work on virtual subpopulations of a subpopulation.
 For example, positive assortative mating can be implemented by mating individua
ls with similar properties such as ancestry and overlapping generations
 could be simulated by copying individuals acorss generations.
 The number of offspring per mating event can be fixed or can follow a statistic
al distribution.
 
\end_layout

\begin_layout Standard
A number of forward-time simulation programs are available.
 If we exclude early forward-time simulation applications developed primarily
 for teaching purposes, notable forward-time simulation programs include
 
\emph on
easyPOP
\emph default
, 
\emph on
FPG
\emph default
, 
\emph on
Nemo
\emph default
 and 
\emph on
quantiNemo
\emph default
, 
\emph on
genoSIM
\emph default
 and 
\emph on
genomeSIMLA
\emph default
, 
\emph on
FreGene
\emph default
, 
\emph on
GenomePop
\emph default
, 
\emph on
ForwSim
\emph default
, and 
\emph on
ForSim
\emph default
.
 These programs are designed with specific applications and specific evolutionar
y scenarios in mind, and excel in what they are designed for.
 For some applications, these programs may be easier to use than simuPOP.
 For example, using a special look-ahead algorithm, 
\emph on
ForwSim
\emph default
 is among the fastest programs to simulate a standard Wright-Fisher process,
 and should be used if such a simulation is needed.
 However, these programs are not flexible enough to be applied to problems
 outside of their designed application area.
 For example, none of these programs can be used to study the evolution
 of a disease predisposing mutant, a process that is of great importance
 in statistical genetics and genetic epidemiology.
 Compared to such programs, simuPOP has the following advantages:
\end_layout

\begin_layout Itemize
The scripting interface gives simuPOP the flexibility to create arbitrarily
 complex evolutionary scenarios.
 For example, it is easy to use simuPOP to explicitly introduce a disease
 predisposing mutant to an evolving population, trace the allele frequency
 of them, and restart the simulation if they got lost due to genetic drift.
\end_layout

\begin_layout Itemize
The Python interface allows users to define customized genetic effects in
 Python.
 In contrast, other programs either do not allow customized effects or force
 users to modify code at a lower (e.g.
 C++) level.
\end_layout

\begin_layout Itemize
simuPOP is the only application that embodies the concept of virtual subpopulati
on that allows evolutions at a finer scale.
 This is required for realistic simulations of complex evolutionary scenarios.
\end_layout

\begin_layout Itemize
simuPOP allows users to examine an evolutionary process very closely because
 all simuPOP objects are Python objects that can be assessed using their
 member functions.
 For example, users can keep track of genotype at particular loci during
 evolution.
 In contrast, other programs work more or less like a black box where only
 limited types of statistics can be outputted.
\end_layout

\begin_layout Section
License, Distribution and Installation
\end_layout

\begin_layout Standard
simuPOP is distributed under a GPL license and is hosted at
\family typewriter
 http://simupop.sourceforge.net
\family default
, the world's largest development and download repository of Open Source
 code and applications.
 simuPOP is available on any platform where Python is available, and is
 currently tested under both 32 and 64 bit versions of Windows (Windows
 2000 and later), Linux (Redhat and Ubuntu), MacOS X and Sun Solaris systems.
 Different C++ compilers such as Microsoft Visual C++, gcc and Intel icc
 are supported under different operating systems.
 Standard installation packages are provided for Windows, Linux, and MacOS
 X systems.
\end_layout

\begin_layout Standard
If a binary distribution is unavailable for a specific platform, it is usually
 easy to compile simuPOP from source, following the standard 
\family typewriter

\begin_inset Quotes eld
\end_inset

python setup.py install
\begin_inset Quotes erd
\end_inset


\family default
 procedure.
 Please refer to the 
\family typewriter
installation
\family default
 section of the simupop website for instructions for specific platforms
 and compilers.
\end_layout

\begin_layout Standard
simuPOP is available for Python 2.4 and later, including the new Python 3.x
 releases.
 Although Python 3 is incompatible with Python 2 in many ways, examples
 in this guide are written in a style that is compatible with both versions
 of Python.
 Some non-classic usages include the use of 
\family typewriter
a//b
\family default
 instead of 
\family typewriter
a/b
\family default
 for floored division and 
\family typewriter
list(range(3))
\family default
 instead of 
\family typewriter
range(3)
\family default
 for sequece 
\family typewriter
[0,1,2]
\family default
 In particular, we use 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print("Population size is %d" % size)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print "Population size is %d" % size
\end_layout

\end_inset

 to output strings because the former is valid in Python 2.x (print a tuple
 with one element) and will generate the same output in Python 3.x.
 Of course, users of simuPOP can choose to use other styles.
\end_layout

\begin_layout Standard
Thanks to the ‘glue language’ nature of Python, it is easy to inter-operate
 with other applications within a simuPOP script.
 For example, users can call any R function from Python/simuPOP for the
 purposes of visualization and statistical analysis, using 
\family typewriter
R
\family default
 and a Python module 
\family typewriter
RPy
\family default
.
 Because simuPOP utility modules such as 
\family typewriter
simuPOP.plotter
\family default
 and 
\family typewriter
simuPOP.sampling
\family default
 makes use of 
\family typewriter
R
\family default
 and 
\family typewriter
rpy
\family default
 (not 
\family typewriter
rpy2
\family default
) to plot figures, 
\series bold
it is hihgly recommended that you install R and RPy with simuPOP
\series default
.
 In addition, although simuPOP uses the standard 
\family typewriter
Tkinter
\family default
 GUI toolkit when a graphical user interface is needed, it can make use
 of a 
\family typewriter
wxPython
\family default
 toolkit if it is available.
\end_layout

\begin_layout Section
How to read this user's guide
\end_layout

\begin_layout Standard
This user's guide describes all simuPOP features using a lot of examples.
 The first few chapters describes all classes in the simuPOP core.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:simuPOP-Operators"

\end_inset

 describes almost all simuPOP operators, divided largely by genetic models.
 Features listed in these two chapters are generally implemented at the
 C++ level and are provided through the 
\family typewriter
simuPOP
\family default
 module.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Utility-Modules"

\end_inset

 describes features that are provided by various simuPOP utility modules.
 These modules provide extensions to the simuPOP core that improves the
 usability and userfriendliness of simuPOP.
 The next chapter (Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

) demonstrates how to write a script to solve a real-world simulation problem.
 Because some sections describe advanced features that are only used in
 the construction of highly complex simulations, or implementation details
 that concern only advanced users, new simuPOP users can safely skip these
 sections.
 
\series bold
Sections that describe advanced topics are marked by one or two asterisks
 (*) after the section
\series default
 
\series bold
titles
\series default
.
\end_layout

\begin_layout Standard
simuPOP is a comprehensive forward-time population genetics simulation environme
nt with many unique features.
 If you are new to simuPOP, you can go through this guide quickly and understand
 what simuPOP is and what features it provides.
 Then, you can read Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:A-real-example"

\end_inset

 and learn how to apply simuPOP in real-world problems.
 After you play with simuPOP for a while and start to write simple scripts,
 you can study relevant sections in details.
 The 
\emph on
simuPOP reference manual
\emph default
 will become more and more useful when the complexity of your scripts grows.
\end_layout

\begin_layout Standard
Before we dive into the details of simuPOP, it is helpful to know a few
 name conventions that simuPOP tries to follow.
 Generally speaking,
\end_layout

\begin_layout Itemize
All class names use the CapWords convention (e.g.
 
\family typewriter
Population()
\family default
, 
\family typewriter
InitSex()
\family default
) .
\end_layout

\begin_layout Itemize
All standalone functions (e.g.
 
\family typewriter
loadPopulation()
\family default
 and 
\family typewriter
initSex()
\family default
), member functions (e.g.
 
\family typewriter
Population.mergeSubPops()
\family default
) and parameter names use the mixedCases style.
\end_layout

\begin_layout Itemize
Constants are written in all capital characters with underscores separating
 words (e.g.
 
\family typewriter
CHROMOSOME_X
\family default
, 
\family typewriter
UNIFORM_DISTRIBUTION
\family default
).
 Their names instead of their actual values should be used because those
 values can change without notice.
\end_layout

\begin_layout Itemize
simuPOP uses the abbreviated form of the following words in function and
 parameter names:
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
pop
\family default
 (population), 
\family typewriter
pops
\family default
 (populations), 
\family typewriter
pos
\family default
 (position),  
\family typewriter
info
\family default
 (information), 
\family typewriter
migr
\family default
 (migration), 
\family typewriter
subPop
\family default
 (subpopulation and virtual subpopulation), 
\family typewriter
subPops
\family default
 (subpopulations and virtual subpopulations), 
\family typewriter
rep
\family default
 (replicates), 
\family typewriter
gen
\family default
 (generation), 
\family typewriter
ops
\family default
 (operators), 
\family typewriter
expr
\family default
 (expression), 
\family typewriter
stmts
\family default
 (statements).
\end_layout

\end_deeper
\begin_layout Itemize
simuPOP uses both singular and plural forms of parameters, according to
 the following rules:
\end_layout

\begin_deeper
\begin_layout Itemize
If a parameter only accept a single input, singular names such as 
\family typewriter
field
\family default
, 
\family typewriter
locus
\family default
, 
\family typewriter
value
\family default
, and 
\family typewriter
name
\family default
 are used.
\end_layout

\begin_layout Itemize
If a parameter accepts a list of values, plural names such as 
\family typewriter
fields
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
values
\family default
 and 
\family typewriter
names
\family default
 are used.
 
\series bold
Such parameters usually accept single inputs.

\series default
 For example, 
\family typewriter
loci=1
\family default
 can be used as a shortcut for 
\family typewriter
loci=[1]
\family default
 and 
\family typewriter
infoFields='x'
\family default
 can be used as a shortcut for 
\family typewriter
infoFields=['x']
\family default
.
\end_layout

\begin_layout Standard
The same rules also hold for function names.
 For example, 
\family typewriter
Population.addInfoFields()
\family default
 accept a list of information fields but 
\family typewriter
pop.addInfoFields('field')
\family default
 is also acceptable.
 
\end_layout

\end_deeper
\begin_layout Section
Other help sources
\end_layout

\begin_layout Standard
If you are new to Python, it is recommended that you borrow a Python book,
 or at least go through the following online Python tutorials:
\end_layout

\begin_layout Enumerate
The Python tutorial (
\family typewriter
http://docs.python.org/tut/tut.html
\family default
)
\end_layout

\begin_layout Enumerate
Other online tutorials listed at 
\family typewriter
http://www.python.org/doc/
\end_layout

\begin_layout Standard
If you are new to simuPOP, please read this guide before you dive into 
\emph on
the simuPOP reference manual
\emph default
, which describes all the details of simuPOP but does not show you how to
 use them.
 Both documents are available online at 
\family typewriter
http://simupop.sourceforge.net
\family default
 in both searchable HTML format and PDF format.
\end_layout

\begin_layout Standard
A 
\emph on
simuPOP online cookbook
\emph default
 (
\family typewriter
http://simupop.sourceforge.net
\family default
/
\family typewriter
cookbook
\family default
) is a wiki-based website where you can browse and download examples, functions
 and scripts for various simulation scenarios, and upload your own code
 snippets for the benefit of all simuPOP users.
 Please consider contributing to this cookbook if you have written some
 scripts that might be useful to others.
\end_layout

\begin_layout Standard
If you cannot find the answer you need, or if you believe that you have
 encountered a bug, or if you would like to request a feature, please subscribe
 to the simuPOP mailinglist (
\family typewriter
simupop-list@lists.sourceforge.net
\family default
) and send your questions there.
\end_layout

\begin_layout Chapter
Loading and running simuPOP
\end_layout

\begin_layout Section
Pythonic issues
\end_layout

\begin_layout Subsection

\family typewriter
from simuPOP import
\family default
 * v.s.
 
\family typewriter
import simuPOP
\end_layout

\begin_layout Standard
Generally speaking, it is recommended to use 
\family typewriter
import simuPOP
\family default
 rather than 
\family typewriter
from simuPOP import *
\family default
 to import a simuPOP module.
 That is to say, instead of using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuPOP import *
\end_layout

\begin_layout Plain Layout

pop = Population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

simu = Simulator(pop, RandomMating())
\end_layout

\end_inset

it is recommended that you use simuPOP like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import simuPOP
\end_layout

\begin_layout Plain Layout

pop = simuPOP.Population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

simu = simuPOP.Simulator(pop, simuPOP.RandomMating())
\end_layout

\end_inset

The major problem with 
\family typewriter
from simuPOP import *
\family default
 is that it imports all simuPOP symbols to the global namespace and increases
 the likelihood of name clashes.
 For example, if you import a module 
\family typewriter
myModule
\family default
 after simuPOP, which happens to have a variable named 
\family typewriter
MALE
\family default
, the following code might lead to a 
\family typewriter
TypeError
\family default
 indicating your input for parameter sex is wrong.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuPOP import *
\end_layout

\begin_layout Plain Layout

from myModule import *
\end_layout

\begin_layout Plain Layout

pop = Population(size=100, loci=[5])
\end_layout

\begin_layout Plain Layout

initSex(pop, sex=[MALE, FEMALE])
\end_layout

\end_inset

It can be even worse if the definition of 
\family typewriter
MALE
\family default
 is changed to a different value of the same type (e.g.
 to 
\family typewriter
FEMALE
\family default
) and your simulation might produce erroranous result without a hint.
\end_layout

\begin_layout Standard
For the sake of brevity, all examples in this user's guide use 
\family typewriter
import simuPOP as sim
\family default
 as an alternative form of the 
\family typewriter
import simuPOP
\family default
 style.
 This saves some keystrokes by referring simuPOP functions as 
\family typewriter
sim.Population()
\family default
 instead of 
\family typewriter
simuPOP.Population()
\family default
.
 Note that simuPOP has a number of submodules, which are not imported by
 default.
 The recommended syntax to load these modules is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# import and use submodule simuPOP.utils
\end_layout

\begin_layout Plain Layout

from simuPOP import utils
\end_layout

\begin_layout Plain Layout

utils.simulateBackwardTrajectory(N=1000, endGen=100, endFreq=0.1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
References and the 
\family typewriter
clone() 
\family default
member function
\end_layout

\begin_layout Standard
Assignment in Python only creates a new reference to an existing object.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop = Population()
\end_layout

\begin_layout Plain Layout

pop1 = pop
\end_layout

\end_inset

creates a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well and the removal of 
\family typewriter
pop
\family default
 will invalidate 
\family typewriter
pop1
\family default
.
 For example, a reference to the first Population in a simulator is returned
 from function 
\family typewriter
func()
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-Population"

\end_inset

.
 The subsequent use of this 
\family typewriter
pop
\family default
 object may crash simuPOP because the simulator 
\family typewriter
simu
\family default
 is destroyed, along with all its internal populations, after 
\family typewriter
func()
\family default
 is finished, leaving 
\family typewriter
pop
\family default
 referring to an invalid object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Reference-to-Population"

\end_inset

Reference to a population in a simulator
\end_layout

\end_inset

def func():
\end_layout

\begin_layout Plain Layout

    simu = Simulator(Population(10), RandomMating(), rep=5)
\end_layout

\begin_layout Plain Layout

    # return a reference to the first Population in the simulator
\end_layout

\begin_layout Plain Layout

    return simu.population(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pop = func()
\end_layout

\begin_layout Plain Layout

# simuPOP will crash because pop refers to an invalid Population.
\end_layout

\begin_layout Plain Layout

pop.popSize()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to have an independent copy of a population, you can use
 the 
\family typewriter
clone()
\family default
 member function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-Population"

\end_inset

 would behave properly if the 
\family typewriter
return
\family default
 statement is replaced by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.population(0).clone()
\end_layout

\end_inset

although in this specific case, extracting the first population from the
 simulator using the 
\family typewriter
extract
\family default
 function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.extract(0)
\end_layout

\end_inset

would be more efficient.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
clone()
\family default
 function exists for all simuPOP classes (objects) such as 
\emph on
simulator
\emph default
, 
\emph on
mating schemes
\emph default
 and 
\emph on
operators
\emph default
.
 simuPOP also supports the standard Python shallow and deep copy operations
 so you can also make a cloned copy of 
\family typewriter
pop
\family default
 using the 
\family typewriter
deepcopy
\family default
 function defined in the Python 
\family typewriter
copy
\family default
 module
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy
\end_layout

\begin_layout Plain Layout

pop1 = copy.deepcopy(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zero-based indexes, absolute and relative indexes
\end_layout

\begin_layout Standard

\series bold
All arrays in simuPOP start at index 0
\series default
.
 This conforms to Python and C++ indexes.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as Individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the 
\emph on
absolute index
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and 
\emph on
relative index
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 of a locus.
 The former index ignores chromosome structure.
 For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two chromosomes are (0, 1, 2, 3, 4), (5, 6, 7,
 8, 9, 10, 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3,
 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(idx)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 An individual can also be referred by its 
\emph on
absolute index
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset

 and 
\emph on
relative index
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 where 
\emph on
relative index
\emph default
 is the index in its subpopulation.
 Related member functions are 
\family typewriter
subPopIndPair(idx)
\family default
 and 
\family typewriter
absIndIndex(idx, subPop)
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "absIndex"

\end_inset

 demonstrates the use of these functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/absIndex.log"
lstparams "caption={Conversion between absolute and relative indexes},label={absIndex}"

\end_inset


\end_layout

\begin_layout Subsection
Ranges and iterators
\end_layout

\begin_layout Standard
Ranges in simuPOP also conform to Python ranges.
 That is to say, a range has the form of 
\family typewriter
[a,b) 
\family default
where 
\family typewriter
a 
\family default
belongs to the range, and 
\family typewriter
b 
\family default
does not.
 For example, 
\family typewriter
pop.chromBegin(1) 
\family default
refers to the index of the first locus on chromosome 1 (actually exists),
 and 
\family typewriter
pop.chromEnd(1) 
\family default
refers to the index of the last locus on chromosome 1 
\series bold
plus 1
\series default
, which might or might not be a valid index.
\end_layout

\begin_layout Standard
A number of simuPOP functions return Python iterators that can be used to
 iterate through an internal array of objects.
 For example, 
\family typewriter
Population.Individuals([subPop])
\family default
 returns an iterator iterates through all individuals, or all individuals
 in a (virtual) subpoulation.
 
\family typewriter
Simulator.populations()
\family default
 can be used to iterate through all populations in a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterator"

\end_inset

 demonstrates the use of ranges and iterators in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/iterator.log"
lstparams "caption={Ranges and iterators},label={iterator}"

\end_inset


\end_layout

\begin_layout Subsection
Empty, 
\family typewriter
ALL_AVAIL
\family default
 and dynamic values for parameters 
\family typewriter
loci
\family default
, 
\family typewriter
reps
\family default
, 
\family typewriter
ancGen
\family default
 and 
\family typewriter
subPops
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
loci
\family default
, 
\family typewriter
reps
\family default
 and 
\family typewriter
subPops
\family default
 are widely used in simuPOP to specify which loci, replicates, ancestral
 generations, or (virtual) subpulations a function or operator is applied
 to.
 These parameter accepts a list of indexes such as 
\family typewriter
[1, 2]
\family default
, names such as 
\family typewriter
['a', 'b']
\family default
, and take single form inputs (e.g.
 
\family typewriter
loci=1
\family default
 is equivalent to 
\family typewriter
loci=[1]
\family default
).
 For example,
\end_layout

\begin_layout Itemize

\family typewriter
Recombinator(loci=[])
\family default
 recombine at no locus, and
\end_layout

\begin_layout Itemize

\family typewriter
Recombinator(loci=1)
\family default
 recombine at locus 1
\end_layout

\begin_layout Itemize

\family typewriter
Recombinator(loci=[1,2,4])
\family default
 recombine at loci 1, 2, and 4
\end_layout

\begin_layout Itemize

\family typewriter
Recombinator(loci=[('1', 20), ('1', 25)])
\family default
 recombine at loci with position 
\family typewriter
20
\family default
 and
\family typewriter
 25
\family default
 on chromosome 
\family typewriter
1
\family default
.
 This usage is only available for parameter 
\family typewriter
loci
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
Recombinator(loci=['a2', 'a4'])
\family default
 recombine at loci 
\family typewriter
'a2'
\family default
 and 
\family typewriter
'a4'
\family default
.
\end_layout

\begin_layout Standard
The last method is easier to understand in some cases.
 Moreover, when you use loci names instead of indexes in an operator, this
 operator can be applied to populations with loci at different locations.
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MaSelector(loci='a2', fitness=[1,1.01,1.02])
\end_layout

\end_inset

will be applied to locus 
\family typewriter
a2
\family default
 regardless the actual location of this locus in the population to which
 this operator is applied.
\end_layout

\begin_layout Standard
However, in the majority of the cases, these parameters take a default value
 
\family typewriter
ALL_AVAIL
\family default
 which applies the function or operator to all available loci, replicates
 or subpopulations.
 That is to say, 
\family typewriter
Recombinator()
\family default
 or 
\family typewriter
Recombinator(loci=ALL_AVAIL)
\family default
 will recombine at all applicable loci, which will vary from population
 to population.
 Value 
\family typewriter
UNSPECIFIED
\family default
 is sometimes used as default parameter of these parameters, indicating
 that no value has been specified.
 Similarly, 
\family typewriter
subPops=[0, 'Male']
\family default
 can be used to refer a virtual subpopulation with name 
\family typewriter
'Male'
\family default
, regardless its virtual subpopulation index.
\end_layout

\begin_layout Standard
Besides 
\family typewriter
subPops=ALL_AVAIL
\family default
, which means 
\family typewriter
subPops=[0,1,2,3]
\family default
 for a population with 4 subpopulations, 
\family typewriter
ALL_AVAIL
\family default
 could also be used as 
\family typewriter
subPops=[(ALL_AVAIL, 1)]
\family default
 to specify a specific virtual subpopulation for all subpopulations, or
 
\family typewriter
subPops=[(1, ALL_AVAIL)]
\family default
 or even 
\family typewriter
subPops=[(ALL_AVAIL, ALL_AVAIL)]
\family default
 to specify all virtual subpopulations in specified or all subpopulations.
 This becomes handy when you, for example, would like to list all male individua
ls in a population, regardless of number of subpopulations.
\end_layout

\begin_layout Subsection
User-defined functions and class 
\family typewriter
WithArgs
\family default
 *
\end_layout

\begin_layout Standard
Some simuPOP objects call user-defined functions to perform customized operation
s.
 For example, a penetrance operator can call a user-defined function with
 genotype at specified loci and use its return value to determine the affection
 status of an individual.
\end_layout

\begin_layout Standard
simuPOP uses parameter names to determine which information should be passed
 to such a function.
 For example, a 
\family typewriter
PyOperator
\family default
 will pass a reference to each offspring to a function defined with parameter
 
\family typewriter
off
\family default
 (e.g.
 
\family typewriter
func(off)
\family default
) and references to offspring and his/her parents to a function defined
 with parameters 
\family typewriter
off
\family default
, 
\family typewriter
dad
\family default
, and 
\family typewriter
mom
\family default
 (e.g.
 
\family typewriter
func(off, dad, mom)
\family default
).
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "userFunc"

\end_inset

 defines a function 
\family typewriter
func(geno, smoking)
\family default
 using parameters 
\family typewriter
geno
\family default
 and 
\family typewriter
smoking
\family default
 so operator 
\family typewriter
PyPenetrance
\family default
 will pass genotype at specified loci and value at information field 
\family typewriter
smoking
\family default
 to this function.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/userFunc.log"
lstparams "caption={Use of user-defined Python function in simuPOP},label={userFunc}"

\end_inset


\end_layout

\begin_layout Standard
However, there are circumstances that you do not know the number or names
 of parameters in advance so it is difficult to define such a function.
 For example, your function may use an information field with programmed
 name '
\family typewriter
off
\family default
'
\family typewriter
+str(numOffspring)
\family default
 where 
\family typewriter
numOffspring
\family default
 is a parameter.
 In this case, you can create a wrapper function object using 
\family typewriter
WithArgs(func, args)
\family default
 and list passed arguments in 
\family typewriter
args
\family default
 (e.g.
 
\family typewriter
WithArgs(func, args=['geno', 'off' + str(numOffspring)]
\family default
).
 As long as simuPOP knows which arguments to pass, your function can be
 defined in any format you want (e.g.
 use *args parameters).
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "WithArgs"

\end_inset

 provides such an example.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/WithArgs.log"
lstparams "caption={Specify arguments of user-provided function using function WithArgs},label={WithArgs}"

\end_inset


\end_layout

\begin_layout Subsection
Exception handling * 
\end_layout

\begin_layout Standard
As shown in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

, optimized modules raise less exceptions than standard modules.
 More specifically, the standard modules check for invalid inputs frequently
 and raise exceptions (e.g.
 out of bound loci indexes).
 In constrast, the optimized modules only raise exceptions where proper
 values could not be pre-determined (e.g.
 looking for an individual in a population with an ID).
 
\series bold
Only exceptions that are raised in both types of modules are documented
 in the simuPOP reference manual
\series default
.
\end_layout

\begin_layout Standard
Generally speaking, 
\series bold
you should avoid using exceptions to direct the logic of your script
\series default
 (e.g.
 use a 
\family typewriter
try ...
 except ...

\family default
 statement around a function to find a valid input value).
 Because the optimized modules might not raise these exceptions, such a
 script may crash or yield invalid results when an optimized module is used.
 If you have to use such a structure, please check the reference manual
 and see whether or not an exception will be raised in optimized modules.
\end_layout

\begin_layout Section
Loading simuPOP modules
\end_layout

\begin_layout Subsection
Short, long, binary, mutant and lineage modules and their optimized versions
\end_layout

\begin_layout Standard
There are ten flavors of the core simuPOP module: short, long, binary, mutant,
 and lineage allele modules, and their optimized versions.
 
\end_layout

\begin_layout Itemize
The short allele modules use 
\emph on
8 bits
\emph default
 to store each allele which limits the possible allele states to 256.
 This is enough most of the times so this is the default module of simuPOP.
\end_layout

\begin_layout Itemize
If you need to a large number of allele states to simulate, for example
 the infinite allele model, you should use the long allele version of the
 modules, which use 
\emph on
32 or 64 bits
\emph default
 for each allele and can have 
\begin_inset Formula $2^{32}$
\end_inset

 or 
\begin_inset Formula $2^{64}$
\end_inset

 possible allele states depending on your platform.
\end_layout

\begin_layout Itemize
If you would like to simulate a large number of binary (SNP) markers, binary
 libraries can save you a lot of RAM because they use 
\emph on
1 bit
\emph default
 for each allele.
\end_layout

\begin_layout Itemize
If you are simulating long sequence regions with rare variants, you can
 use the mutant module.
 This module uses compression technology that ignores wildtype alleles and
 is not efficient if you need to traverse all alleles frequently.
 The maximum allele state is 255 for this module.
 Because this module stores location and value of each allele, it uses at
 least 64 + 8 bits for each allele on a 64 bit system.
 The complexity of the storage also prevents simultaneous write access to
 genotypes so this module does not benefit much from running in multi-thread
 mode.
\end_layout

\begin_layout Itemize
If you are interested in tracing the lineage of each allele (e.g.
 the ID of individuals to whom the allele was introduced), you can use the
 lineage module for which each allele is attached with information about
 its origin.
 The maximum allele state is 255 for this module, and the cost of storing
 each allele is 8 (value) + 32 (lineage) bits.
\end_layout

\begin_layout Standard
Despite of differences in internal memory layout, all these modules have
 the same interface, although some functions behave differently in terms
 of functionality and performance.
 
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure a simulation executes correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time validation varies from case to case but can be
 high under some extreme circumstances.
 Because of this, optimized versions for all modules are provided.
 They bypass most parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confident
 that your simulation is running as expected.
\end_layout

\begin_layout Standard
Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 demonstrate the differences between standard and optimized modules, by
 executing two invalid commands.
 A standard module checks all input values and raises exceptions when invalid
 inputs are detected.
 An interactive Python session would catch these exceptions and print proper
 error messages.
 In constrast, an optimized module returns erroneous results and or simply
 crashes when such inputs are given.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/standard.log"
lstparams "caption={Use of standard simuPOP modules},keywords={from,import},label={lst:Use-of-standard-module}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 also demonstrates how to use the 
\family typewriter
setOptions
\family default
 function in the 
\family typewriter
simuOpt
\family default
 module to control the choice of one of the six simuPOP modules.
 By specifying one of the values 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary 
\family default
for option 
\family typewriter
alleleType
\family default
, and setting
\family typewriter
 optimized
\family default
 to 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
, the right flavor of module will be chosen when simuPOP is loaded.
 In addition, option 
\family typewriter
quiet
\family default
 can be used suppress the banner message when simuPOP is loaded.
 An alternative method is to set environmental variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
r
\end_layout

\end_inset

 to 
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
binary
\family default
 to use the standard short, long or binary module, and variable 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules.
 Command line options 
\family typewriter
--optimized
\family default
 can also be used.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Use-of-optimized-module"

\end_inset

Use of optimized simuPOP modules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

% python
\end_layout

\begin_layout Plain Layout

>>> from simuOpt import setOptions
\end_layout

\begin_layout Plain Layout

>>> setOptions(optimized=True, alleleType='long', quiet=True)
\end_layout

\begin_layout Plain Layout

>>> import simuPOP as sim
\end_layout

\begin_layout Plain Layout

>>> pop = sim.Population(10, loci=[2])
\end_layout

\begin_layout Plain Layout

>>> pop.locusPos(10)
\end_layout

\begin_layout Plain Layout

1.2731974748756028e-313
\end_layout

\begin_layout Plain Layout

>>> pop.individual(20).setAllele(1, 0)
\end_layout

\begin_layout Plain Layout

Segmentation fault
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Execution in multiple threads
\end_layout

\begin_layout Standard
simuPOP is capable of executing in multiple threads but it by default only
 makes use of one thread.
 If you have a multi-core CPU, it is often beneficial to set the number
 of threads to 2 or more to take advantage of this feature.
 The recommended number of threads is usually the number of cores of your
 CPU but you might want to set it to a lower number to leave room for the
 execution of other applications.
 The number of threads used in simuPOP can be controlled in the following
 ways:
\end_layout

\begin_layout Itemize
If an environmental variable 
\family typewriter
OMP_NUM_THREADS
\family default
 is set to a positive number, simuPOP will be started with specified number
 of threads.
\end_layout

\begin_layout Itemize
Before simuPOP is imported, you can set the number of threads using function
 
\family typewriter
simuOpt.setOptions(numThreads=x)
\family default
 where 
\family typewriter
x
\family default
 can be a positive number (number of threads) or 
\family typewriter
0
\family default
, which is intepreted as the number of cores available for your computer.
\end_layout

\begin_layout Standard
The number of threads a simuPOP session is used will be displayed in the
 banner message when simuPOP is imported, and can be retrieved through 
\family typewriter
moduleInfo()['threads']
\family default
.
\end_layout

\begin_layout Standard
Although simuPOP can usually benefit from the use of multiple cores, certain
 features of your script might prevent the execution of simuPOP in multiple
 threads.
 For example, if your script uses a sex mode of 
\family typewriter
GLOBAL_SEX_SEQUENCE
\family default
 to set the sex of offspring according to the global sequence of sexes (e.g.
 male, male, female), simuPOP will only use on thread to generate offspring
 because it is not feasible to assign individual sex from a single source
 of list across multiple threads.
 
\end_layout

\begin_layout Subsection
Graphical user interface
\end_layout

\begin_layout Standard
A complete graphical user interface (GUI) for users to interactively construct
 evolutionary processes is still in the planning stage.
 However, some simuPOP classes and functions can make use of a GUI to improve
 user interaction.
 For example, a parameter input dialog can be constructed automatically
 from a parameter specification list, and be used to accept user input if
 class 
\family typewriter
simuOpt.Params
\family default
 is used to handle parameters.
 Other examples include a progress bar 
\family typewriter
simuPOP.utils.ProgressBar
\family default
 and a dialog used by function 
\family typewriter
simuPOP.utils.viewVars
\family default
 to display a large number of variables.
 The most notable feature of the use of GUI in simuPOP is that 
\series bold
all functionalities can be achieved without a GUI
\series default
.
 For examples, 
\family typewriter
simuOpt.getParam()
\family default
 will use a terminal to accept user input interactively and 
\family typewriter
simuPOP.utils.ProgressBar
\family default
 will turn to a text-based progress bar in the non-GUI mode.
\end_layout

\begin_layout Standard
The use of GUI can be controlled either globally or Individually.
 First, a global GUI parameter could be set by environmental variable 
\family typewriter
SIMUGUI
\family default
, function 
\family typewriter
simuOpt.setOptions(gui)
\family default
 or a command line option 
\family typewriter
--gui
\family default
 of a simuPOP scripts.
 Allowed values include
\end_layout

\begin_layout Itemize

\family typewriter
True
\family default
: This is the system default value.
 A GUI is used whenever possible.
 All GUI-capable functions support 
\family typewriter
wxPython
\family default
 so a 
\family typewriter
wxPython
\family default
 dialog will be used if 
\family typewriter
wxPython
\family default
 is available.
 Otherwise, 
\family typewriter
tkInter
\family default
 based dialogs or text-mode will be used.
\end_layout

\begin_layout Itemize

\family typewriter
False
\family default
: no GUI will be used.
 All functions will use text-based implementation.
 Note that 
\family typewriter
--gui=False
\family default
 is commonly used to run scripts in batch mode.
\end_layout

\begin_layout Itemize

\family typewriter
wxPython
\family default
: Force the use of 
\family typewriter
wxPython
\family default
 GUI toolkit.
\end_layout

\begin_layout Itemize

\family typewriter
Tkinter
\family default
: Force the use of 
\family typewriter
Tkinter
\family default
 GUI toolkit.
\end_layout

\begin_layout Standard
Individual classes and functions that could make use a GUI usually have
 their own 
\family typewriter
gui
\family default
 parameters, which can be set to override global GUI settings.
 For example, you could force the use of a text-based progress bar by using
 
\family typewriter
ProgressBar(gui=False)
\family default
.
\end_layout

\begin_layout Section
Online help system
\end_layout

\begin_layout Standard
Most of the help information contained in this document and 
\emph on
the simuPOP reference manual
\emph default
 is available from command line.
 For example, after you install and import the simuPOP module, you can use
 
\family typewriter
help(Population.addInfoField) 
\family default
to view the help information of member function 
\family typewriter
addInfoField
\family default
 of class 
\family typewriter
Population
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/help.log"
lstparams "caption={Getting help using the \\texttt{help()} function},keywordstyle={\\ttfamily}"

\end_inset


\end_layout

\begin_layout Standard
It is important that you understand that
\end_layout

\begin_layout Itemize
The constructor of a class is named 
\family typewriter
__init__
\family default
 in Python.
 That is to say, you should use the following command to display the help
 information of the constructor of class 
\family typewriter
Population
\family default
: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> help(Population.__init__)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some classes are derived from other classes and have access to member functions
 of their base classes.
 For example, class 
\family typewriter
Population
\family default
 and 
\family typewriter
Individual
\family default
 are both derived from class 
\family typewriter
GenoStruTrait
\family default
.
 Therefore, you can use all 
\family typewriter
GenoStruTrait
\family default
 member functions from these classes.
 
\end_layout

\begin_deeper
\begin_layout Standard
In addition, the constructor of a derived class also calls the constructor
 of its base class so you may have to refer to the base class for some parameter
 definitions.
 For example, parameters 
\family typewriter
begin, end, step, at 
\family default
etc are shared by all operators, and are explained in details only in class
 
\family typewriter
BaseOperator.
\end_layout

\end_deeper
\begin_layout Section
Debug-related functions and operators *
\end_layout

\begin_layout Standard
Debug information can be useful when something looks suspicious.
 By turnning on certain debug code, simuPOP will print out some internal
 information before and during evolution.
 Functions 
\family typewriter
turnOnDebug(code)
\family default
 and 
\family typewriter
turnOffDebug(code)
\family default
 could be used to turn on and off some debug information.
\end_layout

\begin_layout Standard
For example, the following code might crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> Population(1, loci=[100]).individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is unclear why this simple command causes us trouble, instead of outputting
 the genotype of the only Individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Turn on/off debug information
\end_layout

\end_inset

>>> turnOnDebug(DBG_POPULATION)
\end_layout

\begin_layout Plain Layout

>>> Population(1, loci=100).individual(0).genotype()
\end_layout

\begin_layout Plain Layout

Constructor of population is called
\end_layout

\begin_layout Plain Layout

Destructor of population is called 
\end_layout

\begin_layout Plain Layout

Segmentation fault (core dumped)
\end_layout

\end_inset


\family typewriter
Population(1, loci=[100])
\family default
 creates a temporary object that is destroyed right after the execution
 of the command.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The correct method to print the genotype is to create a persistent population
 object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> pop = Population(1, loci=[100])
\end_layout

\begin_layout Plain Layout

>>> pop.individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another useful debug code is 
\family typewriter
DBG_WARNING
\family default
.
 When this code is set, it will output warning messages for some common
 misuse of simuPOP.
 For example, it will warn you that population object returned by function
 
\family typewriter
Simulator.population()
\family default
 is a temporary object that will become invalid once a simulator is changed.
 If you are new to simuPOP, it is recommended that you use 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import simuOpt
\end_layout

\begin_layout Plain Layout

simuOpt.setOptions(optimized=False, debug='DBG_WARNING')
\end_layout

\end_inset

 when you develop your script.
\end_layout

\begin_layout Standard
Besides functions 
\family typewriter
turnOnDebug(code) 
\family default
and 
\family typewriter
turnOffDebug(code)
\family default
, you can set environmental variable 
\family typewriter
SIMUDEBUG=code
\family default
 where 
\family typewriter
code
\family default
 is a comma separated debug codes.

\family typewriter
 
\family default
A list of valid debug code could be found in function 
\family typewriter
moduleInfo()['debug']
\family default
.
 Note that debug information is only available in standard (non-optimized)
 modules.
\end_layout

\begin_layout Standard
The amount of output can be overwhelming in some cases which makes it necessary
 to limit the debug information to certain generations, or triggered by
 certain conditions.
 In addition, debugging information may interfere with your regular output
 so you may want to direct such output to another destination, such as a
 dedicated file.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "debug"

\end_inset

 demonstrates how to turn on debug information conditionally and turn it
 off afterwards, using operator 
\family typewriter
PyOperator
\family default
.
 It also demonstrates how to redirect debug output to a file but redefining
 system standard error output.
 Note that 
\begin_inset Quotes eld
\end_inset


\family typewriter
is None
\family default

\begin_inset Quotes erd
\end_inset

 is used to make sure the lamdba functions return 
\family typewriter
True
\family default
 so that the evolutionary process can continue after the python operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/debug.log"
lstparams "caption={Turn on and off debug information during evolution.},label={debug}"

\end_inset


\end_layout

\begin_layout Section
Random number generator *
\end_layout

\begin_layout Standard
When simuPOP is loaded, it creates a default random number generator (
\family typewriter
RNG
\family default
) of type 
\family typewriter
mt19937
\family default
 for each thread.
 It uses a random seed for the first RNG and uses seeds derived from the
 first seed to initialize RNGs for other threads.
 The seed is drawn from a system random number generator that guarantees
 random seeds for all instances of simuPOP even if they are initialized
 at the same time.
 After simuPOP is loaded, you can reset this system RNG with a different
 random number generator (c.f.
 
\family typewriter
moduleInfo()['availableRNGs']
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
moduleInfo
\end_layout

\end_inset

) or use a specified seed using function , 
\family typewriter
setRNG(name, seed)
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
setRNG
\end_layout

\end_inset

.
  
\end_layout

\begin_layout Standard

\family typewriter
getRNG().seed()
\family default
 returns the seed of the simuPOP random number generator.
 It can be used to replay your simulation if 
\family typewriter
getRNG()
\family default
 is your only source of random number generator.
 If you also use the Python 
\family typewriter
random
\family default
 module, it is a good practise to set its seed using 
\family typewriter
random.seed(getRNG().seed())
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomSeed"

\end_inset

 demonstrates how to use these functions to replay an evolutionary process.
 simuPOP uses a single seed to initialize multiple random number generators
 used for different threads (seeds for other threads are determined from
 the first seed) so you only need to save the head seed (
\family typewriter
getRNG().seed()
\family default
)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomSeed.log"
lstparams "caption={Use saved random seed to replay an evolutionary process},label={randomSeed}"

\end_inset


\end_layout

\begin_layout Chapter
Individuals and Populations
\end_layout

\begin_layout Section
Genotypic structure
\begin_inset CommandInset label
LatexCommand label
name "sec:Genotypic-structure"

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
genotypic structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to structural information shared by all individuals
 in a population, including number of homologous copies of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidy
\end_layout

\end_inset

(), ploidyName
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidyName
\end_layout

\end_inset

()
\family default
), chromosome types and names (c.f.
 
\family typewriter
numChrom
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numChrom
\end_layout

\end_inset

(), chromType()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromType
\end_layout

\end_inset

, chromName
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromName
\end_layout

\end_inset

()
\family default
), position and name of each locus (c.f.
 
\family typewriter
numLoci
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numLoci
\end_layout

\end_inset

(ch),
\family default
 
\family typewriter
locusPos
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!locusPos
\end_layout

\end_inset

(loc),
\family default
 
\family typewriter
locusName(loc)
\family default
), and axillary information attached to each individual (c.f.
 
\family typewriter
infoField
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoField
\end_layout

\end_inset

(idx), infoFields
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoFields
\end_layout

\end_inset

()
\family default
).
 In addition to property access functions, a number of utility functions
 are provided to, for example, look up the index of a locus by its name
 (c.f.
 
\family typewriter
locusByName()
\family default
, 
\family typewriter
chromBegin()
\family default
, 
\family typewriter
chromLocusPair()
\family default
).
\end_layout

\begin_layout Standard
In simuPOP, locus is a (named) position and alleles are just different numbers
 at that position.
 
\series bold
A locus can be a gene, a nucleotide, or even a deletion, depending on how
 you define alleles and mutations
\series default
.
 For example, 
\end_layout

\begin_layout Itemize
A codon can be simulated as a locus with 64 allelic states, or three locus
 each with 4 allelic states.
 Alleles in the first case would be codons such as 
\family typewriter
AAC
\family default
 and a mutation event would mutate one codon to another (e.g.
 
\family typewriter
AAC
\family default
 -> 
\family typewriter
ACC
\family default
).
 Alleles in the second case would be 
\family typewriter
A
\family default
, 
\family typewriter
C
\family default
, 
\family typewriter
T
\family default
 or 
\family typewriter
G
\family default
, and a mutation event would mutate one nucleotide to another (e.g.
 
\family typewriter
A
\family default
 -> 
\family typewriter
G
\family default
).
\end_layout

\begin_layout Itemize
You can use 0 and 1 (and the binary module of simuPOP) to simulate SNP (single-n
ucleotide polymorphism) markers and ignore the exact meaning of 0 and 1,
 or use 0, 1, 2, 3 to simulate different nucleotide (A, C, T, or G) in these
 markers.
 The mutation model in the second case would be more complex.
\end_layout

\begin_layout Itemize
For microsatellite markers, alleles are usually interpreted as the number
 of tandem repeats.
 It would be difficult (though doable) to simulate the expansion and contraction
 of genome caused by the mutation of microsatellite markers.
\end_layout

\begin_layout Itemize
The infinite site and infinite allele mutation models could be simulated
 using either a continuous sequence of nucleotides with a simple 2-allele
 mutation model, or a locus with a large number of possible allelic states.
 It is also possible to simulate an empty region (without any locus) with
 loci introduced by mutation events.
\end_layout

\begin_layout Itemize
If you consider deletion as a special allelic state, you can simulate gene
 deletions without shrinking a chromosome.
 For example, a deletion mutation event can set the allelic state of one
 or more loci to 0, which can no longer be mutated.
\end_layout

\begin_layout Itemize
Alleles in different individuals could be interpretted differently.
 For example, if you would like to simulate major chromosomal mutations
 such as inversion, you could use a super set of markers for different types
 of chromosomes and use an indicator (information field) to mark the type
 of chromosome and which markers are valid.
 Using virtual subpopulations, these individuals could be handled differently
 during mating.
\end_layout

\begin_layout Itemize
In an implementation of an infinite-sites model, 
\series bold
Individual loci are used to store mutation events
\series default
.
 In this example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infiniteSites"

\end_inset

), 100 loci are allocated for each individual and they are used to store
 mutation events (location of a mutation) that happens in a 10Mb region.
 Whenever a mutation event happens, its location is stored as an allele
 of an individual.
 At the end of the evolution, each individual has a list of mutation events
 which can be readily translated to real alleles.
 Similar ideas could be used to simulate the accumulation of recombination
 events.
\end_layout

\begin_layout Standard
In summary, the exact meaning of loci and their alleles are user defined.
 With appropriate mutation model and mating scheme, it is even possible
 to simulate phenotypic traits using this mechanism, although it is more
 natual to use information fields for quatitative traits.
\end_layout

\begin_layout Standard
A genotypic structure can be retrieved from 
\emph on
Individual
\emph default
 and 
\emph on
Population
\emph default
 objects.
 
\series bold
Because a population consists of individuals of the same type, genotypic
 information can only be changed for all individuals at the population level
\series default
.
 populations in a simulator usually have the same genotypic structure because
 they are created by as replicates, but their structure may change during
 evolution.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "genostructure"

\end_inset

 demonstrates how to access genotypic structure functions at the population
 and individual levels.
 Note that 
\family typewriter
lociPos
\family default
 determines the order at which loci are arranged on a chromosome.
 Loci positions and names will be rearranged if given 
\family typewriter
lociPos
\family default
 is unordered.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genoStru.log"
lstparams "caption={Genotypic structure functions},label={genostructure}"

\end_inset


\end_layout

\begin_layout Note
simuPOP does not assume any unit for loci positions.
 Depending on your application, it can be basepair (bp), kilo-basepair (kb),
 mega base pair (mb) or even using genetic-map distance such as centiMorgan.
 It is your responsibility to interpret and use loci positions properly.
 For example, recombination rate between two adjacent markers can be specified
 as the product between their physical distance and a recombination intensity.
 The scale of this intensity will vary by the unit assumed.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Note
Names of loci, alleles and subpopulations are optional.
 Empty names will be used if they are not specified.
 Whereas 
\family typewriter
locusName
\family default
, 
\family typewriter
subPopName
\family default
 and 
\family typewriter
alleleName
\family default
 always return a value (empty string or specified value) for any locus,
 subpopulation or allele, respectively, 
\family typewriter
lociNames
\family default
, 
\family typewriter
subPopNames
\family default
 and 
\family typewriter
alleleNames
\family default
 only return specified values, which can be empty lists.
 
\end_layout

\begin_layout Subsection
Haploid, diploid and haplodiploid populations
\end_layout

\begin_layout Standard
simuPOP is most widely used to study human (diploid) populations.
 A large number of mating schemes, operators and population statistics are
 designed around the evolution of such a population.
 simuPOP also supports haploid and haplodiploid populations although there
 are fewer choices of mating schemes and operators.
 simuPOP can also support other types of populations such as triploid and
 tetraploid populations, but these features are largely untested due to
 their limited usage.
 It is expected that supports for these populations would be enhanced over
 time with additional dedicated operators and functions.
\end_layout

\begin_layout Standard
For efficiency considerations, simuPOP saves the same numbers of homologous
 sets of chromosomes even if some individuals have different numbers of
 homologous sets in a population.
 For example, in a haplodiploid population, because male individuals have
 only one set of chromosomes, their second homologous set of chromosomes
 are 
\emph on
unused
\emph default
, which are labeled as 
\family typewriter
'_'
\family default
, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "haplodiploid"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploid.log"
lstparams "caption={An example of haplodiploid population},keywordstyle={\\ttfamily},label={haplodiploid}"

\end_inset


\end_layout

\begin_layout Subsection
Autosomes, sex chromosomes, mitochondrial, and other types of chromosomes
 *
\end_layout

\begin_layout Standard
The default chromosome type is autosome, which is the 
\emph on
normal
\emph default
 chromosomes in diploid, and in haploid populations.
 simuPOP supports four other types of chromosomes, namely 
\emph on
chromosome X
\emph default
, 
\emph on
chromosome Y, mitochondrial,
\emph default
 and
\emph on
 customized
\emph default
 chromosome types.
 Sex chromosomes are only valid in haploid populations where chromosomes
 X and Y are used to determine the sex of an offspring.
 Mitochondrial DNAs can exists in haploid or diploid populations, and are
 inherited maternally.
 Customized chromosomes rely on user defined functions and operators to
 be passed from parents to offspring.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 shows how to specify different chromosome types, and how genotypes of these
 special chromosomes are arranged.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/chromType.log"
lstparams "caption={Different chromosome types},keywordstyle={\\ttfamily},label={chromtypes}"

\end_inset


\end_layout

\begin_layout Standard
The evolution of sex chromosomes follow the following rules
\end_layout

\begin_layout Itemize
There can be only one X chromosome and one Y chromosome.
 It is not allowed to have only one kind of sex chromosome.
\end_layout

\begin_layout Itemize
The Y chromosome of female individuals are ignored.
 The second homologous copy of the X chromosome and the first copy of the
 Y chromosome are ignored for male individuals.
\end_layout

\begin_layout Itemize
During mating, female parent pass one of her X chromosome to her offspring,
 male parent pass chromosome X or Y to his offspring.
 Recombination is allowed for the X chromosomes of females, but not allowed
 for males.
\end_layout

\begin_layout Itemize
The sex of offspring is determined by the types of sex chromosomes he/she
 inherits, XX for female, and XY for male.
\end_layout

\begin_layout Standard
The evolution of mitochonrial DNAs follow the following rules
\end_layout

\begin_layout Itemize
There can be only one copy of mitochondrial DNA, exists for both males and
 females.
\end_layout

\begin_layout Itemize
In a non-haploid population where all chromosomes have multiple homologous
 copies, only the first copy is used for mitochondrial DNA.
\end_layout

\begin_layout Itemize
mtDNAs are inherited maternally
\end_layout

\begin_layout Standard
Customized chromosomes are used to model more complex types of chromosomes.
 They rely on customized operators for inheritence.
 For example, if you would like to model multiple copies of mitochondrial
 DNAs (cytohets with multiple organellar chromosomes) in a cell, and the
 process of genetic drift of somatic cytoplasmic segregation of mtDNAs,
 you can use multiple customized chromosomes to model multiple cytohets
 (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Pre-defined-genotype-transmitters"

\end_inset

 for an Example).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:chromTypes"

\end_inset

 depicts the possible chromosome structure of two diploid parents, and how
 offspring chromosomes are formed.
 It uses two customized chromosomes to model multiple copies of mitochondrial
 chromosomes that are passed randomly from mother to offspring.
 The second homologous copy of customized chromosomes are unused in this
 example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chromTypes"

\end_inset

Inheritance of different types of chromosomes in a diploid population
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/chromType.png
	lyxscale 40
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
individuals in this population have five chromosomes, one autosome (A),
 one X chromosome (X), one Y chromosome (Y) and two customized chromosomes
 (C).
 The customized chromosomes model multiple copies of mitochondrial chromosomes
 that are passed randomly from mother to offspring.
 Y chromosomes for the female parent, the second copy of chromosome X and
 the first copy of chromosome Y for the male parent, and the second copy
 of customized chromosomes are unused (gray chromosome regions).
 A male offspring inherits one copy of autosome from his mother (with recombinat
ion), one copy of autosome from his father (with recombination), an X chromosome
 from his mother (with recombination), a Y chromosome from his father (without
 recombination), and two copies of the first customized chromosome.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sub:stru-infoFields"

\end_inset


\end_layout

\begin_layout Standard
Different kinds of simulations require different kinds of individuals.
 individuals with only genotype information are sufficient to simulate the
 basic Wright-Fisher model.
 Sex is needed to simulate such a model in diploid populations with sex.
 individual fitness may be needed if selection is induced, and age may be
 needed if the population is age-structured.
 In addition, different types of quantitative traits or affection status
 may be needed to study the impact of genotype on Individual phenotype.
 Because it is infeasible to provide all such information to an individual,
 simuPOP keeps genotype, sex (
\family typewriter
MALE
\family default
 or 
\family typewriter
FEMALE
\family default
) and affection status as 
\emph on
built-in properties
\emph default
 of an individual, and all others as optional 
\emph on
information fields
\emph default
 (float numbers) attached to each individual.
\end_layout

\begin_layout Standard
Information fields can be specified when a population is created, or added
 later using population member functions.
 They are essential for proper operation of many simuPOP operators.
 For example, all selection operators require information field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 Operator 
\family typewriter
Migrator
\family default
 uses information field 
\family typewriter
migrate_to
\family default
 to store the ID of subpopulation an individual will migrate to.
 An error will be raised if these operators are applied to a population
 without needed information fields.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoField.log"
lstparams "caption={Basic usage of information fields},label={basicInfoFields}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicInfoFields"

\end_inset

 demonstrates the basic usage of information fields.
 In this example, a population with two information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 are created.
 Besides the present generation, this population keeps one ancestral generations
 (
\family typewriter
ancGen=1
\family default
, see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details).
 After initializing each individual with two chromosomes with all zero and
 all one alleles respectively, the population evolves one generation, subject
 to recombination at rate 0.01.
 Parents of each individual are recorded, by operator 
\family typewriter
ParentsTagger
\family default
, to information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 of each offspring
\family typewriter
.
\end_layout

\begin_layout Standard
After evolution, the population is extracted from the simulator, and the
 values of information field 
\family typewriter
mother_idx
\family default
 of all individuals are printed.
 The next several statements get the first Individual from the population,
 and his mother from the parental generation using the indexes stored in
 this individual's information fields.
 Genotypes at the first homologous copy of this individual's chromosome
 is printed, along with two parental chromosomes.
\end_layout

\begin_layout Standard

\series bold
Information fields can only be added or removed at the population level
\series default
 because all individuals need to have the same set of fields.
 Values of information fields could be accessed at Individual or population
 levels, using functions such as 
\family typewriter
Individual.info
\family default
, 
\family typewriter
Individual.setInfo
\family default
, 
\family typewriter
population.indInfo
\family default
, 
\family typewriter
Population.setIndInfo
\family default
.
 These functions will be introduced in their respective classes.
\end_layout

\begin_layout Note
Information fields can be located both by names and by indexes
\series bold
,
\series default
 the former provides better readability at a slight cost of performance
 because these names have to be translated into indexes each time.
 However, use of names are recommended in most cases for readability considerati
ons.
\end_layout

\begin_layout Section
Individual
\end_layout

\begin_layout Standard
individuals are building blocks of a population.
 An individual object cannot be created independently, but references to
 inidividuals can be retrieved using member functions of a population object.
\end_layout

\begin_layout Subsection
Access individual genotype 
\end_layout

\begin_layout Standard
From a user's point of view, genotypes of an individual are stored sequentially
 and can be accessed locus by locus, or in batch.
 The alleles are arranged by position, chromosome and ploidy.
 That is to say, the first allele on the first chromosome of the first homologou
s set is followed by alleles at other loci on the same chromosome, then
 markers on the second and later chromosomes, followed by alleles on the
 second homologous set of the chromosomes for a diploid individual.
 A consequence of this memory layout is that alleles at the same locus of
 a non-haploid individual are separated by 
\family typewriter
Individual.totNumLoci()
\family default
 loci.
 The memory layout of a diploid individual with two chromosomes is illustrated
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:genotype-layout"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:genotype-layout"

\end_inset

Memory layout of individual genotype
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/genotype.png
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
simuPOP provides several functions to read/write individual genotype.
 For example, 
\family typewriter
Individual.allele()
\family default
 and 
\family typewriter
Individual.setAllele()
\family default
 can be used to read and write single alleles.
 You could also access alleles in batch mode using functions 
\family typewriter
Individual.genotype()
\family default
 and 
\family typewriter
Individual.setGenotype()
\family default
.
 It is worth noting that, instead of copying genotypes of an individual
 to a Python tuple or list, the return value of function 
\family typewriter
genotype([p, [ch]])
\family default
 is a special python carray object that reflects the underlying genotypes.
 This object behaves like a regular Python list except that the underlying
 genotype will be changed if elements of this object are changed.
 Only 
\family typewriter
count(x)
\family default
 and
\family typewriter
 index(x, [start, [stop]])
\family default
 member functions can be used, but all comparison, assignment and slice
 operations are allowed.
 If you would like to copy the content of this 
\family typewriter
carray
\family default
 to a Python list, use the 
\family typewriter
list()
\family default
 function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individualGenotype"

\end_inset

 demonstrates the use of these functions.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individualGenotype.log"
lstparams "caption={Access individual genotype},label={individualGenotype}"

\end_inset


\end_layout

\begin_layout Standard
The same object will also be returned by function 
\family typewriter
Population.genotype()
\family default
.
\end_layout

\begin_layout Subsection
individual sex, affection status and information fields
\end_layout

\begin_layout Standard
In addition to structural information shared by all individuals in a population,
 the individual class provides member functions to get and set 
\emph on
genotype
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
affection status
\emph default
 and 
\emph on
information fields
\emph default
 of an individual.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individuals"

\end_inset

 demonstrates how to access and modify individual sex, affection status
 and information fields.
 Note that 
\series bold
information fields can be accessed as attributes of individuals
\series default
.
 For example, 
\family typewriter
ind.info('father_idx')
\family default
 is equivalent to 
\family typewriter
ind.father_idx
\family default
 and 
\family typewriter
ind.setInfo(35, 'age')
\family default
 is equivalent to 
\family typewriter
ind.age = 35
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual.log"
lstparams "caption={Access Individual properties},label={individuals}"

\end_inset


\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard
The 
\family typewriter
Population
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Population
\end_layout

\end_inset


\family default
 object is the most important object of simuPOP.
 It consists of one or more generations of individuals, grouped by subpopulation
s, and a local Python dictionary to hold arbitrary population information.
 This class provides a large number of functions to access and modify population
 structure, individuals and their genotypes and information fields.
 The following sections explain these features in detail.
\end_layout

\begin_layout Subsection
Access and change individual genotype
\end_layout

\begin_layout Standard
From a user's point of view, genotypes of all individuals in a population
 are arranged sequentially.
 Similar to functions 
\family typewriter
Individual.genotype()
\family default
 and 
\family typewriter
Individual.setGenotype()
\family default
, genotypes of a population can be accessed in batch using functions 
\family typewriter
Population.genotype()
\family default
 and 
\family typewriter
Population.setGenotype()
\family default
.
 However, because it is error prone to locate an allele of a particular
 individual in this long array, these functions are usually used to perform
 population-level genotype operations such as clearing all alleles (e.g.
 
\family typewriter
pop.setGenotype(0)
\family default
) or counting the number of a particular allele across all individuals (e.g.
 
\family typewriter
pop.genotype().count(1)
\family default
).
\end_layout

\begin_layout Standard
Another way to change alleles across the whole population is to recode existing
 alleles to other numbers.
 This is sometimes needed if you need to change allele states to conform
 with a particular mutation model, assumptions of other software applications
 or genetic samples.
 For example, if your dataset uses 1, 2, 3, 4 for A, C, T, G alleles, and
 you would like to use alleles 0, 1, 2 and 3 for A, C, G, T (a convention
 for simuPOP when nucleotide mutation models are involved), you can use
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.recodeAlleles([0, 0, 1, 3, 2], alleleNames=['A', 'C', 'G', 'T'])
\end_layout

\end_inset

to convert and rename the alleles (1 allele to 0, 2 allele to 1, etc).
 This operation will be applied to all subpopulations for all ancestral
 generations, but can be restricted to selected loci.
\end_layout

\begin_layout Subsection
Subpopulations
\end_layout

\begin_layout Standard
A simuPOP population consists of one or more subpopulations.
 
\series bold
If a population is not structured, it has one subpopulation that is the
 population itself.

\series default
 Subpopulations serve as barriers of individuals in the sense that mating
 only happens between individuals in the same subpopulation.
 A number of functions are provided to merge, remove, resize subpopulations,
 and move individuals between subpopulations (migration).
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to use some of the subpopulation related functions.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPop.log"
lstparams "caption={Manipulation of subpopulations},label={subPop}"

\end_inset


\end_layout

\begin_layout Standard
Some population operations change the IDs of subpopulations.
 For example, if a population has three subpopulations 0, 1, and 2, and
 subpopulation 1 is split into two subpouplations, subpopulation 2 will
 become subpopulation 3.
 Tracking the ID of a subpopulation can be problematic, especially when
 conditional or random subpopulation operations are involved.
 In this case, you can specify names to subpopulations.
 These names will follow their associated subpopulations during population
 operations so you can identify the ID of a subpopulation by its name.
 Note that simuPOP allows duplicate subpopulation names.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPopName.log"
lstparams "caption={Use of subpopulation names},label={subPopName}"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Virtual subpopulations and virtual splitters *
\end_layout

\begin_layout Standard
simuPOP subpopulations can be further divided into virtual subpopulations
 (VSP), which are groups of individuals who share certain properties.
 For example, all male individuals, all unaffected individuals, all individuals
 with information field age > 20, all individuals with genotype 0, 0 at
 a given locus, can form VSPs.
 VSPs do not have to add up to the whole subpopulation, nor do they have
 to be non-overlapping.
 Unlike subpopulations that have strict boundaries, VSPs change easily with
 the changes of individual properties.
\end_layout

\begin_layout Standard
VSPs are defined by virtual splitters.
 
\series bold
It is a definition for groups of individuals in each subpopulation.

\series default
 A splitter defines the same number of VSPs in all subpopulations, although
 sizes of these VSPs vary across subpopulations due to subpopulation differences.
 For example, a 
\family typewriter
SexSplitter()
\family default
 defines two VSPs, the first with all male individuals and the second with
 all female individuals, and a 
\family typewriter
InfoSplitter(field='x', values=[1, 2, 4])
\family default
 defines three VSPs whose members have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 and 
\family typewriter
4
\family default
 at information field 
\family typewriter
x
\family default
, respectively.
 This splitter also allows the use of cutoff values and ranges to define
 VSPs.
 If different types of VSPs are needed, a combined splitter can be used
 to combine VSPs defined by several splitters.
\end_layout

\begin_layout Standard
A VSP is represented by a 
\family typewriter
[sp, vsp]
\family default
 pair where 
\family typewriter
sp
\family default
 and 
\family typewriter
vsp
\family default
 can be subpopulation indexes or names.
 Its name and size can be obtained using functions 
\family typewriter
subPopName()
\family default
 and 
\family typewriter
subPopSize()
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSplitter"

\end_inset

 demonstrates how to apply virtual splitters to a population, and how to
 check VSP names and sizes.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSplitter.log"
lstparams "caption={Define virtual subpopulations in a population},label={virtualSplitter}"

\end_inset


\end_layout

\begin_layout Standard
VSP provides an easy way to access groups of individuals in a subpopulation
 and allows finer control of an evolutionary process.
 For example, mating schemes can be applied to VSPs which makes it possible
 to apply different mating schemes to, for example, individuals with different
 ages.
 By applying migration, mutation etc to VSPs, it is easy to implement advanced
 features such as sex-biased migrations, different mutation rates for individual
s at different stages of a disease.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSubPop"

\end_inset

 demonstrates how to initialize genotype and information fields to individuals
 in male and female VSPs.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSubPop.log"
lstparams "caption={Applications of virtual subpopulations},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Subsection
Advanced virtual subpopulation splitters **
\end_layout

\begin_layout Standard
simuPOP provides a number of virtual splitters that can define VSPs using
 specified properties.
 For example, 
\family typewriter
InfoSplitter(field='a', values=[1,2,3])
\family default
 defines three VSPs whose individuals have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, and 
\family typewriter
3
\family default
 at information field 
\family typewriter
a
\family default
, respectively; 
\family typewriter
SexSplitter()
\family default
 defines two VSPs of male and female individuals, respectively; and 
\family typewriter
RangeSplitter(ranges=[[0, 2000], [2000, 5000]])
\family default
 defines two VSPs using two blocks of individuals.
\end_layout

\begin_layout Standard
A 
\family typewriter
CombinedSplitter
\family default
 can be used if your simulation needs more than one sets of VSPs.
 For example, you may want to split your subpopulations both by sex and
 by affection status.
 In this case, you can define a combined splitter using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CombinedSplitter(splitters=[SexSplitter(), AffectionSplitter()])
\end_layout

\end_inset

This splitter simply stacks VSPs defined in 
\family typewriter
AffectionSplitter()
\family default
 after 
\family typewriter
SexSplitter()
\family default
 so that unaffected and affected VSPs are now VSPs 2 and 3 (0 and 1 are
 used for male and female VSPs).
\end_layout

\begin_layout Standard
There are also scenarios when you would like to define finer VSPs with individua
ls belonging to more than one VSPs.
 For example, you may want to have a look of frequencies of certain alleles
 in affected male vs affected females, or count the number of males and
 females with certain value at an information field.
 In this case, a 
\family typewriter
ProductSplitter
\family default
 can be used to define VSPs using interactions of several VSPs.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ProductSplitter(splitters=[SexSplitter(), AffectionSplitter()])
\end_layout

\end_inset

defines 4 subpopulations by splitting VSPs defined by 
\family typewriter
SexSplitter()
\family default
 with affection status.
 These four VSPs will then have unaffected male, affected male, unaffected
 female and affected female individuals, respectively.
\end_layout

\begin_layout Standard
If you consider 
\family typewriter
ProductSplitter
\family default
 as an intersection splitter that defines new VSPs as intersections of existing
 VSPs, you may wonder how to define unions of VSPs.
 For example, you can make a case where you want to consider Individuals
 with information field a < 0 or a > 100 together.
 A regular 
\family typewriter
InfoSplitter(field='a', cutoff=[0, 100])
\family default
 cannot do that because it defines three VSPs with 
\begin_inset Formula $a<0$
\end_inset

, 
\begin_inset Formula $0\leq a<100$
\end_inset

 and 
\begin_inset Formula $a\geq100$
\end_inset

, respectively.
 The trick here is to use parameter 
\family typewriter
vspMap
\family default
 of a 
\family typewriter
CombinedSplitter
\family default
.
 If this parameter is defined, multiple VSPs could be groups or reordered
 to define a new set of VSPs.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CombinedSplitter(splitters=[InfoSplitter(field='a', cutoff=[0, 100])], vspMap=[[
0,2], 1])
\end_layout

\end_inset

 defines two VSPs using VSPs 0 and 2, and VSP 1 defined by the 
\family typewriter
InfoSplitter
\family default
 so that the first VSP contains individuals with 
\begin_inset Formula $a<0$
\end_inset

 or 
\begin_inset Formula $a\geq100$
\end_inset

.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "advancedVSP"

\end_inset

 demonstrates some advanced usages of virtual splitters.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/advancedVSP.log"
lstparams "caption={Advanced virtual subpopulation usages.},label={advancedVSP}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Individuals"

\end_inset

Access individuals and their properties
\end_layout

\begin_layout Standard
There are many ways to access individuals of a population.
 For example, function 
\family typewriter
Population.Individual(idx)
\family default
 returns a reference to the 
\family typewriter
idx
\family default
-th individual in a population.
 An optional parameter 
\family typewriter
subPop
\family default
 can be specified to return the 
\family typewriter
idx
\family default
-th individual in the 
\family typewriter
subPop
\family default
-th subpopulation.
\end_layout

\begin_layout Standard
If you would like to access a group of individuals, either from a whole
 population, a subpopulation, or from a virtual subpopulation, 
\family typewriter
Population.individuals([subPop])
\family default
 is easier to use.
 This function returns a Python iterator that can be used to iterate through
 individuals.
 An advantage of this function is that 
\family typewriter
subPop 
\family default
can be a virtual subpopulation which makes it easy to iterate through Individual
s with certain properties (such as all male Individuals).
 If you would like to iterate through multiple virtual subpopulations in
 one or more ancestral generations, you can use another function 
\family typewriter
Population.allIndividuals(subPops, ancGens)
\family default
.
\end_layout

\begin_layout Standard
If more than one generations are stored in a population, function 
\family typewriter
ancestor(idx, [subPop], gen)
\family default
 can be used to access Individual from an ancestral generation (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details).
 Because there is no group access function for ancestors, it may be more
 convenient to use 
\family typewriter
useAncestralGen
\family default
 to make an 
\emph on
ancestral
\emph default
 generation the 
\emph on
current
\emph default
 generation, and use 
\family typewriter
Population.Individuals
\family default
.
 Note that ancestor() function can always access individuals at a certain
 generation, regardless which generation the current generation is.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to use all these Individual-access functions.
\end_layout

\begin_layout Standard
If an unique ID is assigned to all individuals in a population, you can
 look up individuals from their IDs using function 
\family typewriter
Population.indByID()
\family default
.
 The information field to save individual ID is usually 
\family typewriter
ind_id
\family default
 and you can use operator 
\family typewriter
IdTagger
\family default
 and its function form 
\family typewriter
tagID
\family default
 to set this field.
 Note that this function can be used to look up individuals in the present
 and all ancestral generations, although a parameter (
\family typewriter
ancGen
\family default
) can be used to limit search to a specific generation if you know in advance
 which generation the individual locates.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/accessIndividual.log"
lstparams "caption={Access individuals of a population},label={accessIndividual}"

\end_inset


\end_layout

\begin_layout Standard
Although it is easy to access individuals in a population, it is often more
 efficient to access genotypes and information fields in batch mode.
 For example, functions 
\family typewriter
genotype()
\family default
 and
\family typewriter
 setGenotype()
\family default
 can read/write genotype of all individuals in a population or (virtual)
 subpopulation, functions 
\family typewriter
indInfo()
\family default
 and 
\family typewriter
setIndInfo()
\family default
 can read/write certain information fields in a population or (virtual)
 subpopulation.
 The write functions work in a circular manner in the sense that provided
 values are reused if they are not enough to fill all genotypes or information
 fields.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates the use of such functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/batchAccess.log"
lstparams "caption={Access Individual properties in batch mode},label={batchAccess}"

\end_inset


\end_layout

\begin_layout Subsection
Attach arbitrary auxillary information using information fields
\begin_inset CommandInset label
LatexCommand label
name "sec:Information-fields"

\end_inset


\end_layout

\begin_layout Standard
Information fields are usually set during population creation, using the
 
\family typewriter
infoFields
\family default
 parameter of the population constructor.
 It can also be set or added using functions 
\family typewriter
setInfoFields, addInfoField 
\family default
and 
\family typewriter
addInfoFields
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popInfo"

\end_inset

 demonstrates how to read and write information fields from an individual,
 or from a population in batch mode.
 Note that functions 
\family typewriter
Population.indInfo
\family default
 and 
\family typewriter
Population.setIndInfo
\family default
 can be applied to (virtual) subpopulation using a optional parameter subPop.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popInfo.log"
lstparams "caption={Add and use of information fields in a population},label={popInfo}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Keep track of ancestral generations
\end_layout

\begin_layout Standard
A simuPOP population usually holds individuals in one generation.
 During evolution, an offspring generation will replace the parental generation
 and become the present generation (population), after it is populated from
 a parental population.
 The parental generation is discarded.
\end_layout

\begin_layout Standard
This is usually enough when only the present generation is of interest.
 However, parental generations can provide useful information on how genotype
 and other information are passed from parental to offspring generations.
 simuPOP provides a mechanism to store and access arbitrary number of ancestral
 generations in a population object.
 Applications of this feature include pedigree tracking, reconstruction,
 and pedigree ascertainments.
\end_layout

\begin_layout Standard
A parameter 
\family typewriter
ancGen
\family default
 is used to specify how many generations a population object 
\emph on
can
\emph default
 store (which is usually called the 
\emph on
ancestral depth
\emph default
 of a population).
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number 
\family typewriter
n
\family default
 to store n most recent generations; or -
\family typewriter
1
\family default
 to store all generations.
 Of course, storing all generations during an evolutionary process is likely
 to exhaust the RAM of your computer quickly.
\end_layout

\begin_layout Standard
Several member functions can be used to manipulate ancestral generations:
\end_layout

\begin_layout Itemize

\family typewriter
ancestralGens() 
\family default
returns the number of ancestral generations stored in a population.
\end_layout

\begin_layout Itemize

\family typewriter
setAncestralDepth(depth)
\family default
 resets the number of generations a population can store.
\end_layout

\begin_layout Itemize

\family typewriter
push(pop)
\family default
 will push population 
\family typewriter
pop
\family default
 into the current population.
 
\family typewriter
pop
\family default
 will become the current generation, and the current generation will either
 be removed (if ancGen == 0), or become the parental generation of pop.
 The greatest ancestral generation may be removed.
 This function is rarely used because populations with ancestral generations
 are usually created during an evolutionary process.
\end_layout

\begin_layout Itemize

\family typewriter
useAncestralGen(idx)
\family default
 set the present generation to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the parental generation, 
\family typewriter
2
\family default
 for grand-parental, ..., and 
\family typewriter
0
\family default
 for the present generation.
 This is useful because most population functions act on the 
\emph on
present
\emph default
 generation.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral generations.
 
\end_layout

\begin_layout Standard
If a population has several ancestral generations, they are referred by
 their indexes 0 (the latest generation), 1 (parental generation), ...
 and 
\begin_inset Formula $k$
\end_inset

 (top-most ancestral generation) where 
\begin_inset Formula $k$
\end_inset

 equals to 
\family typewriter
ancestralGens()
\family default
.
 In many cases, you can retrieve the properties of ancestral generations
 directly, using functions such as
\end_layout

\begin_layout Itemize

\family typewriter
popSize(ancGen=-1), subPopSizes(ancGen=-1), subPopSize(subPop, ancGen=-1)
\family default
: population and subpopulation sizes of ancestral generation 
\family typewriter
ancGen
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
ancestor(index, ancGen)
\family default
: Get a reference to the 
\family typewriter
index
\family default
 individual of ancestral generation 
\family typewriter
ancGen
\family default
.
\end_layout

\begin_layout Standard
However, most population member functions work at the current generation
 so you will need to switch to an ancestral generation using function 
\family typewriter
useAncestralGen()
\family default
 if you would like to manipulate an ancestral generation.
 For example, you can remove the second subpopulation of the parental generation
 using functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.useAncestralGen(1)
\end_layout

\begin_layout Plain Layout

pop.removeSubPops(1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A typical use of ancestral generations is demonstrated in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

.
 In this example, a population is created and is initialized with allele
 frequency 0.5.
 Its ancestral depth is set to 2 at the beginning of generation 18 so that
 it can hold parental generations at generation 18 and 19.
 The allele frequency at each generation is calculated and displayed, both
 during evolution using a 
\family typewriter
Stat
\family default
 operator, and after evolution using the function form this operator.
 Note that setting the ancestral depth at the end of an evolutionary process
 is a common practice because we are usually only interested in the last
 few generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ancestralPop.log"
lstparams "caption={Ancestral populations},label={ancestralPop}"

\end_inset


\end_layout

\begin_layout Subsection
Change genotypic structure of a population 
\end_layout

\begin_layout Standard
Several functions are provided to remove, add empty loci or chromosomes,
 and to merge loci or chromosomes from another population.
 They can be used to trim unneeded loci, expand existing population or merge
 two populations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates how to use these populations.
 Note that function 
\family typewriter
Population.addLociFrom
\family default
 by default merges chromosomes one by one according to chromosome index.
 If 
\family typewriter
byName
\family default
 is set to True, it will try to match chromosomes by name and merge them.
 This example also demonstrates the use of 
\family typewriter
DBG_WARNING
\family default
 flag, which will trigger a warning message when chromosomes with different
 names are merged.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/addRemoveLoci.log"
lstparams "caption={Add and remove loci and chromosomes},keywordstyle={\\ttfamily},label={addRemoveLoci}"

\end_inset


\end_layout

\begin_layout Subsection
Remove or extract individuals and subpopulations from a population
\end_layout

\begin_layout Standard
Functions 
\family typewriter
Population.removeIndividuals
\family default
 and 
\family typewriter
Population.removeSubPops
\family default
 remove selected individuals or groups of individuals from a population.
 Functions 
\family typewriter
Population.extractIndividuals
\family default
 and 
\family typewriter
Population.extractSubPops
\family default
 extract individuals and subpopulations from an existing population and
 form a new one.
\end_layout

\begin_layout Standard
Functions 
\family typewriter
removeIndividauls
\family default
 and 
\family typewriter
extractIndividuals
\family default
 could be used to remove or extract individuals from the present generation
 by indexes or from all ancestral generations by IDs or a Python filter
 function.
 This function should accept parameter 
\family typewriter
ind
\family default
 or one or more information fields.
 simuPOP will pass individual for parameter 
\family typewriter
ind
\family default
, and values at specified information fields (
\family typewriter
age
\family default
 in this example) of each individual to this function.
 The present population structure will be kept, even if some subpopulations
 are left empty.
 For example, you could remove the first thirty individuals of a population
 using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.removeIndividuals(indexes=range(30))
\end_layout

\end_inset

or remove all individuals at age 20 or 30 using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.removeIndividuals(IDs=(20, 30), idField='age')
\end_layout

\end_inset

or remove all individuals with age between 20 and 30 using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.removeIndividuals(filter=lambda age: age >=20 and age <=30)
\end_layout

\end_inset

.
 In the last example, a Python lambda function is defined to avoid the definitio
n of a named function.
\end_layout

\begin_layout Standard
Functions 
\family typewriter
removeSubPops
\family default
 or 
\family typewriter
extractSubPops
\family default
 could be used to remove or extract subpopulations, or goups of individuals
 defined by virtual subpopulations from a population.
 The latter case is very interesting because it could be used to remove
 or extract individuals with similar properties, such as all individuals
 between the ages 40 and 60, as demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/extract.log"
lstparams "caption={Extract individuals, loci and information fields from an existing population},keywordstyle={\\ttfamily},label={extract}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Population-Variables"

\end_inset

Store arbitrary population information as population variables
\end_layout

\begin_layout Standard
Each simuPOP population has a Python dictionary that can be used to store
 arbitrary Python variables.
 These variables are usually used by various operators to share information
 between them.
 For example, the 
\family typewriter
Stat
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operator!Stat
\end_layout

\end_inset


\family default
 operator calculates population statistics and stores the results in this
 Python dictionary.
 Other operators such as the 
\family typewriter
PyEval
\family default
 and 
\family typewriter
TerminateIf 
\family default
read from this dictionary and act upon its information.
\end_layout

\begin_layout Standard
simuPOP provides two functions, namely 
\family typewriter
Population.vars
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Population!vars
\end_layout

\end_inset

()
\family default
 and 
\family typewriter
Population.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Population!Population
\end_layout

\end_inset

dvars()
\family default
 to access a population dictionary.
 These functions return the same dictionary object but 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is equivalent to 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 Because dictionary 
\family typewriter
subPop[spID]
\family default
 is frequently used by operators to store variables related to a particular
 (virtual) subpopulation, function 
\family typewriter
pop.vars(subPop)
\family default
 is provided as a shortcut to 
\family typewriter
pop.vars()['subPop'][spID]
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popVars"

\end_inset

 demonstrates how to set and access population variables.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popVars.log"
lstparams "caption={population variables},label={popVars}"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that this dictionary forms a 
\series bold
local namespace
\series default
 in which Python expressions can be evaluated.
 This is the basis of how expression-based operators work.
 For example, the 
\family typewriter
PyEval 
\family default
operator in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

 evaluates expression 
\family typewriter
``'%.2f
\backslash
t' % LD[0][1]''
\family default
 in each population's local namespace when it is applied to that population.
 This yields different results for different population because their LD
 values are different.
 In addition to Python expressions, Python statements can also be executed
 in the local namespace of a population, using the 
\family typewriter
stmts
\family default
 parameter of the 
\family typewriter
PyEval
\family default
 or 
\family typewriter
PyExec
\family default
 operator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "expression"

\end_inset

 demonstrates the use of a simuPOP terminator, which terminates the evolution
 of a population when its expression is evaluated as 
\family typewriter
True
\family default
.
 Note that The 
\family typewriter
evolve() 
\family default
function of this example does not specify how many generations to evolve
 so it will stop only after all replicates stop.
 The return value of this function indicates how many generations each replicate
 has evolved.
 This example also demonstrates how to run multiple replicates of an evolutionar
y process, which we will discuss in detail latter.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/expression.log"
lstparams "caption={Expression evaluation in the local namespace of a population},label={expression}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and load a population
\end_layout

\begin_layout Standard
simuPOP populations can be saved to and loaded from disk files using 
\family typewriter
Population.save
\begin_inset Index idx
status open

\begin_layout Plain Layout
Population!save
\end_layout

\end_inset

(file)
\family default
 member function and global function 
\family typewriter
loadPopulation
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
function!loadPopulation
\end_layout

\end_inset

.
 
\series bold
Virtual splitters are not saved
\series default
 because they are considered as runtime definitions.
 Although files in any extension can be used, extension 
\family typewriter
.pop
\family default
 is recommended.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "savePop"

\end_inset

 demonstrates how to save and load a population in the native simuPOP format.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePop.log"
lstparams "caption={Save and load a population},label={savePop}"

\end_inset


\end_layout

\begin_layout Standard
The native simuPOP format is portable across different platforms but is
 not human readable and is not recognized by other applications.
 If you need to save a simuPOP population in a format that is recognizable
 by a particular software, you can use functions 
\family typewriter
importPopulation
\family default
, 
\family typewriter
export
\family default
, and operator 
\family typewriter
Exporter
\family default
 if you would like to export populations during evolution.
 These functions are defined in module 
\family typewriter
simuPOP.utils
\family default
.
 
\end_layout

\begin_layout Subsection
Import and export datasets in unsupported formats *
\end_layout

\begin_layout Standard
simuPOP provides a few utility functions to import and export populations
 in common formats such as GENEPOP, Phylip, and STRUCTURE (see chapter utility
 modules for details).
 If you need to import data from a file in a format that is not currently
 supported, you generally need to first scan the file for information such
 as number and names of chromosomes, loci, alleles, subpopulation, and individua
ls.
 After you create a population without genotype information from these parameter
s, you can scan the file for the second time and fill the population with
 genotypes and other information.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "importData"

\end_inset

 demonstrates how to define a function to import from a file that is saved
 by function 
\family typewriter
utils.saveCSV
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/importData.log"
lstparams "caption={Import a population from another file format},label={importData}"

\end_inset


\end_layout

\begin_layout Standard
Unless there are specific requirements in the order and labeling of individuals,
 exporting a simuPOP population is usually straightforward.
 Functions that are useful in such occasions include structural functions
 
\family typewriter
Population.numSubPop()
\family default
, 
\family typewriter
Population.subPopName(), Population.popSize()
\family default
 and 
\family typewriter
Population.subPopSizes()
\family default
, 
\family typewriter
and
\family default
 individual access functions 
\family typewriter
Population.individual()
\family default
 and 
\family typewriter
Population.individuals()
\family default
 and individual population access functions such as 
\family typewriter
Individual.allele()
\family default
 and 
\family typewriter
Individual.info()
\family default
.
 Function 
\family typewriter
saveFSTAT
\family default
 in the cookbook module 
\family typewriter
fstatUtil
\family default
 or 
\family typewriter
saveCSV
\family default
 in module 
\family typewriter
simuPOP.utils
\family default
 are good examples you can follow.
\end_layout

\begin_layout Chapter
simuPOP Operators
\begin_inset CommandInset label
LatexCommand label
name "cha:simuPOP-Operators"

\end_inset


\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 70 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), gene conversion,
 quantitative trait, selection, penetrance (single or multi-locus, hybrid),
 ascertainment (case-control, affected sibpairs, random), statistics calculation
 (allele, genotype, haplotype, heterozygote number and frequency; expected
 heterozygosity; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules).
 This chapter covers the basic and some not-so-basic usages of these operators,
 organized roughly by genetic factors.
\end_layout

\begin_layout Section
Introduction to operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 There are two types of operators:
\end_layout

\begin_layout Itemize

\series bold
Operators that are applied to populations
\series default
.
 These operators are used in the 
\family typewriter
initOps
\family default
, 
\family typewriter
preOps
\family default
, 
\family typewriter
postOps
\family default
 and 
\family typewriter
finalOps
\family default
 parameters of the 
\family typewriter
evolve
\family default
 function.
 The 
\family typewriter
initOps
\family default
 operators are applied before an evolutionary process, the 
\family typewriter
preOps
\family default
 operators are applied to the parental population at each generation before
 mating, the 
\family typewriter
postOps
\family default
 operators are applied to the offspring population at each generation after
 mating, and the 
\family typewriter
finalOps
\family default
 operators are applied after an evolutionary process.
 Examples of such operators include 
\family typewriter
MergeSubPops
\family default
 to merge subpopulations and 
\family typewriter
StepwiseMutator
\family default
 to mutate individuals using a stepwise mutation model.
\end_layout

\begin_layout Itemize

\series bold
Operators that are applied to individuals
\series default
 (offspring) during mating.
 These operators are used in the 
\family typewriter
ops
\family default
 parameter of a mating scheme.
 They are usually used to transmit genotype or other information from parents
 to offspring.
 Examples of such operators include 
\family typewriter
MendelianGenoTransmitter
\family default
 that transmit parental genotype to offspring according to Mendelian laws
 and 
\family typewriter
ParentsTagger
\family default
 that record the indexes of parents in the parental population to each offspring.
\end_layout

\begin_layout Standard
Some mutators could be applied both to populations and individuals.
 For example, an 
\family typewriter
IdTagger
\family default
 could be applied to a whole population and assign an unique ID to all individua
ls, or to offspring during mating.
\end_layout

\begin_layout Standard
The following sections will introduce common features of all operators.
 The next chapter will explain all simuPOP operators in detail.
\end_layout

\begin_layout Subsection
Apply operators to selected replicates and (virtual) subpopulations at selected
 generations
\end_layout

\begin_layout Standard
Operators are, by default, applied to all generations during an evolutionary
 process.
 This can be changed using the 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
 parameters.
 As their names indicate, these parameters control the starting generation
 (
\family typewriter
begin
\family default
), ending generation (
\family typewriter
end
\family default
), generations between two applicable generations (
\family typewriter
step
\family default
), and an explicit list of applicable generations (
\family typewriter
at
\family default
, a single generation number is also acceptable).
 Other parameters will be ignored if 
\family typewriter
at
\family default
 is specified.
 It is worth noting that, if an evolutionary process has a pre-sepcified
 ending generation, negative generations numbers are allowed.
 They are counted backward from the ending generation.
\end_layout

\begin_layout Standard
For example, if a simulator starts at generation 
\family typewriter
0
\family default
, and the 
\family typewriter
evolve
\family default
 function has parameter 
\family typewriter
gen=10
\family default
, the simulator will stop at the 
\emph on
beginning
\emph default
 of generation 
\family typewriter
10
\family default
.
 Generation 
\family typewriter
-1
\family default
 refers to generation 
\family typewriter
9
\family default
, and generation 
\family typewriter
-2
\family default
 refers to generation 
\family typewriter
8
\family default
, and so on.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 demonstrates how to set applicable generations of an operator.
 In this example, a population is initialized before evolution using an
 
\family typewriter
InitGenotype
\family default
 operator.
 allele frequency at locus 
\family typewriter
0
\family default
 is calculated at generation 
\family typewriter
80
\family default
, 
\family typewriter
90
\family default
, but not 
\family typewriter
100
\family default
 because the evolution stops at the beginning of generation 
\family typewriter
100
\family default
.
 A 
\family typewriter
PyEval
\family default
 operator outputs generation number and allele frequency at the end of generatio
n 
\family typewriter
80
\family default
 and 
\family typewriter
90
\family default
.
 Another 
\family typewriter
PyEval
\family default
 operator outputs similar information at generation 
\family typewriter
90
\family default
 and 
\family typewriter
99
\family default
, before and after mating.
 Note, however, because allele frequencies are only calculated twice, the
 pre-mating allele frequency at generation 
\family typewriter
90
\family default
 is actually calculated at generation 
\family typewriter
80
\family default
, and the allele frequencies display for generation 
\family typewriter
99
\family default
 are calculated at generation 
\family typewriter
90
\family default
.
 At the end of the evolution, the population is saved to a file using a
 
\family typewriter
SavePopulation
\family default
 operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/applicableGen.log"
lstparams "caption={Applicable generations of an operator.},label={applicableGen}"

\end_inset


\end_layout

\begin_layout Subsection
Applicable populations and (virtual) subpopulations
\end_layout

\begin_layout Standard
A simulator can evolve multiple replicates of a population simultaneously.
 Different operators can be applied to different replicates of this population.
 This allows side by side comparison between simulations.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
reps
\family default
 is used to control which replicate(s) an operator can be applied to.
 This parameter can be a list of replicate numbers or a single replicate
 number.
 Negative index is allowed where 
\family typewriter
-1
\family default
 refers to the last replicate.
 This technique has been widely used to produce table-like output where
 a 
\family typewriter
PyOutput
\family default
 outputs a newline when it is applied to the last replicate of a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates how to use this 
\family typewriter
reps
\family default
 parameter.
 It is worth noting that negative indexes are 
\emph on
dynamic
\emph default
 indexes relative to number of active populations.
 For example, 
\family typewriter
rep=-1
\family default
 will refer to a previous population if the last population has stopped
 evolving.
 Use a non-negative replicate number if this is not intended.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/replicate.log"
lstparams "caption={Apply operators to a subset of populations},label={replicate}"

\end_inset


\end_layout

\begin_layout Standard
An operator can also be applied to specified (virtual) subpopulations.
 For example, an 
\family typewriter
initializer
\family default
 can be applied to male individuals in the first subpopulation, and everyone
 in the second subpopulation using parameter 
\family typewriter
subPops=[(0,0)
\family default
, 1], if a virtual subpopulation is defined by individual sex.
 Generally speaking,
\end_layout

\begin_layout Itemize

\family typewriter
subPops=[]
\family default
 applies the operator to all subpopulation.
 This is usually the default value of an operator.
\end_layout

\begin_layout Itemize

\family typewriter
subPops=[vsp1, vsp2,...]
\family default
 applies the operator all specified (virtual) subpopulations.
 (e.g.
 
\family typewriter
subPops=[(0,0)
\family default
, 1]).
\end_layout

\begin_layout Itemize

\family typewriter
subPops=sp
\family default
 is an abbreviation for 
\family typewriter
subPops=[sp]
\family default
.
 If 
\family typewriter
sp
\family default
 is virtual, it has to be written as 
\family typewriter
[sp]
\family default
 because 
\family typewriter
subPops=(0, 1)
\family default
 is intepreted as two non-virtual subpopulation.
\end_layout

\begin_layout Standard
However, not all operators support this parameter, and even if they do,
 their interpretations of parameter input may vary.
 Please refer to documentation for individual operators in 
\emph on
the simuPOP reference manual
\emph default
 for details.
\end_layout

\begin_layout Subsection
Dynamically determined loci (parameter 
\family typewriter
loci
\family default
) *
\end_layout

\begin_layout Standard
Many operators accept a parameter 
\family typewriter
loci
\family default
 to specify the applicable loci.
 This parameter can be
\end_layout

\begin_layout Itemize

\family typewriter
ALL_AVAIL
\family default
: all available loci of the population to which the operator is applied.
\end_layout

\begin_layout Itemize
[1, 2, 4, 5]: A list of loci indexes.
 When the operator is applied to a population, it will be applied to the
 specified loci.
\end_layout

\begin_layout Itemize

\family typewriter
[('chr1', 5), ('chr1', 10), ('chr2', 5)]
\family default
: A list of chromosome position pairs.
 That is to say, when the operator is applied to a population, it will find
 loci at specified position of specified chromosome.
 Here chromosome names are names specified by parameter 
\family typewriter
chromNames
\family default
 of the 
\family typewriter
Population
\family default
 constructor.
 That is to say, the operator can be applied to all population with such
 chromosomes and loci at specified locations.
\end_layout

\begin_layout Itemize
func: A function with an optional parameter 
\family typewriter
pop
\family default
.
 When the operator is applied to a population, it will call this function,
 optionally pass the population to be applied to this function, and use
 its output as indexes of loci.
\end_layout

\begin_layout Standard
The last usage is very interesting because it allows the determination of
 loci according to population property.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "dynamicLoci"

\end_inset

 shows an example with a 
\family typewriter
MaSelector
\family default
 that is applied to the locus with highest frequency at each generation
 by calling function 
\family typewriter
mostPopular
\family default
, which calculates allele frequency and pick the locus with highest allele
 frequency, This example looks silly, but the technique is very useful in
 simulating the introduction of disease loci by, for example, adding positive
 selection pressure to one of the chosen loci.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/dynamicLoci.log"
lstparams "caption={Natural selection with dynamically determined loci},label={dynamicLoci}"

\end_inset


\end_layout

\begin_layout Subsection
Write output of operators to one or more files
\end_layout

\begin_layout Standard
All operators we have seen, except for the 
\family typewriter
SavePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

, write their output to the standard output, namely your terminal window.
 However, it would be much easier for bookkeeping and further analysis if
 these output can be redirected to disk files.
 Parameter 
\family typewriter
output
\family default
 is designed for this purpose.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
output
\family default
 can take the following values:
\end_layout

\begin_layout Itemize

\family typewriter
''
\family default
 (an empty string): No output.
\end_layout

\begin_layout Itemize

\family typewriter
'>'
\family default
: Write to standard output.
\end_layout

\begin_layout Itemize

\family typewriter
'filename'
\family default
 or 
\family typewriter
'>filename'
\family default
: Write the output to a file named filename.
 If multiple operators write to the same file, or if the same operator writes
 to the file file several times, only the last write operation will succeed.
\end_layout

\begin_layout Itemize

\family typewriter
'>>filename'
\family default
: Append the output to a file named filename.
 The file will be opened at the beginning of 
\family typewriter
evolve
\family default
 function and closed at the end.
 An existing file will be cleared.
\end_layout

\begin_layout Itemize

\family typewriter
'>>>filename'
\family default
: This is similar to the 
\family typewriter
'>>'
\family default
 form but the file will not be cleared at the beginning of the 
\family typewriter
evolve
\family default
 function.
\end_layout

\begin_layout Itemize

\family typewriter
'!expr'
\family default
: 
\family typewriter
expr
\family default
 is considered as a Python expression that will be evaluated at a population's
 local namespace whenever an output string is needed.
 For example, 
\family typewriter
'!
\begin_inset Quotes erd
\end_inset

%d.txt
\begin_inset Quotes erd
\end_inset

 % gen'
\family default
 would return 
\family typewriter
0.txt
\family default
, 
\family typewriter
1.txt
\family default
 etc at generation 
\family typewriter
0
\family default
, 
\family typewriter
1
\family default
, ....
\end_layout

\begin_layout Itemize
File handle of an opened file.
 Actually any python object with a 
\family typewriter
write
\family default
 function.
\end_layout

\begin_layout Itemize
A Python function that can accept a string as its only parameter (
\family typewriter
func(msg)
\family default
).
 When an operator outputs a message, this function will be called with this
 message.
\end_layout

\begin_layout Itemize
A 
\family typewriter
WithMode(output, 'b')
\family default
 object with 
\family typewriter
output
\family default
 being the any of the allowed output string or function.
 This object tells simuPOP that the output is opened in binary model so
 that it should output bytes instead of texts to it.
 This is mostly designed for Python 3 because file objects in Python 2 accepts
 string even if they are opened in binary mode.
 
\end_layout

\begin_layout Standard
Because a table output such as the one in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 is written by several operators, it is clear that all of them need to use
 the 
\family typewriter
'>>'
\family default
 output format.
\end_layout

\begin_layout Standard
The 
\family typewriter
SavePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 write to file 
\family typewriter
sample.pop
\family default
.
 This works well if there is only one replicate but not so when the operator
 is applied to multiple populations.
 Only the last population will be saved successfully! In this case, the
 expression form of parameter 
\family typewriter
output
\family default
 should be used.
\end_layout

\begin_layout Standard
The expression form of this parameter accepts a Python expression.
 Whenever a filename is needed, this expression is evaluated against the
 local namespace of the population it is applied to.
 Because the 
\family typewriter
evolve
\family default
 function automatically sets variables 
\family typewriter
gen
\family default
 and 
\family typewriter
rep
\family default
 in a population's local namespace, such information can be used to produce
 an output string.
 Of course, any variable in this namespace can be used so you are not limited
 to these two variable.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 demonstrates the use of these two parameters.
 In this example, a table is written to file 
\family typewriter
LD.txt
\family default
 using 
\family typewriter
output='>>LD.txt'
\family default
.
 Similar operation to 
\family typewriter
output='R2.txt'
\family default
 fails because only the last 
\begin_inset Formula $R^{2}$
\end_inset

 value is written to this file.
 The last operator writes output for each replicate to their respective
 output file such as 
\family typewriter
LD_0.txt
\family default
, using an expression that involves variable 
\family typewriter
rep
\family default
.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/output.log"
lstparams "caption={Use the output and outputExpr parameters},label={output}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "outputFunc"

\end_inset

 demonstrates an advanced usage of the 
\family typewriter
output
\family default
 parameter.
 In this example, a logging object is created to write to a logfile as well
 as the standard output.
 The 
\family typewriter
info
\family default
 and 
\family typewriter
debug
\family default
 functions of this object are assigned to two operators so that their outputs
 can be sent to both a logfile and to the console window.
 One of the advantages of using a logging mechanism is that debugging output
 could be suppressed easily by adjusting the logging level of the logging
 object.
 Note that function 
\family typewriter
logging.info()
\family default
 automatically adds a new line to its input messages before it writes them
 to an output.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/outputFunc.log"
lstparams "caption={Output to a Python function},label={outputFunc}"

\end_inset


\end_layout

\begin_layout Subsection
During-mating operators
\end_layout

\begin_layout Standard
All operators in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "replicate"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 are applied before or after mating.
 There is, however, a hidden during-mating operator that is called by 
\family typewriter
RandomMating()
\family default
.
 This operator is called 
\family typewriter
MendelianGenoTransmitter()
\family default
 and is responsible for transmitting genotype from parents to offspring
 according to Mendel's laws.
 All pre-defined mating schemes (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Mating-Schemes"

\end_inset

) use a special kind of during-mating operator to transmit genotypes.
 They are called 
\series bold
genotype transmitters
\series default
 just to show the kind of task they perform.
 More during mating operators could be specified by replacing the default
 operator used in the 
\family typewriter
ops
\family default
 parameter of a mating scheme (or an offspring generator if you are defining
 your own mating scheme).
\end_layout

\begin_layout Standard
Operators used in a mating scheme honor applicability parameters 
\family typewriter
begin
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
at
\family default
 and 
\family typewriter
reps
\family default
 although they do not support negative population and replicate indexes.
 It is therefore possible to apply different during-mating operators at
 different generations.
 For example, a 
\family typewriter
Recombinator
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "transmitter"

\end_inset

 to transmit parental genotypes to offspring after generation 30 while the
 
\family typewriter
MendelianGenoTransmitter
\family default
 is applied before that.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/transmitter.log"
lstparams "caption={Genotype transmitters},label={transmitter}"

\end_inset


\end_layout

\begin_layout Standard
During-mating operators can be applied to (virtual) subpopulations using
 parameter 
\family typewriter
subPops
\family default
, which 
\series bold
refers to (virtual) subpopulations in the offspring population
\series default
.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Pre-defined-genotype-transmitters"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Genotype-transmitters"

\end_inset

 list all genotype transmitters, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Customized-genotype-transmitter"

\end_inset

 demonstrates how to define your own genotype transmitter, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:vspSelection"

\end_inset

 demonstrates the use of during-mating operator in virtual subpopulations.
\end_layout

\begin_layout Subsection
Function form of an operator
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-form"

\end_inset


\end_layout

\begin_layout Standard
Operators are usually applied to populations through a simulator but they
 can also be applied to a population directly.
 For example, it is possible to create an 
\family typewriter
InitGenotype
\family default
 operator and apply to a population as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InitGenotype(freq=[.3, .2, .5]).apply(pop)
\end_layout

\end_inset

Similarly, you can apply the hybrid penetrance model defined in Example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 to a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyPenetrance(func=myPenetrance, loci=[10, 30, 50]).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This usage is used so often that it deserves some simplification.
 Equivalent functions are defined for most operators.
 For example, function 
\family typewriter
initGenotype
\family default
 is defined for operator 
\family typewriter
InitGenotype
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/funcform.log"
lstparams "caption={The function form of operator \\texttt{InitGenotype}},label={funcform}"

\end_inset


\end_layout

\begin_layout Standard
These functions are called function form of operators.
 Using these functions, the above two example can be written as 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initGenotype(pop, freq=[.3, .2, .5])
\end_layout

\end_inset

and 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyPenetrance(pop, func=myPenetrance, loci=[10, 30, 50])
\end_layout

\end_inset

respectively.
 Note that applicability parameters such as 
\family typewriter
begin
\family default
 and 
\family typewriter
end
\family default
 can still be passed, but they are ignored by these functions.
\end_layout

\begin_layout Standard
Finally, it is worth noting that, if you have a function that manipulates
 population, you can make it an operator by wrapping it in a 
\family typewriter
PyOperator
\family default
 so that it can be called repeatedly during evolution.
 For example, for a function 
\family typewriter
myFunc
\family default
 that works on a population, you can define a wrapper function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def Func(pop):
\end_layout

\begin_layout Plain Layout

    # call myFunc
\end_layout

\begin_layout Plain Layout

    myFunc(pop)
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which can then use it in a 
\family typewriter
PyOperator
\family default
 as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyOperator(func=Func)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The wrapper function is not needed if myFunc returns 
\family typewriter
True
\family default
 by itself.
 It can also be simplifed to a lambda function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyOperator(func=lambda pop: myFunc(pop) is None)
\end_layout

\end_inset

if you are certain that 
\family typewriter
myFunc
\family default
 does not return any value (return 
\family typewriter
None
\family default
).
\end_layout

\begin_layout Note
Whereas output files specified by 
\family typewriter
'>'
\family default
 are closed immediately after they are written, those specified by 
\family typewriter
'>>'
\family default
 and 
\family typewriter
'>>>'
\family default
 are not closed after the operator is applied to a population.
 This is not a problem when operators are used in a simulator because 
\family typewriter
Simulator.evolve
\family default
 closes all files opened by operators, but can cause trouble when the operator
 is applied directly to a population.
 For example, multiple calls to 
\family typewriter
dump(pop, output='>>file')
\family default
 will dump pop to 
\family typewriter
file
\family default
 repeatedly but 
\family typewriter
file
\family default
 will not be closed afterward.
 In this case, 
\family typewriter
closeOutput('file')
\family default
 should be used to explicitly close the file.
\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
simuPOP provides three operators to initialize individual sex, information
 fields and genotype at the population level.
 A number of parameter are provided to cover most commonly used initialization
 scenarios.
 A Python operator can be used to intialize a population explicitly if none
 of the operators fits your need.
\end_layout

\begin_layout Subsection
Initialize individual sex (operator 
\family typewriter
InitSex
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
InitSex()
\family default
 and function 
\family typewriter
initSex()
\family default
 initialize individual sex either randomly or using a given sequence.
 In the first case, individuals are assigned 
\family typewriter
MALE
\family default
 or 
\family typewriter
FEMALE
\family default
 with equal probability unless parameter 
\emph on
maleFreq
\emph default
 is used to specify the probability of having a male Individual.
 Alternatively, parameter 
\emph on
maleProp
\emph default
 can be used to specify exact proportions of male individuals so that you
 will have exactly 1000 males and 1000 females if you apply 
\family typewriter
InitSex(maleProp=0.5)
\family default
 to a population of 2000 individuals.
\end_layout

\begin_layout Standard
Both parameters 
\family typewriter
maleFreq
\family default
 and 
\family typewriter
maleProp
\family default
 assigns individual sex randomly.
 If for some reason you need to specify individual sex explicitly, you could
 use a sequence of sex (
\family typewriter
MALE
\family default
 or 
\family typewriter
FEMALE
\family default
) to assign sex to individuals succesively.
 The list will be reused if needed.
 If a list of (virtual) subpopulations are given, this operator will only
 initialize individuals in these (virtual) subpopulations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "InitSex"

\end_inset

 demonstrates how to use two 
\family typewriter
InitSex
\family default
 operators to initialize two subpopulations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitSex.log"
lstparams "caption={Initialize individual sex},label={InitSex}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize genotype (operator 
\family typewriter
InitGenotype
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
InitGenotype
\family default
 (and its function form 
\family typewriter
initGenotype
\family default
) initializes individual genotype by allele frequency, allele proportion,
 haplotype frequency, haplotype proportions or a list of genotypes:
\end_layout

\begin_layout Itemize
By frequency of alleles.
 For example, 
\family typewriter
InitGenotype(freq=(0, 0.2, 0.4, 0.2))
\family default
 will assign allele 0, 1, 2, and 3 with probability 0, 0.2, 0.4 and 0.2 respectivel
y.
\end_layout

\begin_layout Itemize
By proportions of alleles.
 For example, 
\family typewriter
InitGenotype(prop=(0, 0.2, 0.4, 0.2))
\family default
 will assign 400 allele 1, 800 allele 2 and 400 allele 3 to a diploid population
 with 800 individuals.
\end_layout

\begin_layout Itemize
By frequency of haplotypes.
 For example, 
\family typewriter
InitGenotype(haplotypes=[[0, 0], [1,1], [0,1],[1,1]])
\family default
 will assign four haplotypes with equal probabilities.
 
\family typewriter
InitGenotype(haplotypes=[[0, 0], [1,1], [0,1],[1,1]], freq=[0.2, 0.2, 0.3,
 0.3])
\family default
 will assign these haplotypes with different frequencies.
 If there are more than two loci, the haplotypes will be repeated.
\end_layout

\begin_layout Itemize
By frequency of haplotypes.
 For example, 
\family typewriter
InitGenotype(haplotypes=[[0, 0], [1,1], [0,1],[1,1]], prop=[0.2, 0.2, 0.3,
 0.3])
\family default
 will assign four haplotypes with exact proportions.
 
\end_layout

\begin_layout Itemize
By a list of genotype.
 For example, 
\family typewriter
InitGenotype(genotype=[1, 2, 2, 1])
\family default
 will assign genotype 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
1
\family default
 repeatedly to a population.
 If individuals in this population has two homologous copies of a chromosome
 with two loci, this operator will assign haplotype 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 to the first homologous copy of the chromosome, and 
\family typewriter
2
\family default
, 
\family typewriter
1
\family default
 to the second copy.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
loci
\family default
 and 
\family typewriter
ploidy
\family default
 can be used to specify a subset of loci and homologous sets of chromosomes
 to initialize, and parameter 
\family typewriter
subPops
\family default
 can be used to specify subsets of individuals to initialize.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "InitGenotype"

\end_inset

 demonstrates how to use these the 
\family typewriter
InitGenotype
\family default
 operator, including examples on how to define and use virtual subpopulations
 to initialize individual genotype by sex or by proportion.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitGenotype.log"
lstparams "caption={Initialize individual genotype},label={InitGenotype}"

\end_inset


\end_layout

\begin_layout Subsection
Initialize information fields (operator 
\family typewriter
InitInfo
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
InitInfo
\family default
 and its function form 
\family typewriter
initInfo
\family default
 initialize one or more information fields of all individuals or Individuals
 in selected (virtual) subpopulations using either a list of values or a
 Python function.
 If a value or a list of value is given, it will be used repeatedly to assign
 values of specified information fields of all applicable individuals.
 For example, 
\family typewriter
initInfo(pop, values=1, infoFields='x')
\family default
 will assign value 
\family typewriter
1
\family default
 to information field 
\family typewriter
x
\family default
 of all individuals, and 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initInfo(pop, values=[1, 2, 3], infoFields='x', subPops=[(0,1)])
\end_layout

\end_inset

will assign values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
3
\family default
, 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
, 
\family typewriter
3
\family default
...
 to information field 
\family typewriter
x
\family default
 of individuals in the second virtual subpopulation of subpopulation 0.
\end_layout

\begin_layout Standard
The 
\family typewriter
values
\family default
 parameter also accepts a Python function.
 This feature is usually used to assign random values to an information
 field.
 For example, 
\family typewriter
values=random.random
\family default
 would assign a random value between 0 and 1.
 If a function takes parameters, a lambda function can be used.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initInfo(pop, lambda : random.randint(2, 5), infoFields=['x', 'y'])
\end_layout

\end_inset

 assigns random integers between 2 and 5 to information fields 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 of all individuals in 
\emph on
pop
\emph default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "InitInfo"

\end_inset

 demonstrates these usages.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitInfo.log"
lstparams "caption={initialize information fields},label={InitInfo}"

\end_inset


\end_layout

\begin_layout Section
Expressions and statements
\end_layout

\begin_layout Subsection
Output a Python string (operator 
\family typewriter
PyOutput
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
PyOutput
\family default
 is a simple operator that prints a Python string when it is applied to
 a population.
 It is commonly used to print the progress of a simulation (e.g.
 
\family typewriter
PyOutput('start migration
\backslash
n', at=200)
\family default
) or output separators to beautify outputs from 
\family typewriter
PyEval
\family default
 outputs (e.g.
 
\family typewriter
PyOutput('
\backslash
n', rep=-1)
\family default
.
\end_layout

\begin_layout Subsection
Execute Python statements (operator 
\family typewriter
PyExec
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
PyExec
\family default
 executes Python statements in a population's local namespace when it is
 applied to that population.
 This operator is designed to execute short Python statements but multiple
 statements separated by newline characters are allowed.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyExec"

\end_inset

 uses two 
\family typewriter
PyExec
\family default
 operators to create and use a variable 
\family typewriter
traj
\family default
 in each population's local namespace.
 The first operator initialize this variable as an empty list.
 During evolution, the frequency of allele 1 at locus 0 is calcuated (operator
 
\family typewriter
Stat
\family default
) and appended to this variable (operator 
\family typewriter
PyExec
\family default
).
 The result is a trajectory of allele frequencies during evolution.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyExec.log"
lstparams "caption={Execute Python statements during evolution},label={PyExec}"

\end_inset


\end_layout

\begin_layout Subsection
Evaluate and output Python expressions (operator 
\family typewriter
PyEval
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
PyEval
\family default
 evaluate a given Python expression in a population's local namespace and
 output its return value.
 This operator has been widely used (e.g.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "ancestralPop"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "applicableGen"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

) to output statistics of populations and report progress.
\end_layout

\begin_layout Standard
Two additional features of this operator may become handy from time to time.
 First, an optional Python statements (parameter 
\emph on
stmts
\emph default
) can be specified which will be executed before the expression is evaluated.
 Second, the population being applied can be exposed in its own namespace
 as a variable (parameter 
\emph on
exposePop
\emph default
).
 This makes it possible to access properties of a population other than
 its variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyEval"

\end_inset

 demonstrates both features.
 In this example, two statements are executed to count the number of unique
 parents in an offspring population and save them as variables 
\family typewriter
numFather
\family default
 and 
\family typewriter
numMother
\family default
.
 The operator outputs these two variables alone with a generation number.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyEval.log"
lstparams "caption={Evaluate a expression and statements in a population's local namespace.},label={PyEval}"

\end_inset


\end_layout

\begin_layout Standard
Note that the function form of this operator (
\family typewriter
pyEval
\family default
) returns the result of the expression rather than writting it to an output.
\end_layout

\begin_layout Subsection
Expression and statement involving individual information fields (operator
 
\family typewriter
InfoEval
\family default
 and 
\family typewriter
InfoExec
\family default
) *
\end_layout

\begin_layout Standard
Operators 
\family typewriter
PyEval
\family default
 and 
\family typewriter
PyExec
\family default
 work at the population level, using the local namespace of populations.
 Operator 
\family typewriter
InfoEval
\family default
 and 
\family typewriter
InfoExec
\family default
, on the contraray, work at the individual level, using individual information
 fields (and population variables) as variables.
 In this case, individual information fields are copied to the population
 namespace one by one before expression or statements are executed for each
 individual.
 Optionally, the individual object can be exposed to these namespace using
 a user-specified name (parameter 
\emph on
exposeInd
\emph default
).
 Individual information fields will be updated if the value of these fields
 are changed.
\end_layout

\begin_layout Standard
Operator 
\family typewriter
InfoEval
\family default
 evaluates an expression and outputs its value.
 Operator 
\family typewriter
InfoExec
\family default
 executes one or more statements and does not produce any output.
 Operator 
\family typewriter
InfoEval
\family default
 is usually used to output individual information fields and properties
 in batch mode.
 It is faster and sometimes easier to use than corresponding for loop plus
 individual level operations.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
InfoEval(r'
\begin_inset Quotes erd
\end_inset

%.2f
\backslash
t
\begin_inset Quotes erd
\end_inset

 % a')
\family default
 outputs the value of information field a for all individuals, separated
 by tabs.
\end_layout

\begin_layout Itemize

\family typewriter
InfoEval('ind.sexChar()', exposeInd='ind')
\family default
 outputs the sex of all individuals using an exposed individual object 
\family typewriter
ind
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
InfoEval('a+b**2')
\family default
 outputs 
\begin_inset Formula $a+b^{2}$
\end_inset

 for information fields 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 for all individuals.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "InfoEval"

\end_inset

 demonstrates the use of this operator.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InfoEval.log"
lstparams "caption={Evaluate expressions using individual information fields},label={InfoEval}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
InfoExec
\family default
 is usually used to set individual information fields.
 For example
\end_layout

\begin_layout Itemize

\family typewriter
InfoExec('age += 1')
\family default
 increases the age of all individuals by one.
\end_layout

\begin_layout Itemize

\family typewriter
InfoExec('risk = 2 if packPerYear > 10 else 1.5')
\family default
 sets information field 
\family typewriter
risk
\family default
 to 
\family typewriter
2
\family default
 if 
\family typewriter
packPerYear
\family default
 is greater than 
\family typewriter
10
\family default
, and 
\family typewriter
1.5
\family default
 otherwise.
 Note that conditional expression is only available for Python version 2.5
 or later.
\end_layout

\begin_layout Itemize

\family typewriter
InfoExec('a = b*c')
\family default
 sets the value of information field 
\family typewriter
a
\family default
 to the product of 
\family typewriter
b
\family default
 and 
\family typewriter
c
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "InfoExec"

\end_inset

 demonstrates the use of this operator, using its function form 
\family typewriter
infoExec
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InfoExec.log"
lstparams "caption={Execute statements using individual information fields},label={InfoExec}"

\end_inset


\end_layout

\begin_layout Standard
Note that a statement can also be specified for operator 
\family typewriter
InfoEval
\family default
, which will be executed before an expression is evaluated.
\end_layout

\begin_layout Subsection
Using functions in external modules in simuPOP expressions and statements
\end_layout

\begin_layout Standard
All simuPOP expressions and statements are evaluated in a population's local
 namespace, which is a dictionary with no access to external modules.
 If you would like to use external modules (e.g.
 functions from the 
\family typewriter
random
\family default
 module), you will have to import them to the namespace explicitly, using
 something like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

exec('import random', pop.vars(), pop.vars())
\end_layout

\end_inset

before you evolve the population.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "outputByInterval"

\end_inset

 demonstrates the application of this technique.
 This example imports the 
\family typewriter
time
\family default
 module in the population's local namespace and set 
\family typewriter
init_time
\family default
 and 
\family typewriter
last_time
\family default
 before evolution.
 During evolution, an
\family typewriter
 IfElse
\family default
 operator is used to output the status of the simulation for every 5 seconds
 using expression 
\family typewriter
time.time() - last_time > 5
\family default
.
 
\family typewriter
last_time
\family default
 is reset using the 
\family typewriter
PyExec
\family default
 operator.
 The evolution will last 20 seconds and be terminated by the Terminator
 with expression 
\family typewriter
time.time() - init_time > 20.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/outputByInterval.log"
lstparams "caption={Write the status of an evolutionary process every 10 seconds},label={outputByInterval}"

\end_inset


\end_layout

\begin_layout Section
Demographic changes
\end_layout

\begin_layout Standard
A mating scheme controls the size of an offspring generation using parameter
 
\family typewriter
subPopSize
\family default
.
 This parameter has been described in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

.
 In summary,
\end_layout

\begin_layout Itemize
The subpopulation sizes of the offspring generation will be the same as
 the parental generation if subPopSize is not set.
\end_layout

\begin_layout Itemize
The offspring generation will have a fixed size if 
\family typewriter
subPopSize
\family default
 is set to a number (no subpopulation) or a list of subpopulation sizes.
 
\end_layout

\begin_layout Itemize
The subpopulation sizes of an offspring generation will be determined by
 the return value of a demographic function if 
\family typewriter
subPopSize
\family default
 is set to such a function (a function that returns subpopulation sizes
 at each generation).
\end_layout

\begin_layout Note
Parameter 
\family typewriter
subPopSize
\family default
 only controls subpopulation sizes of an offspring generation immediately
 after it is generated.
 population or subpopulation sizes could be changed by other operators.
\end_layout

\begin_layout Standard
During mating, a mating scheme goes through each parental subpopulation
 and populates its corresponding offspring subpopulation.
 This implies that
\end_layout

\begin_layout Itemize
Parental and offspring populations should have the same number of subpopulations.
\end_layout

\begin_layout Itemize
Mating happens strictly within each subpopulation.
\end_layout

\begin_layout Standard
This section will introduce several operators that allow you to move dndividuals
 across the boundary of subpopulations (migration), and change the number
 of subpopulations during evolution (split and merge).
 Please refer to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

 (control the size of the offspring generation section of chapter mating
 scheme) for more details.
 For more advanced demographic models, please refer to the 
\family typewriter
simuPOP.demography
\family default
 module.
\end_layout

\begin_layout Subsection
Migration (operator 
\family typewriter
Migrator
\family default
)
\end_layout

\begin_layout Subsubsection
Migration by probability
\end_layout

\begin_layout Standard
Operator 
\family typewriter
Migrator
\family default
 (and its function form 
\family typewriter
migrate
\family default
) migrates individuals from one subpopulation to another.
 The key parameters are
\end_layout

\begin_layout Itemize

\emph on
from
\emph default
 subpopulations (parameter 
\family typewriter
subPops
\family default
).
 A list of subpopulations from which individuals migrate.
 Default to all subpopulations.
\end_layout

\begin_layout Itemize

\emph on
to
\emph default
 subpopulations (parameter 
\family typewriter
toSubPops
\family default
).
 A list of subpopulations to which individuals migrate.
 Default to all subpopulations.
 
\series bold
A new subpopulation ID can be specified to create a new subpopulation from
 migrants.
\end_layout

\begin_layout Itemize
A migration rate matrix (parameter 
\family typewriter
rate
\family default
).
 A 
\begin_inset Formula $m$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 matrix ( a nested list in Python) that specifies migration rate from each
 source to each destination subpopulation.
 That is to say, 
\begin_inset Formula $\mbox{rate}{}_{i,j}$
\end_inset

 specifies migration rate from 
\begin_inset Formula $\mbox{subPops}_{i}$
\end_inset

 to 
\begin_inset Formula $\mbox{toSubPops}_{j}$
\end_inset

.
 Needless to say, 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are determined by the number of 
\emph on
from
\emph default
 and 
\emph on
to
\emph default
 subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByProb"

\end_inset

 demonstrate the use of a 
\family typewriter
Migrator
\family default
 to migrate individuals between three subpopulations.
 Note that 
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
Migrator
\family default
 relies on an information field 
\family typewriter
migrate_to
\family default
 (configurable) to record destination subpopulation of each individual so
 this information field needs to be added to a population befor migration.
\end_layout

\begin_layout Itemize
Migration rates to subpopulation themselves are determined automatically
 so they can be left unspecified.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateByProb.log"
lstparams "caption={Migration by probability},label={migrateByProb}"

\end_inset


\end_layout

\begin_layout Subsubsection
Migration by proportion and counts
\end_layout

\begin_layout Standard
Migration rate specified in the rate parameter in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByProb"

\end_inset

 is intepreted as probabilities.
 That is to say, a migration rate 
\begin_inset Formula $r_{m,n}$
\end_inset

 is interpreted as the probability at which any individual in subpopulation
 
\begin_inset Formula $m$
\end_inset

 migrates to subpopulation 
\begin_inset Formula $n$
\end_inset

.
 The exact number of migrants are randomly distributed.
\end_layout

\begin_layout Standard
If you would like to specify exactly how many migrants migrate from a subpopulat
ion to another, you can specify parameter 
\family typewriter
mode
\family default
 of operator 
\family typewriter
Migrator
\family default
 to 
\family typewriter
BY_PROPORTION
\family default
 or 
\family typewriter
BY_COUNTS
\family default
.
 The 
\family typewriter
BY_PROPORTION
\family default
 mode interpret 
\begin_inset Formula $r_{m,n}$
\end_inset

 as proportion of individuals who will migrate from subpopulation 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 so the number of 
\begin_inset Formula $m\rightarrow n$
\end_inset

 migrant will be exactly 
\begin_inset Formula $r_{m,n}\times$
\end_inset

subPopSize(m).
 In the 
\family typewriter
BY_COUNTS
\family default
 mode, 
\begin_inset Formula $r_{m,n}$
\end_inset

 is interpretted as number of migrants, regardless the size of subpopulation
 
\begin_inset Formula $m$
\end_inset

.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateByPropAndCount"

\end_inset

 demonstrates these two migration modes, as well as the use of parameters
 
\family typewriter
subPops
\family default
 and 
\family typewriter
toSubPops.

\family default
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateByPropAndCount.log"
lstparams "caption={Migration by proportion and count},label={migrateByPropAndCount}"

\end_inset


\end_layout

\begin_layout Subsubsection
Theoretical migration models
\end_layout

\begin_layout Standard
To facilitate the use of widely used theoretical migration models, a few
 functions are defined in module 
\family typewriter
simuPOP.demography
\family default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Predefined-migration-models"

\end_inset

.
 These functions generate migration matrixes that can be plugged in to the
 
\family typewriter
Migrator
\family default
 operator.
\end_layout

\begin_layout Subsubsection
migrate from virtual subpopulations *
\end_layout

\begin_layout Standard
Under a realistic eco-social settings, individuals in a subpopulation rarely
 have the same probability to migrate.
 Genetic evidence has shown that female has a higher migrate rate than male
 in humans, perhaps due to migration patterns related to inter-population
 marriages.
 Such sex-biased migration also happens in other large migration events
 such as slave trade.
\end_layout

\begin_layout Standard
It is easy to simulate most of such complex migration models by migrating
 from virtual subpopulations.
 For example, if you define virtual subpopulations by sex, you can specify
 different migration rates for males and females and control the proportion
 of males among migrants, by specifying virtual subpopulations in parameter
 
\family typewriter
subPops
\family default
.
 Parameter 
\family typewriter
toSubPops
\family default
 does not accept virtual subpopulations because you cannot, for example,
 migrate to females in a subpopulation.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrateVSP"

\end_inset

 demonstrate a sex-biased migration model where males dominate migrants
 from subpopulation 0.
 To avoid confusing, this example uses the proportion migration mode.
 At the beginning of the first generation, there are 500 males and 500 females
 in each subpopulation.
 A 10% male migration rate and 5% female migration rate leads to 50 male
 migrants and 25 female migrants.
 Subpopulation sizes and number of males in each subpopulation before mating
 are therefore:
\end_layout

\begin_layout Itemize
Subpopulation 0: male 500-50, female 500-25, total 925
\end_layout

\begin_layout Itemize
Subpopulation 1: male 500+50, female 500+25, total 1075
\end_layout

\begin_layout Standard
Note that the unspecified 
\emph on
to
\emph default
 subpopulations are subpopulation 0 and 1, which cannot be virtual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrateVSP.log"
lstparams "caption={Migration from virtual subpopulations},label={migrateVSP}"

\end_inset


\end_layout

\begin_layout Subsubsection
Arbitrary migration models **
\end_layout

\begin_layout Standard
If none of the described migration mothods fits your need, you can always
 resort to manual migration.
 One such example is when you need to mimick an existing evolutionary scenario
 so you know exactly which subpopulation each individual will migrate to.
\end_layout

\begin_layout Standard
Manual migration is actually very easy.
 All you need to do is specifying the destination subpopulation of all individua
ls in the 
\emph on
from
\emph default
 subpopulations (parameter 
\family typewriter
subPops
\family default
), using an information field (usually 
\family typewriter
migrate_to
\family default
).
 You can then call the 
\family typewriter
Migrator
\family default
 using 
\family typewriter
mode=BY_IND_INFO
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "manualMigration"

\end_inset

 shows how to manually move individuals around.
 This example uses the function form of 
\family typewriter
Migrator
\family default
.
 You usually need to use a Python operator to set destination subpopulations
 if you would like to manually migrate individuals during an evolutionary
 process.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/manualMigration.log"
lstparams "caption={Manual migration},label={manualMigration}"

\end_inset


\end_layout

\begin_layout Note
individuals with an invalid destination subpopulation ID (e.g.
 an negative number) will be discarded silently.
 Although not recommended, this feature can be used to remove individuals
 from a subpopulation.
\end_layout

\begin_layout Subsection
Split subpopulations (operators 
\family typewriter
SplitSubPops
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
SplitSubPops
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SplitSubPops
\end_layout

\end_inset


\family default
 splits one or more subpopulations into finer subpopulations.
 It can be used to simulate populations that originate from the same founder
 population.
 For example, a population of size 1000 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitBySize"

\end_inset

 is split into three subpopulations of sizes 300, 300 and 400 respectively,
 after evolving as a single population for two generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitBySize.log"
lstparams "caption={Split subpopulations by size},label={splitBySize}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
SplitSubPops
\family default
 splits a subpopulation by sizes of the resulting subpopulations.
 It is often easier to do so with proportions.
 In addition, if a demographic function is used, you should make sure that
 the number of subpopulations will be the same before and after mating at
 any generation.
 One way of doing this is to apply a 
\family typewriter
SplitSubPops
\family default
 operator at the right generation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByProp"

\end_inset

 demonstrates such an evolutionary scenario.
 However, it is often easier to split the population in the demographic
 function in such case (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Advanced-demo-func"

\end_inset

 for details).
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitByProp.log"
lstparams "caption={Split subpopulations by proportion},label={splitByProp}"

\end_inset


\end_layout

\begin_layout Standard
Either by 
\emph on
sizes
\emph default
 or by 
\emph on
proportions
\emph default
, individuals in a subpopulation are divided randomly.
 It is, however, also possible to split subpopulations according to individual
 information fields.
 In this case, individuals with different values at a given information
 field will be split into different subpopulations.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByInfo"

\end_inset

 where the function form of operator 
\family typewriter
SplitSubPops
\family default
 is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/splitByInfo.log"
lstparams "caption={Split subpopulations by individual information field},label={splitByInfo}"

\end_inset


\end_layout

\begin_layout Subsection
Merge subpopulations (operator 
\family typewriter
MergeSubPops
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
MergeSubPops
\family default
 merges specified subpopulations into a single subpopulation.
 This operator can be used to simulate admixed populations where two or
 more subpopulations merged into one subpopulation and continue to evolve
 for a few generations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MergeSubPops"

\end_inset

 simulates such an evolutionary scenario.
 A demographic model could be added similar to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByProp"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MergeSubPops.log"
lstparams "caption={Merge multiple subpopulations into a single subpopulation},label={MergeSubPops}"

\end_inset


\end_layout

\begin_layout Subsection
Resize subpopulations (operator 
\family typewriter
ResizeSubPops
\family default
)
\end_layout

\begin_layout Standard
Whenever possible, it is recommended that subpopulation sizes are changed
 naturally, namely through the population of an offspring generation.
 However, it is sometimes desired to change the size of a population forcefully.
 Examples of such applications include immediate expansion of a small population
 before evolution, and the simulation of sudden population size change caused
 by natural disaster.
 By default, new individuals created by such sudden population expansion
 get their genotype from existing individuals.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ResizeSubPops"

\end_inset

 shows a scenario where two subpopulations expand instantly at generation
 3.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ResizeSubPops.log"
lstparams "caption={Resize subpopulation sizes},label={ResizeSubPops}"

\end_inset


\end_layout

\begin_layout Subsection
Time-dependent migration rate
\end_layout

\begin_layout Standard
In evolutionary scenarios with complex demographic models, number of subpopulati
ons and migration rate might change from generation to generation.
 For example, if one of the subpopulations is split into two, the migration
 matrix has to be changed to accommendate increased number of subpopulations.
\end_layout

\begin_layout Standard
If there are a limited number of demographic changes and a few number of
 pre-determined migration matrices.
 You can use a number of 
\family typewriter
Migrators
\family default
 that are applied at different generations.
 For example, you can use the following operators to apply the first migration
 scheme during first ten generations (0, ..., 9), and the second migration
 scheme during the rest of the evolutionary process: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

preOps=[
\end_layout

\begin_layout Plain Layout

    Migrator(rate=M1, end=9),
\end_layout

\begin_layout Plain Layout

    Migrator(rate=M2, begin=10),
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If changes of demographies are frequent or stochastic so that migration
 matrices can only be determined programmatically, it is easier to use a
 
\family typewriter
PyOperator
\family default
 to migrate populations using the function form of a 
\family typewriter
Migrator
\family default
.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varyingMigr"

\end_inset

 where migration matrixes are computed dynamically due to random split of
 subpopulations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/VaryingMigr.log"
lstparams "caption={Varying migration rate},label={varyingMigr}"

\end_inset


\end_layout

\begin_layout Section
Genotype transmitters
\begin_inset CommandInset label
LatexCommand label
name "sec:Genotype-transmitters"

\end_inset


\end_layout

\begin_layout Subsection
Generic genotype transmitters (operators 
\family typewriter
GenoTransmitter
\family default
, 
\family typewriter
CloneGenoTransmitter
\family default
, 
\family typewriter
MendelianGenoTransmitter
\family default
, 
\family typewriter
SelfingGenoTransmitter
\family default
, 
\family typewriter
HaplodiploidGenoTransmitter
\family default
, and 
\family typewriter
MitochondrialGenoTransmitter
\family default
) *
\end_layout

\begin_layout Standard
A number of during-mating operators are defined to transmit genotype from
 parent(s) to offspring.
 They are rarely used or even seen directly because they are used as genotype
 transmitters of mating schemes.
\end_layout

\begin_layout Itemize

\family typewriter
GenoTransmitter
\family default
: This genotype transmitter is usually used by customized genotype transmitters
 because it provides some utility functions that are more efficient than
 their Pythonic counterparts.
\end_layout

\begin_layout Itemize

\family typewriter
CloneGenoTransmitter
\family default
: Copy all genotype on non-customized chromosomes from a parent to an offspring.
 It also copies parental sex to the offspring because sex can be genotype
 determined.
 This genotype transmitter is used by mating scheme 
\family typewriter
CloneMating
\family default
.
 This genotype transmitter can be applied to populations of 
\series bold
any ploidy
\series default
 type.
 If you would like to copy part of the chromosomes, or customized chromosomes,
 a parameter chroms could be used to specify chromosomes to copy.
\end_layout

\begin_layout Itemize

\family typewriter
MendelianGenoTransmitter
\family default
: Copy genotypes from two parents (a male and a female) to an offspring
 following Mendel's laws, used by mating scheme 
\family typewriter
RandomMating.
\family default
This genotype transmitter can only be applied to 
\series bold
diploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
SelfingGenoTransmitter
\family default
: Copy genotypes from one parent to an offspring using self-fertilization,
 used by mating scheme 
\family typewriter
SelfMating
\family default
.
 This genotype transmitter can only be applied to 
\series bold
diploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
HaplodiploidGenoTransmitter
\family default
: Set genotype to male and female offspring differently in a haplodiploid
 population, used by mating scheme 
\family typewriter
HaplodiploidMating
\family default
.
 This genotype transmitter can only be applied to 
\series bold
haplodiploid
\series default
 populations.
\end_layout

\begin_layout Itemize

\family typewriter
MitochondrialGenoTransmitter
\family default
: Treat a single mitochondrial chromosome, or all customized chromosomes,
 or specified chromosomes as mitochondrial chromosomes and transmit maternal
 mitochondrial chromosomes randomly to an offspring.
 This genotype transmitter can be applied to populations of 
\series bold
any ploidy
\series default
 type.
 It trasmits the first homologous copy of chromosomes maternally and clears
 alleles on other homologous copies of chromosomes of an offspring.
 
\end_layout

\begin_layout Subsection
Recombination (Operator 
\family typewriter
Recombinator
\family default
)
\end_layout

\begin_layout Standard
The generic genotype transmitters do not handle genetic recombination.
 A genotype transmitter 
\family typewriter
Recombinator
\family default
 is provided for such purposes, and can be used with 
\family typewriter
RandomMating
\family default
 and 
\family typewriter
SelfMating
\family default
 (replace 
\family typewriter
MendelianGenoTransmitter
\family default
 and 
\family typewriter
SelfingGenoTransmitter
\family default
 used in these mating schemes).
\end_layout

\begin_layout Standard
Recombination rate is implemented 
\series bold
between adjacent markers
\series default
.
 There can be only one recombination event between adjacent markers no matter
 how far apart they are located on a chromosome.
 In practise, a 
\family typewriter
Recombinator
\family default
 goes along chromosomes and determine, between each adjacent loci, whether
 or not a recombination happens.
\end_layout

\begin_layout Standard
Recombination rates could be specified in the following ways:
\end_layout

\begin_layout Enumerate
If a single recombination rate is specified through paramter 
\family typewriter
rate
\family default
s, it will be the recombination rate between all adjacent loci, regardless
 of loci position.
\end_layout

\begin_layout Enumerate
If recombination happens only after certain loci, you can specify these
 loci using parameter 
\family typewriter
loci
\family default
.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Recombinator(rates=0.1, loci=[2, 5])
\end_layout

\end_inset

recombines a chromosome only 
\series bold
after
\series default
 loci 2 (between 2 and 3) and 5 (between 5 and 6).
\end_layout

\begin_layout Enumerate
If parameter 
\family typewriter
loci
\family default
 is given with a list of loci, different recombination rate can be given
 to each of them.
 The two lists should have the same length.
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Recombinator(rates=[0.1, 0.05], loci=[2, 5])
\end_layout

\end_inset

uses two different recombination rates after loci 2 and 5.
\end_layout

\begin_layout Enumerate
If parameter 
\family typewriter
loci
\family default
 is not given (default to 
\family typewriter
loci=ALL_AVAIL
\family default
) but a list of recombination rates is assigned, the rates will be assigned
 to each locus.
 The length of prameter 
\family typewriter
rates
\family default
 should equal to total number of loci but the recombiantion rates for the
 locus at the end of each chromosome will be ignored (assumed to be 0.5).
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Recombinator(rates=[0.1]*5 + [0.2]*5)
\end_layout

\end_inset

uses two different recombination rates for two chromosomes with 5 loci.
\end_layout

\begin_layout Enumerate
If recombination rates vary across your chromosomes, a long list of 
\family typewriter
rate
\family default
 and 
\family typewriter
loci
\family default
 may be needed to specify recombination rates one by one.
 An alternative method is to specify a 
\series bold
recombination intensity
\series default
.
 Recombination rate between two adjacent loci is calculated as the product
 of this intensity and distance between them.
 For example, if you apply operator
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Recombinator(intensity=0.1)
\end_layout

\end_inset

to a population
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Population(size=100, loci=[4], lociPos=[0.1, 0.2, 0.4, 0.8])
\end_layout

\end_inset

The recombination rates between adjacent markers will be 
\family typewriter
0.1*0.1
\family default
, 
\family typewriter
0.1*0.2
\family default
 and 
\family typewriter
0.1*0.4
\family default
 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/recRate.log"
lstparams "caption={Genetic recombination at all and selected loci},label={recRate}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "recRate"

\end_inset

 demonstrates how to specify recombination rates for all loci or for specified
 loci.
 In this example, two replicates of a population are evolved, subject to
 two different Recombinators.
 The first Recombinator applies the same recombination rate between all
 adjacent loci, and the second Recombinator recombines only after loci 50
 - 59.
 Because there is no recombination event between loci 60 and 70 for the
 second replicate, linkage disequilibrium values between these two loci
 does not decrease as what happens in the first replicate.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/recIntensity.log"
lstparams "caption={Genetic recombination rates specified by intensity},label={recIntensity}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "recIntensity"

\end_inset

 demonstrates the use of the 
\family typewriter
intensity
\family default
 parameter.
 In this example, the distances between the first two loci and the latter
 two loci are 1 and 0.1 respectively.
 This leads recombination rates 0.01 and 0.001 respectively with a recombination
 intensity 0.01.
 Consequently, LD between the first two loci decay much faster than the
 latter two.
\end_layout

\begin_layout Standard
If more advanced recombination model is desired, a customized genotype transmitt
er can be used.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 uses two Recombinators to implement sex-specific recombination.
\end_layout

\begin_layout Note
Both loci positions and recombination intensity are unitless.
 You can assume different unit for loci position and recombination intensity
 as long as the resulting recombination rate makes sense.
\end_layout

\begin_layout Subsection
Gene conversion (Operator 
\family typewriter
Recombinator
\family default
) *
\end_layout

\begin_layout Standard
simuPOP uses the Holliday junction model to simulate gene conversion.
 This model treats recombination and conversion as a unified process.
 The key features of this model is
\end_layout

\begin_layout Itemize
Two (out of four) chromatids pair and a single strand cut is made in each
 chromatid
\end_layout

\begin_layout Itemize
Strand exchange takes place between the chromatids
\end_layout

\begin_layout Itemize
Ligation occurs yielding two completely intact DNA molecules
\end_layout

\begin_layout Itemize
Branch migration occurs, giving regions of heteroduplex DNA
\end_layout

\begin_layout Itemize
Resolution of the Holliday junction gives two DNA molecules with heteroduplex
 DNA.
 Depending upon how the holliday junction is resolved, we either observe
 no exchange of flanking markers, or an exchange of flanking markers.
 The former forms a conversion event, which can be considered as a double
 recombination.
\end_layout

\begin_layout Standard
In practise, gene conversion can be considered as a double recombination
 event.
 That is to say, when a recombination event happens, it has certain probability
 to trigger a second recombination event along the chromosome.
 The distance between the two locations where recombination events happen
 is the tract length of this conversion event.
\end_layout

\begin_layout Standard
The probability at which gene conversion happens, and how tract length is
 determined is specify using parameter 
\family typewriter
convMode
\family default
 of a Recombinator.
 This parameter can be
\end_layout

\begin_layout Itemize

\family typewriter
NoConversion
\family default
 No gene conversion.
 (default)
\end_layout

\begin_layout Itemize

\family typewriter
(NUM_MARKERS, prob, N)
\family default
 Convert a fixed number 
\family typewriter
N
\family default
 of markers at probability 
\family typewriter
prob
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
(TRACT_LENGTH, prob, N)
\family default
 Convert a fixed length 
\family typewriter
N
\family default
 of chromosome regions at probability 
\family typewriter
prob
\family default
.
 This can be used when markers are not equally spaced on chromosomes.
\end_layout

\begin_layout Itemize

\family typewriter
(GEOMETRIC_DISTRIBUTION, prob, p)
\family default
 When a conversion event happens at probability 
\family typewriter
prob
\family default
, convert a random number of markers, with a geometric distribution with
 parameter 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
(EXPONENTIAL_DISTRIBUTION, prob, p)
\family default
 When a conversion event happens at probability 
\family typewriter
prob
\family default
, convert a random length of chromosome region, using an exponential distributio
n with parameter 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
If tract length is determined by length (
\family typewriter
TractLength
\family default
 or 
\family typewriter
ExponentialDistribution
\family default
), the starting point of the flanking region is uniformly distributed between
 marker 
\begin_inset Formula $i-1$
\end_inset

 and 
\begin_inset Formula $i$
\end_inset

, if the recombination happens at marker 
\begin_inset Formula $i$
\end_inset

.
 That is to say, it is possible that no marker is converted with a positive
 tract length.
\end_layout

\begin_layout Itemize
A conversion event will act like a recombination event if its flanking region
 exceeds the end of a chromosome, or if another recombination event happens
 before the end of the flanking region.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "conversion"

\end_inset

 compares two Recombinators.
 The first Recombinator is a regular Recombinator that recombine between
 loci 50 and 51.
 The second Recombinator is a conversion operator because every recombination
 event will become a conversion event (prob=1).
 Because a second recombination event will surely happen between loci 60
 and 61, there will be either no or double recombination events between
 loci 40, 70.
 LD between these two loci therefore does not decrease, although LD between
 locus 55 and these two loci will decay.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/conversion.log"
lstparams "caption={Gene conversion},label={conversion}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking all recombination events **
\end_layout

\begin_layout Standard
To understand the evolutionary history of a simulated population, it is
 sometimes needed to track down all ancestral recombination events.
 In order to do that, you will first need to give an unique ID to each individua
l so that you could make sense of the dumped recombination events.
 Although this is routinely done using operator 
\family typewriter
IdTagger
\family default
 (see example 
\begin_inset CommandInset ref
LatexCommand ref
reference "IdTagger"

\end_inset

 for details), it is a little tricky here because you need to place the
 during-mating 
\family typewriter
IdTagger
\family default
 before a 
\family typewriter
Recombinator
\family default
 in the 
\family typewriter
ops
\family default
 parameter of a mating scheme so that offspring ID could be set and outputted
 correctly.
\end_layout

\begin_layout Standard
After setting the name of the ID field (usually 
\family typewriter
ind_id
\family default
) to the 
\family typewriter
infoField
\family default
 parameter of a 
\family typewriter
Recombinator
\family default
, it can dump a list of recombinatin events (loci after which recombinatin
 events happened) for each set of homologous chromosomes of an offspring.
 Each line is in the format of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

offspringID parentID startingPloidy rec1 rec2 ....
\end_layout

\end_inset

Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "trackRec"

\end_inset

 gives an example how the output looks like.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/trackRec.log"
lstparams "caption={Tracking all recombination events},label={trackRec}"

\end_inset


\end_layout

\begin_layout Section
Mutation
\end_layout

\begin_layout Standard
A mutator (a mutation operator) mutates alleles at certain loci from one
 allele to another.
 Because alleles are simple non-nagative numbers that can be intrepreted
 as nucleotides, codons, squences of nucleotides or even genetic deletions,
 appropriate mutation models have to be chosen for different types of loci.
 Please refer to Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Genotypic-structure"

\end_inset

 for a few examples.
\end_layout

\begin_layout Standard
A mutator will mutate alleles at all loci unless parameter 
\family typewriter
loci
\family default
 is used to specify a subset of loci.
 Different mutators have different concepts and forms of mutation rates.
 If a mutator accepts only a single mutation rate (which can be in the form
 of a list or a matrix), it uses parameter 
\family typewriter
rate
\family default
 and applies the same mutation rate to all loci.
 If a mutator accepts a list of mutation rates (each of which is a single
 number), it uses parameter 
\family typewriter
rates
\family default
 and applies different mutation rates to different loci if multiple loci
 are specified.
 Note that parameter 
\family typewriter
rates
\family default
 also accepts single form inputs (e.g.
 
\family typewriter
rates=0.01
\family default
) in which case the same mutation rate will be applied to all loci.
\end_layout

\begin_layout Subsection
Mutation models specified by rate matrixes (
\family typewriter
MatrixMutator
\family default
) 
\end_layout

\begin_layout Standard
A mutation model can be defined as a 
\series bold
mutation rate matrix
\series default
 
\begin_inset Formula $\left(p_{ij}\right)_{n\times n}$
\end_inset

 where 
\begin_inset Formula $p_{ij}$
\end_inset

 is the probability that an allele 
\begin_inset Formula $i$
\end_inset

 mutates to 
\begin_inset Formula $j$
\end_inset

 per generation per locus.
 Although mathematical formulation of 
\begin_inset Formula $p_{ij}$
\end_inset

 are sometimes unscaled, simuPOP assumes 
\begin_inset Formula $\sum_{j=0}^{n-1}p_{ij}=1$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

 and requires such rate matrixes in the specification of a mutation model.
 
\begin_inset Formula $p_{ii}$
\end_inset

 of such a matrix are ignored because they are automatically calculated
 from 
\begin_inset Formula $p_{ii}=1-\sum_{j\ne i}p_{ij}$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\family typewriter
MatrixMutator
\family default
 is defined to mutate between alleles 0, 1, ..., 
\begin_inset Formula $n-1$
\end_inset

 according to a given rate matrix.
 Conceptually speaking, this mutator goes through each mutable allele and
 mutates it to allele 
\begin_inset Formula $0,1,..,n-1$
\end_inset

 according to probabilities 
\begin_inset Formula $p_{ij}$
\end_inset

, 
\begin_inset Formula $j=0,...,n-1$
\end_inset

.
 Most alleles will be kept intact because mutations usually happen at low
 probability (with 
\begin_inset Formula $p_{ii}$
\end_inset

 close to 1).
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatrixMutator"

\end_inset

 simulates a locus with 3 alleles.
 Because the rate at which allele 2 mutats to alleles 0 and 1 is higher
 than the rate alleles 0 and 2 mutate to allele 2, the frequency of allele
 2 decreases over time.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MatrixMutator.log"
lstparams "caption={General mutator specified by a mutation rate matrix},label={MatrixMutator}"

\end_inset


\end_layout

\begin_layout Note
Alleles other than 0, 1, ..., 
\begin_inset Formula $n-1$
\end_inset

 will not be mutated because their mutation rates are undefined.
 A warning message will be displayed for this case when debugging code 
\family typewriter
DBG_WARNING
\family default
 is turnned on.
\end_layout

\begin_layout Subsection
k-allele mutation model (
\family typewriter
KAlleleMutator
\family default
)
\end_layout

\begin_layout Standard
A 
\begin_inset Formula $k$
\end_inset

-allele model assumes 
\begin_inset Formula $k$
\end_inset

 alleles 
\begin_inset Formula $\left(0,1,...,k-1\right)$
\end_inset

 at a locus and mutate between them using rate matrix 
\begin_inset Formula 
\[
p_{ij}=\left(\begin{array}{cccc}
1-\mu & \frac{\mu}{k-1} & \cdots & \frac{\mu}{k-1}\\
\frac{\mu}{k-1} & 1-\mu & \cdots & \frac{\mu}{k-1}\\
\vdots & \vdots & \ddots & \vdots\\
\frac{\mu}{k-1} & \frac{\mu}{k-1} & \cdots & 1-\mu
\end{array}\right)
\]

\end_inset

The only parameter 
\begin_inset Formula $\mu$
\end_inset

 is the mutation rate, which is the rate at which an allele mutates to any
 other allele with equal probability.
\end_layout

\begin_layout Standard
This mutation model is a special case of the 
\family typewriter
MatrixMutator
\family default
 but a specialized 
\family typewriter
KAlleleMutator
\family default
 is recommended because it provides better performance, especially when
 
\begin_inset Formula $k$
\end_inset

 is large.
 In addition, this operator allows different mutation rates at different
 loci.
 When 
\begin_inset Formula $k$
\end_inset

 is not specified, it is assumed to be the number of allowed alleles (e.g.
 2 for binary modules).
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "KAlleleMutator"

\end_inset

 desmonstrates the use of this operator where parameters 
\family typewriter
rate
\family default
 and 
\family typewriter
loci
\family default
 are used to specify different mutation rates for different loci.
 Because this operator treats all alleles equally, all alleles will have
 the same allele frequency in the long run.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/KAlleleMutator.log"
lstparams "caption={A k-allele mutation model},label={KAlleleMutator}"

\end_inset


\end_layout

\begin_layout Note
If alleles 
\begin_inset Formula $k$
\end_inset

 and higher exist in the population, they will not be mutated because their
 mutation rates are undefined.
 A warning message will be displayed for this case when debugging code 
\family typewriter
DBG_WARNING
\family default
 is turnned on.
\end_layout

\begin_layout Subsection
Diallelic mutation models (
\family typewriter
SNPMutator
\family default
)
\end_layout

\begin_layout Standard

\family typewriter
MatrixMutator
\family default
 and 
\family typewriter
KAlleleMutator
\family default
 are general purpose mutators in the sense that they do not assume a type
 for the mutated alleles.
 This and the following sections describe mutation models for specific types
 of alleles.
\end_layout

\begin_layout Standard
If there are only two alleles at a locus, a diallelic mutation model should
 be used.
 Because single nucleotide polymorphisms (SNPs) are the most widely avaiable
 diallelic markers, a 
\family typewriter
SNPMutator
\family default
 is provided to mutate such markers using a mutate rate matrix
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
R=\left(\begin{array}{cc}
1-u & u\\
v & 1-v
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Despite of its name, this mutator can be used in many theoretical models
 assuming 
\begin_inset Formula $\mbox{Pr}\left(A\rightarrow a\right)=u$
\end_inset

 and 
\begin_inset Formula $\mbox{Pr}\left(a\rightarrow A\right)=v$
\end_inset

.
 If 
\begin_inset Formula $v=0$
\end_inset

, mutations will be directional.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "SNPMutator"

\end_inset

 applies such a directional mutaton model to two loci, but with a purifying
 selection applied to the first locus.
 Because of the selection pressure, the frequency of allele 1 at the first
 locus does not increase indefinitely as allele 1 at the second locus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/SNPMutator.log"
lstparams "caption={A diallelic directional mutation model},label={SNPMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Nucleotide mutation models (
\family typewriter
AcgtMutator
\family default
)
\end_layout

\begin_layout Standard
Mutations in these models assume alleles 0, 1, 2, 3 as nucleotides A, C,
 G, and T.
 The operator is named 
\family typewriter
AcgtMutator
\family default
 to remind you the alphabetic order of these nucleotides.
 This mutation model is specified by a rate matrix
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\begin{array}{ccccc}
 & A & C & G & T\\
A & - & x_{1} & x_{2} & x_{3}\\
C & x_{4} & - & x_{5} & x_{6}\\
G & x_{7} & x_{8} & - & x_{9}\\
T & x_{10} & x_{11} & x_{12} & -
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\align left
which is determined by 12 parameters.
 However, several simpler models with fewer parameters can be used.
 In addition to parameters shared by all mutation operators, a nucleotide
 mutator is specified by a parameter list and a model name.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

AcgtMutator(rate=[1e-5, 0.5], model='K80')
\end_layout

\end_inset

specifies a nucleotide mutator using Kimura's 2-parameter model with 
\begin_inset Formula $\mu=10^{-5}$
\end_inset

 and 
\begin_inset Formula $\kappa=0.5$
\end_inset

.
 Because multiple parameters could be involved for a particular mutation
 model, 
\series bold
the definition of a mutation rate and other paramters are model dependent
 and may varying with different mathematical representation of the models
\series default
.
\end_layout

\begin_layout Standard
The names and acceptable parameters of acceptable models are listed below:
\end_layout

\begin_layout Enumerate
Jukes and Cantor 1969 model: 
\family typewriter
model='JC69'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

 ]
\end_layout

\begin_deeper
\begin_layout Standard
The Jukes and Cantor model is similar to a 
\begin_inset Formula $4$
\end_inset

-allele model but its definition of 
\begin_inset Formula $\mu$
\end_inset

 is different.
 More specifically, when a mutation event happens at rate 
\begin_inset Formula $\mu$
\end_inset

, an allele will have equal probability to mutate to any of the 4 allelic
 states.
 
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \frac{\mu}{4} & \frac{\mu}{4} & \frac{\mu}{4}\\
\frac{\mu}{4} & - & \frac{\mu}{4} & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4} & - & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4} & \frac{\mu}{4} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Kimura's 2-parameter 1980 model: 
\family typewriter
model='K80'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
Kimura 's model distinguishes transitions (
\begin_inset Formula $A\longleftrightarrow G$
\end_inset

, and 
\begin_inset Formula $C\leftrightarrow T$
\end_inset

 namely 
\begin_inset Formula $0\longleftrightarrow2$
\end_inset

 and 
\begin_inset Formula $1\longleftrightarrow3$
\end_inset

 with probability 
\begin_inset Formula $\frac{\mu}{4}\kappa$
\end_inset

) and transversions (others) with probability 
\begin_inset Formula $\frac{\mu}{4}$
\end_inset

.
 It would be a Jukes and Cantor model if 
\begin_inset Formula $\kappa=1$
\end_inset

.
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \frac{\mu}{4} & \frac{\mu}{4}\kappa & \frac{\mu}{4}\\
\frac{\mu}{4} & - & \frac{\mu}{4} & \frac{\mu}{4}\kappa\\
\frac{\mu}{4}\kappa & \frac{\mu}{4} & - & \frac{\mu}{4}\\
\frac{\mu}{4} & \frac{\mu}{4}\kappa & \frac{\mu}{4} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Felsenstein 1981 model: 
\family typewriter
model='F81'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

].
 
\end_layout

\begin_deeper
\begin_layout Standard
This model assumes different base frequencies but the same probabilities
 for transitions and transversions.
 
\begin_inset Formula $\pi_{T}$
\end_inset

 is calculated from 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

 and 
\begin_inset Formula $\pi_{G}$
\end_inset

.
 
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\pi_{C} & \mu\pi_{G} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Hasegawa, Kishino and Yano 1985 model: 
\family typewriter
model='HKY85'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model replaces 1/4 frequency used in the Kimura's 2-parameter model
 with nucleotide-specific frequencies.
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\kappa\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\kappa\pi_{T}\\
\mu\kappa\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\kappa\pi_{C} & \mu\pi_{G} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Tamura 1992 model: 
\family typewriter
model='T92'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\pi_{GC}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model is a HKY85 model with 
\begin_inset Formula $\pi_{G}=\pi_{C}=\pi_{GC}/2$
\end_inset

 and 
\begin_inset Formula $\pi_{A}=\pi_{T}=\pi_{AT}/2=\left(1-\pi_{GC}\right)/2$
\end_inset

,
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \frac{1}{2}\mu\pi_{GC} & \frac{1}{2}\mu\nu\pi_{GC} & \frac{1}{2}\mu\pi_{AT}\\
\frac{1}{2}\mu\pi_{AT} & - & \frac{1}{2}\mu\pi_{GC} & \frac{1}{2}\mu\nu\pi_{AT}\\
\frac{1}{2}\mu\nu\pi_{AT} & \frac{1}{2}\mu\pi_{GC} & - & \frac{1}{2}\mu\pi_{AT}\\
\frac{1}{2}\mu\pi_{AT} & \frac{1}{2}\mu\nu\pi_{GC} & \frac{1}{2}\mu\pi_{GC} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Tamura and Nei 1993 model: 
\family typewriter
model='TN93'
\family default
, rate=[
\begin_inset Formula $\mu$
\end_inset

, 
\begin_inset Formula $\kappa_{1}$
\end_inset

, 
\begin_inset Formula $\kappa_{2}$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
This model extends the HKY1985 model by distinguishing 
\begin_inset Formula $A\longleftrightarrow G$
\end_inset

 transitions (namely 
\begin_inset Formula $0\longleftrightarrow2$
\end_inset

) and 
\begin_inset Formula $C\leftrightarrow T$
\end_inset

 transitions (
\begin_inset Formula $1\longleftrightarrow3$
\end_inset

) with different 
\begin_inset Formula $\kappa$
\end_inset

.
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \mu\pi_{C} & \mu\kappa_{1}\pi_{G} & \mu\pi_{T}\\
\mu\pi_{A} & - & \mu\pi_{G} & \mu\kappa_{2}\pi_{T}\\
\mu\kappa_{1}\pi_{A} & \mu\pi_{C} & - & \mu\pi_{T}\\
\mu\pi_{A} & \mu\kappa_{2}\pi_{C} & \mu\pi_{G} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Generalized time reversible model: 
\family typewriter
model='GTR'
\family default
, rate=[
\begin_inset Formula $x_{1}$
\end_inset

, 
\begin_inset Formula $x_{2}$
\end_inset

, 
\begin_inset Formula $x_{3}$
\end_inset

, 
\begin_inset Formula $x_{4}$
\end_inset

, 
\begin_inset Formula $x_{5}$
\end_inset

, 
\begin_inset Formula $x_{6}$
\end_inset

, 
\begin_inset Formula $\pi_{A}$
\end_inset

, 
\begin_inset Formula $\pi_{C}$
\end_inset

, 
\begin_inset Formula $\pi_{G}$
\end_inset

]
\end_layout

\begin_deeper
\begin_layout Standard
The generalized time reviersible model is the most general neutral, indepdendent
, finite-sites, time-reversible model possible.
 It is specified by six parameters and base frequencies.
 Its rate matrix is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & \frac{\pi_{A}x_{1}}{\pi_{C}} & \frac{\pi_{A}x_{2}}{\pi_{G}} & \frac{\pi_{A}x_{3}}{\pi_{T}}\\
x_{1} & - & \frac{\pi_{C}x_{4}}{\pi_{G}} & \frac{\pi_{C}x_{5}}{\pi_{T}}\\
x_{2} & x_{4} & - & \frac{\pi_{G}x_{6}}{\pi_{T}}\\
x_{3} & x_{5} & x_{6} & -
\end{array}\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
General model: 
\family typewriter
model='general'
\family default
 (default), rate=[
\begin_inset Formula $x_{1}$
\end_inset

, 
\begin_inset Formula $x_{2}$
\end_inset

, 
\begin_inset Formula $x_{3}$
\end_inset

, 
\begin_inset Formula $x_{4}$
\end_inset

, 
\begin_inset Formula $x_{5}$
\end_inset

, 
\begin_inset Formula $x_{6}$
\end_inset

, 
\begin_inset Formula $x_{7}$
\end_inset

, 
\begin_inset Formula $x_{8}$
\end_inset

, 
\begin_inset Formula $x_{9}$
\end_inset

, 
\begin_inset Formula $x_{10}$
\end_inset

, 
\begin_inset Formula $x_{11}$
\end_inset

, 
\begin_inset Formula $x_{12}$
\end_inset

].
\end_layout

\begin_deeper
\begin_layout Standard
This is the most general model with 12 parameters:
\begin_inset Formula 
\[
R=\left(\begin{array}{cccc}
- & x_{1} & x_{2} & x_{3}\\
x_{4} & - & x_{5} & x_{6}\\
x_{7} & x_{8} & - & x_{9}\\
x_{10} & x_{11} & x_{12} & -
\end{array}\right)
\]

\end_inset

It is not surprising that all other models are implemented as special cases
 of this model.
\end_layout

\end_deeper
\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "AcgtMutator"

\end_inset

 applies a Kimmura's 2-parameter mutation model to a population with a single
 nucleotide marker.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/AcgtMutator.log"
lstparams "caption={A Kimura's 2 parameter mutation model},label={AcgtMutator}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Amino acid mutation models (
\family typewriter
AminoAcidMutator
\family default
, not yet implemented)
\end_layout

\begin_layout Plain Layout
Amino acid mutation models assume alleles 0, 1, 2, 3, ..., 19 as 20 amino acids
 C, S, T, P, A, G, N, D, E, Q, H, R, K, M, I, L, V, F, Y, and W.
 This mutation model is specified by a 20 by 20 rate matrix.
 The mutator should work similarly to 
\family typewriter
AcgtMutator
\family default
 but it is more tedious.
 I will implement popular mutation matrixes if there is a demonstrated need
 for such an operator (an email to the simuPOP mailing list should be enough.
 :-).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mutation model for microsatellite markers (
\family typewriter
StepwiseMutator
\family default
)
\end_layout

\begin_layout Standard
The 
\series bold
stepwise mutation model
\series default
 (SMM) was proposed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Ohta1973"

\end_inset

 to model the mutation of Variable Number Tandem Repeat (VNTR), which consists
 of tandem repeat of sequences.
 VNTR markers consisting of short sequences (e.g.
 5 basepair or less) are also called microsatellite markers.
 A mutation event of a VNTR marker either increase of decrease the number
 of repeats, as a result of slipped-strand mispairing or unequal sister
 chromatid exchange and genetic recombination.
\end_layout

\begin_layout Standard
A 
\family typewriter
StepwiseMutator
\family default
 assumes that alleles at a locus are the number of tandem repeats and mutates
 them by increasing or decreasing the number of repeats during a mutation
 event.
 By adjusting parameters 
\family typewriter
incProb
\family default
, 
\family typewriter
maxAllele
\family default
 and 
\family typewriter
mutStep
\family default
, this operator can be used to simulate the standard neutral stepwise mutation
 model and a number of 
\series bold
generalized stepwise mutation models
\series default
.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "StepwiseMutator"

\end_inset

 uses two 
\family typewriter
StepwiseMutator
\family default
 to mutate two microsatellite markers, using a standard and a generalized
 model where a geometric distribution is used to determine the number of
 steps.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/StepwiseMutator.log"
lstparams "caption={A standard and a generalized stepwise mutation model},label={StepwiseMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Simulating arbitrary mutation models using a hybrid mutator (
\family typewriter
PyMutator
\family default
)*
\end_layout

\begin_layout Standard
A hybrid mutator 
\family typewriter
PyMutator
\family default
 mutates random alleles at selected loci (parameter 
\family typewriter
loci
\family default
), replicates (parameter 
\family typewriter
loci
\family default
), subpopulations (parameter 
\family typewriter
subPop
\family default
) with specified mutation rate (parameter 
\family typewriter
rate
\family default
).
 Instead of mutating the alleles by itself, it passes the alleles to a user-defi
ned function and use it return values as the mutated alleles.
 Arbitrary mutation models could be implemented using this operator.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyMutator"

\end_inset

 applies a simple mutation model where an allele is increased by a random
 number between 1 and 5 when it is mutated.
 Two different mutation rates are used for two different loci so average
 alleles at these two loci are different.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyMutator.log"
lstparams "caption={A hybrid mutation model},label={PyMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Mixed mutation models (
\family typewriter
MixedMutator
\family default
) **
\end_layout

\begin_layout Standard
Mixed mutation models are sometimes used to model real data.
 For example, a 
\begin_inset Formula $k$
\end_inset

-allele model can be used to explain extremely large or small number of
 tandem repeats at a microsatellite marker which are hard to justify using
 a standard stepwise mutation model.
 A mixed mutation model would apply two or more mutation models at pre-specified
 probabilities.
\end_layout

\begin_layout Standard
A 
\family typewriter
MixedMutator
\family default
 is constructed by a list of mutators and their respective probabilities.
 It accepts regular mutator parameters such as 
\family typewriter
rates
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
subPops
\family default
, 
\family typewriter
mapIn and mapOut
\family default
 and mutates aleles at specified rate.
 When a mutation event happens, it calls one of the mutators to mutate the
 allele.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MixedMutator"

\end_inset

 applies a mixture of 
\begin_inset Formula $k$
\end_inset

-allele model and stepwise model to mutate a micosatellite model.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MixedMutator.log"
lstparams "caption={A mixed k-allele and stepwise mutation model},label={MixedMutator}"

\end_inset


\end_layout

\begin_layout Standard
When a mutation event happens, mutators in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MixedMutator"

\end_inset

 mutate the allele with probability (mutation rate) 1.
 If different mutation rates are specified, the overall mutation rates would
 be the product of mutation rate of 
\family typewriter
MixedMutator
\family default
 and the passed mutators.
 However, it is extremely important to understand that although 
\family typewriter
MixedMutator(rates=mu)
\family default
 with 
\family typewriter
StepwiseMutator(rates=1)
\family default
 and 
\family typewriter
MixedMutator(rates=1) 
\family default
with 
\family typewriter
StepwiseMutator(rates=mu)
\family default
 mutate alleles at the same mutation rate, the former is much more efficient
 because it triggers far less mutation events.
\end_layout

\begin_layout Subsection
Context-dependent mutation models (
\family typewriter
ContextMutator
\family default
)**
\end_layout

\begin_layout Standard
All mutation models we have seen till now are context independent.
 That is to say, how an allele is mutated depends only on the allele itself.
 However, it is understood that DNA and amino acid substitution rates are
 highly sequence context-dependent, e.g., C 
\begin_inset Formula $\rightarrow$
\end_inset

 T substitutions in vertebrates may occur much more frequently at CpG sites.
 To simulate such models, a mutator must consider the context of a mutated
 allele, e.g.
 certain number of alleles to the left and right of this allele, and mutate
 the allele accordingly.
\end_layout

\begin_layout Standard
A 
\family typewriter
ContextMutator
\family default
 can be used to mutate an allele depending on its surrounding loci.
 This mutator is constructed by a list of mutators and their respective
 contexts.
 It accepts regular mutator parameters such as 
\family typewriter
rates
\family default
, 
\family typewriter
loci
\family default
, 
\family typewriter
subPops
\family default
, 
\family typewriter
mapIn and mapOut
\family default
 and mutates aleles at specified rate.
 When a mutation event happens, it checks the context of the mutaed allele
 and choose a corresponding mutator to mutate the allele.
 An additional mutator can be specified to mutate alleles with unknown context.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ContextMutator"

\end_inset

 applies two 
\family typewriter
SNPMutator
\family default
 at different rates under different contexts.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ContextMutator.log"
lstparams "caption={A context-dependent mutation model},label={ContextMutator}"

\end_inset

Note that although 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ContextMutator(mutators=[
\end_layout

\begin_layout Plain Layout

    SNPMutator(u=0.1),
\end_layout

\begin_layout Plain Layout

    SNPMutator(u=1)],
\end_layout

\begin_layout Plain Layout

    contexts=[(0, 0), (1, 1)],
\end_layout

\begin_layout Plain Layout

    rates=0.01
\end_layout

\begin_layout Plain Layout

)    
\end_layout

\end_inset

and 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ContextMutator(mutators=[
\end_layout

\begin_layout Plain Layout

    SNPMutator(u=0.001),
\end_layout

\begin_layout Plain Layout

    SNPMutator(u=0.01)],
\end_layout

\begin_layout Plain Layout

    contexts=[(0, 0), (1, 1)],
\end_layout

\begin_layout Plain Layout

    rates=1
\end_layout

\begin_layout Plain Layout

)    
\end_layout

\end_inset

both apply two 
\family typewriter
SNPMutator
\family default
 at mutation rates 
\family typewriter
0.001
\family default
 and 
\family typewriter
0.01
\family default
, the former is more efficient because it triggers less mutation events.
\end_layout

\begin_layout Standard
Context-dependent mutator can also be implemented by a 
\family typewriter
PyMutator
\family default
.
 When a non-zero parameter 
\family typewriter
context
\family default
 is specified, this mutator will collect 
\family typewriter
context
\family default
 number of alleles to the left and right of a mutated allele and pass them
 as a second parameter of the user-provided mutation function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyContextMutator"

\end_inset

 applies the same mutation model as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ContextMutator"

\end_inset

 using a 
\family typewriter
PyMutator
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyContextMutator.log"
lstparams "caption={A hybrid context-dependent mutation model},label={pyContextMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Manually-introduced mutations (
\family typewriter
PointMutator
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
PointMutator
\family default
 is different from all other mutators in that it mutates specified alleles
 of specified individuals.
 It is usually used to manually introduce one or more mutants to a population.
 Although it is not a recommended method to introduce a disease predisposing
 allele, the following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PointMutator"

\end_inset

) demonstrates an evolutionary process where mutants are repeatedly introduced
 and raised by positive selection until it reaches an appreciable allele
 frequency.
 This example uses two 
\family typewriter
IfElse
\family default
 operators.
 The first one introduces a mutant when there is no mutant in the population,
 and the second one terminate the evolution when the frequency of the mutant
 reaches 0.05.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PointMutator.log"
lstparams "caption={Use a point mutator to introduce a disease predisposing allele},label={PointMutator}"

\end_inset


\end_layout

\begin_layout Subsection
Apply mutation to (virtual) subpopulations *
\end_layout

\begin_layout Standard
A mutator is usually applied to all individuals in a population.
 However, you can restrict its use to specified subpopulations and/or virtual
 subpopulations using parameter 
\family typewriter
subPop
\family default
.
 For example, you can use 
\family typewriter
subPop=[0, 2]
\family default
 to apply the mutator only to individuals in subpopulations 0 and 2.
\end_layout

\begin_layout Standard
Virtual subpopulations can also be specified in this parameter.
 For example, you can apply different mutation models to male and female
 individuals, to unaffected or affected individuals, to patients at different
 stages of a cancer.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mutatorVSP"

\end_inset

 demonstrate a mutation model where individuals with more tandem repeats
 at a disease predisposing locus are more likely to develop a disease (e.g.
 fragile-X).
 Affected individuals are then subject to a non-neutral mutation model at
 an accerlerated mutation rate.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mutatorVSP.log"
lstparams "caption={Applying mutation to virtual subpopulations.},label={mutatorVSP}"

\end_inset


\end_layout

\begin_layout Standard
At the beginning of a simulation, all individuals have 50 copies of a tandem
 repeat and the mutation follows a standard neutral stepwise mutation model.
 individuals with more than 50 repeats will have an increasing probability
 to develop a disease (
\begin_inset Formula $\mbox{Pr}\left(\mbox{affected}\mid n\right)=\left(n-50\right)*0.05$
\end_inset

) for 
\begin_inset Formula $50\le n\le70$
\end_inset

).
 The averge repeat number therefore increases for affected individuals.
 In contrast, the mean number of repeats at locus 1 on a separate chromosome
 oscillate around 50.
\end_layout

\begin_layout Subsection
Allele mapping **
\end_layout

\begin_layout Standard
If alleles in your simulation do not follow the convention of a mutation
 model, you may want to use the 
\family typewriter
pop.recodeAlleles()
\family default
 function to recode your alleles so that appropriate mutation models could
 be applied.
 If this is not possible, you can use a general mutation model with your
 own mutation matrix, or an advanced feature called 
\series bold
allele mapping
\series default
.
 
\end_layout

\begin_layout Standard
Allele mapping is done through two parameters 
\emph on
mapIn
\emph default
 and 
\emph on
mapOut
\emph default
, which map alleles in your population to and from alleles assumed in a
 mutation model.
 For example, an 
\family typewriter
AcgtMutator
\family default
 mutator assumes alleles 
\family typewriter
A
\family default
, 
\family typewriter
C
\family default
, 
\family typewriter
G
\family default
 and 
\family typewriter
T
\family default
 for alleles 0, 1, 2, and 3 respectively.
 If for any reason the alleles in your application does not follow this
 order, you will need to map these alleles to the alleles assumed in the
 mutator.
 For example, if you assumes 
\family typewriter
C
\family default
, 
\family typewriter
G
\family default
, 
\family typewriter
A
\family default
, 
\family typewriter
T
\family default
 for alleles 0, 1, 2, and 3 respectively, you can use parameters
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mapIn=[1, 2, 0, 3], mapOut=[2, 0, 1, 3]
\end_layout

\end_inset

to map your alleles (
\family typewriter
C(0)->C(1)
\family default
, 
\family typewriter
G(1)->G(2)
\family default
, 
\family typewriter
A(2)->A(0)
\family default
, 
\family typewriter
T(3)->T(3)
\family default
) to alleles 
\family typewriter
AcgtMutator
\family default
 assumes, and then map mutated alleles (
\family typewriter
A(0)->A(2)
\family default
, 
\family typewriter
C(1)->C(0)
\family default
, 
\family typewriter
G(2)->G(1)
\family default
, 
\family typewriter
T(3)->T(3)
\family default
) back.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "alleleMapping"

\end_inset

 gives another example where alleles 4, 5, 6 and 7 are mutated using a 4-allele
 model.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/alleleMapping.log"
lstparams "caption={Allele mapping for mutation operators},label={alleleMapping}"

\end_inset


\end_layout

\begin_layout Standard
These two parameters also accept Python functions which should return correspond
ing mapped-in or out allele for a given allele.
 These two functions can be used to explore very fancy mutation models.
 For example, you can categorize a large number of alleles into alleles
 assumed in a mutation model, and emit random alleles from a mutated allele.
\end_layout

\begin_layout Subsection
Mutation rate and transition matrix of a 
\family typewriter
MatrixMutator 
\family default
**
\end_layout

\begin_layout Standard
A 
\family typewriter
MatrixMutator
\family default
 is specified by a mutation rate matrix.
 Although mutation rates of this mutator is typically allele-dependent,
 the 
\family typewriter
MatrixMutator
\family default
 is implemented as a two-step process where mutation events are triggered
 independent to allelic states.
 This section describes these two steps which can be useful if you need
 to use a 
\family typewriter
maxtrixMutator
\family default
 in a 
\family typewriter
MixedMutator
\family default
 or 
\family typewriter
ContextMutator
\family default
, and would like to factor out an allele-independent mutation rate to the
 wrapper mutator.
\end_layout

\begin_layout Standard
Because alleles usually have different probabilities of mutating to other
 alleles, 
\series bold
a mutation process is usually allele dependent
\series default
.
 Given a mutation model 
\begin_inset Formula $\left(p_{ij}\right)$
\end_inset

, it is obviously inefficient to go through all mutable alleles and determine
 whether or not to mutate it using 
\begin_inset Formula $p_{ij},$
\end_inset

 
\begin_inset Formula $j=0,...,1-n$
\end_inset

.
 simuPOP uses a two step procedure to mutate a large number of alleles.
 More specifically, for each mutation model, we determine 
\begin_inset Formula $\mu=\max_{i=0}^{n-1}\left(1-p_{ii}\right)$
\end_inset

 as the overall mutation rate, and then
\end_layout

\begin_layout Enumerate
For each allele, trigger a mutation event with probability 
\begin_inset Formula $\mu$
\end_inset

.
 Because 
\begin_inset Formula $\mu$
\end_inset

 is usually very small and is the same for all alleles, this step can be
 implemented efficiently.
\end_layout

\begin_layout Enumerate
When a mutation event happens, mutation allele 
\begin_inset Formula $i$
\end_inset

 to allele 
\begin_inset Formula $j$
\end_inset

 with probability 
\begin_inset Formula 
\[
\mbox{Pr}\left(i\rightarrow j\right)=\begin{cases}
1-\frac{1}{\mu}\left(1-p_{ii}\right) & \mbox{if }i=j\\
\frac{p_{ij}}{\mu} & \mbox{if }i\ne j
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Because steps 1 and 2 are independent, it is easy to verify that
\begin_inset Formula 
\[
p_{ij}=\mu\mbox{Pr}\left(i\rightarrow j\right)
\]

\end_inset

if 
\begin_inset Formula $i\ne j$
\end_inset

 and 
\begin_inset Formula 
\[
p_{ii}=\left(1-\mu\right)+\mu\mbox{Pr}\left(i\rightarrow i\right)
\]

\end_inset

where the first and second items are probabilities of no-mutation at steps
 1 and 2.
 
\begin_inset Formula $\mu$
\end_inset

 was chosen as the smallest 
\begin_inset Formula $\mu$
\end_inset

 that makes 
\begin_inset Formula $0\leq\mbox{Pr}\left(i\rightarrow i\right)\leq1$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
For example, for a 
\begin_inset Formula $k$
\end_inset

-allele model with 
\begin_inset Formula 
\[
p_{ij}=\left(\begin{array}{cccc}
1-\mu & \frac{\mu}{k-1} & \cdots & \frac{\mu}{k-1}\\
\frac{\mu}{k-1} & 1-\mu & \cdots & \frac{\mu}{k-1}\\
\vdots & \vdots & \ddots & \vdots\\
\frac{\mu}{k-1} & \frac{\mu}{k-1} & \cdots & 1-\mu
\end{array}\right)
\]

\end_inset


\begin_inset Formula $\mu$
\end_inset

 is directly 
\begin_inset Formula $\mu$
\end_inset

 for the first step and 
\begin_inset Formula 
\[
\mbox{Pr}\left(i\rightarrow j\right)=\begin{cases}
0 & \mbox{if }i=j\\
\frac{1}{k-1} & \mbox{if }i\ne j
\end{cases}
\]

\end_inset

for the second step.
 Therefore, mutation rate 
\begin_inset Formula $\mu$
\end_inset

 in a 
\begin_inset Formula $k$
\end_inset

-allele model could be interpreted as the probability of mutation, and a
 mutation event would mutate an allele to any other allele with equal probabilit
y.
\end_layout

\begin_layout Standard
For a classical mutation model with 
\begin_inset Formula $P\left(A\rightarrow a\right)=u$
\end_inset

 and 
\begin_inset Formula $P\left(a\rightarrow A\right)=v$
\end_inset

, 
\begin_inset Formula 
\[
p_{ij}=\left(\begin{array}{cc}
1-u & u\\
v & 1-v
\end{array}\right)
\]

\end_inset

if 
\begin_inset Formula $u=0.001$
\end_inset

 and 
\begin_inset Formula $v=0.0005$
\end_inset

, 
\begin_inset Formula $\mu=\max\left(u,v\right)=0.001$
\end_inset

,
\begin_inset Formula 
\[
\mbox{Pr}\left(i\rightarrow j\right)=\left(\begin{array}{cc}
0 & 1\\
\frac{v}{u}=0.5 & 1-\frac{v}{u}=0.5
\end{array}\right)
\]

\end_inset

That is to say, we would mutate at a mutation rate 
\begin_inset Formula $u=0.001$
\end_inset

, mutate allele 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

 with probability 1 and mutate allele 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

 with probability 0.5.
\end_layout

\begin_layout Subsection
Infinite-sites model and other simulation techniques **
\end_layout

\begin_layout Standard
Infinite-sites and infinite-alleles models have some similarities.
 If you assume that mutation is the only force to create new mutants, you
 can treat a long chromosomal region as a locus and use the infinite-alleles
 model, actually a 
\begin_inset Formula $k$
\end_inset

-allele model with large 
\begin_inset Formula $k$
\end_inset

, to mimic the infinite-site model.
 This assumption is certainly wrong with the infinite-site model when recombinat
ion is involved, because recombination creates new haplotypes (alleles)
 under the infinite-site model.
 However, for short regions where recombination can be ignored, an 
\begin_inset Formula $k$
\end_inset

-allele model can be an easy and fast way to mimic an infinite-site model.
 That statement basically says that you have a choice between two models
 if you would like to simulate the evolution of this gene, namely considering
 the gene as a locus and simulating variants as alleles, or considering
 the gene as a sequence and simulating haplotypes as alleles.
\end_layout

\begin_layout Standard
For example, the CFTR gene (for cystic fibrosis) can have many alleles (thinking
 in terms of infinite-allele model) which are nucleotide mutations on tens
 of locations (infinite-site model).
 In order to simulate the evolution of this gene, you have a choice between
 two models, namely considering the gene as a locus and simulating variants
 as alleles, or considering the gene as a sequence and simulating haplotypes
 as alleles.
 Because there is supposed to be only one mutant at each site, you can assign
 a unique 
\emph on
location
\emph default
 for each allele of an infinite-allele model and convert multi-allelic datasets
 simulated by an infinite-allele model to sequences of diallelic markers.
 Note that mutation rates are interpreted differently for these two models.
\end_layout

\begin_layout Standard
If specific location of such a mutation is needed, it is possible to record
 the location of mutations during an evolution and minic an infinite-sites
 model.
 For example, alleles in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infiniteSites"

\end_inset

 are used to store location of a mutation event.
 When a mutation event happens, the location of the new allele (rather the
 allele itself) is recorded on the chromosome (actually list of mutation
 events) of an individual.
 The transmission of chromosomes proceed normally and effectively transmit
 mutants from parents to offspring.
 At the end of the simulation, each individual accumulates a number of mutation
 events and they are essentially alleles at their respective locations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infiniteSites.log"
lstparams "caption={Mimicking an infinite-sites model using mutation events as alleles},label={infiniteSites}"

\end_inset


\end_layout

\begin_layout Standard
All mutation models in simuPOP apply to existing alleles at pre-specified
 loci.
 However, if the location of loci cannot be determined beforehand, it is
 sometimes desired to create new loci as a result of mutation.
 A customized operator can be used for this purpose (see Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "newOperator"

\end_inset

), but extra attention is needed to make sure that other operators are applied
 to the correct loci because loci indexes will be changed with the insertion
 of new loci.
 This technique could also be used to simulate mutations over long sequences.
\end_layout

\begin_layout Subsection
Recording and tracing individual mutants **
\end_layout

\begin_layout Standard
Mutation operators mutate alleles in place and by default do not generate
 any output.
 If you are interested in knowing the source of each mutant, you can specify
 an output stream and let the mutation operators dump details of each mutation
 event, which consists of generation number, locus index, ploidy, original
 allele, and mutated allele.
 If a list of information fields are specified through parameter 
\family typewriter
infoFields
\family default
, values at these information fields will also be outputted (if they exist
 in the population.
 The default information field is 
\family typewriter
ind_id
\family default
, which allow you to record the ID of individuals harboring the mutants.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "countMutants"

\end_inset

 demonstrates how to use this feature to count the number of mutants at
 each locus.
 Instead of sending the output to a file (e.g.
 
\family typewriter
output='>>mutants.txt'
\family default
), this example sends the output to a Python function, which parses input
 string and counts the number of mutants at each locus using a global dictionary
 variable.
 As we can see from the output, because the KAlleleMutator uses a higher
 mutation rate (0.01) at locus 1 than mutation rate (0.001) at locus 0, there
 are 10 times more mutants at the second locus.
 There are about 3/4 mutations on the locus on chromosome X and 1/4 mutations
 on the locus on chromosome Y, for obvious reasons.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/countMutants.log"
lstparams "caption={Count number of mutants from mutator outputs},label={countMutants}"

\end_inset


\end_layout

\begin_layout Section
Penetrance
\end_layout

\begin_layout Standard
Penetrance is the probability for an individual to be affected with a disease
 conditioning on his or her genotype and other risk factors.
 A penetrance model calculates such a probability for an individual and
 assign affection status randomly according to this probability.
 For example, if an individual with genotype 
\family typewriter
10
\family default
 has probability 0.2 to be affected according to a penetrance model, he or
 she will be affected with probability 0.2.
 Note that simuPOP supports only one affection status.
 If there are multiple affection outcomes involved, you can treat them as
 binary quantitative traits and use information fields to store them.
\end_layout

\begin_layout Standard
A penetrance operator can be applied before or after mating, to assign affection
 status to all individuals in the parental or offspring generation, respectively.
 It can also be applied during mating and assign affection status to each
 offspring.
 The latter could be used to assit natural selection through the selection
 of offspring.
 You can also assign affection status to all individuals in a population
 using the function form of a penetrance operator (e.g.
 function 
\family typewriter
mapPenetrance
\family default
 for operator 
\family typewriter
MapPenetrance
\family default
).
 Compared the penetrance operators that assign affection status to only
 the current generation, 
\series bold
these functions by default assign affection status to all ancestral generations
 as well
\series default
.
\end_layout

\begin_layout Standard
A penetrance operator usually do not store the penetrance values.
 However, if an information field is given, penetrance values will be saved
 to this information field before it is used to determine individual affection
 status.
\end_layout

\begin_layout Subsection
Map penetrance model (operator 
\family typewriter
MapPenetrance
\family default
)
\end_layout

\begin_layout Standard
A map penetrance opertor uses a Python dictionary to provide penetrance
 values for each type of genotype.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MapPenetrance"

\end_inset

 uses a dictionary with keys 
\family typewriter
(0,0)
\family default
, 
\family typewriter
(0,1)
\family default
 and 
\family typewriter
(1,1)
\family default
 to specify penetrance for individuals with these genotypes at locus 0.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MapPenetrance.log"
lstparams "caption={A penetrance model that uses pre-defined fitness value},label={MapPenetrance}"

\end_inset


\end_layout

\begin_layout Standard
The above example assumes that penetrance for individuals with genotypes
 
\family typewriter
(0,1)
\family default
 and 
\family typewriter
(1,0)
\family default
 are the same.
 This assumption is usually valid but can be vialoated with impriting.
 In that case, you can specify fitness for both types of genotypes.
 The underlying mechanism is that the 
\family typewriter
MapPenetrance
\family default
 looks up a genotype in the dictionary first directly, and then without
 phase information if a genotype is not found.
\end_layout

\begin_layout Standard
This operator supports haplodiploid populations and sex chromosomes.
 In these cases, only valid alleles should be listed which can lead to dictionar
y keys with different lengths.
 In addition, although less used because of potentially a large number of
 keys, this operator can act on multiple loci.
 For example, 
\end_layout

\begin_layout Itemize
keys 
\family typewriter
(a1,a2)
\family default
 and 
\family typewriter
(a1,)
\family default
 can be used to specify fitness values for female and male individuals in
 a haplodiploid population, respectively
\end_layout

\begin_layout Itemize
keys 
\family typewriter
(x1,x2)
\family default
 and 
\family typewriter
(x1,)
\family default
 can be used to specify fitness for female and male individuals according
 to a locus on the X chromosome in a diploid population, respectively.
 Similarly, keys 
\family typewriter
()
\family default
 and 
\family typewriter
(y,)
\family default
 for a locus on chromosome Y.
\end_layout

\begin_layout Itemize
keys 
\family typewriter
(a1,a2,b1,b2)
\family default
 can be used to specify fitness values according to genotype at two loci
 in a diploid population.
\end_layout

\begin_layout Subsection
Multi-allele penetrance model (operator 
\family typewriter
MaPenetrance
\family default
)
\end_layout

\begin_layout Standard
A multi-allele penetrance model divides alleles into two groups, wildtype
 
\emph on
A
\emph default
 and mutants 
\emph on
a
\emph default
, and treat alleles within each group as the same.
 The penetrance model is therefore simplified to
\end_layout

\begin_layout Itemize
Two fitness values for genotype 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 in the haploid case
\end_layout

\begin_layout Itemize
Three fitness values for genotype 
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
 in the diploid single locus case.
 Genotype 
\emph on
Aa
\emph default
 and 
\emph on
aA
\emph default
 are assumed to have the same impact on fitness.
\end_layout

\begin_layout Standard
The default wildtype group contains allele 0 so the two allele groups are
 zero and non-zero alleles.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MaPenetrance"

\end_inset

 demonstrates the use of this operator.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MaPenetrance.log"
lstparams "caption={A multi-allele penetrance model},label={MaPenetrance}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
MaPenetrance
\family default
 also supports multiple loci by specifying fitness values for all combination
 of genotype at specified loci.
 In the case of two loci, this operator requires
\end_layout

\begin_layout Itemize
Four fitness values for genotype 
\family typewriter
AB
\family default
, 
\family typewriter
Ab
\family default
, 
\family typewriter
aB
\family default
 and 
\family typewriter
ab
\family default
 in the haploid case,
\end_layout

\begin_layout Itemize
Nine fitness values for genotype 
\family typewriter
AABB
\family default
, 
\family typewriter
AABb
\family default
, 
\family typewriter
AAbb
\family default
, 
\family typewriter
AaBB
\family default
, 
\family typewriter
AaBb
\family default
, 
\family typewriter
Aabb
\family default
, 
\family typewriter
aaBB
\family default
, 
\family typewriter
aaBb
\family default
, and 
\family typewriter
aabb
\family default
 in the haploid case.
\end_layout

\begin_layout Standard
In general, 
\begin_inset Formula $2^{n}$
\end_inset

 values are needed for haploid populations and 
\begin_inset Formula $3^{n}$
\end_inset

 values are needed for diploid populations where 
\begin_inset Formula $n$
\end_inset

 is the number of loci.
 This operator does not yet support haplodiploid populations and sex chromosomes.
\end_layout

\begin_layout Subsection
Multi-loci penetrance model (operator 
\family typewriter
MlPenetrance
\family default
)
\end_layout

\begin_layout Standard
Although an individual's affection status can be affected by several factors,
 each of which can be modeled individually, 
\series bold
only one penetrance value is used to determine a person's affection status
\series default
 and we have to use a multi-locus penetrance model to combine single-locus
 models.
\end_layout

\begin_layout Standard
This multi-loci penetrance model applies several penetrance models to each
 Individual and computes an overall penetrance value from the penetrance
 values provided by these operators.
 Although this selector is designed to obtain multi-loci penetrance values
 from several single-locus penetrance models, any penetrance operator, including
 those obtain their penetrance values from multiple disease predisposing
 loci, can be used in this operator.
 This operator uses parameter 
\family typewriter
mode
\family default
 to control how Individual penetrance values are combined.
 More specifically, if 
\begin_inset Formula $f_{i}$
\end_inset

 are penetrance values obtained from individual selectors, this selector
 returns
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Pi_{i}f_{i}$
\end_inset

 if 
\family typewriter
mode=MULTIPLICATIVE
\family default
, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sum_{i}f_{i}$
\end_inset

 if 
\family typewriter
mode=ADDITIVE
\family default
, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $1-\Pi_{i}\left(1-f_{i}\right)$
\end_inset

 if 
\family typewriter
mode=HETEROGENEITY
\end_layout

\begin_layout Standard
0 or 1 will be returned if the returned fitness value is out of range of
 
\family typewriter
[0,1]
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MlPenetrance"

\end_inset

 demonstrates the use of this operator using an multiplicative multi-locus
 model over three additive single-locus models at three diesease predisposing
 loci.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MlPenetrance.log"
lstparams "caption={A multi-loci penetrance model},label={MlPenetrance}"

\end_inset


\end_layout

\begin_layout Subsection
Hybrid penetrance model (operator 
\family typewriter
PyPenetrance
\family default
)
\end_layout

\begin_layout Standard
When your selection model involves multiple interacting genetic and environmenta
l factors, it might be easier to calculate a penetrance value explicitly
 using a Python function.
 A hybrid penetrance operator can be used for this purpose.
 If your penetrance model depends solely on genotype, you can define a function
 such as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pfunc(geno):
\end_layout

\begin_layout Plain Layout

    # calculate penetrance according to genotype at specified loci
\end_layout

\begin_layout Plain Layout

    # in the order of A1,A2,B1,B2,C1,C2 for loci A,B,C (for diploid)
\end_layout

\begin_layout Plain Layout

    return val
\end_layout

\end_inset

and use this function in an operator 
\family typewriter
PySelector(func=pfunc, loci=loci)
\family default
.
 If your penetrance model depends on genotype as well as some information
 fields, you can define a function in the form of 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pfunc(geno, fields):
\end_layout

\begin_layout Plain Layout

    # calculate penetrance according to genotype at specified loci
\end_layout

\begin_layout Plain Layout

    # and values at specified informaton fields.
\end_layout

\begin_layout Plain Layout

    return val
\end_layout

\end_inset

and use this function in an operator 
\family typewriter
PySelector(func=pfunc, loci=loci, paramFields=fields)
\family default
.
 If the function you provide accepts three arguments, 
\family typewriter
PyPenetrance
\family default
 will pass generation number as the third argument so that you could implement
 generation-specific penetrance models (e.g.
 
\family typewriter
pfunc(geno, fields, gen)
\family default
).
\end_layout

\begin_layout Standard
When a 
\family typewriter
PyPenetrance
\family default
 operator is used to calculate penetrance for an individual, it will collect
 his or her genotype at specified loci, optional values at specified information
 fields, and the generation number to a user-specified Python function,
 and take its return value as penetrance.
 As you can imagine, the incorporation of information fields and generation
 number allow the implementation of very complex penetrance scenarios such
 as gene environment interaction and varying selection pressures.
 Note that this operator does not pass sex and affection status to the user-defi
ned function.
 If your selection model is sex-dependent, you can define an information
 field 
\family typewriter
sex
\family default
, synchronize its value with individual sex (e.g.
 using operator 
\family typewriter
InfoExec('sex=ind.sex()', exposeInd='ind'
\family default
) and pass this information to the user-defined function (
\family typewriter
PySelector(func=func, paramFields='sex')
\family default
).
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PySelector"

\end_inset

 demonstrates how to use a 
\family typewriter
PyPenetrance
\family default
 to specify penetrance values according to a fitness table and the smoking
 status of each individual.
 In this example, Individual risk is doubled when he or she smokes.
 The disease prevalence is therefore much higher in smokers than in non-smokers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyPenetrance.log"
lstparams "caption={A hybrid penetrance model},label={PyPenetrance}"

\end_inset


\end_layout

\begin_layout Section
Quantitative trait
\end_layout

\begin_layout Standard
Quantitative traits are naturally stored in information fields of each individua
l.
 A quantitative trait operator assigns quantitative trait fields according
 to individual genetic (genotype) and environmental (other information fields)
 information.
 Although a large number of quantitative trait models have been used in
 theoretical and empirical studies, no model is popular enough to deserve
 a specialized operator.
 Therefore, only one hybrid operator is currently provided in simuPOP.
\end_layout

\begin_layout Subsection
A hybrid quantitative trait operator (operator 
\family typewriter
PyQuanTrait
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
PyQuanTrait
\family default
 accepts a user defined function that returns quantitative trait values
 for specified information fields.
 This operator can comunicate with functions in one of the forms of 
\family typewriter
func(geno)
\family default
, 
\family typewriter
func(geno, field_name, ...)
\family default
 or 
\family typewriter
func(geno, field_name, gen)
\family default
 where 
\family typewriter
field_name
\family default
 should be name of existing fields.
 simuPOP will pass genotype and value of specified fields according to name
 of the passed function.
 Note that geno are arrange locus by locus, namely in the order of 
\family typewriter
A1
\family default
,
\family typewriter
A2
\family default
,
\family typewriter
B1
\family default
,
\family typewriter
B2
\family default
 for loci 
\family typewriter
A
\family default
 and 
\family typewriter
B
\family default
.
 
\end_layout

\begin_layout Standard
A quantitative trait operator can be applied before or after mating and
 assign values to the trait fields of all parents or offspring, respectively.
 It can also be applied during mating to assign trait values to offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyQuanTrait"

\end_inset

 demonstrates the use of this operator, using two trait fields 
\family typewriter
trait1
\family default
 and 
\family typewriter
trait2
\family default
 which are determined by individual genotype and age.
 This example also demonstrates how to calculate statistics within virtual
 subpopulations (defined by age).
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyQuanTrait.log"
lstparams "caption={A hybrid quantitative trait model},label={PyQuanTrait}"

\end_inset


\end_layout

\begin_layout Section
Natural Selection
\end_layout

\begin_layout Subsection
Natural selection through the selection of parents
\end_layout

\begin_layout Standard
In the simplest scenario, natural selection is implemented in two steps:
\end_layout

\begin_layout Itemize
Before mating happens, an operator (called a 
\series bold
selector
\series default
) goes through a population and assign each individual a fitness value.
 The fitness values are stored in an information field called 
\family typewriter
fitness
\family default
.
\end_layout

\begin_layout Itemize
When mating happens, parents are chosen with probabilities that are proportional
 to their fitness values.
 For example, assuming that a parental population consists of four Individuals
 with fitness values 1, 2, 3, and 4, respectively, the probability that
 they are picked to produce offspring are 
\begin_inset Formula $1/\left(1+2+3+4\right)=0.1$
\end_inset

, 
\begin_inset Formula $0.2$
\end_inset

, 
\begin_inset Formula $0.3$
\end_inset

, and 
\begin_inset Formula $0.4$
\end_inset

 respectively.
 As you can image, if the offspring population has 10 individuals, the four
 parents will on average parent 1, 2, 3 and 4 offspring.
\end_layout

\begin_layout Standard
Because parents with lower fitness values have less chance to be produce
 offspring, their genotypes have less chance to be passed to an offspring
 generation.
 If the decreased fitness is caused by the presence of certain mutant (e.g.
 a mutant causing a serious disease), individuals with that mutant will
 have less change to survive and effecitively reduce or eleminate that mutant
 from the population.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 gives an example of natural selection.
 In this example, a 
\family typewriter
MapSelector
\family default
 is used to explicitly assign fitness value to genotypes at the first locus.
 The fitness values are 
\family typewriter
1
\family default
, 
\family typewriter
0.98
\family default
, 
\family typewriter
0.97
\family default
 for genotypes 
\family typewriter
00
\family default
, 
\family typewriter
01
\family default
 and 
\family typewriter
11
\family default
 respectively.
 The selector set individual fitness values to information field 
\family typewriter
fitness
\family default
 before mating happens.
 The 
\family typewriter
RandomMating
\family default
 mating scheme then selects parents according to parental fitness values.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selectParents.log"
lstparams "caption={Natural selection through the selection of parents},label={selectParents}"

\end_inset


\end_layout

\begin_layout Note
The selection algorithm used in simuPOP is called 
\emph on
fitness proportionate selection
\emph default
, or 
\emph on
roulette-wheel selection
\emph default
.
 simuPOP does not use the more efficient 
\emph on
stochastic universal sampling
\emph default
 algorithm because the number of needed offspring is unknown in advance.
\end_layout

\begin_layout Subsection
Natural selection through the selection of offspring *
\end_layout

\begin_layout Standard
Natural selection can also be implemented as selection of offspring.
 Remember that an individual will be discarded if one of the during-mating
 operators fails (return 
\family typewriter
False
\family default
), 
\series bold
a
\series default
 
\series bold
during-mating selector
\series default
 
\series bold
discards offspring according to fitness values of offspring
\series default
.
 Instead of relative fitness that will be compared against other individuals
 during the selection of parents, 
\series bold
fitness values of a during-mating selector are considered as absolute fitness
 which are probabilities to survive
\series default
 and have to be between 0 and 1.
\end_layout

\begin_layout Standard
A during-mating selector works as follows:
\end_layout

\begin_layout Enumerate
During evolution, parents are chosen randomly to produce one or more offspring.
 (Nothing prevents you from choosing parents according to their fitness
 values, but it is rarely justifiable to apply natural selection to both
 parents and offspring.)
\end_layout

\begin_layout Enumerate
A selection operator is applied to each offspring during mating and determines
 his or her fitness value.
 The fitness value is considered as probability to survive so an offspring
 will be discarded (operator returns 
\family typewriter
False
\family default
) if the fitnessvalue is larger than an uniform random number.
\end_layout

\begin_layout Enumerate
Repeat steps 1 and 2 until the offspring generation is populated.
\end_layout

\begin_layout Standard
Because many offspring will be generated and discarded, especially when
 offspring fitness values are low, selection through offspring is less efficient
 than selection through parents.
 In addition, absolute fitness is usually more difficult to estimate than
 relative fitness.
 So, unless there are compelling reasons (e.g.
 simulating realistic scenarios of survival competition among offspring),
 selection through parents are recommended.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectOffspring"

\end_inset

 gives an example of natural selection through the selection of offspring.
 This example looks almost identical to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 but the underlying selection mechanism is quite different.
 Note that selection through offspring does not save fitness values to an
 information field so you do not need to add information field fitness to
 the population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/selectOffspring.log"
lstparams "caption={Natural selection through the selection of offspring},label={selectOffspring}"

\end_inset


\end_layout

\begin_layout Subsection
Are two selection scenarios equivalent? **
\end_layout

\begin_layout Standard
If you look closely at Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectParents"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "selectOffspring"

\end_inset

, you will notice that their results are quite similar.
 This is actually what you should expect in most cases.
 Let us look at the theoretical consequence of selection through parents
 or offspring in a simple case with asexual mating.
\end_layout

\begin_layout Standard
Assuming a diallelic marker with three genotypes 
\begin_inset Formula $g_{AA}$
\end_inset

, 
\begin_inset Formula $g_{Aa}$
\end_inset

 and 
\begin_inset Formula $g_{aa}$
\end_inset

, with frequencies 
\begin_inset Formula $P_{AA}$
\end_inset

, 
\begin_inset Formula $P_{Aa}$
\end_inset

 and 
\begin_inset Formula $P_{aa}$
\end_inset

, and relative fitness values 
\begin_inset Formula $w_{AA}$
\end_inset

, 
\begin_inset Formula $w_{Aa}$
\end_inset

, and 
\begin_inset Formula $w_{22}$
\end_inset

 respectively.
 If we select through offspring, the proportion of genotype 
\begin_inset Formula $g_{AA}$
\end_inset

 etc., should be
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P_{AA}'=\frac{P_{AA}w_{AA}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}
\]

\end_inset


\begin_inset Formula 
\[
P_{Aa}'=\frac{P_{Aa}w_{Aa}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}
\]

\end_inset


\begin_inset Formula 
\[
P_{aa}'=\frac{P_{aa}w_{aa}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}
\]

\end_inset

because offspring genotypes are randomly drawn from the parental generation,
 and each offspring has certain probability to survive.
\end_layout

\begin_layout Standard
Now, if we select through parents, the proportion of parents with genotype
 
\begin_inset Formula $AA$
\end_inset

 will be the number of 
\begin_inset Formula $AA$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula 
\[
n_{AA}\frac{w_{AA}}{\sum_{n=1}^{N}w_{n}}
\]

\end_inset

This is, however, exactly 
\begin_inset Formula 
\[
n_{AA}\frac{w_{AA}}{\sum_{n=1}^{N}w_{n}}=\frac{n_{AA}w_{AA}}{n_{AA}w_{AA}+n_{Aa}w_{Aa}+n_{aa}w_{aa}}=\frac{P_{AA}w_{AA}}{P_{AA}w_{AA}+P_{Aa}w_{Aa}+P_{aa}w_{aa}}=P_{AA}'
\]

\end_inset

which corresponds to the proportion of offspring with such genotype.
 That is to say, 
\series bold
in this simple case, two types of selection scenarios yield identical results
\series default
.
\end_layout

\begin_layout Standard
These two types of selection scenarios do not have to always yield identical
 results.
 Exceptions exist in cases with more than one offspring or sexual mating
 with sex-specific survival rate.
 simuPOP provides both selection implementations and you should choose one
 of them for your particular simulation.
\end_layout

\begin_layout Subsection
Map selector (operator 
\family typewriter
MapSelector
\family default
)
\end_layout

\begin_layout Standard
A map selector uses a Python dictionary to provide fitness values for each
 type of genotype.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MapSelector"

\end_inset

 uses a dictionary with keys 
\family typewriter
(0,0)
\family default
, 
\family typewriter
(0,1)
\family default
 and 
\family typewriter
(1,1)
\family default
 to specify fitness values for individuals with these genotypes at locus
 0.
 This example is a typical example of heterozygote advantage.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if 
\begin_inset Formula $s_{1}=w_{12}-w_{11}$
\end_inset

 and 
\begin_inset Formula $s_{2}=w_{12}-w_{22}$
\end_inset

, the stable allele frequency of allele 0 is
\begin_inset Formula 
\[
p=\frac{s_{2}}{s_{1}+s_{2}}
\]

\end_inset

which is 
\begin_inset Formula $\frac{2}{3}$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MapSelector.log"
lstparams "caption={A selector that uses pre-defined fitness value},label={MapSelector}"

\end_inset


\end_layout

\begin_layout Standard
The above example assumes that the fitness value for individuals with genotypes
 
\family typewriter
(0,1)
\family default
 and 
\family typewriter
(1,0)
\family default
 are the same.
 This assumption is usually valid but can be vialoated with impriting.
 In that case, you can specify fitness for both types of genotypes.
 The underlying mechanism is that the 
\family typewriter
MapSelector
\family default
 looks up a genotype in the dictionary first directly, and then without
 phase information if a genotype is not found.
\end_layout

\begin_layout Standard
This operator supports haplodiploid populations and sex chromosomes.
 In these cases, only valid alleles should be listed which can lead to dictionar
y keys with different lengths.
 In addition, although less used because of potentially a large number of
 keys, this operator can act on multiple loci.
 Please refer to 
\family typewriter
MapPenetrance
\family default
 for details.
\end_layout

\begin_layout Subsection
Multi-allele selector (operator 
\family typewriter
MaSelector
\family default
)
\end_layout

\begin_layout Standard
A multi-allele selector divides alleles into two groups, wildtype 
\emph on
A
\emph default
 and mutants 
\emph on
a
\emph default
, and treat alleles within each group as the same.
 The fitness model is therefore simplified to
\end_layout

\begin_layout Itemize
Two fitness values for genotype 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 in the haploid case
\end_layout

\begin_layout Itemize
Three fitness values for genotype 
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
 in the diploid single locus case.
 Genotype Aa and aA are assumed to have the same impact on fitness.
\end_layout

\begin_layout Standard
The default wildtype group contains allele 0 so the two allele groups are
 zero and non-zero alleles.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MaSelector"

\end_inset

 demonstrates the use of this operator.
 This example is identical to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MapSelector"

\end_inset

 except that there are five alleles at locus 0 and alleles 1, 2, 3, 4 are
 treated as a single non-widetype group.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MaSelector.log"
lstparams "caption={A multi-allele selector},label={MaSelector}"

\end_inset


\end_layout

\begin_layout Standard
Operator 
\family typewriter
MaSelector
\family default
 also supports multiple loci by specifying fitness values for all combination
 of genotype at specified loci.
 In the case of two loci, this operator requires
\end_layout

\begin_layout Itemize
Four fitness values for genotype 
\family typewriter
AB
\family default
, 
\family typewriter
Ab
\family default
, 
\family typewriter
aB
\family default
 and 
\family typewriter
ab
\family default
 in the haploid case,
\end_layout

\begin_layout Itemize
Nine fitness values for genotype 
\family typewriter
AABB
\family default
, 
\family typewriter
AABb
\family default
, 
\family typewriter
AAbb
\family default
, 
\family typewriter
AaBB
\family default
, 
\family typewriter
AaBb
\family default
, 
\family typewriter
Aabb
\family default
, 
\family typewriter
aaBB
\family default
, 
\family typewriter
aaBb
\family default
, and 
\family typewriter
aabb
\family default
 in the haploid case.
\end_layout

\begin_layout Standard
In general, 
\begin_inset Formula $2^{n}$
\end_inset

 values are needed for haploid populations and 
\begin_inset Formula $3^{n}$
\end_inset

 values are needed for diploid populations where 
\begin_inset Formula $n$
\end_inset

 is the number of loci.
 This operator does not yet support haplodiploid populations and sex chromosomes.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MaSelectorHaploid"

\end_inset

 demonstrates the use of a multi-locus model in a haploid population.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MaSelectorHaploid.log"
lstparams "caption={A multi-locus multi-allele selection model in a haploid population},label={MaSelectorHaploid}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-locus selection models (operator 
\family typewriter
MlSelector
\family default
)
\end_layout

\begin_layout Standard
Although an individual's fitness can be affected by several factors, each
 of which can be modeled individually, 
\series bold
only one fitness value is used to determine a person's ability to pass all
 these factors to his or her offspring
\series default
.
 Although in theory we sometimes assume independent evolution of disease
 predisposing loci (mostly for mathematical reasons), in practise we have
 to use a multi-locus selection model to combine single-locus models.
\end_layout

\begin_layout Standard
This multi-loci selector applies several selectors to each individual and
 computes an overall fitness value from the fitness values provided by these
 selectors.
 Although this selector is designed to obtain multi-loci fitness values
 from several single-locus fitness models, any selector, including those
 obtain their fitness values from multiple disease predisposing loci, can
 be used in this selector.
 This selector uses parameter 
\family typewriter
mode
\family default
 to control how individual fitness values are combined.
 More specifically, if 
\begin_inset Formula $f_{i}$
\end_inset

 are fitness values obtained from individual selectors, this selector returns
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Pi_{i}f_{i}$
\end_inset

 if 
\family typewriter
mode=MULTIPLICATIVE
\family default
, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $1-\sum_{i}\left(1-f_{i}\right)$
\end_inset

 if 
\family typewriter
mode=ADDITIVE
\family default
, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $1-\Pi_{i}\left(1-f_{i}\right)$
\end_inset

 if 
\family typewriter
mode=HETEROGENEITY
\end_layout

\begin_layout Standard
0 will be returned if the returned fitness value is less than 0.
\end_layout

\begin_layout Standard
This operator simply combines individual fitness values and it is your responsib
ility to apply and interpret these models.
 For example, if relative fitness values are greater than one, the heterogeneity
 model hardly makes sense.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "MlSelector"

\end_inset

 demonstrates the use of this operator using an additive multi-locus model
 over an additive and a recessive single-locus model at two diesease predisposin
g loci.
 For comparison, we simulate two additional replicates with selection only
 applying to one of the two loci.
 It would be interesting to see if these two loci evolve more or less independen
tly by comparing allele freqency trajectories of these two replicates to
 those in the first replicate.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/MlSelector.log"
lstparams "caption={A multi-loci selector},label={MlSelector}"

\end_inset


\end_layout

\begin_layout Subsection
A hybrid selector (operator 
\family typewriter
PySelector
\family default
)
\end_layout

\begin_layout Standard
When your selection model involves multiple interacting genetic and environmenta
l factors, it might be easier to calculate a fitness value explicitly using
 a Python function.
 A hybrid selector can be used for this purpose.
 If your selection model depends solely on genotype, you can define a function
 such as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitness_func(geno):
\end_layout

\begin_layout Plain Layout

    # calculate fitness according to genotype at specified loci
\end_layout

\begin_layout Plain Layout

    # genotypes are arrange locus by locus, namely A1,A2,B1,B2 for loci
 A and B
\end_layout

\begin_layout Plain Layout

    return val
\end_layout

\end_inset

and use this function in an operator 
\family typewriter
PySelector(func=fitness_func, loci=loci)
\family default
.
 If your selection model depends on genotype as well as some information
 fields, you can define a function in the form of 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fitness_func(geno, field1, field2):
\end_layout

\begin_layout Plain Layout

    # calculate fitness according to genotype at specified loci
\end_layout

\begin_layout Plain Layout

    # and values at specified informaton fields.
\end_layout

\begin_layout Plain Layout

    return val
\end_layout

\end_inset

where 
\family typewriter
field1
\family default
, 
\family typewriter
field2
\family default
 are names of information fields.
 simuPOP will pass genotype and value of specified fields according to name
 of the passed function.
 Note that genotypes are arrange locus by locus, namely in the order of
 
\family typewriter
A1
\family default
,
\family typewriter
A2
\family default
,
\family typewriter
B1
\family default
,
\family typewriter
B2
\family default
 for loci 
\family typewriter
A
\family default
 and 
\family typewriter
B
\family default
.
 Other parameters such as 
\family typewriter
gen
\family default
, 
\family typewriter
ind
\family default
, and 
\family typewriter
pop
\family default
 are also allowed.
 Please check the reference manual for details.
\end_layout

\begin_layout Standard
When a 
\family typewriter
PySelector
\family default
 is used to calculate fitness for an individual (parents if applied pre-mating,
 offspring if applied during-mating), it will collect his or her genotype
 at specified loci, optional values at specified information fields, generation
 number, or individual to a user-specified Python function, and take its
 return value as fitness.
 As you can imagine, the incorporation of information fields and generation
 number allow the implementation of very complex selection scenarios such
 as gene environment interaction and varying selection pressures.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PySelector"

\end_inset

 demonstrates how to use a 
\family typewriter
PySelector
\family default
 to specify fitness values according to a fitness table and the smoking
 status of each individual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PySelector.log"
lstparams "caption={A hybrid selector},label={PySelector}"

\end_inset


\end_layout

\begin_layout Subsection
Multi-locus random fitness effects (operator 
\family typewriter
PyMlSelector
\family default
)
\end_layout

\begin_layout Standard
If the fitness of individuals is determined by fitness effects over a large
 number of loci, both 
\family typewriter
MlSelector
\family default
 and 
\family typewriter
PySelector
\family default
 are difficult to use because the former requires a large number of single-locus
 selectors, and the latter requires the processing long genome sequences.
 If the overall fitness can be determined by fitness effects of mutants,
 a 
\family typewriter
PyMlSelector
\family default
 can be used.
 This operator
\end_layout

\begin_layout Itemize
Calls a user-provided call-back function for each locus with at least a
 mutant (non-zero allele).
 The function can accept location and genotype so the fitness can be location
 and genotype dependent.
 The return value is cached so the function will be called only once for
 each locus-genotype pair.
\end_layout

\begin_layout Itemize
The fitness of each individual is determined by fitness values of loci with
 at least one mutant, using the same methods as operator 
\family typewriter
MlSelector
\family default
.
 This implicitly assumes that loci without any mutant have fitness value
 1 and will not contribute to the final fitness value.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PySelector"

\end_inset

 demonstrates how to use a 
\family typewriter
PyMlSelector
\family default
 to implement a fitness model where each mutant has a random fitness drawn
 from a Gamma distribution.
 An additive model is used so a homozygote will have a fitness penalty that
 doubles that of a heterozygote.
 Because the fitness values of heterozygote and homozygote at each locus
 are requested separately, a class is used to store locus-specific s values.
 
\end_layout

\begin_layout Standard
The fitness value of each locus-genotype pair is outputted to a file, and
 it should be interesting to plot the distribution of allele frequency at
 each locus against the fitness values, because mutants that suffer from
 stronger negative natural selection are supposed to be rarer.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyMlSelector.log"
lstparams "caption={Random fitness effect},label={PyMlSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Alternative implementations of natural selection
\end_layout

\begin_layout Standard
If you know how natural selection works in simuPOP, you do not have to use
 a selector to perform natural selection.
 For example, 
\end_layout

\begin_layout Itemize
If you choose to use fitness values of parents to perform probabilistic
 natural selection during mating, you just need to set individual fitness
 in some way before mating.
 (You do not even have to use information field 
\family typewriter
fitness
\family default
 because you can specify which information field to use in a mating scheme
 using parameter 
\family typewriter
selectionField
\family default
).
 This can be done through a penetrance model (as shown in the following
 example) where affected individuals are selected against during mating,
 a quantitative trait model (where a trait is defined to control individual
 fitness), or by setting information field fitness manually through a Python
 operator.
\end_layout

\begin_layout Itemize
If you would like to perform deterministic selection on certain phenotype,
 you can explicitly remove individuals before or during mating.
 More explicitly, you can use an operator 
\family typewriter
DiscardIf
\family default
 to remove parents before mating or remove offspring during mating according
 to certain status (disease status or quantitative trait), provided that
 the trait status is defined before this operator is applied.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "peneSelector"

\end_inset

 demonstrates a commonly used case where parents who are affected with certain
 disease are excluded from producing offspring.
 In this example, a penetrance model (operator 
\family typewriter
MaPenetrance
\family default
) is applied to the parental generation to determine who will be affected.
 An 
\family typewriter
InfoExec
\family default
 operator is used to set individual fitness to 1 if he or she is unaffected,
 and 0 if he or she is affected.
 Due to the way parents are selected, affected parents will not be able
 to produce offspring as long as there is any unaffected individual.
 Because individual affection status is determined by his or her genotype,
 this genotype - affection status - fitness relationship could be implemented
 using an equivalent 
\family typewriter
MaSelector
\family default
.
 This method could be extended to 
\family typewriter
InfoExec('fitness = 1 - 0.01*ind.affected()', exposeInd='ind')
\family default
 to select against, but not remove, affected parents, and similarly 
\family typewriter
InfoExec('fitness = 1 - 0.01*(LDL > 250)')
\family default
 to select against individuals according to a quantitative trait.
 For this particular example, a 
\family typewriter
DiscardIf
\family default
 operator could be used, although it can be slower because of the explicit
 removal of parents.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/peneSelector.log"
lstparams "caption={Natural selection according to individual affection status},label={peneSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Frequency dependent or dynamic selection pressure *
\end_layout

\begin_layout Standard
If individual fitness depends on individual information fields and/or population
 variables, you will have to calculate individual fitness using expressions
 or functions.
 In order to access individual information fields and population variable
 and calculate individual fitness, you have the option to 
\end_layout

\begin_layout Itemize
Use a 
\family typewriter
PySelector
\family default
 and pass genotype, values of information fields, references to individual
 and population to a user-provided function, which returns fitness value
 for each individual.
\end_layout

\begin_layout Itemize
Use of 
\family typewriter
PyOperator
\family default
 to obtain information of the population (e.g.
 variables) and all individuals.
 Determine individual fitness and set information field 
\family typewriter
fitness
\family default
 of all individuals.
\end_layout

\begin_layout Itemize
Use an operator 
\family typewriter
InfoExec
\family default
 to calculate individual fitness using expressions.
 This method can be more efficient than others because simuPOP does not
 have to call a user-provided function.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "freqDependentSelection"

\end_inset

 demonstrates an example where the fitness values of individuals are calculated
 from allele frequencies calculated using a 
\family typewriter
Stat
\family default
 operator.
 Because the fitness values of individuals are 1, 
\begin_inset Formula $1-(p-0.5)*0.1$
\end_inset

, 
\begin_inset Formula $1-(p-0.5)*0.2$
\end_inset

 for genotype 00, 01 and 11 where 
\begin_inset Formula $p$
\end_inset

 is the frequency of allele 1, this allele will be under purifying selection
 if its frequency is over 0.5, and positive selection if its frequency is
 less than 0.5.
 Consequently, the frequency of this allele will oscillate around 0.5 during
 evolution, as shown in the result of this example.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/freqDependentSelector.log"
lstparams "caption={Frequency dependent selection},label={freqDependentSelection}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:vspSelection"

\end_inset

Support for virtual subpopulations *
\end_layout

\begin_layout Standard
Support for virtual subpopulations allows you to use different selectors
 for different (virtual) subpopulations.
 Because virtual subpopulations may overlap, and they do not have to cover
 all individuals in a subpopulation, it is important to remember that
\end_layout

\begin_layout Itemize
If virtual subpopulations overlap, the fitness value set by the last selector
 will be used.
\end_layout

\begin_layout Itemize
If an individual is not included in any of the virtual subpopulation, its
 fitness value will be zero which will prevent them from producing any offspring.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "vspSelector"

\end_inset

 demonstrates how to apply selectors to virtual subpopulations.
 This example has two subpopulations, each having two virtual subpopulations
 defined by sex.
 Natural selection is applied to male individuals in the first subpopulation,
 and female individuals in the second subpopulation.
 However, because the sex of offspring is randomly determined, the selection
 actually decreases the disease allele frequency for all inviduals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/vspSelector.log"
lstparams "caption={Selector in virtual subpopulations},label={vspSelector}"

\end_inset


\end_layout

\begin_layout Standard
Selecting through offspring can also be applied to virtual subpopulations.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "vspDuringMatingSelector"

\end_inset

 moves the selectors to the 
\family typewriter
ops
\family default
 parameter of 
\family typewriter
RandomMating
\family default
.
 In this way, male and female offspring will have different survival probabiliti
es according to their genotype.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/vspDuringMatingSelector.log"
lstparams "caption={Selection against offspring in virtual subpopulations},label={vspDuringMatingSelector}"

\end_inset


\end_layout

\begin_layout Subsection
Natural selection in heterogeneous mating schemes **
\end_layout

\begin_layout Standard
Multiple mating schemes could be applied to the same subpopulation in a
 heterogeneous mating scheme (
\family typewriter
HeteroMating
\family default
).
 These mating schemes may or may not support natural selection, may be applied
 to different virtual subpopulations of population, and they may see Individuals
 differently in terms of individual fitness.
 Parameter 
\family typewriter
fitnessField
\family default
 of a mating scheme could be used to handle such cases.
 More specifically,
\end_layout

\begin_layout Itemize
You can turn off the natural selection support of a mating scheme by setting
 
\family typewriter
fitnessField=''
\family default
.
\end_layout

\begin_layout Itemize
If a mating scheme uses a different set of fitness values, you can add an
 information field (e.g.
 
\family typewriter
fitness1
\family default
), setting individual fitness to this information field using a selector
 (with parameter 
\family typewriter
infoFields='fitness1'
\family default
) and tells a mating scheme to look in this information field for fitness
 values (using parameter 
\family typewriter
fitnessField='fitness1'
\family default
).
\end_layout

\begin_layout Section
Tagging operators
\end_layout

\begin_layout Standard
In simuPOP, tagging refers to the action of setting various information
 fields of offspring, usually using various parental information during
 the production of offspring.
 simuPOP provides a number of tagging operators (called taggers) for various
 purposes.
 Because tagging operators are during-mating operators, parameter 
\family typewriter
subPops
\family default
 can be used to tag only offspring that belong to specified virtual subpopulatio
n.
 (e.g.
 all male offspring)
\end_layout

\begin_layout Subsection
Inheritance tagger (operator 
\family typewriter
InheritTagger
\family default
)
\end_layout

\begin_layout Standard
An inheritance tagger passes values of parental information field(s) to
 the corresponding offspring information field(s).
 Depending on the parameters, an InheritTagger can 
\end_layout

\begin_layout Itemize
For asexual mating schemes, pass one or more information fields from parent
 to offspring.
\end_layout

\begin_layout Itemize
Pass one or more information fields from father to offspring (
\family typewriter
mode=PATERNAL
\family default
).
\end_layout

\begin_layout Itemize
Pass one or more information fields from mother to offspring (
\family typewriter
mode=MATERNAL
\family default
).
\end_layout

\begin_layout Itemize
Pass the maximal, minimal, sum, multiplcation or average of values of one
 or more information fields of both parents (
\family typewriter
mode=MAXIMUM
\family default
, 
\family typewriter
MINIMUM
\family default
, 
\family typewriter
ADDITION, MULTIPLICATION
\family default
 or 
\family typewriter
MEAN
\family default
).
\end_layout

\begin_layout Standard
This can be used to track the spread of certain information during evolution.
 For example, Example
\begin_inset CommandInset ref
LatexCommand ref
reference "InheritTagger"

\end_inset

 tags the first individuals of ten subpopulations of size 1000.
 individuals in the offspring generation inherits the maximum value of field
 
\family typewriter
x
\family default
 from his/her parents so 
\family typewriter
x
\family default
 is inherited regardless of the sex of parents.
 A Stat operator is used to calculate the number of offspring having this
 tag in each subpopulation.
 The results show that some tagged ancestors have many offspring, and some
 have none.
 If you run this simulation long enough, you can see that all ancestors
 become the ancestor of either none or all indiviudals in a population.
 Note that this simulation only considers genealogical inheritance and ancestors
 do not have to pass any genotype to the last generation.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InheritTagger.log"
lstparams "caption={Use an inherit tagger to track offspring of individuals},label={InheritTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Summarize parental informatin fields (operator 
\family typewriter
SummaryTagger)
\end_layout

\begin_layout Standard
A 
\family typewriter
SummaryTagger
\family default
 summarize values of one or more parental information fields and place the
 result in an offspring information field.
 If mating is sexual, two sets of values will be involved.
 Summarization methods include 
\family typewriter
MEAN
\family default
, 
\family typewriter
MINIMUM
\family default
, 
\family typewriter
MAXIMUM
\family default
, 
\family typewriter
 SUMMATION
\family default
 and 
\family typewriter
MULTIPLICATION
\family default
.
 The operator is usually used to summarize certain characteristic of parents
 of each offspring.
 For example, a 
\family typewriter
SummaryTagger
\family default
 is used in  Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "SummaryTagger"

\end_inset

 to calculate the mean fitness of parents during each  mating event.
 The results are saved in the 
\family typewriter
avgFitness
\family default
 field of offspring.
 Because allele 1 at locus 0 is under purifying selection, the allele frequency
 of this allele decreases.
 In the mean time, fitness of parents increases because less and less parents
 have this allele.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/SummaryTagger.log"
lstparams "caption={Using a summary tagger to calculate mean fitness of parents.},label={SummaryTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking parents (operator 
\family typewriter
ParentsTagger
\family default
)
\end_layout

\begin_layout Standard
A parents tagger is used to record the indexes of parents (in the parental
 population) in the information fields (default to 
\family typewriter
father_idx
\family default
, 
\family typewriter
mother_idx
\family default
) of their offspring.
 These indexes provide a way to track down an individuals parents, offspring
 and consequently all relatives in a multi-generation population.
 Because this operator has been extensively used in this guide, please refer
 to other sections for an Example (e.g.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicInfoFields"

\end_inset

).
\end_layout

\begin_layout Standard
As long as parental generations do not change after the offspring generation
 is created, recorded parental indexes can be used to locate parents of
 an individual.
 However, in certain applications when parental generations change (e.g.
 to draw a pedigree from a large population), or when individuals can not
 be looked up easily using indexes (e.g.
 after individuals are saved to a file), giving every Individual an unique
 ID and refer to them using ID will be a better choice.
\end_layout

\begin_layout Subsection
Tracking index of offspring within families (operator 
\family typewriter
OffspringTagger
\family default
)
\end_layout

\begin_layout Standard
An offspring tagger is used to record the index of offspring within each
 family in an information field (default to 
\family typewriter
offspring_idx
\family default
) of offspring.
 Because the index is reset for each mating event, the index will be reset
 even if two adjacent families share the same parents.
 In addition, this operator records the relative index of an offspring so
 the index will not change if an offspring is re-generated when the previous
 offspring is discarded for any reason.
\end_layout

\begin_layout Standard
Because during-mating selection operator discards offspring according their
 genotypes, a mating scheme can produce families with varying sizes even
 if 
\family typewriter
numOffspring
\family default
 is set to a constant number.
 On the other hand, if we would like to ensure equal family size 
\emph on
N
\emph default
 in the presence of natural selection, we will have to produce more offspring
 so that there can be at least 
\emph on
N
\emph default
 offspring in each family after selection.
 Once 
\emph on
N
\emph default
 offspring have been generated, excessive offspring can be discarded according
 to 
\family typewriter
offspring_idx
\family default
.
 The following example demonstrates such a simulation scenario: 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/OffspringTagger.log"
lstparams "caption={Keeping constant family size in the presence of natural selection against offspring},label={OffspringTagger}"

\end_inset


\end_layout

\begin_layout Standard
Because families with lethal alleles produce the same number of offspring
 as families without such alleles, natural selection happens within each
 families and is weaker than the case when natural selection is used to
 all offspring.
 This phenomena is generally referred to as reproductive compensation.
 
\end_layout

\begin_layout Subsection
Assign unique IDs to individuals (operator 
\family typewriter
IdTagger
\family default
)
\end_layout

\begin_layout Standard
Although it is possible to use generation number and individual indexes
 to locate individuals in an evolving population, an unique I D makes it
 much easier to identify individuals when migration is involved, and to
 analyze an evolutionary process outside of simuPOP.
 An operator 
\family typewriter
IdTagger
\family default
 (and its function form 
\family typewriter
tagID
\family default
) is provided by simuPOP to assign an unique ID to all individuals during
 evolution.
\end_layout

\begin_layout Standard
The IDs of individuals are usually stored in an information field named
 
\family typewriter
ind_id
\family default
.
 To ensure uniqueness across populations, a single source of ID is used
 for this operator.
 individual IDs are assigned consecutively starting from 0.
 If you would like to reset the sequence or start from a different number,
 you can call the 
\family typewriter
reset(startID)
\family default
 function of any 
\family typewriter
IdTagger
\family default
.
\end_layout

\begin_layout Standard
An 
\family typewriter
IdTagger
\family default
 is usually used during-mating to assign ID to each offspring.
 However, if it is applied directly to a population, it will assign unique
 IDs to all individuals in this population.
 This property is usually used in the 
\family typewriter
preOps
\family default
 parameter of function 
\family typewriter
Simulator.evolve
\family default
 to assign initial ID to a population.
 For example, two 
\family typewriter
IdTagger
\family default
 operators are used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "IdTagger"

\end_inset

 to assign IDs to all individuals.
 Although different operators are used, different IDs are assigned to individual
s.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/IdTagger.log"
lstparams "caption={Assign unique IDs to individuals},label={IdTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tracking Pedigrees (operator 
\family typewriter
PedigreeTagger
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
PedigreeTagger
\family default
 is similar to a 
\family typewriter
ParentsTagger
\family default
 in that it records parental information in offspring's information fields.
 However, instead of indexes of parents, this operator records an unique
 ID of each parent to make it easier to study and reconstruct a complete
 pedigree of a whole evolutionary process.
 The default information fields are 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
.
\end_layout

\begin_layout Standard
By default, the 
\family typewriter
PedigreeTagger
\family default
 does not produce any output.
 However, if a valid output string (or function) is specified, it will output
 the ID of offspring and their parents, sex and affection status of offspring,
 and optionally values at specified information fields (parameter 
\family typewriter
outputFields
\family default
) and genotype at specified loci (parameter 
\family typewriter
outputLoci
\family default
).
 Because this operator only outputs offspring, the saved file does not have
 detailed information of individuals in the top-most ancestral generation.
 If you would like to record complete pedigree information, you can apply
 
\family typewriter
PedigreeTagger
\family default
 in the 
\family typewriter
initOps
\family default
 operator of function 
\family typewriter
Simulator.evolve
\family default
 or 
\family typewriter
Population.evolve
\family default
 to output information of the initial population.
 Although this operator is primarily used to output pedigree information,
 values at specified information fields and genotypes at specified loci
 could also be outputed.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PedigreeTagger"

\end_inset

 demonstrates how to output the complete pedigree of an evolutionary process.
 Note that 
\family typewriter
IdTagger
\family default
 has to be applied before 
\family typewriter
PedigreeTagger
\family default
 so that IDs of offspring could be assigned before they are outputted.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PedigreeTagger.log"
lstparams "caption={Output a complete pedigree of an evolutionary process},label={PedigreeTagger}"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
A hybrid tagger (operator 
\family typewriter
PyTagger
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
PyTagger
\family default
 uses a user-defined function to pass parental information fields to offspring.
 When a mating event happens, this operator collect values of specified
 information fields of parents, pass them to a user-provided function, and
 use the return values to set corresponding offspring information fields.
 A typical usage of this operator is to set random environmental factors
 that are affected by parental values.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyTagger"

\end_inset

 demonstrates such an example where the location of each offspring (x, y)
 is randomly assigned around the middle position of his or her parents.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyTagger.log"
lstparams "caption={Use of a hybrid tagger to pass parental information to offspring},label={PyTagger}"

\end_inset


\end_layout

\begin_layout Subsection
Tagging that involves other parental information
\end_layout

\begin_layout Standard
If the way how parental information fields pass to their offspring is affected
 by parental genotype, sex, or affection status, you could use a Python
 operator (
\family typewriter
PyOperator
\family default
) during mating to explicitly obtain parental information and set offspring
 information fields.
\end_layout

\begin_layout Standard
Alternatively, you can add another information field, translate needed informati
on to this field and pass the genotype information in the form of information
 field.
 Operator 
\family typewriter
InfoExec
\family default
 could be helpful in this case.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "otherTagging"

\end_inset

 demonstrates such an example where the number of affected parents are recorded
 in an information field.
 Before mating happens, a penetrance operator is used to assign affection
 status to parents.
 The affection status is then copied to an information field affected so
 that operator 
\family typewriter
SummaryTagger
\family default
 could be used to count the number of affected parents.
 Two 
\family typewriter
MaPenetrance
\family default
 operators are used both before and after mating to assign affection status
 to both parental and offspring generations.
 This helps dividing the offspring generation into affected and unaffected
 virtual subpopulations.
 Not surprisingly, the average number of affected parents is larger for
 affected individuals than unaffected individuals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/otherTagging.log"
lstparams "caption={Tagging that involves other parental information},label={otherTagging}"

\end_inset


\end_layout

\begin_layout Section
Statistics calculation (operator 
\family typewriter
Stat
\family default
)
\end_layout

\begin_layout Subsection
How statistics calculation works
\end_layout

\begin_layout Standard
A 
\family typewriter
Stat
\family default
 operator calculates specified statistics of a population when it is applied
 to this population.
 This operator can be applied to specified replicates (parameter 
\emph on
rep
\emph default
) at specified generations (parameter 
\emph on
begin
\emph default
, 
\emph on
end
\emph default
, 
\emph on
step
\emph default
, and 
\emph on
at
\emph default
).
 This operator does not produce any output (ignore parameter 
\emph on
output
\emph default
) after statistics are calculated.
 Instead, it stores results in the local namespace of the population being
 applied.
 Other operators can retrieve these variables or evalulate expression directly
 in this local namespace.
\end_layout

\begin_layout Standard
The 
\family typewriter
Stat
\family default
 operator is usually used in conjunction with a 
\family typewriter
PyEval
\family default
 or 
\family typewriter
PyExec
\family default
 operator which execute Python statements and/or expressions in a population's
 local namespace.
 For example, operators 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ops = [
\end_layout

\begin_layout Plain Layout

    Stat(alleleFreq=[0]),
\end_layout

\begin_layout Plain Layout

    PyEval("'%.2f' % alleleFreq[0][0]")
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset

in the 
\family typewriter
ops
\family default
 parameter of the 
\family typewriter
Simulator.evolve
\family default
 function will be applied to populations during evolution.
 The first operator calculates allele frequency at the first locus and store
 the results in each population's local namespace.
 The second operator formats and outputs one of the variables.
 Because of the flexiblity of the 
\family typewriter
PyEval
\family default
 operator, you can output statistics, even simple derived statistics, in
 any format.
 For example, you can output expected heterozygosity (
\begin_inset Formula $1-\sum p_{i}^{2}$
\end_inset

) using calculated allele frequencies as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyEval("'H_exp=%.2f' % (1-sum([x*x for x in alleleFreq[0].values()]))")
\end_layout

\end_inset

Note that 
\family typewriter
alleleFreq[0]
\family default
 is a dictionary.
\end_layout

\begin_layout Standard
You can also retrieve variables in a population directly using functions
 
\family typewriter
Population.vars()
\family default
 or 
\family typewriter
Population.dvars()
\family default
.
 The only difference between these functions is that 
\family typewriter
vars()
\family default
 returns a dictionary and 
\family typewriter
dvars()
\family default
 returns a Python object that uses variable names as attributes (
\family typewriter
vars()['alleleFreq']
\family default
 is equivalent to 
\family typewriter
dvars().alleleFreq
\family default
).
 This method is usually used when the function form of the 
\family typewriter
Stat
\family default
 operator is used.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(pop, alleleFreq=[0])
\end_layout

\begin_layout Plain Layout

H_exp = 1 - sum([x*x for x in pop.dvars().alleleFreq[0].values()])
\end_layout

\end_inset

uses the 
\family typewriter
stat
\family default
 function (note the capital S) to count frequencies of alleles for a given
 population and calculates expected heterozygosity using these variables.
\end_layout

\begin_layout Subsection

\family typewriter
defdict
\family default
 datatype
\end_layout

\begin_layout Standard
simuPOP uses dictionaries to save statistics such as allele frequencies.
 For example, 
\family typewriter
alleleFreq[5]
\family default
 can be 
\family typewriter
{0:0.2, 3:0.8}
\family default
 meaning there are 20% allele 0 and 80% allele 3 at locus 5 in a population.
 However, because it is sometimes unclear whether or not a particular allele
 exists in a population, 
\family typewriter
alleleFreq[5][allele]
\family default
 can fail with a 
\family typewriter
KeyError
\family default
 exception if 
\family typewriter
alleleFreq[5]
\family default
 does not have key 
\family typewriter
allele
\family default
.
\end_layout

\begin_layout Standard
To address this problem, a special default dictionary type 
\family typewriter
defdict
\family default
 is used for dictionaries with keys determined from a population.
 This derived dictionary type works just like a regular dictionay, but it
 returns 0, instead of raising a 
\family typewriter
KeyError
\family default
 exception, when an invalid key is used.
 For example, subpopulations in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "defdictType"

\end_inset

 have different alleles.
 Although 
\family typewriter
pop.dvars(sp).alleleFreq[0]
\family default
 have only two keys for 
\family typewriter
sp=0
\family default
 or 
\family typewriter
1
\family default
, 
\family typewriter
pop.dvars(sp).alleleFreq[0][x]
\family default
 are used to print frequencies of alleles 
\family typewriter
0
\family default
, 
\family typewriter
1
\family default
 and 
\family typewriter
2
\family default
.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/defdict.log"
lstparams "caption={The defdict datatype},label={defdictType}"

\end_inset


\end_layout

\begin_layout Note
The standard 
\family typewriter
collections
\family default
 module of Python has a 
\family typewriter
defaultdict
\family default
 type that accepts a default factory function that will be used when an
 invalid key is encountered.
 The 
\family typewriter
defdict
\family default
 type is similar to 
\family typewriter
defaultdict(int)
\family default
 but with an important difference: when an invalid key is encountered, 
\family typewriter
d[key]
\family default
 with a default value will be inserted to a 
\family typewriter
defaultdict(int)
\family default
, but will not be inserted to a 
\family typewriter
defdict
\family default
.
 That is to say, it is safe to use 
\family typewriter
alleleFreq[loc].keys()
\family default
 to get available alleles after non-assignment 
\family typewriter
alleleFreq[loc][allele]
\family default
 operations.
\end_layout

\begin_layout Subsection
Support for virtual subpopulations
\end_layout

\begin_layout Standard
The 
\family typewriter
Stat
\family default
 operator supports parameter 
\emph on
subPops
\emph default
 and can calculate statistics in specified subpopulations.
 For example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(alleleFreq=[0], subPops=[(0, 0), (1, 0)])
\end_layout

\end_inset

will calculate the frequencies of alleles at locus 0, among Individuals
 in two virtual subpopulations.
 If the virtual subpopulation is defined by sex (using a 
\family typewriter
SexSplitter
\family default
), the above operator will calculate allele frequency among all males in
 the first and second subpopulations (not separately!).
 If 
\family typewriter
subPops
\family default
 is not specified, allele frequency of the whole population (all subpopulations)
 will be calculated.
\end_layout

\begin_layout Standard
Although many statistics could be calculated and outputted, the 
\family typewriter
Stat
\family default
 operator by default outputs a selected number of variables for each statisic
 calculated.
 Other statistics could be calculated and outputted if their names are specified
 in parameter 
\family typewriter
vars
\family default
.
 Variable names ending with 
\family typewriter
_sp
\family default
 is interpreted as variables that will be calculated and outputted in all
 or specified (virtual) subpopulations.
 For example, parameter 
\family typewriter
vars
\family default
 in  
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(alleleFreq=[0], subPops=[0, (1, 0)], vars=['alleleFreq_sp', 'alleleNum_sp']
)
\end_layout

\end_inset

tells this operator to output numbers and frequencies of alleles at locus
 
\family typewriter
0
\family default
 in subpopulation 
\family typewriter
0
\family default
 and virtual subpopulation 
\family typewriter
(1,0)
\family default
.
 These variables will be saved in dictionaries 
\family typewriter
subPop[sp]
\family default
 of the local namespace.
 For example, the above operator will write variables such as 
\family typewriter
subPop[0]['alleleFreq'], subPop[(1,0)]['alleleFreq'] and subPop[(1,0)]['alleleNu
m']
\family default
.
 Functions 
\family typewriter
Population.vars(sp)
\family default
 and 
\family typewriter
Population.dvars(sp)
\family default
 are provided as shortcuts to access these variables but the full variable
 names have to be specified if these variables are used in expressions.
\end_layout

\begin_layout Standard
By default, the same variables will be set for a statistic, regardless of
 the values of the 
\family typewriter
loci
\family default
 and 
\family typewriter
subPops
\family default
 parameter.
 This can be a problem if multiple 
\family typewriter
Stat
\family default
 operators are used to calculate the same statistics for different sets
 of loci (e.g.
 for each chromosome) or subpopulations.
 To avoid name conflict, you can use parameter 
\emph on
suffix
\emph default
 to add a suffix to all variables outputted by a Stat operator.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statSuffix"

\end_inset

 uses 4 
\family typewriter
Stat
\family default
 operators to calculate overall and pairwise 
\begin_inset Formula $F_{ST}$
\end_inset

 values for three subpopulations.
 Different suffixes are used for pairwise 
\begin_inset Formula $F_{ST}$
\end_inset

 estimators so that variables set by these operators will not override each
 other.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statSuffix.log"
lstparams "caption={Add suffixes to variables set by multiple Stat operators},label={statSuffix}"

\end_inset


\end_layout

\begin_layout Note
The 
\family typewriter
Stat
\family default
 opeartor accepts overlapping or even duplicate virtual subpopulations.
 During the calculation of summary statistics, these subpopulations are
 treated as separate subpopulations so some individuals can be counted more
 than once.
 For example, individuals in virtual subpopulation (0, 1) will be counted
 twice during the calculation of allele frequency and population size in
 operator 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(alleleFreq=[0], popSize=True, subPops=[0, (0, 1)])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Counting individuals by sex and affection status
\end_layout

\begin_layout Standard
Parameters 
\emph on
popSize
\emph default
, 
\emph on
numOfMales
\emph default
 and 
\emph on
numOfAffected
\emph default
 provide basic Individual counting statistics.
 They count the number of all, male/female, affected/unaffected individuals
 in all or specified (virtual) subpopulations, and set variables such as
 
\family typewriter
popSize
\family default
, 
\family typewriter
numOfMales
\family default
, 
\family typewriter
numOfFemales
\family default
, 
\family typewriter
numOfAffected
\family default
, 
\family typewriter
numOfUnaffected
\family default
.
 Proportions and statistics for  subpopulations are available if variables
 such as 
\family typewriter
propOfMales
\family default
, 
\family typewriter
numOfAffected_sp
\family default
 are specified in parameter vars.
 Another variable 
\family typewriter
subPopSize
\family default
 is defined for parameter 
\family typewriter
popSize=True
\family default
.
 It is a list of sizes of all or specified subpopulations and is easier
 to use than referring to variable 
\family typewriter
popSize
\family default
 from individual subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statCount"

\end_inset

 demonstrates how to use these parameters in operator 
\family typewriter
Stat
\family default
.
 It defines four VSPs by sex and affection status (using a 
\family typewriter
stackedSplitter
\family default
) and count individuals by sex and affection status.
 It is worth noting that 
\family typewriter
pop.dvars().popSize
\family default
 in the first example is the total number of individuals in two virtual
 subpopulations 
\family typewriter
(0,0)
\family default
 and 
\family typewriter
(0,2)
\family default
, which are all male indiviudals, and all unaffected individuals.
 Because these two VSPs overlap, this variable can be larger than actual
 population size.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statCount.log"
lstparams "caption={Count individuals by sex and/or affection status},label={statCount}"

\end_inset


\end_layout

\begin_layout Subsection
Number of segregating and fixed sites
\end_layout

\begin_layout Standard
Parameter 
\shape italic
numOfSegSites
\shape default
 counts the number of segregating sites for specified or all loci, for all
 individuals or individuals in specified (virtual) subpopulations.
 It can also be used to count the number of fixed sites .
 This parameter sets variables 
\family typewriter
numOfSegSites
\family default
 and 
\family typewriter
numOfFixedSites
\family default
.
 Here we defined fixed sites as loci with only one non-zero allele (e.g.
 fixed to a non-zero allele).
 Other numbers, such as all loci with only one allele (including zero),
 or loci with all wildtype alleles (only zero), can be derived from these
 two counts.
 Starting from version 1.1.3, variables 
\family typewriter
segSites
\family default
 and 
\family typewriter
fixedSites
\family default
 can be used to return a list of segregating and fixed sites.
\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "numSegSites"

\end_inset

 demonstrates how to use this operator to calculate the number of segregating
 sites (sites with alleles 0 and 1), number of fixed sites (sites with only
 allele 1), and number of loci with only wildtype alleles (loci with only
 allele 0).
 As you can see, the population starts with 100 segregating sites.
 During evolution, alleles at some loci get lost and some get fixed, and
 there should be no segregating site if we evolve the population for long
 enough.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statNumOfSegSites.log"
lstparams "caption={Count number of segregating and fixed sites},label={numSegSites}"

\end_inset


\end_layout

\begin_layout Subsection
Allele count and frequency
\end_layout

\begin_layout Standard
Parameter 
\emph on
alleleFreq
\emph default
 accepts a list of markers at which allele frequencies in all or specified
 (virtual) subpopulations will be calculated.
 This statistic sets variables 
\family typewriter
alleleFreq[loc][allele]
\family default
 and 
\family typewriter
alleleNum[loc][allele]
\family default
 which are frequencies and numbers of allele 
\family typewriter
allele
\family default
 at locus 
\family typewriter
loc
\family default
, respectively.
 If variables 
\family typewriter
alleleFreq_sp
\family default
 and 
\family typewriter
alleleNum_sp
\family default
 are specified in parameter 
\emph on
vars
\emph default
, these variables will be set for all or specified (virtual) subpopulations.
 
\series bold
At the Python level, these variables are dictionaries of default dictionaries.

\series default
 That is to say, 
\family typewriter
alleleFreq[loc]
\family default
 at a unspecified locus will raise a 
\family typewriter
KeyError
\family default
 exception, and 
\family typewriter
alleleFreq[loc][allele]
\family default
 of an invalid allele will return 0.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statAlleleFreq"

\end_inset

 demonstrates an advanced usage of allele counting statistic.
 In this example, two virtual subpopulations are defined by individual affection
 status.
 During evolution, a multi-allele penetrance operator is used to determine
 individual affection status and a 
\family typewriter
Stat
\family default
 operator is used to calculate allele frequencies in these two virtual subpopula
tions, and in the whole population.
 Because the simulated disease is largely caused by the existence of allele
 1 at the first locus, it is expected that the frequency of allele 1 is
 higher in the case group than in the control group.
 It is worth noting that 
\family typewriter
alleleFreq[0][1]
\family default
 in this example is the frequency of allele 1 in the whole population because
 these two virtual subpopulations add up to the whole population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statAlleleFreq.log"
lstparams "caption={Calculate allele frequency in affected and unaffected individuals},label={statAlleleFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Genotype count and frequency
\end_layout

\begin_layout Standard
Parameter 
\emph on
genoFreq
\emph default
 accepts a list of loci at which genotype counts and frequencies are calculated
 and outputted.
 A genotype is represented as a tuple of alleles at a locus.
 The length of the tupples
\series bold
 
\series default
is determined by the number of homologous copy of chromosomes in a population.
 For example, genotypes in a diploid population are ordered pairs such as
 
\family typewriter
(1, 2)
\family default
 where 1 and 2 are alleles at a locus on, respectively, the first and second
 homologous copies of chromosomes.
 
\family typewriter
(1, 2)
\family default
 and 
\family typewriter
(2, 1)
\family default
 are different genotypes.
 This statistic sets dictionaries (with locus indexes as keys) of default
 dictionaries (with genotypes as keys) 
\family typewriter
genoFreq
\family default
 and 
\family typewriter
genoNum
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statGenoFreq"

\end_inset

 creates a small population and initializes a locus with rare alleles 0,
 1 and a common allele 2.
 A function 
\family typewriter
stat
\family default
 (the function form of operator 
\family typewriter
Stat
\family default
) is used to count the available genotypes.
 Note that 
\family typewriter
pop.dvars().genoFreq[0][(i,j)]
\family default
 can be used to print frequencies of all genotypes even when not all genotypes
 are available in the population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statGenoFreq.log"
lstparams "caption={Counting genotypes in a population},label={statGenoFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Homozygote and heterozygote count and frequency
\end_layout

\begin_layout Standard
In a diploid population, a heterozygote is a genotype with two different
 alleles and a homozygote is a genotype with two identical alleles.
 Parameter 
\family typewriter
heteroFreq
\family default
 accepts a list of loci and outputs variables 
\family typewriter
heteroFreq
\family default
 which is a dictionary of heterozygote frequencies at specfied loci.
 Optional variables 
\family typewriter
heteroNum
\family default
, 
\family typewriter
homoFreq
\family default
 and 
\family typewriter
homoNum
\family default
 can be outputted for all and each (virtual) subpopulations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHeteroFreq"

\end_inset

 demonstrates the decay of heterozygosity of a locus due to genetic drift.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHeteroFreq.log"
lstparams "caption={Counting homozygotes and heterozygotes in a population},label={statHeteroFreq}"

\end_inset


\end_layout

\begin_layout Subsection
Haplotype count and frequency
\end_layout

\begin_layout Standard
Haplotypes refer to alleles on the same homologous copy of a chromosome
 at specified loci.
 For example, an diploid individual can have haplotypes 
\family typewriter
(0, 2, 1)
\family default
 and 
\family typewriter
(0, 1, 1)
\family default
 at loci 
\family typewriter
(2, 3, 5)
\family default
 if he or she has genotype 
\family typewriter
(0, 0)
\family default
, 
\family typewriter
(2, 1)
\family default
 and 
\family typewriter
(1,1)
\family default
 at loci 2, 3 and 5 respectively.
 Parameter 
\emph on
haploFreq
\emph default
 accept one or more lists of loci specifying one or more haplotype sites
 (e.g.
 
\family typewriter
haploFreq=[(0,1,2), (2,3)]
\family default
 specifies two haplotype sites).
 The results are saved to dictionaries (with haplotype site as keys) of
 default dictionaries (with haplotype as keys).
 For example, 
\family typewriter
haploFreq[(0,1,2)][(0,1,1)]
\family default
 will be the frequency of haplotype 
\family typewriter
(0, 1, 1)
\family default
 at loci 
\family typewriter
(0, 1, 2)
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHaploFreq"

\end_inset

 prints the numbers of genotypes and haplotypes at loci 0, 1 and 2 of a
 small population.
 Note that the 
\family typewriter
viewVars
\family default
 function defined in module 
\family typewriter
simuUtil
\family default
 can make use of a wxPython window to view all variables if it is called
 in GUI mode.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHaploFreq.log"
lstparams "caption={Counting haplotypes in a population},label={statHaploFreq}"

\end_inset


\end_layout

\begin_layout Note

\emph on
haploFreq
\emph default
 does not check if loci in a haplotype site belong to the same chromosome,
 or if loci are duplicated or in order.
 It faithfully assemble alleles at specified loci as haplotypes although
 these haplotypes might not be biologically meaningful.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Note
Counting a large number of haplotypes on long haplotype sites may exhaust
 the RAM of your computer.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Summary statistics of information fields
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
sumOfInfo
\family default
, 
\family typewriter
meanOfInfo
\family default
, 
\family typewriter
varOfInfo
\family default
, 
\family typewriter
maxOfInfo
\family default
 and 
\family typewriter
minOfInfo
\family default
 are used to calculate the sum, mean, sample variance (
\begin_inset Formula $\frac{1}{n-1}\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$
\end_inset

), max and min of specified information fields of individuals in all or
 specified (virtual) subpopulations.
 The results are saved in dictionaries 
\family typewriter
sumOfInfo
\family default
, 
\family typewriter
meanOfInfo
\family default
, 
\family typewriter
varOfInfo
\family default
, 
\family typewriter
maxOfInfo
\family default
 and 
\family typewriter
minOfInfo
\family default
 with information fields as keys.
 For example, parameter  
\family typewriter
meanOfInfo='age'
\family default
 calculates the mean age of all individuals and set variable 
\family typewriter
meanOfInfo['age']
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statInfo"

\end_inset

 demonstrates a mixing process of two populations.
 The population starts with two types of individuals with ancestry values
 0 or 1 (information field 
\family typewriter
anc
\family default
).
 During the evolution, parents mate randomly and the ancestry of offspring
 is the mean of parental ancestry values.
 A 
\family typewriter
Stat
\family default
 operator is used to calculate the mean and variance of individual ancestry
 values, and the number of individuals in five ancestry groups.
 It is not surprising that whereas population mean ancestry does not change,
 more and more people have about the same number of ancestors from each
 group and have an ancestry value around 0.5.
 The variance of ancestry values therefore decreases gradually.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statInfo.log"
lstparams "caption={Calculate summary statistics of information fields},label={statInfo}"

\end_inset


\end_layout

\begin_layout Subsection
Linkage disequilibrium
\end_layout

\begin_layout Standard
Parameter 
\emph on
LD
\emph default
 accepts a list of loci-pairs (e.g.
 
\family typewriter
LD=[(0,1),(2,3)]
\family default
) with optional primary alleles at two loci (e.g.
 
\family typewriter
LD=[(0,1,0,0),(2,3)]
\family default
).
 For each pair of loci, this operator calculates linkage disequilibrium
 and optional association measures between them.
 
\end_layout

\begin_layout Standard
Assuming that two loci are both diallelic, one with alleles 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

, and the other with alleles 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

.
 If we denote 
\begin_inset Formula $P_{x}$
\end_inset

, 
\begin_inset Formula $P_{xy}$
\end_inset

 as allele and haplotype frequencies for allele 
\begin_inset Formula $x$
\end_inset

 and haplotype 
\begin_inset Formula $xy$
\end_inset

, respectively, the linkage disequilibrium measures 
\series bold
with respect to primaries alleles
\series default
 
\emph on
A
\emph default
 and 
\emph on
B
\emph default
 are
\end_layout

\begin_layout Itemize
Basic LD measure 
\begin_inset Formula $D$
\end_inset

: 
\begin_inset Formula 
\[
D=P_{AB}-P_{A}P_{B}
\]

\end_inset


\emph on
D
\emph default
 ranges from -0.25 to 0.25.
 The sign depends on the choice of alleles (
\emph on
A
\emph default
 and 
\emph on
B
\emph default
) at two loci.
\end_layout

\begin_layout Itemize
Lewontin's 
\begin_inset Formula $D'=D/D_{max}$
\end_inset

 where 
\begin_inset Formula 
\[
D_{max}=\begin{cases}
\min\left(P_{A}\left(1-P_{B}\right),\left(1-P_{A}\right)P_{B}\right) & \textrm{if }D>0\\
\min\left(P_{A}P_{B},\left(1-P_{A}\right)\left(1-P_{B}\right)\right) & \textrm{if }D<0
\end{cases}
\]

\end_inset


\emph on

\begin_inset Formula $D'$
\end_inset


\emph default
 ranges from -1 to 1.
 The sign depends on the choice of alleles (
\emph on
A
\emph default
 and 
\emph on
B
\emph default
) at two loci.
\end_layout

\begin_layout Itemize
\begin_inset Formula $r^{2}$
\end_inset

 (
\begin_inset Formula $\Delta^{2}$
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand citet
key "Devlin1995"

\end_inset

) 
\begin_inset Formula 
\[
r^{2}=\frac{D^{2}}{P_{A}\left(1-P_{A}\right)P_{B}\left(1-P_{B}\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
If one or both loci have more than 2 alleles, or if no primary allele is
 specified, the LD measures are calculated as follows:
\end_layout

\begin_layout Itemize
If primary alleles are specified, all other alleles are considered as minor
 alleles with combined frequency (e.g.
 
\begin_inset Formula $1-P_{A}$
\end_inset

).
 The same formulas apply which lead to signed 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize
If primary alleles are not specified, these LD measures are calculated as
 the average of the absolute value of diallelic measures of all allele pairs.
 For example, the multi-allele version of 
\begin_inset Formula $r^{2}$
\end_inset

 is
\begin_inset Formula 
\[
r^{2}=\sum_{i}\sum_{j}P_{i}P_{j}\left|r_{ij}^{2}\right|=\sum_{i}\sum_{j}\frac{D_{ij}^{2}}{\left(1-P_{i}\right)\left(1-P_{j}\right)}
\]

\end_inset

where 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 iterate through all alleles at the two loci.
 
\series bold
In the diallelic case, LD measures will be the absolute value of the single
 measures
\series default
 because 
\begin_inset Formula $D_{ij}$
\end_inset

 and 
\begin_inset Formula $D'_{ij}$
\end_inset

 only differ by signs.
\end_layout

\begin_layout Standard
In another word,
\end_layout

\begin_layout Itemize

\family typewriter
LD=[loc1, loc2]
\family default
 will yield positive 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize

\family typewriter
LD=[loc1, loc2, allele1, allele2]
\family default
 will yield signed 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

 measures.
\end_layout

\begin_layout Itemize
In the diallelic case, both cases yield identical results except for signs
 of 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $D'$
\end_inset

.
\end_layout

\begin_layout Itemize
In the multi-allelic case, the results can be different because 
\family typewriter
LD=[loc1, loc2, allele1, allele2]
\family default
 combines non-primary alleles and gives a single diallelic measure.
\end_layout

\begin_layout Note
A large number of linkage disequilibrium measures have been used in different
 disciplines but not all of them are well-accepted.
 Requests of adding a particular LD measure will be considered when a reliable
 reference is provided.
\end_layout

\begin_layout Standard
Association tests between specified loci could also be calculated using
 a 
\begin_inset Formula $m$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 table of haplotype frequencies.
 If primary alleles are specified, non-primary alleles are combined to form
 a 2 by 2 table (
\begin_inset Formula $m=n=2$
\end_inset

).
 Otherwise, 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are respective numbers of alleles at two loci.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\chi^{2}$
\end_inset

 and its 
\begin_inset Formula $p$
\end_inset

-value (variable 
\family typewriter
LD_ChiSq
\family default
 and 
\family typewriter
LD_ChiSq_p
\family default
, respectively).
 A one-side 
\begin_inset Formula $\chi^{2}$
\end_inset

 test with 
\begin_inset Formula $\left(m-1\right)\times\left(n-1\right)$
\end_inset

 degrees of freedom will be used.
\end_layout

\begin_layout Itemize
Cramer V statistic (variable 
\family typewriter
CramerV
\family default
): 
\begin_inset Formula 
\[
V=\sqrt{\frac{\chi^{2}}{N\times\mbox{min}\left(m-1,n-1\right)}}
\]

\end_inset

where 
\begin_inset Formula $N$
\end_inset

 equals the total number of haplotypes (
\begin_inset Formula $2\times\mbox{popSize}$
\end_inset

 for autosomes in diploid populations).
\end_layout

\begin_layout Standard
This statistic sets variables 
\family typewriter
LD
\family default
, 
\family typewriter
LD_prime
\family default
, 
\family typewriter
R2
\family default
, and optionally 
\family typewriter
ChiSq
\family default
, 
\family typewriter
ChiSq_p
\family default
 and 
\family typewriter
CramerV
\family default
.
 SubPopulation specific variables can be calculated by specifying variables
 such as 
\family typewriter
LD_sp
\family default
 and 
\family typewriter
R2_sp
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statLD"

\end_inset

 demonstrates how to calculate various LD measures and output selected variables.
 Note that the significant overall LD between two loci is an artifact of
 population structure because loci are in linkage equilibrium in each subpopulat
ion.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statLD.log"
lstparams "caption={Linkage disequilibrium measures},label={statLD}"

\end_inset


\end_layout

\begin_layout Subsection
Genetic association
\end_layout

\begin_layout Standard
Genetic association refers to association between individual genotype (alleles
 or genotype) and phenotype (affection status).
 There are a large number of statistics tests based on different study designs
 (e.g.
 case-control, Pedigree, longitudinal) with different covariate variables.
 Although specialized software applications should be used for sophisticated
 statistical analysis, simuPOP provides a number of simple genetic association
 tests for convenience.
 These tests
\end_layout

\begin_layout Itemize
Are single-locus tests that test specified loci separately.
\end_layout

\begin_layout Itemize
Are based on individual affection status.
 Associations between genotype and quantitative traits are currently unsupported.
\end_layout

\begin_layout Itemize
Apply to all individuals in specified (virtual) subpopulations.
 Because a population usually has much more unaffected individuals than
 affected ones, it is a common practice to draw certain types of samples
 (e.g.
 a case-control sample with the same number of cases and controls) before
 statistical tests are applied.
\end_layout

\begin_layout Standard
simuPOP currently supports the following tests:
\end_layout

\begin_layout Itemize

\series bold
Allele-based Chi-square test
\series default
: This is the basic allele-based 
\begin_inset Formula $\chi^{2}$
\end_inset

 test that can be applied to diploid as well as haploid populations.
 Basically, a 2 by 
\begin_inset Formula $n$
\end_inset

 contigency table is set up for each locus with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of alleles 
\begin_inset Formula $j$
\end_inset

 in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A 
\begin_inset Formula $\chi^{2}$
\end_inset

 test is applied to each locus and set variables 
\family typewriter
Allele_ChiSq
\family default
 and 
\family typewriter
Allele_ChiSq_p
\family default
 to the 
\begin_inset Formula $\chi^{2}$
\end_inset

 statistic and its two-sided 
\begin_inset Formula $p$
\end_inset

 value (with degrees freedom 
\begin_inset Formula $n-1$
\end_inset

).
 Note that genotype information is not preserved in such a test.
\end_layout

\begin_layout Itemize

\series bold
Genotype-based Chi-square test
\series default
: This is the genotype-based 
\begin_inset Formula $\chi^{2}$
\end_inset

 test for diploid populations.
 Basically, a 2 by 
\begin_inset Formula $n$
\end_inset

 contigency table is set up for each locus with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of genotype 
\begin_inset Formula $j$
\end_inset

 (unordered pairs of alleles) in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A 
\begin_inset Formula $\chi^{2}$
\end_inset

 test is applied to each locus and set variables 
\family typewriter
Geno_ChiSq
\family default
 and 
\family typewriter
Geno_ChiSq_p
\family default
 to the 
\begin_inset Formula $\chi^{2}$
\end_inset

 statistic and its two-sided 
\begin_inset Formula $p$
\end_inset

 value (with degrees freedom 
\begin_inset Formula $n-1$
\end_inset

).
 This test is usually applied to diallelic loci with 3 genotypes (
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
) but it can be applied to loci with more than two alleles as well.
\end_layout

\begin_layout Itemize

\series bold
Genotype-based trend test
\series default
: This Cochran-Armitage test can only be applied to diallelic loci in diploid
 populations.
 For each locus, a 2 by 3 contigency table is set up with 
\begin_inset Formula $n_{ij}$
\end_inset

 being the number of genotype 
\begin_inset Formula $j$
\end_inset

 (
\emph on
AA
\emph default
, 
\emph on
Aa
\emph default
 and 
\emph on
aa
\emph default
 with 
\emph on
A
\emph default
 being the wildtype allele) in cases 
\begin_inset Formula $\left(i=0\right)$
\end_inset

 and controls 
\begin_inset Formula $\left(i=1\right)$
\end_inset

.
 A Cochran-Armitage trend test is applied to each locus and set variables
 
\family typewriter
Armitage_p
\family default
 to its two-sided 
\begin_inset Formula $p$
\end_inset

 value.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statAssociation"

\end_inset

 demonstrates how to apply a penetrance model, draw a case-control sample
 and apply genetic association tests to an evolving population.
 In this example, a penetrance model is applied to a locus (locus 3).
 A Python operator is then used to draw a case-control sample from the populatio
n and test genetic association at two surrounding loci.
 Because these two loci are tightly linked to the disease predisposing locus,
 they are in strong association with the disease initially.
 However, because of recombination, such association decays with time at
 rates depending on their genetic distances to the disease predisposing
 locus.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statAssociation.log"
lstparams "caption={Genetic association tests},label={statAssociation}"

\end_inset


\end_layout

\begin_layout Subsection
population structure
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
structure
\family default
 measures the structure of a population using the following statistics:
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $G_{ST}$
\end_inset

 statistic developed by Nei 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Nei1973"

\end_inset

.
 This statistic is equivalent to Wright's fixation index 
\begin_inset Formula $F_{ST}$
\end_inset

 in the diallelic case so it can be considered as the multi-allele and multi-loc
us extension of Wright's 
\begin_inset Formula $F_{ST}$
\end_inset

.
 It assumes known genotype frequency so it can be used to calculate true
 
\begin_inset Formula $F_{ST}$
\end_inset

 of a population when all genotype information is available.
 This statistic sets a dictionary of locus level 
\begin_inset Formula $G_{ST}$
\end_inset

 (variable 
\family typewriter
g_st
\family default
) and a summary statistics for all loci (variable 
\family typewriter
G_st
\family default
).
\end_layout

\begin_layout Itemize
Wright's fixation index 
\begin_inset Formula $F_{ST}$
\end_inset

 calculated using an algorithm developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Weir1984"

\end_inset

.
 This statistic considers existing populations as random samples from an
 infinite pool of populations with the same ancestral population so it is
 best to be applied to random samples where true genotype frequencies are
 unknown.
 This statistic sets dictionaries of locus level 
\begin_inset Formula $F_{ST}$
\end_inset

, 
\begin_inset Formula $F_{IT}$
\end_inset

 and 
\begin_inset Formula $F_{IS}$
\end_inset

 (variables 
\family typewriter
f_st
\family default
, 
\family typewriter
f_is
\family default
 and 
\family typewriter
f_it
\family default
), and summary statistics for all loci (variables 
\family typewriter
F_st
\family default
, 
\family typewriter
F_is
\family default
 and 
\family typewriter
F_it
\family default
) .
 When hetergozygote count is unavailable (non-diploid population, loci on
 sex chromosomes and mitochondrial chromosomes), simuPOP uses expected heterozyg
osity to estimate this quantity.
\end_layout

\begin_layout Standard
These statistics by default uses all existing subpopulations, but it can
 also be applied to a subset of subpopulations, or even virtual subpopulations
 using parameter 
\emph on
subPops
\emph default
.
 That is to say, you can measure the genetic difference between males and
 females using 
\family typewriter
subPops=[(0,0), (0,1)]
\family default
 if a SexSplitter is used to define two virtual subpopulations with male
 and female individuals respectively.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statStructure"

\end_inset

 demonstrate a simulation with two replicates.
 In the first replicate, three subpopulations evolve separately without
 migration and become more and more genetically distinct.
 In the second replicate, a low level migration is applied between subpopulation
s so the population structure is kept at a low level.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statStructure.log"
lstparams "caption={Measure of population structure},label={statStructure}"

\end_inset


\end_layout

\begin_layout Subsection
Hardy-Weinberg equilibrium test
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
HWE
\family default
 accepts a list of loci at which exact Hardy Weinberg equilibrium tests
 are applied.
 The 
\emph on
p
\emph default
-values of the tests are assigned to a dictionary 
\family typewriter
HWE
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statHWE"

\end_inset

 demonstrates how Hardy Weinberg equilibrium is reached in one generation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statHWE.log"
lstparams "caption={Hardy Weinberg Equilibrium test},label={statHWE}"

\end_inset


\end_layout

\begin_layout Subsection
Measure of Inbreeding 
\end_layout

\begin_layout Standard
Inbreeding coefficient at a generation is defined as the probability that
 the two alleles in a given individual are identical by decent (IBD).
 Although it is usually very difficult to estimate this quantity, it is
 easy to observe it directly during evolution if the ancestors of alleles
 are tracked.
 This can be done using the lineage module of simuPOP where allelic lineage
 is tracked during evolution.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statIBD"

\end_inset

 output the frequency of IBD loci in a population of size 500.
 It also outputs the frequency of IBS (Identical by State), which should
 always be larger than IBD frequency, and theoretical estimate of the decay
 of inbreeding coefficient.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statIBD.log"
lstparams "caption={Frequency of IBD as a measure of inbreeding coefficient},label={statIBD}"

\end_inset


\end_layout

\begin_layout Subsection
Effective population size
\end_layout

\begin_layout Standard
Effective population size is an important, yet complicated concept in population
 genetics.
 Simply put, the effective population size is determined by a mating scheme,
 namely how parents are selected and how offsprings are generated.
 In the context of forward-time simulation, if we populate an offspring
 population from a parental population, a true effective population size
 can be calculated, under certain assumptions, as 
\begin_inset Formula 
\[
Ne=\frac{kN-1}{k-1+V_{k}/k}
\]

\end_inset

where 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $V_{k}$
\end_inset

 are the mean and variance of the number of gametes each parent  transmits
 to the offspring generation.
 Naturally, the number of sex chromosomes transmitted will be different
 for males and females.
 This effective size is independent of genotypes and is called the demographic
 effective size.
\end_layout

\begin_layout Standard
Because the calculation of demographic effective size needs to track which
 alleles are transmitted from parental to offspring population, it has to
 collect information from both parental and offspring populations, and can
 only be calculated using the lineage modules of simuPOP.
 As shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statNeDemographic"

\end_inset

, a 
\family typewriter
Stat
\family default
 operator is applied before mating to mark lineage of alleles of each locus
 with an individual index, and save the IDs of parents in a variable 
\family typewriter
Ne_demo_base
\family default
.
 After mating, another 
\family typewriter
Stat
\family default
 operator is used to count how many alleles each parent has contributed
 to the offspring generation, and calculate demographic effective size according
ly.
 This example uses three virtual subpopulations, a whole subpopulation,
 all male individuals, and all female individuals, and calculated effective
 size for loci on an autosome, an X chromosome, and a Y chromosome.
 As we can imagine, the effective size is 0 at the Y chromosome for all
 females, because no such chromsome is transmitted from the parental population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statNeDemographic.log"
lstparams "caption={Demographic effective population size},label={statNeDemographic}"

\end_inset


\end_layout

\begin_layout Standard
Effective population sizes could also be estimated from genotypes because
 changes of genotypes reflects properties of the mating scheme.
 However, it is important to realize that 
\series bold
\emph on
evolving a population for one generation is only one realization of many
 possible realizations of the same mating scheme
\series default
\emph default
 (effective size).
 If we consider the demographic effective size as the average effective
 size of all realizations, estimating effective size from genotypes will
 be inaccurate unless a large number of unlinked loci are used.
 The temporal methods essentially try to get better estimate by averaging
 such realizations across multiple generations, although the demographic
 effective size might vary due to change of population size.
\end_layout

\begin_layout Standard
simuPOP currently provides two temporal methods proposed by Waples (1989)
 and Jorde & Ryman's (2007).
 Because these methods estimate effective population size using changes
 of allele frequencies of samples at two generations, it is necessary to
 set a baseline generation before any temporal method could be applied.
\end_layout

\begin_layout Standard
The baseline information is saved to variable 
\family typewriter
Ne_temporal_base
\family default
 when this variable is specified in the 
\family typewriter
vars
\family default
 parameter of the 
\family typewriter
Stat
\family default
 operator.
 After the baseline is set, for example, at generation 0, if the operator
 
\family typewriter
Stat
\family default
 is applied at generations 0, 20, and 40, it will set variable 
\family typewriter
Ne_waples89_P1
\family default
, 
\family typewriter
Ne_waples89_P2 
\family default
(for Waples 1989) and 
\family typewriter
Ne_tempoFS_P1
\family default
, 
\family typewriter
Ne_tempoFS_P
\family default
2 (for Jorde & Ryman 2007, as implemented in a package 
\family typewriter
TempoFS
\family default
) as the census population size at generation 0, estimated effective population
 sizes between generation 0 and 20 at generation 20, and estimates between
 0 and 40 at generation 40.
 The variables are lists of three elements: the estimated Ne and lower and
 upper boundaries of the 95% confidence interval.
\end_layout

\begin_layout Standard
Sampling plan 1 assumes that samples are drawn with replacement at the first
 time point so that some of the individuals sampled in the first time period
 could have contributed genes to subsequent generations (see Nei and Tajima,
 1981 Genetics and other papers).
 simuPOP uses census population (or subpopulation if the statistics are
 calcuated for each subpopulations) size as 
\begin_inset Formula $N$
\end_inset

 and consider the sample being a subset of the population (or subpopulation),
 it should be applied to a virtual subpopulation (e.g.
 a subset of individuals defined by a 
\family typewriter
RangeSplitter
\family default
) of the whole population.
 Sample plan 2 treats the sample as a sample from an infinitely-sized population
, and should be applied to a population (sample) that is actually extracted
 from a larger population.
 Results under both assumptions are calculated and provided so you should
 choose the ones that match your sampling plan.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statNeTemporal"

\end_inset

 demonstrates how to calculate temporal effective population sizes at a
 20 generation interval during evolution, using a fixed baseline generation
 at generation 0.
 The statistics are estimated from genotypes at 50 unlinked loci from 500
 random samples from a population of size 2000.
 Instead of drawing random samples explicitly, this example defines a virtual
 subpopulation that consists of the first 500 individuals in the population.
 The Stat operator is applied at generations 0, 20, 40, ..., 100 to this virtual
 subpopulation, with the first output being the census size (of the sample).
 Because a standard Wright-Fisher random mating scheme is used, the true
 effective population size should be around 2000.
 It would be interesting to adjust this evolutionary process (with population
 expansion, with varying number of offspring etc) and the method of estimation
 (sample size, generations between estimates) to see how well this statistic
 estimate effective population size under different scenarios.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statNeTemporal.log"
lstparams "caption={Temporal effective population size using a fixed baseline sample},label={statNeTemporal}"

\end_inset


\end_layout

\begin_layout Standard
Instead of using a fixed baseline generation, it is also possible to reset
 baseline generation during evolution.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statNeInterval"

\end_inset

 demonstrates how to calculate temporal effective population sizes at a
 20 generation interval during evolution.
 This example sets variable 
\family typewriter
Ne_temporal_base
\family default
 with 
\family typewriter
Ne_waples89_P1
\family default
 whenever the Stat operator is applied.
 This effectively resets the baseline generation to the present generation
 at generations 0, 20, 40, etc, so baseline generations 0, 20, 40, ...
 are used at generations 20, 40, ....
 This example also demonstrates how to use the suffix parameter to apply
 the same statistics with different parameters.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statNeInterval.log"
lstparams "caption={Temporal effective population size between consecutive samples},label={statNeInterval}"

\end_inset


\end_layout

\begin_layout Standard
Linkage disequilibrium method is another popular method to estimate effective
 population size.
 Compared to temporal methods, it has the distinct advantage that it requires
 only one sample.
 simuPOP provides a method that is developed by Waples in his 2006 paper.
 To use this method, you will need to specify variable 
\family typewriter
Ne_LD
\family default
 for a random mating scheme, or 
\family typewriter
Ne_LD_mono
\family default
 for a monogamous mating scheme.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "statNeLD"

\end_inset

 demonstrates this usage.
 Note that because the LDNe mehod is sensitive to rare alleles (which can
 lead to inflated measure of LD), simuPOP provides estimates that ignores
 alleles with frequencies less than 0 (all alleles are kept), 0.01, 0.02 and
 0.05.
 The results are saved in variable 
\family typewriter
Ne_LD
\family default
 as a dictionary with keys 0, 0.01, 0.02, 0.05, and values as lists of estimated
 effective population sizes and their 95% confidence intervals.
 Because of the existence of many rare alleles, the example gives quite
 different estimates with and without rare alleles (using cutoff=0.02).
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statNeLD.log"
lstparams "caption={Effective population size estimated using a LD based method},label={statNeLD}"

\end_inset


\end_layout

\begin_layout Standard
simuPOP allows you to estimate effective population size using genotypes
 at selected loci from selected individuals.
 It is up to you, however, to decide when to apply the operator (pre- or
 post-mating), how to draw samples, and select the right method for your
 data.
 For example, the temporal methods assume discrete generations and no (or
 slight) selection, migration, and mutation.
 The LD method assumes that markers are selectively neutral and independent;
 population has discrete generations and is closed to immigration; and sampling
 is random.
 In addition, to keep the interface simple, simuPOP does not provide many
 options as dedicated programs do (e.g.
 TempoFS).
 Please export your samples in other formats (e.g.
 use operator 
\family typewriter
Export(format=
\begin_inset Quotes erd
\end_inset

GENEPOP
\begin_inset Quotes erd
\end_inset

)
\family default
 or function 
\family typewriter
export(pop, format=
\begin_inset Quotes erd
\end_inset

GENEPOP
\begin_inset Quotes erd
\end_inset

)
\family default
 from module 
\family typewriter
simuPOP.utiles
\family default
) and use these programs if you need such flexibilities.
\end_layout

\begin_layout Subsection
Other statistics
\end_layout

\begin_layout Standard
If you need other statistics, a popular approach is to define them using
 Python operators.
 If your statistics is based on existing statistics such as allele frequency,
 it is a good idea to calculate existing statistics using a 
\family typewriter
stat
\family default
 function and derive your statistics from population variables.
 Please refer to the last chapter of this guide on an example.
\end_layout

\begin_layout Standard
If you would like to calculate some summary statistics that involves individual
 information fields but cannot be calculated using parameters such as minOfInfo,
 you can try to use operators such as InfoExec to process individuals one
 by one and collect result.
 For example, you can use operators 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyExec('s=0')
\end_layout

\begin_layout Plain Layout

InfoExec('s+=x*x')
\end_layout

\begin_layout Plain Layout

PyEval('s')
\end_layout

\end_inset

 to calculate and report 
\begin_inset Formula $s=\sum x^{2}$
\end_inset

 where x is an information field during evolution.
 This makes use of the fact that operator 
\family typewriter
InfoExec
\family default
 goes through all individuals and evaluate the statement.
\end_layout

\begin_layout Standard
If performance becomes a problem, you might want to have a look at the source
 code of simuPOP and implement your statistics at the C++ level.
 If you believe that your statistics are popular enough, please send your
 implementation to the simuPOP mailinglist for possible inclusion of your
 statistics into simuPOP.
\end_layout

\begin_layout Subsection
Support for sex and customized chromosome types
\end_layout

\begin_layout Standard
simuPOP supports statistics calculation for loci on sex chromosomes.
 For example, when pair-wise difference between haplotypes is calculated
 using parameter 
\family typewriter
neutrality
\family default
, it will pick the right haplotypes for X, and Y chromosomes.
 However, because neutrality is calculated based on a group of haplotypes
 of all specified loci, even if the loci are collected across chromosomes,
 you can not use operator 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(neutrality=ALL_AVAIL)
\end_layout

\end_inset

if the loci are selected from chromosomes of different types, because different
 numbers of haplotypes exists on these chromosomes.
 To calculate 
\family typewriter
Pi
\family default
 for these chromosomes, you would have to calculate them separately, using
 operators such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(neutrality=range(30,40), suffix='_X')
\end_layout

\begin_layout Plain Layout

Stat(neutrality=range(40,50), suffix='_Y')
\end_layout

\end_inset

so that all specified loci are on the same type of chromosomes.
 Here we use parameter 
\family typewriter
suffix
\family default
 to avoid conflict of variable names because both operator would produce
 the same variable 
\family typewriter
Pi
\family default
 without this parameter.
\end_layout

\begin_layout Standard
The case with customized chromosomes are more complex because the meaning
 of these chromosomes are defined by users.
 If these chromosomes are mitochondrial DNAs, only chromosomes from the
 females are carrying useful information.
 If you would like to calculate, for example, the 
\family typewriter
Pi
\family default
 statistics for these chromosomes, you will have to explicitly selected
 females for calculation.
 This can be done by operator
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(neutrality=range(50,60), vsps=[(ALL_AVAIL, 'FEMALE')], suffix='_mt')
\end_layout

\end_inset

if VSPs have been created by a 
\family typewriter
SexSplitter
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "statChromTypes"

\end_inset

 demonstrates the use of these operators.
 This example intentionally initializes all individuals with the same haplotypes
 on all chromosomes (the 
\family typewriter
InitGenotype
\family default
 operator ignores chromosome types).
 Because of different chromosome types, four 
\family typewriter
Stat
\family default
 operators are used to get the 
\family typewriter
Pi
\family default
 statistics for them.
 These operators return different results because different sets of haplotypes
 are picked for the calculation of this statistics.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/statChromTypes.log"
lstparams "caption={Statistics for sex and customized chromosome types},label={statChromTypes}"

\end_inset


\end_layout

\begin_layout Section
Conditional operators
\end_layout

\begin_layout Subsection
Conditional operator (operator 
\family typewriter
IfElse
\family default
) *
\end_layout

\begin_layout Standard
Operator 
\family typewriter
IfElse
\family default
 provides a simple way to conditionally apply an operator.
 The condition can be a fixed condition, a expression (a string) that will
 be evaluated in a population's local namespace or a user-defined function
 when it is applied to the population.
\end_layout

\begin_layout Standard
The first case is used to control the execution of certain operators depending
 on user input.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "IfElseFixed"

\end_inset

 determines whether or not some outputs should be given depending on a variable
 
\family typewriter
verbose
\family default
.
 Note that the applicability of the conditional operators are determined
 by the 
\family typewriter
IfElse
\family default
 operator and individual opearators.
 That is to say, the parameters 
\family typewriter
begin
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
at
\family default
, and 
\family typewriter
reps
\family default
 of operators in 
\family typewriter
ifOps
\family default
 and 
\family typewriter
elseOps
\family default
 are only honored when operator 
\family typewriter
IfElse
\family default
 is applied.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/IfElseFixed.log"
lstparams "caption={A conditional opeartor with fixed condition},label={IfElseFixed}"

\end_inset


\end_layout

\begin_layout Standard
When a string is specified, it will be considered as an expression and be
 evaluated in a population's namespace.
 The return value will be used to determine if an operator should be executed.
 For example, you can re-introduce a mutant if it gets lost in the population,
 output a warning when certain condition is met, or record the occurance
 of certain events in a population.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "IfElse"

\end_inset

 records the number of generations the frequency of an allele goes below
 0.4 and beyong 0.6 before it gets lost or fixed in the population.
 Note that a list of else-operators can also be executed when the condition
 is not met.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/IfElse.log"
lstparams "caption={A conditional opeartor with dynamic condition},label={IfElse}"

\end_inset


\end_layout

\begin_layout Standard
In the last case, a user-defined function can be specified.
 This function should accept parameter 
\family typewriter
pop
\family default
 when the operator is applied to a population, and one or more parameters
 
\family typewriter
pop
\family default
, 
\family typewriter
off
\family default
, 
\family typewriter
dad
\family default
 and 
\family typewriter
mom
\family default
 when it is applied during-mating.
 The later could be used to apply different during-mating operators for
 different types of parents or offspring.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pedigreeMatingAgeStructured"

\end_inset

 in Chapter 6 uses a 
\family typewriter
CloneGenoTransmitter
\family default
 when only one parent is available (when parameter 
\family typewriter
mom
\family default
 is 
\family typewriter
None
\family default
), and a 
\family typewriter
MendelianGenoTransmitter
\family default
 when two parents are available.
\end_layout

\begin_layout Subsection
Conditionally terminate an evolutionary process (operator 
\family typewriter
TerminateIf
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
TerminateIf
\family default
 has been described and used in several examples such as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simuGen"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "expression"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "IfElse"

\end_inset

.
 This operator accept an Python expression and terminate the evolution of
 the population being applied if the expression is evaluated to be 
\family typewriter
True
\family default
.
 This operator is well suited for situations where the number of generations
 to evolve cannot be determined in advance.
\end_layout

\begin_layout Standard
If a 
\family typewriter
TerminateIf
\family default
 operator is applied to the offspring generation, the evolutionary cycle
 is considered to be completed.
 If the evolution is terminated before mating, the evolutionary cycle is
 condered to be incomplete.
 Such a difference can be important if the number of generations that have
 been involved is important for your analysis.
\end_layout

\begin_layout Standard
A less-known feature of operator 
\family typewriter
TerminateIf
\family default
 is its ability to terminate the evolution of all replicates, using parameter
 
\family typewriter
stopAll=True
\family default
.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "TerminateIf"

\end_inset

 terminates the evolution of all populations when one of the populations
 gets fixed.
 The return value of 
\family typewriter
simu.evolve
\family default
 shows that some populations have evolved one generation less than the populatio
n being fixed.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/TerminateIf.log"
lstparams "caption={Terminate the evolution of all populations in a simulator},label={TerminateIf}"

\end_inset


\end_layout

\begin_layout Subsection
Conditionally revert or forward an evolutionary process to a saved state
 (operator 
\family typewriter
RevertIf
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
RevertIf
\family default
 is a very interesting operator.
 It accepts a condition and a saved population (
\family typewriter
.pop
\family default
 file) and will revert the current evolving population to the saved population
 if the condition is met.
 There are at least two secenarios for which this operator can be very useful.
\end_layout

\begin_layout Standard
One of the biggest problem with introducing a disease allele to an evolving
 population (using an operator PointMutate) is that the disease allele will
 very likely get lost because of genetic drift.
 It is possible to simulate the allele frequency trajectory backward in
 time and follow the trajectory during the forward-time simulation phase
 (
\family typewriter
simuPOP.utils.simulateBackwardTrajectory
\family default
, 
\family typewriter
simuPOP.utils.simulateForwardTrajectory
\family default
, and a 
\family typewriter
ControlledRandomMating
\family default
 mating scheme with a 
\family typewriter
ControlledOffspringGenerator
\family default
).
 However, that method is applicable only to evolutionary processes with
 a small number of loci under selection, and has a number of limitations
 (e.g.
 unlinked disease predisposing loci).
\end_layout

\begin_layout Standard
A natural way to simulate the introduction of disease alleles is therefore
 to terminate and restart the simulation whenever the disease allele gets
 lost.
 This could be done by splitting the evolutionary process into two stages.
 The disease allele is introduced at the second stage and the simulation
 will be terminated as soon as the introduced allele is lost (using a 
\family typewriter
TerminateIf
\family default
 operator).
 The second stage would be repeated until the simulation succeeds.
 Alternatively, you can save the population before the introduction of the
 disease allele, and revert to the saved population when the introduced
 allele gets lost.
 The latter can be done using operator 
\family typewriter
RevertIf
\family default
.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "RevertToSaved"

\end_inset

 shows an example of such an evolutionary process.
 This example saves an evolving population at the beginning of generation
 4 and introduces a disease allele to the population.
 Starting from the fifth generation, a RevertIf opeartor checks if the disease
 allele still exists in the population, and revert to the saved population
 if the allele has been lost.
 When you read the example, it is important to remind yourself that after
 the 
\family typewriter
RevertIf
\family default
 operator is triggered and applied, the population is at generation 4 before
 the disease allele is introduced, This is why the 
\family typewriter
SavePopulation
\family default
 and 
\family typewriter
RevertIf
\family default
 operators are usually put together.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/RevertToSaved.log"
lstparams "caption={Revert an evolutionary process to a previous saved state when an introduced allele is lost},label={RevertToSaved}"

\end_inset


\end_layout

\begin_layout Standard
The second application is to skip certain part of the evolutionary process
 if it has been executed before.
 For example, many forward-time simulation scenarios have a long burn-in
 process.
 It you simulate several replicates of the evolutionary process, you can
 save the burned in initial population of the first replicate, and reuse
 it for subsequent simulations.
 In Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ReuseBurnin"

\end_inset

, we save the population at generation 10 for the first replicate.
 The next few replicates would load the saved file and jump directly to
 generation 10.
 Note that although the 
\family typewriter
RevertIf
\family default
 is applied at generation 0, it cannot be put in parameter 
\family typewriter
initOps
\family default
 because it otherwise evolve another 20 generations from generation 10.
 However, combining the 
\family typewriter
RevertIf
\family default
 operator with complex demographic models can have unexpected results.
 As shown in the second part of the example, because the demographic model
 starts from the generation when the model is first called (intialized),
 the evolutionary model will evolve from generation 10 to 30.
 The problem can be avoided by calling 
\family typewriter
RevertIf
\family default
 at the second generation where the demographic model is already initialized
 at generation 0.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ReuseBurnIn.log"
lstparams "caption={Jump to the middle of an evolutionary process by uing a previously saved population.},label={ReuseBurnin}"

\end_inset


\end_layout

\begin_layout Subsection
Conditional during mating operator (operator 
\family typewriter
DiscardIf
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
DiscardIf
\family default
 accepts a condition or a Python function.
 When it is applied during mating, it will evaluate the condition or call
 the function for each offspring, and discard the offspring if the return
 value of the expression or function is True.
 The python expression accepts information fields as variables so operator
 
\family typewriter
DiscardIf('age > 80')
\family default
 will discard all individuals with age > 80.
 Optionally, the offspring itself can be used in the expression if parameter
 exposeInd is used to set the variable name of the offspring.
 
\end_layout

\begin_layout Standard
Alternatively, a Python function can be passed to this operator.
 This function should be defined with parameters 
\family typewriter
pop
\family default
, 
\family typewriter
off
\family default
, 
\family typewriter
mom
\family default
, 
\family typewriter
dad
\family default
 or names of information fields.
 For example, 
\family typewriter
DiscardIf(lambda age: age > 80)
\family default
 will remove individuals with age > 80.
\end_layout

\begin_layout Standard
A constant expression is also allowed in this operator.
 Although it does not make sense to use 
\family typewriter
DiscardIf(True)
\family default
 because all offspring will be discarded, it is quite useful to use this
 operator in the context of 
\family typewriter
DiscardIf(True, subPops=[(0, 0)])
\family default
 to remove all individuals in a virtual subpopulation.
 If virtual subpopulation 
\family typewriter
(0, 0)
\family default
 is defined as all individuals with age > 80, the last method achieves the
 same effect as the first two methods.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "DiscardIf"

\end_inset

 demonstrates an interesting application of this operator.
 This example evolves a population for one generation.
 Instead of keeping all offspring, it keeps only 500 affected and 500 unaffected
 offspring.
 This is achieved by defining virtual subpopulations by affection status
 and range, and discard the first 500 offspring if they are unaffected,
 and the last 500 offspring if they are affected.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/DiscardIf.log"
lstparams "caption={Use operator DiscardIf to generate case control samples},label={DiscardIf}"

\end_inset


\end_layout

\begin_layout Section
Miscellaneous operators
\end_layout

\begin_layout Subsection
An operator that does nothing (operator 
\family typewriter
NoneOp
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
NoneOp
\family default
 does nothing when it is applied to a population.
 It provides a placeholder when an operator is needed but no action is required.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "NoneOp"

\end_inset

 demonstrates a typical usage of this operator
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "NoneOp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if hasSelection:
\end_layout

\begin_layout Plain Layout

    sel = MapSelector(loci=[0], fitness=[1, 0.99, 0.98])
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    sel = NoneOp()
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    preOps=[sel], # and other operators
\end_layout

\begin_layout Plain Layout

    matingScheme=RandomMating(),
\end_layout

\begin_layout Plain Layout

    gen=10
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
dump the content of a population (operator 
\family typewriter
Dumper
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
Dumper
\family default
 and its function form 
\family typewriter
dump
\family default
 has been used extensively in this guide.
 They are prefect for demonstration and debugging purposes because they
 display all properties of a population in a human readable format.
 They are, however, rarely used in realistic settings because outputting
 a large population to your terminal can be disastrous.
\end_layout

\begin_layout Standard
Even with modestly-sized populations, it is a good idea to dump only parts
 of the population that you are interested.
 For example, you can use parameter 
\family typewriter
genotype=False
\family default
 to stop outputting individual genotype, 
\family typewriter
structure=False
\family default
 to stop outtputing genotypic and population structure information, 
\family typewriter
loci=range(5)
\family default
 to output genotype only at the first five loci, 
\family typewriter
max=N
\family default
 to output only the first 
\family typewriter
N
\family default
 individuals (default to 
\family typewriter
100
\family default
), 
\family typewriter
subPops=[(0, 0)]
\family default
 to output, for example, only the first virtual subpopulation in subpopulation
 0.
 Multiple virtual subpopulations are allowed and you can even use 
\family typewriter
subPops=[(ALL_AVAIL, 0)]
\family default
 to go through a specific virtual subpopulation of all subpopulations.
 This operator by default only dump the present generation but you can set
 
\family typewriter
ancGens
\family default
 to a list of generation numbers or 
\family typewriter
ALL_AVAIL
\family default
 to dump part or all ancestral generations.
 Finally, if there are more than 10 alleles, you can set the 
\family typewriter
width
\family default
 at which each allele will be printed.
 The following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "Dumper"

\end_inset

) presents a rather complicated usage of this operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/Dumper.log"
lstparams "caption={dump the content of a population},label={Dumper}"

\end_inset


\end_layout

\begin_layout Subsection
Save a population during evolution (operator 
\family typewriter
SavePopulation
\family default
)
\end_layout

\begin_layout Standard
Because it is usually not feasible to store all parental generations of
 an evolving population, it is a common practise to save snapshots of a
 population during an evolutionary process for further analysis.
 Operator 
\family typewriter
SavePopulation
\family default
 is designed for this purpose.
 When it is applied to a population, it will save the population to a file
 specified by parameter 
\family typewriter
output
\family default
.
\end_layout

\begin_layout Standard
The tricky part is that populations at different generations need to be
 saved to different filenames so the expression version of parameter 
\family typewriter
output
\family default
 needs to be used (see operator 
\family typewriter
BaseOperator
\family default
 for details).
 For example, expression 
\family typewriter
'snapshot_%d_%d.pop' % (rep, gen)
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "SavePopulation"

\end_inset

 to save population to files such as 
\family typewriter
snapshot_5_20.pop
\family default
 during the evolution.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/SavePopulation.log"
lstparams "caption={Save snapshots of an evolving population},label={SavePopulation}"

\end_inset


\end_layout

\begin_layout Subsection
Pause and resume an evolutionary process (operator 
\family typewriter
Pause
\family default
) *
\end_layout

\begin_layout Standard
If you are presenting an evolutinary process in public, you might want to
 temporarily stop the evolution so that your audience can have a better
 look at intermediate results or figures.
 If you have an exceptionally long evolutionary process, you might want
 to examine the status of the evolution process from time to time.
 These can be done using a 
\family typewriter
Pause
\family default
 operator.
\end_layout

\begin_layout Standard
The 
\family typewriter
Pause
\family default
 operator can stop the evolution at specified generations, or when you press
 a key.
 In the first case, you usually specify the generations to Pause (e.g.
 
\family typewriter
Pause(step=1000)
\family default
) so that you can examine the status of a simulation from time to time.
 In the second case, you can apply the operator at each generation and Pause
 the simulation when you press a key (e.g.
 
\family typewriter
Pause(stopOnKeyStroke=True)
\family default
).
 A specific key can be specified so that you can use different keys to stop
 different populations, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pause"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/Pause.log"
lstparams "caption={Pause the evolution of a simulation},label={Pause}"

\end_inset


\end_layout

\begin_layout Standard
When a simulation is Paused, you are given the options to resume evolution,
 stop the evolution of the Paused population or all populations, or enter
 an interactive Python shell to examine the status of a population, which
 will be available in the Python shell as 
\family typewriter
pop_X_Y
\family default
 where 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 are generation and replicate number of the population, respectively.
 The evolution will resume after you exit the Python shell.
\end_layout

\begin_layout Subsection
Measuring execution time of operators (operator 
\family typewriter
TicToc
\family default
) *
\end_layout

\begin_layout Standard
The 
\family typewriter
TicToc
\family default
 operator can be used to measure the time between two events during an evolution
ary process.
 It outputs the elapsed time since the last time it is called, and the overall
 time since the operator is created.
 It is very flexible in that you can measure the time spent for mating in
 an evolutionary cycle if you apply it before and after mating, and you
 can measure time spent for several evolutionary cycles using generation
 applicability parameters such as 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
.
 The latter usage is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "TicToc"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/TicToc.log"
lstparams "caption={Monitor the performance of operators},label={TicToc}"

\end_inset


\end_layout

\begin_layout Section
Hybrid and Python operators
\end_layout

\begin_layout Subsection
Hybrid operators
\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a 
\emph on
hybrid operator
\emph default
.
\end_layout

\begin_layout Standard
A 
\emph on
hybrid operator
\emph default
 is an operator that calls a user-defined function when its applied to a
 population.
 The number and meaning of input parameters and return values vary from
 operator to operator.
 For example, a hybrid mutator sends a to-be-mutated allele to a user-defined
 function and use its return value as a mutant allele.
 A hybrid selector uses the return value of a user defined function as individua
l fitness.
 Such an operator handles the routine part of the work (e.g.
 scan through a chromosome and determine which allele needs to be mutated),
 and leave the creative part to users.
 Such a mutator can be used to implement complicated genetic models such
 as an asymmetric stepwise mutation model for microsatellite markers.
\end_layout

\begin_layout Standard

\series bold
simuPOP operators use parameter names to determine which information should
 be passed to a user-defined function
\series default
.
 For example, a hybrid quantitative trait operator recognizes parameters
 
\family typewriter
ind
\family default
, 
\family typewriter
geno
\family default
, 
\family typewriter
gen
\family default
 and names of information fields such as 
\family typewriter
smoking
\family default
.
 If your model depends on genotype, you could provide a function with parameter
 geno (e.g.
 
\family typewriter
func(geno)
\family default
); if your model depends on smoking and genotype, you could provide a function
 with parameters geno and smoking (e.g.
 
\family typewriter
func(geno, smoking)
\family default
); if you model depends on individual sex, you can use a function that passes
 the whole individual (e.g.
 
\family typewriter
func(ind)
\family default
) so that you could check individual sex.
 When a hybrid operator is applied to a population, it will check the parameter
 names of provided Python function and send requested information automatically.
\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybridOperator"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset CommandInset citation
LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (parameter 
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability that this individual will become
 affected.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/hybrid.log"
lstparams "caption={Use a hybrid operator},keywordstyle={\\ttfamily},label={hybridOperator}"

\end_inset


\end_layout

\begin_layout Subsection
Python operator 
\family typewriter
PyOperator
\family default
 *
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can always resort
 to a pure-Python operator 
\family typewriter
PyOperator
\family default
.
 This operator has full access to the evolving population (or parents and
 offspring when aplied during-mating), and can therefore perform arbitrary
 operations.
\end_layout

\begin_layout Standard
A 
\family typewriter
PyOperator
\family default
 that is applied pre- or post- mating expects a function with one or both
 parameters 
\family typewriter
pop
\family default
 and 
\family typewriter
param
\family default
, where
\family typewriter
 pop
\family default
 is the population being applied, and 
\family typewriter
param
\family default
 is optional, depending on whether or not a parameter is passed to the 
\family typewriter
PyOperator()
\family default
 constructor.
 Function 
\family typewriter
func
\family default
 can perform arbitrary action to 
\family typewriter
pop
\family default
 and must return 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
.
 
\series bold
The evolution of pop will be stopped if this function returns False.

\series default
 This is essentially how operator 
\family typewriter
TerminateIf
\family default
 works.
 Alternatively, this callback function can accept 
\family typewriter
ind
\family default
 as one of the parameters.
 In this case, the function will be called for all individuals or individuals
 in specified (virtual) subpopulations.
 
\series bold
Individuals will be removed from the populaton if this function returns
 False
\series default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyOperator"

\end_inset

 defines such a function.
 It accepts a cutoff value and two mutation rates as parameters.
 It then calculate the frequency of allele 1 at each locus and apply a two-allel
e model at high mutation rate if the frequency is lower than the cutoff
 and a low mutation rate otherwise.
 The 
\family typewriter
kAlleleMutate
\family default
 function is the function form of a mutator 
\family typewriter
KAlleleMutator
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Function-form"

\end_inset

 for details).
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyOperator.py"
lstparams "caption={A frequency dependent mutation operator},label={PyOperator},lastline=15"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "usePyOperator"

\end_inset

 demonstrates how to use this operator.
 It first initializes the population using two 
\family typewriter
InitGenotype
\family default
 operators that initialize loci with different allele frequencies.
 It applies a 
\family typewriter
PyOperator 
\family default
with function 
\family typewriter
dynaMutator
\family default
 and a tuple of parameters.
 Allele frequencies at all loci are printed at generation 
\family typewriter
0
\family default
, 
\family typewriter
10
\family default
, 
\family typewriter
20
\family default
, and 
\family typewriter
30
\family default
.
 Note that this 
\family typewriter
PyOperator
\family default
 is applied at to the parental generation so allele frequencies have to
 be recalculated to be used by post-mating operator 
\family typewriter
PyEval
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyOperator.log"
lstparams "caption={Use a PyOperator during evolution},firstline=17,label={usePyOperator}"

\end_inset


\end_layout

\begin_layout Subsection
During-mating Python operator *
\end_layout

\begin_layout Standard
A 
\family typewriter
PyOperator
\family default
 can also be applied during-mating.
 They can be used to filter out unwanted offspring (by returning 
\family typewriter
False
\family default
 in a user-defined function), modify offspring, calculate statistics, or
 pass additional information from parents to offspring.
 Depending the names of parameters of your function, the Python operator
 will pass offspring (parameter 
\family typewriter
off
\family default
), his or her parents (parameter 
\family typewriter
dad
\family default
 and 
\family typewriter
mom
\family default
), the whole population (parameter 
\family typewriter
pop
\family default
) and an optional parameter (parameter 
\family typewriter
param
\family default
) to this function.
 For example, function 
\family typewriter
func(off)
\family default
 will accept references to an offspring, and 
\family typewriter
func(off, mom, dad)
\family default
 will accept references to both offspring and his or her parents.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "duringMatingPyOperator"

\end_inset

 demonstrates the use of a during-mating Python operator.
 This operator rejects an offspring if it has allele 1 at the first locus
 of the first homologous chromosome, and results in an offspring population
 without such individuals.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyDuringMatingOperator.log"
lstparams "caption={Use a during-mating PyOperator},label={duringMatingPyOperator}"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
PyOperator
\family default
 is the most powerful operator in simuPOP and has been widely used, for
 example, to calculate statistics and is not supported by the 
\family typewriter
Stat()
\family default
 operator, to examine population property during evolution, or prepare populatio
ns for a special mating scheme.
 However, because 
\family typewriter
PyOperator 
\family default
works in the Python interpreter, it is expected that it runs slower than
 operators that are implemented at the C/C++ level.
 If performance becomes an issue, you can re-implement part or all the operator
 in C++.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Using-C++"

\end_inset

 describes how to do this.
\end_layout

\begin_layout Subsection
Define your own operators *
\end_layout

\begin_layout Standard

\family typewriter
PyOperator
\family default
 is a Python class so you can derive your own operator from this operator.
 The tricky part is that the constructor of the derived operator needs to
 call the 
\family typewriter
__init__
\family default
 function of 
\family typewriter
PyOperator
\family default
 will proper functions.
 This technique has been used by simuPOP in a number of occasions.
 For example, the 
\family typewriter
VarPlotter
\family default
 operator defined in 
\family typewriter
plotter.py
\family default
 is derived from 
\family typewriter
PyOperator
\family default
.
 This class encapsulates several different plot class that uses 
\family typewriter
rpy
\family default
 to plot python expressions.
 One of the plotters is passed to the func parameter of 
\family typewriter
PyOperator.__init__
\family default
 so that it can be called when this operator is applied.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 rewrites the 
\family typewriter
dynaMutator
\family default
 defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyOperator"

\end_inset

 into a derived operator.
 The parameters are now passed to the constructor of 
\family typewriter
dynaMutator
\family default
 and are saved as member variables.
 A member function 
\family typewriter
mutate
\family default
 is defined and is passed to the constructor of 
\family typewriter
PyOperator
\family default
.
 Other than making 
\family typewriter
dynaMutator
\family default
 look like a real simuPOP operator, this example does not show a lot of
 advantage over defining a function.
 However, when the operator gets complicated (as in the case for 
\family typewriter
VarPlotter
\family default
), the object oriented implementation will prevail.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/newOperator.log"
lstparams "caption={Define a new Python operator},label={newOperator}"

\end_inset


\end_layout

\begin_layout Standard
New during-mating operators can be defined similarly.
 They are usually used to define customized genotype transmitters.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Customized-genotype-transmitter"

\end_inset

 will describe this feature in detail.
\end_layout

\begin_layout Chapter
Evolving populations
\end_layout

\begin_layout Section
Mating Schemes
\begin_inset CommandInset label
LatexCommand label
name "sec:Mating-Schemes"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mating schemes are responsible for populating an offspring generation from
 the parental generation.
 There are currently two types of mating schemes
\end_layout

\begin_layout Itemize
A 
\series bold
homogeneous mating scheme
\series default
 is the most flexible and most frequently used mating scheme and is the
 center topic of this section.
 A homogeneous mating is composed of a 
\emph on
parent chooser
\emph default
 that is responsible for choosing parent(s) from a (virtual) subpopulation
 and an 
\emph on
offspring generator
\emph default
 that is used to populate all or part of the offspring generation.
 During-mating operators are used to transmit genotypes from parents to
 offspring.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:homogeneous-mating-scheme"

\end_inset

 demonstrates this process.
\end_layout

\begin_layout Itemize
A 
\series bold
heterogeneous mating scheme
\series default
 applies several homogeneous mating scheme to different (virtual) subpopulations.
 Because the division of virtual subpopulations can be arbitrary, this mating
 scheme can be used to simulate mating in heterogeneous populations such
 as populations with age structure.
\end_layout

\begin_layout Itemize
A 
\series bold
pedigree mating scheme
\series default
 evolves a population by following the pedigree structure of a pedigree.
 This mating scheme is used to a replay a recorded or manually created evolution
ary process.
 
\end_layout

\begin_layout Standard
This section describes some standard features of mating schemes and most
 pre-defined mating schemes.
 The next section will demonstrate how to build complex nonrandom mating
 schemes from scratch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:homogeneous-mating-scheme"

\end_inset

A homogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/HomoMatingScheme.png
	lyxscale 20
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
A homogeneous mating scheme is responsible to choose parent(s) from a subpopulat
ion or a virtual subpopulation, and population part or all of the corresponding
 offspring subpopulation.
 A parent chooser is used to choose one or two parents from the parental
 generation, and pass it to an offspring generator, which produces one or
 more offspring.
 During mating operators such as taggers and Recombinator can be applied
 when offspring is generated.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Control the size of the offspring generation
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-size"

\end_inset


\end_layout

\begin_layout Standard
A mating scheme goes through each subpopulation and populates the subpopulations
 of an offspring generation sequentially.
 The number of offspring in each subpopulation is determined by the mating
 scheme, following the following rules:
\end_layout

\begin_layout Itemize
A simuPOP mating scheme, by default, produces an offspring generation that
 has the same subpopulation sizes as the parental generation.
 This does not guarantee a constant population size because some operators,
 such as a 
\family typewriter
Migrator
\family default
 and 
\family typewriter
DiscardIf
\family default
 can change population or subpopulation sizes.
\end_layout

\begin_layout Itemize
If fixed subpopulation sizes are given to parameter 
\family typewriter
subPopSize
\family default
.
 A mating scheme will generate an offspring generation with specified sizes
 even if an operator has changed parental population sizes.
\end_layout

\begin_layout Itemize
A 
\series bold
demographic function
\series default
 can be specified to parameter 
\family typewriter
subPopSize
\family default
.
 This function should take one of the two forms 
\family typewriter
func(gen)
\family default
 or 
\family typewriter
func(gen, pop)
\family default
 where 
\family typewriter
gen
\family default
 is the current generation number and 
\family typewriter
pop
\family default
 is the parental population just before mating.
 This function should return an array of new subpopulation sizes.
 A single number can be returned if there is only one subpopulation.
 The 
\family typewriter
simuPOP.demography
\family default
 module provides a number of demography-related functions for complex evolutiona
ry secenarios.
 
\series bold
Please consider contributing to this module if you have implemented demographic
 models for particular populations.
\end_layout

\begin_layout Standard
The following examples demonstrate these cases.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrSize"

\end_inset

 uses a default 
\family typewriter
RandomMating()
\family default
 scheme that keeps parental subpopulation sizes.
 Because migration between two subpopulations are asymmetric, the size of
 the first subpopulation increases at each generation, although the overall
 population size keeps constant.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrSize.log"
lstparams "caption={Free change of subpopulation sizes},label={migrSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "migrFixedSize"

\end_inset

 uses the same Migrator to move individuals between two subpopulations.
 Because a constant subpopulation size is specified, the offspring generation
 always has 500 and 1000 individuals in its two subpopulations.
 Note that operators 
\family typewriter
Stat
\family default
 and 
\family typewriter
PyEval
\family default
 are applied both before and after mating.
 It is clear that subpopulation sizes changes before mating as a result
 of migration, although the pre-mating population sizes vary because of
 uncertainties of migration.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/migrFixedSize.log"
lstparams "caption={Force constant subpopulation sizes},label={migrFixedSize}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "demoFunc"

\end_inset

 uses a demographic function to control the subpopulation size of the offspring
 generation.
 This example implements a linear population expansion model but arbitrarily
 complex demographic model can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoFunc.log"
lstparams "caption={Use a demographic function to control population size},label={demoFunc}"

\end_inset


\end_layout

\begin_layout Standard
If the size of the offspring generation can not be determined directly from
 generation number, you can pass the parental population as parameter 
\family typewriter
pop
\family default
 to the demographic function.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "demoFunc1"

\end_inset

 implements a demographic model where a population expand at random numbers
 at each generation.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoFunc1.log"
lstparams "caption={Use parental population to determine the size of offspring population},label={demoFunc1}"

\end_inset


\end_layout

\begin_layout Standard
In all the above examples, migration and demographic changes are introduced
 manually to influence the evolution of populations.
 However, the demographic changes might be driven by other factors such
 as natural selection so that it is difficult to predict the size of offspring
 generations in advance.
 In this case, you can manually remove individuals from parental (or offspring)
 populations using appropriate operators.
\end_layout

\begin_layout Standard
For example, a population in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "demoBySelection"

\end_inset

 suffers from a sudden reduction of population size (due to perhaps a famine)
 at generation 3, and a gradual reduction of population size (due to perhaps
 an outburst of an infectious disease) after generation 5.
 The first event is implemented using a 
\family typewriter
ResizeSubPops
\family default
 operator that directly shrink the population size in half.
 The second event is implemented using a 
\family typewriter
MaPenetrance
\family default
 and a 
\family typewriter
DiscardIf
\family default
 operator.
 The first operator assigns affection status of each individual using a
 disease model that involves individual genotype.
 The second operator discard all individuals that are affected with the
 disease.
 Despite of these unfortunate events, the population tries to expand exponential
ly with offspring population sizes set to 105% of their parental populations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoBySelection.log"
lstparams "caption={Change of  population size caused by natural selection},label={demoBySelection}"

\end_inset


\end_layout

\begin_layout Subsection
Advanced use of demographic functions 
\begin_inset CommandInset label
LatexCommand label
name "sub:Advanced-demo-func"

\end_inset

*
\end_layout

\begin_layout Standard
The parental population passed to a demographic function is usually used
 to determine offspring population size from parental population size.
 However, because this function is called immediately before mating happens,
 it provides a good opportunity for you to prepare the parental generation
 for mating.
 Such activities could generally be done by operators, but operations related
 to demographic changes could be done here.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "advancedDemoFunc"

\end_inset

 uses a demographic function to split populations at certain generation.
 The advantage of this method over the use of a 
\family typewriter
SplitSubPops
\family default
 operator (for example as in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitByProp"

\end_inset

) is that all demographic information presents in the same function so you
 do not have to worry about changing an operator when your demographic model
 changes.
  
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/advancedDemoFunc.log"
lstparams "caption={Use a demographic function to split parental population},label={advancedDemoFunc}"

\end_inset


\end_layout

\begin_layout Subsection
Determine the number of offspring during mating
\begin_inset CommandInset label
LatexCommand label
name "sub:number-of-offspring"

\end_inset


\end_layout

\begin_layout Standard
simuPOP by default produces only one offspring per mating event.
 Because more parents are involved in the production of offspring, this
 setting leads to larger effective population sizes than mating schemes
 that produce more offspring at each mating event.
 However, various situations require a larger family size or even varying
 family sizes.
 In these cases, parameter 
\family typewriter
numOffspring
\family default
 can be used to control the number of offspring that are produced at each
 mating event.
 This parameter takes the following types of inputs
\end_layout

\begin_layout Itemize
If a single number is given, 
\family typewriter
numOffspring
\family default
 offspring are produced at each mating event.
\end_layout

\begin_layout Itemize
If a Python function is given, this function will be called each time when
 a mating event happens.
 Generation number can be passed to this function as parameter 
\family typewriter
gen
\family default
 to allow different numbers of offspring at different generations.
 A python generator function can also be passed to provide an iterator interface
 to yield number of offspring for all mating events.
\end_layout

\begin_layout Itemize
If a tuple (or list) with more than one numbers is given, the first number
 must be one of 
\family typewriter
GEOMETRIC_DISTRIBUTION
\family default
, 
\family typewriter
POISSON_DISTRIBUTION
\family default
, 
\family typewriter
BINOMIAL_DISTRIBUTION
\family default
 and 
\family typewriter
UNIFORM_DISTRIBUTION
\family default
, with one or two additional parameters.
 
\end_layout

\begin_layout Standard
The number of offspring in the last case will then follow a specific statistical
 distribution.
 More specifically, 
\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(GEOMETRIC_DISTRIBUTION, p)
\family default
: The number of offspring for each mating event follows a geometric distribution
 with mean 
\begin_inset Formula $1/p$
\end_inset

 and variance 
\begin_inset Formula $\left(1-p\right)/p^{2}$
\end_inset

: 
\begin_inset Formula 
\[
\mbox{Pr}\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1
\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(POISSON_DISTRIBUTION, p)
\family default
: The number of offspring for each mating event follows a Poisson distribution
 with mean 
\begin_inset Formula $p$
\end_inset

 and variance 
\begin_inset Formula $p$
\end_inset

.
 The distribution is
\begin_inset Formula 
\[
\mbox{Pr}\left(k\right)=\frac{p^{k}e^{-p}}{k!}\;\textrm{ for }k\geq0
\]

\end_inset

Note that, however, because families with zero offspring are ignored, the
 distribution of the observed number of offspring (excluding zero) follows
 a zero-truncated Poission distribution with probability
\begin_inset Formula 
\[
\mbox{Pr}\left(k\right)=\frac{p^{k}e^{-p}}{k!\left(1-e^{-p}\right)}\;\textrm{ for }k\geq1
\]

\end_inset

The mean number of offspring is therefore 
\begin_inset Formula $\frac{1}{1-e^{-p}}p$
\end_inset

, which is 2.31 for 
\begin_inset Formula $p=2$
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(BINOMIAL_DISTRIBUTION, p, n): 
\family default
The number of offspring for each mating event follows a Binomial distribution
 with mean 
\begin_inset Formula $np$
\end_inset

 and variance 
\begin_inset Formula $np\left(1-p\right)$
\end_inset

.
 
\begin_inset Formula 
\[
\mbox{Pr}\left(k\right)=\frac{n!}{k!\left(n-k\right)!}p^{k}\left(1-p\right)^{n-k}\;\textrm{ for }n\geq k\geq0
\]

\end_inset

Because families with zero offspring are ignored, the distribution of the
 observed number of offspring (excluding zero) follows a zero-truncated
 Bionimial distribution, with mean number of offspring being 
\begin_inset Formula $\frac{np}{\left(1-p\right)^{n}}$
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
numOffspring=(UNIFORM_DISTRIBUTION, a, b):
\family default
 The number of offspring for each mating event follows a discrete uniform
 distribution with lower bound 
\begin_inset Formula $a$
\end_inset

 and upper bound 
\begin_inset Formula $b$
\end_inset

.
 
\begin_inset Formula 
\[
\mbox{Pr}\left(k\right)=\frac{1}{b-a+1}\;\textrm{ for }b\geq k\geq a
\]

\end_inset

The lower bound of this distribution can be 
\family typewriter
0
\family default
 but is identical to the case with 
\begin_inset Formula $a=1$
\end_inset

.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "numOff"

\end_inset

 demonstrates how to use parameter 
\family typewriter
numOffspring
\family default
.
 In this example, a function 
\family typewriter
checkNumOffspring
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 30 individuals.
 After evolving a population for one generation, parental indexes are used
 to identify siblings, and then the number of offspring per mating event.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/numOff.log"
lstparams "caption={Control the number of offspring per mating event.},label={numOff}"

\end_inset


\end_layout

\begin_layout Standard
However, 
\series bold
the actual number of offspring can be less than specified because offspring
 can be discarded during mating.

\series default
 More specifically, if any during-mating generator, such as a during-mating
 selector, returns 
\family typewriter
False
\family default
 during the production of offspring, the offspring will be discarded so
 the total number of offspring will be reduced.
 This is the case in the seventh case of Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "numOff"

\end_inset

 where offspring with certain genotypes have lower probabilities to survive.
 If you would like to control size of families in the presence of natural
 selection, you could set a larger 
\family typewriter
numOffspring
\family default
 use a 
\family typewriter
OffspringTagger
\family default
 to mark the index of offspring, and discard offspring conditionally using
 operator 
\family typewriter
DiscardIf
\family default
 .
 Please refer to example 
\begin_inset CommandInset ref
LatexCommand ref
reference "OffspringTagger"

\end_inset

 for details.
\end_layout

\begin_layout Subsection
Determine sex of offspring
\begin_inset CommandInset label
LatexCommand label
name "sub:offspring-sex"

\end_inset


\end_layout

\begin_layout Standard
Because sex can influence how genotypes are transmitted (e.g.
 sex chromosomes, haplodiploid population), simuPOP determines offspring
 sex before it passes an offspring to a 
\emph on
genotype transmitter
\emph default
 (during-mating operator) to transmit genotype from parents to offspring.
 The default 
\family typewriter
sexMode
\family default
 in almost all mating schemes is 
\family typewriter
RandomSex
\family default
, in which case simuPOP assign 
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
 to offspring with equal probability.
\end_layout

\begin_layout Standard
Other sex determination methods are also available:
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=RANDOM_SEX
\family default
: Sex is determined randomly, with equal probability for 
\family typewriter
MALE
\family default
 and 
\family typewriter
FEMALE
\family default
.
 This is the default mode for sexual mating schemes such as random mating.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=NO_SEX
\family default
: Sex is not simulated so everyone is 
\family typewriter
MALE
\family default
.
 This is the default mode for asexual mating schemes.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(PROB_OF_MALES, prob)
\family default
: Produce males with given probability.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NUM_OF_MALES, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Male
\family default
.
 If the number of offspring at a mating event is less than or equal to 
\family typewriter
n
\family default
, all offspring will be male.
 
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(NUM_OF_FEMALES, n)
\family default
: The first 
\family typewriter
n
\family default
 offspring in each family will be 
\family typewriter
Female
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(SEQUENCE_OF_SEX, s1, s2, ...)
\family default
: Use sequence 
\family typewriter
s1
\family default
, 
\family typewriter
s2
\family default
, ...
 for offspring in each mating event.
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=(GLOBAL_SEQUENCE_OF_SEX, s1, s2, ...)
\family default
: Use sequence 
\family typewriter
s1
\family default
, 
\family typewriter
s2
\family default
, ...
 for all offspring in a subpopulation.
 Because other mode of sex determination works within each mating event,
 this is the only way to ensure proportion of sex in a subpopulation.
 For example, 
\family typewriter
(GLOBAL_SEQUENCE_OF_SEX, MALE, FEMALE)
\family default
 will gives 
\family typewriter
MALE
\family default
 and 
\family typewriter
FEMALE
\family default
 iteratively to all offspring, making sure there are equal number of males
 and females (if there are even number of offspring).
\end_layout

\begin_layout Itemize

\family typewriter
sexMode=func
\family default
 or 
\family typewriter
sexMode=generator_func
\family default
: In this last case, a Python function or a Python generator function can
 be specified to provide sex to each offspring.
 The function is called whenever an offspring is created.
 The generator function is called for each subpopulation, and provides an
 iterator that provides sex for all offspring in a subpopulation.
\end_layout

\begin_layout Standard

\family typewriter
NumOfMales
\family default
 and 
\family typewriter
NumOfFemales
\family default
 are useful in theoretical studies where the sex ratio of a population needs
 to be controlled strictly, or in special mating schemes, usually for animal
 populations, where only a certain number of male or female Individuals
 are allowed in a family.
 It worth noting that a genotype transmitter can override specified offspring
 sex.
 This is the case for 
\family typewriter
CloneGenoTransmitter
\family default
 where an offspring inherits both genotype and sex from his/her parent.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexMode"

\end_inset

 demonstrates how to use parameter 
\family typewriter
sexMode
\family default
.
 In this example, a function 
\family typewriter
checkSexMode
\family default
 is defined.
 It takes a mating scheme as its input parameter and use it to evolve a
 population with 40 individuals.
 After evolving a population for one generation, sexes of all offspring
 are returned as a string.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexMode.log"
lstparams "caption={Determine the sex of offspring},label={sexMode}"

\end_inset


\end_layout

\begin_layout Subsection
Monogamous mating
\end_layout

\begin_layout Standard
Monogamous mating (monogamy) in simuPOP refers to mating schemes in which
 each parent mates only once.
 In an asexual setting, this implies parents are chosen without replacement.
 In sexual mating schemes, this means that parents are chosen without replacemen
t, they have only one spouse during their life time so that all siblings
 have the same parents (no half-sibling).
\end_layout

\begin_layout Standard
simuPOP provides a diploid sexual monogamous mating scheme 
\family typewriter
MonogamousMating
\family default
.
 However, without careful planning, this mating scheme can easily stop working
 due to the lack of parents.
 For example, if a population has 40 males and 55 females, only 40 successful
 mating events can happen and result in 40 offspring in the offspring generation.
 
\family typewriter
MonogamousMating
\family default
 will exit if the offspring generation is larger than 40.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "monogamous"

\end_inset

 demonstrates one scenario of using a monogamous mating scheme where sex
 of parents and offspring are strictly specified so that parents will not
 be exhausted.
 The sex initializer 
\family typewriter
InitSex
\family default
 assigns exactly 10 males and 10 females to the initial population.
 Because of the use of 
\family typewriter
numOffspring=2, sexMode=(NUM_OF_MALES, 1)
\family default
, each mating event will produce exactly one male and one female.
 Unlike a random mating scheme that only about 80% of parents are involved
 in the production of an offspring population with the same size, this mating
 scheme makes use of all parents.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/monogamous.log"
lstparams "caption={Sexual monogamous mating},label={monogamous}"

\end_inset


\end_layout

\begin_layout Subsection
Polygamous mating
\end_layout

\begin_layout Standard
In comparison to monogamous mating, parents in a polygamous mate with more
 than one spouse during their life-cycle.
 Both 
\emph on
polygany
\emph default
 (one man has more than one wife) and 
\family typewriter
\emph on
polyandry
\family default
\emph default
 (one woman has more than one husband) are supported.
\end_layout

\begin_layout Standard
Other than regular parameters such as 
\family typewriter
numOffspring
\family default
, mating scheme 
\family typewriter
PolygamousMating
\family default
 accepts parameters 
\family typewriter
polySex
\family default
 (default to 
\family typewriter
Male
\family default
) and 
\family typewriter
polyNum
\family default
 (default to 1).
 During mating, an individual with 
\family typewriter
polySex
\family default
 is selected and then mate with 
\family typewriter
polyNum
\family default
 randomly selected spouse.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "polygamous"

\end_inset

 demonstrates the use of this mating schemes.
 Note that this mating scheme support natural selection, but does not yet
 handle varying 
\family typewriter
polyNum
\family default
 and selection of parents without replacement.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/polygamous.log"
lstparams "caption={Sexual polygamous mating},label={polygamous}"

\end_inset


\end_layout

\begin_layout Subsection
Asexual random mating
\end_layout

\begin_layout Standard
Mating scheme 
\family typewriter
RandomSelection
\family default
 implements an asexual random mating scheme.
 It randomly select parents from a parental population (with replacement)
 and copy them to an offspring generation.
 Both genotypes and sex of the parents are copied because genotype and sex
 are sometimes related.
 This mating scheme can be used to simulate the evolution of haploid sequences
 in a standard haploid Wright-Fisher model.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "RandomSelection"

\end_inset

 applies a 
\family typewriter
RandomSelection
\family default
 mating scheme to a haploid population with 100 sequences.
 A 
\family typewriter
parentTagger
\family default
 is used to track the parent of each individual.
 Although sex information is not used in this mating scheme, Individual
 sexes are initialized and passed to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/RandomSelection.log"
lstparams "caption={Asexual random mating},label={RandomSelection}"

\end_inset


\end_layout

\begin_layout Subsection
Mating in haplodiploid populations
\end_layout

\begin_layout Standard
Male individuals in a haplodiploid population are derived from unfertilized
 eggs and thus have only one set of chromosomes.
 Mating in such a population is handled by a special mating scheme called
 
\family typewriter
haplodiplodMating
\family default
.
 This mating scheme chooses a pair of parents randomly and produces some
 offspring.
 It transmit maternal chromosomes and paternal chromosomes (the only copy)
 to female offspring, and only maternal chromosomes to male offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "HaplodiploidMating"

\end_inset

 demonstrates how to use this mating scheme.
 It uses three initializers because sex has to be initialized before two
 other intializers can initialize genotype by sex.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/HaplodiploidMating.log"
lstparams "caption={Random mating in haplodiploid populations},label={HaplodiploidMating}"

\end_inset


\end_layout

\begin_layout Standard
Note that this mating scheme does not support recombination and the standard
 Recombinator does not work with haplodiploid populations.
 Please refer to the next Chapter for how to define a customized genotype
 transmitter to handle such a situation.
\end_layout

\begin_layout Subsection
Self-fertilization
\end_layout

\begin_layout Standard
Some plant populations evolve through self-fertilization.
 That is to say, a parent fertilizes with itself during the production of
 offspring (seeds).
 In a 
\family typewriter
SelfMating
\family default
 mating scheme, parents are chosen randomly (one at a time), and are used
 twice to produce two homologous sets of offspring chromosomes.
 The standard Recombinator can be used with this mating scheme.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "SelfMating"

\end_inset

 initializes each chromosome with different alleles to demonstrate how these
 alleles are transmitted in this population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/SelfMating.log"
lstparams "caption={Selfing mating scheme},label={SelfMating}"

\end_inset


\end_layout

\begin_layout Subsection
Heterogeneous mating schemes *
\end_layout

\begin_layout Standard
Different groups of individuals in a population may have different mating
 patterns.
 For example, individuals with different properties can have varying fecundity,
 represented by different numbers of offspring generated per mating event.
 This can be extended to aged populations in which only adults (may be defined
 by age > 20 and age < 40) can produce offspring, where other individuals
 will either be copied to the offspring generation or die.
\end_layout

\begin_layout Standard
A heterogeneous mating scheme (
\family typewriter
HeteroMating
\family default
) accepts a list of mating schemes that are applied to different subpopulation
 or virtual subpopulations.
 If multiple mating schemes are applied to the same subpopulation, each
 of them only populate part of the offspring subpopulation.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heterogenous-mating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heterogenous-mating"

\end_inset

Illustration of a heterogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/MatingScheme.png
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
A heterogeneous mating scheme that applies homogeneous mating schemes MS0,
 MS0.0, MS0.1, MS1, MS2.0 and MS2.1 to subpopulation 0, the first and second
 virtual subpopulation in subpopulation 0, subpopulation 1, the first and
 second virtual subpopulation in subpopulation 2, respectively.
 Note that VSP 0 and 1 in subpopulation 0 overlap, and do not add up to
 subpopulation 0.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingSP"

\end_inset

 applies two random mating schemes to two subpopulations.
 The first mating scheme produces two offspring per mating event, and the
 second mating scheme produces four.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/HeteroMatingSP.log"
lstparams "caption={Applying different mating schemes to different subpopulations },label={hateroMatingSP}"

\end_inset


\end_layout

\begin_layout Standard
The real power of heterogeneous mating schemes lies on their ability to
 apply different mating schemes to different virtual subpopulations.
 For example, due to different micro-environmental factors, plants in the
 same population may exercise both self and cross-fertilization.
 Because of the randomness of such environmental factors, it is difficult
 to divide a population into self and cross-mating subpopulations.
 Applying different mating schemes to groups of individuals in the same
 subpopulation is more appropriate.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hateroMatingVSP"

\end_inset

 applies two mating schemes to two VSPs defined by proportions of individuals.
 In this mating scheme, 20% of individuals go through self-mating and 80%
 of individuals go through random mating.
 This can be seen from the parental indexes of individuals in the offspring
 generation: individuals whose 
\family typewriter
mother_idx
\family default
 are 
\family typewriter
-1
\family default
 are genetically only derived from their fathers.
 
\end_layout

\begin_layout Standard
It might be surprising that offspring resulted from two mating schemes mix
 with each other so the same VSPs in the next generation include both selfed
 and cross-fertilized offspring.
 If this not desired, you can set parameter 
\family typewriter
shuffleOffspring=False
\family default
 in 
\family typewriter
HeteroMating
\family default
().
 Because the number of offspring that are produced by each mating scheme
 is proportional to the size of parental (virtual) subpopulation, the first
 20% of individuals that are produced by self-fertilization will continue
 to self-fertilize.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/HeteroMatingVSP.log"
lstparams "caption={Applying different mating schemes to different virtual subpopulations },label={hateroMatingVSP}"

\end_inset


\end_layout

\begin_layout Standard
Because there is no restriction on the choice of VSPs, mating schemes can
 be applied to overlapped (virtual) subpopulations.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HeteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        SelfMating(subPops=[(0, 0)]),
\end_layout

\begin_layout Plain Layout

        RandomMating(subPops=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will apply SelfMating to the first 20% individuals, and RandomMating will
 be applied to all individuals.
 Similarly,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HeteroMating(
\end_layout

\begin_layout Plain Layout

    matingSchemes = [
\end_layout

\begin_layout Plain Layout

        SelfMating(subPops=0),
\end_layout

\begin_layout Plain Layout

        RandomMating(subPops=0)
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

will allow all individuals to be involved in both 
\family typewriter
SelfMating
\family default
 and 
\family typewriter
RandomMating
\family default
.
\end_layout

\begin_layout Standard
This raises the question of how many offspring each mating scheme will produce.
 By default, the number of offspring produced will be proportional to the
 size of parental (virtual) subpopulations.
 In the last example, because both mating schemes are applied to the same
 subpopulation, half of all offspring will be produced by selfing and the
 other half will be produced by random mating.
\end_layout

\begin_layout Standard
This behavior can be changed by a weighting scheme controlled by parameter
 
\family typewriter
weight
\family default
 of each homogeneous mating scheme.
 Briefly speaking, a positive weight will be compared against other mating
 schemes.
 a negative weight is considered proportional to the existing (virtual)
 subpopulation size.
 Negative weights are considered before positive or zero weights.
\end_layout

\begin_layout Standard
This weighting scheme is best explained by an example.
 Assuming that there are three mating schemes working on the same parental
 subpopulation
\end_layout

\begin_layout Itemize
Mating scheme A works on the whole subpopulation of size 1000
\end_layout

\begin_layout Itemize
Mating scheme B works on a virtual subpopulation of size 500
\end_layout

\begin_layout Itemize
Mating scheme C works on another virtual subpopulation of size 800
\end_layout

\begin_layout Standard
Assuming the corresponding offspring subpopulation has 
\begin_inset Formula $N$
\end_inset

 individuals, 
\end_layout

\begin_layout Itemize
If all weights are 0, the offspring subpopulation is divided in proportion
 to parental (virtual) subpopulation sizes.
 In this example, the mating schemes will produce 
\begin_inset Formula $\frac{10}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{5}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{8}{23}N$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Itemize
If all weights are negative, they are multiplied to their parental (virtual)
 subpopulation sizes.
 For example, weight (-1, -2, -0.5) will lead to sizes (1000, 1000, 400)
 in the offspring subpopulation.
 If 
\begin_inset Formula $N\ne2400$
\end_inset

 in this case, an error will be raised.
\end_layout

\begin_layout Itemize
If all weights are positive, the number of offspring produced from each
 mating scheme is proportional to these weights.
 For example, weights (1, 2, 3) will lead to 
\begin_inset Formula $\frac{1}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{2}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{1}{3}N$
\end_inset

 individuals respectively.
 In this case, 0 weights will produce no offspring.
\end_layout

\begin_layout Itemize
If there are mixed positive and negative weights, the negative weights are
 processed first, and the rest of the individuals are divided using non-negative
 weights.
 For example, three mating schemes with weights (-0.5, 2, 3) will produce
 500, 
\begin_inset Formula $\frac{2}{5}\left(N-500\right)$
\end_inset

, 
\begin_inset Formula $\frac{3}{5}\left(N-500\right)$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Standard
The last case is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "HeteroMatingWeight"

\end_inset

 where three random mating schemes are applied to subpopulation 
\family typewriter
0
\family default
, virtual subpopulation
\family typewriter
 (0, 0)
\family default
 and virtual subpopulation 
\family typewriter
(0, 1)
\family default
, with weights 
\family typewriter
-
\family default
0.5, 
\family typewriter
2
\family default
, and 
\family typewriter
3
\family default
 respectively.
 This example uses an advanced features that will be described in the next
 section.
 Namely, three during-mating Python operators are passed to each mating
 scheme to mark their offspring with different numbers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/HeteroMatingWeight.log"
lstparams "caption={A weighting scheme used by heterogeneous mating schemes.},label={HeteroMatingWeight}"

\end_inset


\end_layout

\begin_layout Subsection
Conditional mating schemes
\end_layout

\begin_layout Standard
A 
\family typewriter
ConditionalMating
\family default
 mating scheme allows you to apply different mating schemes to populations
 with different properties.
 The condition can be a constant (True or False), an expression that will
 be evaluated in the local namspace of the parental population, or a function
 that can take parental population as its input paramter (with parameter
 name 
\family typewriter
pop
\family default
).
 
\end_layout

\begin_layout Standard
Using variable 
\family typewriter
rep
\family default
 and 
\family typewriter
gen
\family default
 in the local namespace of the parental population, we can use this mating
 scheme to apply different mating schemes to different replicates and/or
 at different generations.
 For example, 
\begin_inset CommandInset ref
LatexCommand ref
reference "matingSchemeByRepAndGen"

\end_inset

 simulates the evolution of three replicates.
 The first replicate uses regular mating scheme, the third replicate uses
 a mating scheme that produces 70% of males, and the second replicate do
 this only for the first 5 generations.
 Because there are three cases, a nested 
\family typewriter
ConditionalMating
\family default
 is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/matingSchemeByRepAndGen.log"
lstparams "caption={Apply different mating schemes for different replicates at different generations},label={matingSchemeByRepAndGen}"

\end_inset


\end_layout

\begin_layout Standard
A function can be passed as the condition of a 
\family typewriter
ConditionalMating
\family default
 mating scheme.
 This allows you to apply operators such as 
\family typewriter
Stat
\family default
 to examine the condition of populations more closely and determine which
 mating scheme to use.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
A simuPOP simulator evolves one or more copies of a population forward in
 time, subject to various operators.
 Although a population could evolve by itself using function 
\family typewriter
Population.evolve
\family default
, a simulator with one replicate is actually used.
\end_layout

\begin_layout Subsection
Add, access and remove populations from a simulator
\end_layout

\begin_layout Standard
A simulator could be created by one or more replicates of a list of populations.
 For example, you could create a simulator from five replicates of a population
 using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Simulator(pop, rep=5)
\end_layout

\end_inset

or from a list of populations using 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Simulator([pop, pop1, pop2])
\end_layout

\end_inset

.
 
\family typewriter
pop
\family default
, 
\family typewriter
pop1
\family default
 and 
\family typewriter
pop2
\family default
 do not have to have the same genotypic structure.
 In order to avoid duplication of potentially large populations, a population
 is by default 
\emph on
stolen
\emph default
 after it is used to create a simulator.
 If you would like to keep the populations, you could set parameter 
\family typewriter
stealPops
\family default
 to 
\family typewriter
False
\family default
 so that the populations will be copied to the simulator.
 Populations in a simulator can be added or removed using functions 
\family typewriter
Simulator.add()
\family default
 and 
\family typewriter
Simulator.extract(idx)
\family default
.
\end_layout

\begin_layout Standard
When a simulator is created, you can access populations in this simulator
 using function 
\family typewriter
Simulator.population(idx)
\family default
 or iterate through all populations using function 
\family typewriter
Simulator.populations()
\family default
.
 These functions return references to the populations so that you can access
 populations.
 Modifying these references will change the corresponding populations within
 the simulator.
 The references will become invalid once the simulator object is destoryed.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "Simulator"

\end_inset

 demonstrates different ways to create a simulator and how to access populations
 within it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/Simulator.log"
lstparams "caption={Create a simulator and access populations},label={Simulator}"

\end_inset


\end_layout

\begin_layout Subsection
Number of generations to evolve
\end_layout

\begin_layout Standard
A simulator usually evolves a specific number of generations according to
 parameter 
\family typewriter
gen
\family default
 of the 
\family typewriter
evolve
\family default
 function.
 A generation number is used to track the number of generations a simulator
 has evolved.
 Because a new population has generation number 0, a population would be
 at the beginning of generation 
\begin_inset Formula $n$
\end_inset

 after it evolves 
\begin_inset Formula $n$
\end_inset

 generations.
 The generation number would increase if the simulator continues to evolve.
 During evoluting, variables 
\family typewriter
rep
\family default
 (replicate number) and 
\family typewriter
gen
\family default
 (current generation number) are set to each population's local namespace.
\end_layout

\begin_layout Standard
It is not always possible to know in advance the number of generations to
 evolve.
 For example, you may want to evolve a population until a specific allele
 gets fixed or lost in the population.
 In this case, you can let the simulator run indefinitely (do not set the
 
\family typewriter
gen
\family default
 parameter) and depend on a 
\emph on
terminator 
\emph default
to terminate the evolution of a population.
 The easiest method to do this is to use population variables to track the
 status of a population, and use a 
\family typewriter
TerminateIf
\family default
 operator to terminate the evolution according to the value of an expression.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simuGen"

\end_inset

 demonstrates the use of such a terminator, which terminates the evolution
 of a population if allele 0 at locus 5 is fixed or lost.
 It also shows the application of an interesting operator 
\family typewriter
IfElse
\family default
, which applies an operator, in this case 
\family typewriter
PyEval
\family default
, only when an expression returns 
\family typewriter
True
\family default
.
 Note that this example calls the 
\family typewriter
simulator.evolve
\family default
 function twice.
 The first call does not specify a mating scheme so a default empty mating
 scheme (
\family typewriter
MatingScheme
\family default
) that does not transmit genotype is used.
 Populations start from the beginning of the fifth generation when the second
 
\family typewriter
simulator.evole
\family default
 function is called.
\end_layout

\begin_layout Standard
The generation number is stored in each Population using population variable
 
\family typewriter
gen
\family default
.You can access these numbers from a simulator using function 
\family typewriter
Simulator.dvars(idx)
\family default
 or from a population using function 
\family typewriter
Population.dvars()
\family default
.
 If needed, 
\series bold
you can reset generation numbers by changing these variables.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuGen.log"
lstparams "caption={Generation number of a simulator},keywordstyle={\\ttfamily},label={simuGen}"

\end_inset


\end_layout

\begin_layout Subsection
Evolve populations in a simulator
\end_layout

\begin_layout Standard
There are a number of rules about when and how operators are applied during
 the evolution of a population.
 In summary, in the order at which operators are processed and applied,
\end_layout

\begin_layout Itemize
Operators specified in parameter 
\family typewriter
initOps
\family default
 of function 
\family typewriter
Simulator.evolve
\family default
 will be applied to the initial population before evolution, subject to
 replicate applicability restraint specified by parameter 
\family typewriter
reps
\family default
.
\end_layout

\begin_layout Itemize
Operators specified in parameter 
\family typewriter
preOps
\family default
 of function 
\family typewriter
Simulator.evolve
\family default
 will be applied to the parental population at each generation, subject
 to replicate and generation applicability restraint specified by parameters
 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
, and 
\family typewriter
reps
\family default
.
\end_layout

\begin_layout Itemize
During-mating operators specified in the 
\family typewriter
ops
\family default
 parameter of a mating scheme will be called during mating to transmit genotype
 (and possibly information fields etc) from parental to offspring, subject
 to replicate and generation applicability restraint specified by parameters
 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
, and 
\family typewriter
reps
\family default
.
 
\end_layout

\begin_layout Itemize
Operators specified in parameter postOps of function 
\family typewriter
Simulator.evolve
\family default
 will be applied to the offspring population at each generation, subject
 to replicate and generation applicability restraint specified by parameters
 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
, and 
\family typewriter
reps
\family default
.
\end_layout

\begin_layout Itemize
Operators specified in parameter 
\family typewriter
finalOps
\family default
 of function 
\family typewriter
Simulator.evolve
\family default
 will be applied to the final population after evolution, subject to replicate
 applicability restraint specified by parameter 
\family typewriter
reps
\family default
.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:operator-orders"

\end_inset

 illustrated how operators are applied to an evolutionary process.
 It worth noting that a default during-mating operator is defined for each
 mating scheme.
 User-specfied operators will 
\series bold
replace
\series default
 the default operator so you need to explicitly specify the default operator
 if you intent to add another one.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:operator-orders"

\end_inset

Orders at which operators are applied during an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/operators.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you suspect that your simulation is not running as expected, you can
 have a close look at your evolutionary process by setting the 
\family typewriter
dryrun
\family default
 parameter of an 
\family typewriter
evolve
\family default
 function to 
\family typewriter
True
\family default
, or by calling function 
\family typewriter
describeEvolProcess()
\family default
.
 This function takes the same set of parameters as 
\family typewriter
Simulator.evolve()
\family default
 and returns a description of the evolution process, which might help you
 identify misuse of operators.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/describe.log"
lstparams "caption={describe an evolutionary process},label={describe}"

\end_inset


\end_layout

\begin_layout Section
Non-random and customized mating schemes *
\end_layout

\begin_layout Subsection
The structure of a homogeneous mating scheme *
\end_layout

\begin_layout Standard
A 
\emph on
homogeneous mating scheme
\emph default
 (
\family typewriter
HomoMating
\family default
) populates an offspring generation as follows:
\end_layout

\begin_layout Enumerate
Create an empty offspring population (generation) with appropriate size.
 Parental and offspring generation can differ in size but they must have
 the same number of subpopulations.
\end_layout

\begin_layout Enumerate
For each subpopulation, repeatedly choose a parent or a pair of parents
 from the parental generation.
 This is done by a simuPOP object called a 
\series bold
parent chooser
\series default
.
\end_layout

\begin_layout Enumerate
One or more offspring are produced from the chosen parent(s) and are placed
 in the offspring population.
 This is done by a simuPOP 
\series bold
offspring generator
\series default
.
 An offspring generator uses one or more during-mating operators to transmit
 parental genotype to offspring.
 These operators are called 
\series bold
genotype transmitters
\series default
.
\end_layout

\begin_layout Enumerate
After the offspring generation is populated, it will replace the parental
 generation and becomes the present generation of a population.
\end_layout

\begin_layout Standard
To define a homogeneous mating scheme, you will need to provide a 
\family typewriter
chooser
\family default
 (a 
\emph on
parent chooser
\emph default
 that is responsible for choosing one or two parents from the parental generatio
n) and a 
\family typewriter
generator
\family default
 (an 
\emph on
offspring generator
\emph default
 that is responsible for generating a number of offspring from the chosen
 parents).
 For example, a 
\family typewriter
selfingMating
\family default
 mating scheme uses a 
\family typewriter
RandomParentChooser
\family default
 to choose a parent randomly from a population, possibly according to individual
 fitness, it uses a standard 
\family typewriter
OffspringGenerator
\family default
 that uses a 
\family typewriter
selfingOffspringGenerator
\family default
 to transmit genotype.
 The constructor of 
\family typewriter
HomoMating
\family default
 also accepts parameters 
\family typewriter
subPopSize
\family default
 (parameter to control offspring subpopulation sizes), 
\family typewriter
subPops
\family default
 (applicable subpopulatiosn or virtual subpopulations), and 
\family typewriter
weight
\family default
 (weighting parameter when used in a heterogeneous mating scheme).
 When this mating scheme is applied to the whole population, 
\family typewriter
subPopSize
\family default
 is used to determine the subpopulation sizes of the offspring generation
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-size"

\end_inset

 for details), parameters 
\family typewriter
subPops
\family default
 and 
\family typewriter
weight
\family default
 are ignored.
 Otherwise, the number of offspring this mating scheme will produce is determine
d by the heterogeneous mating scheme.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "RandomMating"

\end_inset

 demonstrates how the most commonly used mating scheme, the diploid sexual
 
\family typewriter
RandomMating
\family default
 mating scheme is defined in 
\family typewriter
simuPOP.py
\family default
.
 This mating scheme uses a 
\family typewriter
RandomParentsChooser
\family default
 with replacement, and a standard 
\family typewriter
OffspringGenerator
\family default
 using a default 
\family typewriter
MendelianGenoTransmitter
\family default
.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/RandomMating.py"
lstparams "caption={Define a random mating scheme},firstline=2,label={RandomMating}"

\end_inset


\end_layout

\begin_layout Standard
Different parent choosers and offspring generators can be combined to define
 a large number of homogeneous mating schemes.
 Some of the parent choosers return one parent so they work with offspring
 generators that need one parent (e.g.
 selfing or clone offspring generator); some of the parent choosers return
 two parents so they work with offspring generators that need two parents
 (e.g.
 Mendelian offspring generator).
 For example, the standard 
\family typewriter
SelfMating
\family default
 mating scheme uses a 
\family typewriter
RandomParentChooser
\family default
 but you can easily use a 
\family typewriter
SequentialParentChooser
\family default
 to choose parents sequentially and self-fertilize parents one by one.
 This is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sequentialSelfing.log"
lstparams "caption={Define a sequential selfing mating scheme},label={sequentialSelfing}"

\end_inset


\end_layout

\begin_layout Subsection
Offspring generators *
\end_layout

\begin_layout Standard
An 
\family typewriter
OffspringGenerator
\family default
 accepts a parameters 
\family typewriter
ops
\family default
 (a list of during-mating operators), 
\family typewriter
numOffspring
\family default
 (control number of offspring per mating event) and 
\family typewriter
sexMode
\family default
 (control offspring sex).
 We have examined the last two parameters in detail in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:number-of-offspring"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:offspring-sex"

\end_inset

.
 
\end_layout

\begin_layout Standard
The most tricky parameter is the 
\family typewriter
ops
\family default
 parameter.
 It accepts a list of during mating operators that are used to transmit
 genotypes from parent(s) to offspring and/or set individual information
 fields.
 The standard 
\family typewriter
OffspringGenerator
\family default
 does not have any default operator so no genotype will be transmitted by
 default.
 All stock mating schemes use a default genotype transmitter.
 (e,g, a 
\family typewriter
MendelianGenoTransmitter
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "RandomMating"

\end_inset

 is passed to the offspring generator used in 
\family typewriter
RandomMating
\family default
).
 Note that you need to specify all needed operators if you use parameter
 
\family typewriter
ops
\family default
 to change the operators used in a mating scheme (see Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "HeteroMatingWeight"

\end_inset

).
 That is to say, you can use 
\family typewriter
ops=Recombinator()
\family default
 to replace a default 
\family typewriter
MendelianGenoTransmitter()
\family default
, but you have to use 
\family typewriter
ops=[IdTagger(), MendelianGenoTransmitter()]
\family default
 if you would like to add a during-mating operator to the default one.
\end_layout

\begin_layout Standard
Another offspring generator is provided in simuPOP.
 This 
\family typewriter
ControlledOffspringGenerator 
\family default
is used to control an evolutionary process so that the allele frequencies
 at certain loci follows some pre-simulated 
\emph on
frequency trajectories
\emph default
.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

 for rationals behind such an offspring generator and its applications in
 the simulation of complex human diseases.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

 demonstrates the use of such a controlled offspring generator.
 Instead of using a realistic frequency trajectory function, it forces allele
 frequency at locus 5 to increase linearly.
 In contrast, the allele frequency at locus 15 on the second chromosome
 oscillates as a result of genetic drift.
 Note that the random mating version of this mating scheme is defined in
 simuPOP as 
\family typewriter
ControlledRandomMating
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/controlledOffGenerator.log"
lstparams "caption={A controlled random mating scheme},label={controlledOffGenerator}"

\end_inset


\end_layout

\begin_layout Subsection
Genotype transmitters *
\begin_inset CommandInset label
LatexCommand label
name "sub:Pre-defined-genotype-transmitters"

\end_inset


\end_layout

\begin_layout Standard
Although any during mating operators can be used in parameter 
\family typewriter
ops 
\family default
of an offspring generator, those that transmit genotype from parents to
 offspring are customarily called 
\series bold
genotype transmitters
\series default
.
 simuPOP provides a number of genotype transmitters including clone, Mendelian,
 selfing, haplodiploid, genotype transmitter, and a Recombinator.
 They are usually used implicitly in a mating scheme, but they can also
 be used explicitly.
\end_layout

\begin_layout Standard
Although simuPOP provides a number of genotype transmitters, they may still
 be cases where customized genotype transmitter is needed.
 For example, a Recombinator can be used to recombine parental chromosomes
 but it is well known that male and female individuals differ in recombination
 rates.
 How can you apply two different Recombinators to male and female Individuals
 separately?
\end_layout

\begin_layout Standard
An immediate thought can be the use of virtual subpopulations.
 If you apply two random mating schemes to two virtual subpopulations defined
 by sex, 
\family typewriter
RandomParentsChooser
\family default
 will not work because no opposite sex can be found in each virtual subpopulatio
n.
 In this case, a customized genotype transmitter can be used.
\end_layout

\begin_layout Standard
A customized genotype transmitter is only a Python during-mating operator.
 Although it is possible to define a function and use a PyOperator directly
 (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyOperator"

\end_inset

), it is much better to derive an operator from PyOperator, as the case
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "newOperator"

\end_inset

.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 defines a 
\family typewriter
sexSpecificRecombinator
\family default
 that uses, internally, two different Recombinators to recombine male and
 female parents.
 The key statement is the 
\family typewriter
PyOperator.__init__
\family default
 line which initializes a Python operator with given function 
\family typewriter
self.transmitGenotype
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sexSpecificRec"

\end_inset

 outputs the population in two generations.
 You should notice that paternal chromosome are not recombined when they
 are transmitted to offspring.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sexSpecificRec.log"
lstparams "caption={A customized genotype transmitter for sex-specific recombination},label={sexSpecificRec}"

\end_inset


\end_layout

\begin_layout Subsection
A Python parent chooser *
\end_layout

\begin_layout Standard
Parent choosers are responsible for choosing one or two parents from a parental
 (virtual) subpopulation.
 simuPOP defines a few parent choosers that choose parent(s) sequentially,
 randomly (with or without replacement), or with additional conditions.
 Some of these parent choosers support natual selection.
 We have seen sequential and random parent choosers in Examples 
\begin_inset CommandInset ref
LatexCommand ref
reference "sequentialSelfing"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

.
 Please refer to the simuPOP reference manual for details about these objects.
\end_layout

\begin_layout Standard
A parent choosing scheme can be quite complicated in reality.
 For example, salamanders along a river may mate with their neighbors and
 form several subspecies.
 This behavior cannot be readily simulated using any pre-define parent choosers
 so a hybrid parent chooser 
\family typewriter
PyParentsChooser()
\family default
 should be used.
\end_layout

\begin_layout Standard
A 
\family typewriter
PyParentsChooser
\family default
 accepts a user-defined Python generator function, instead of a normal python
 function, that returns a parent, or a pair of parents repeatedly.
 Briefly speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when this iterator iterates, this function resumes where it was
 stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,5$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 sequentially.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator.log"
lstparams "caption={A sample generator function},label={generator}"

\end_inset


\end_layout

\begin_layout Standard
A 
\family typewriter
PyParentsChooser
\family default
 accepts a parent generator function, which takes a population and a subpopulati
on index as parameters.
 When this parent chooser is applied to a subpopulation, it will call this
 generator function and ask the generated generator object repeated for
 either a parent, or a pair of parents (
\emph on
references to individual objects or indexes relative to a subpopulation
\emph default
).
 Note that 
\family typewriter
PyParentsChooser
\family default
 does not support virtual subpopulation but you can mimic the effect by
 returning only parents from certain virtual subpopulations.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyParentsChooser"

\end_inset

 implements a hybrid parent chooser that chooses parents with equal social
 status (
\family typewriter
rank
\family default
).
 In this parent chooser, all males and females are categorized by their
 sex and social status.
 A parent is chosen randomly, and then his/her spouse is chosen from females/mal
es with the same social status.
 The rank of their offspring can increase or decrease randomly.
 It becomes obvious now that whereas a python function can return random
 male/female pair, the generator interface is much more efficient because
 the identification of sex/status groups is done only once.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/PyParentsChooser.log"
lstparams "caption={A hybrid parent chooser that chooses parents by their social status},label={PyParentsChooser}"

\end_inset


\end_layout

\begin_layout Standard
Built-in parent choosers could be used in a 
\family typewriter
PyParentsChooser
\family default
 to choose parents.
 The parent chooser needs to be initialized with the parental population
 and subpopulation index.
 Calling the 
\family typewriter
chooseParents
\family default
 function repeatedly will return pairs of individuals from the population
 (
\family typewriter
None
\family default
 will be returned for one of the parents if the parent chooser only returns
 one parent).
 The use of built-in parent choosers can improve the performance of your
 
\family typewriter
PyParentsChooser
\family default
, especially for complex selection patterns (e.g.
 with natural selection).
 For example, 
\begin_inset CommandInset ref
LatexCommand ref
reference "BuiltInParentsChooser"

\end_inset

 implements a similar mating scheme as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyParentsChooser"

\end_inset

 but uses a 
\family typewriter
RandomParentChooser
\family default
 to choose males randomly.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/BuiltInParentsChooser.log"
lstparams "caption={Use built-in parent choosers in a Python parent chooser},label={BuiltInParentsChooser}"

\end_inset


\end_layout

\begin_layout Subsection
Using C++ to implement a parent chooser **
\begin_inset CommandInset label
LatexCommand label
name "sub:Using-C++"

\end_inset


\end_layout

\begin_layout Standard
A user defined parent chooser can be fairly complex and computationally
 intensive.
 For example, if a parent tends to find a spouse in his/her vincinity, geometric
 distances between all qualified individuals and a chosen parent need to
 be calculated for each mating event.
 If the optimization of the parent chooser can speed up the simulation significa
ntly, it may be worthwhile to write the parent chooser in C++.
 
\end_layout

\begin_layout Standard
Although it is feasible, and sometimes easier to derive a class from class
 
\family typewriter
ParentChooser
\family default
 in mating.h (.cpp), modifying simuPOP source code is not recommended because
 you would have to modify a new version of simuPOP whenever you upgrade
 your simuPOP distribution.
 Implementing your parent choosing algorithm in another Python module is
 preferred.
\end_layout

\begin_layout Standard
The first step is to write your own parent chooser in C/C++.
 Basically, you will need to pass all necessary information to the C++ level
 and implement an algorithm to choose parents randomly.
 Although simple function based solutions are possible, a C++ level class
 such as the 
\family typewriter
myParentsChooser 
\family default
class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 is recommended.
 This class is initialized with indexes of male and female individuals and
 use a function 
\family typewriter
chooseParents
\family default
 to return a pair of parents randomly.
 This parent chooser is very simple but more complicated parent selection
 scenarios can be implemented similarly.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.h"
lstparams "caption={Implement a parent chooser in C++},label={parentChooseHeader},language=C"

\end_inset


\end_layout

\begin_layout Standard
The second step is to wrap your C++ functions and classes to a Python module.
 There are many tools available but SWIG (
\family typewriter
www.swig.org
\family default
) is arguably the most convenient and powerful one.
 To use SWIG, you will need to prepare an interface file, which basically
 tells SWIG which functions and classes you would like to expose and how
 to pass parameters between Python and C++.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserInterface"

\end_inset

 lists an interface file for the C++ class defined in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

.
 Please refer to the SWIG reference manual for details.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/myParentsChooser.i"
lstparams "caption={An interface file for the myParentsChooser class},label={parentsChooserInterface},language=Awk"

\end_inset


\end_layout

\begin_layout Standard
The exact procedure to generate and compile a wrapper file varies from system
 to system, and from compiler to compiler.
 Fortunately, the standard Python module setup process supports SWIG.
 All you need to do is to write a Python 
\family typewriter
setup.py
\family default
 file and let the 
\family typewriter
distutil
\family default
 module of Python handle all the details for you.
 A typical 
\family typewriter
setup.py
\family default
 file is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentsChooserSetup"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/setup.py"
lstparams "caption={Building and installing the myParentsChooser module},label={parentsChooserSetup}"

\end_inset


\end_layout

\begin_layout Standard
You parent chooser can now be compiled and installed using the standard
 Python 
\family typewriter
setup.py
\family default
 commands such as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to the Python reference manual for other building and installation
 options.
 Note that Python 2.4 and earlier do not support option swig_opts well so
 you might have to pass these options using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python setup.py build_ext --swig-opts=-O -templatereduce 
\backslash

\end_layout

\begin_layout Plain Layout

    -shadow -c++ -keyword -nodefaultctor install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "parentChooseHeader"

\end_inset

 demonstrates how to use such a C++ parents chooser in your simuPOP script.
 It uses the same Python parent chooser interface as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "PyParentsChooser"

\end_inset

, but leaves all the (potentially) computationally intensive parts to the
 C++ level 
\family typewriter
myParentsChooser
\family default
 object.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/cppParentChooser.py"
lstparams "caption={Implement a parent chooser in C++},label={cppParentChooser}"

\end_inset


\end_layout

\begin_layout Section
Age structured populations with overlapping generations **
\end_layout

\begin_layout Standard
Age is an important factor in many applications because it is related to
 many genetic (most obviously mating) and environmental factors that influence
 the evolution of a population.
 The evolution of age structured populations will lead to overlapping generation
s because parents can co-exist with their offspring in such a population.
 Although simuPOP is based on a discrete generation model, it can be used
 to simulate age structured populations.
\end_layout

\begin_layout Standard
To evolve an age structured population, you will need to
\end_layout

\begin_layout Itemize
Define an information field 
\family typewriter
age
\family default
 and use it to store age of all individuals.
 Age is usally assigned randomly at the beginning of a simulation.
\end_layout

\begin_layout Itemize
Define a virtual splitter that splits the parental population into several
 virtual subpopulation.
 The most important VSP consists of mating individuals (e.g.
 individuals with age between 20 and 40).
 Advanced features of virtual splitters can be used to define complex VSPs
 such as males between age 20 - 40 and females between age 15-30 (use a
 
\family typewriter
ProductSplitter
\family default
 to split subpopulations by sex and age, and then a 
\family typewriter
CombinedSplitter
\family default
 to join several smaller VSPs together).
\end_layout

\begin_layout Itemize
Use a heterogeneous mating scheme that clones most individuals to the next
 generation (year) and produce offspring from the mating VSP.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ageStructured"

\end_inset

 gives an example of the evolution of age-structured population.
 
\end_layout

\begin_layout Itemize
Information fields 
\family typewriter
ind_id
\family default
, 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
 and operators 
\family typewriter
IdTagger
\family default
 and 
\family typewriter
PedigreeTagger
\family default
 are used to track pedigree information during evolution.
\end_layout

\begin_layout Itemize
A 
\family typewriter
CloneMating
\family default
 mating scheme is used to copy surviving individuals and a 
\family typewriter
RandomMating
\family default
 mating scheme is used to produce offspring.
\end_layout

\begin_layout Itemize

\family typewriter
IdTagger
\family default
 and 
\family typewriter
PedigreeTagger
\family default
 are used in the 
\family typewriter
ops
\family default
 parameter of 
\family typewriter
RandomMating
\family default
 because only new offspring should have a new ID and record parental IDs.
 If you use these operators in the 
\family typewriter
duringOps
\family default
 parameter of the 
\family typewriter
evolve
\family default
 function, individuals copied by 
\family typewriter
CloneMating
\family default
 will have a new ID, and a missing parental ID.
\end_layout

\begin_layout Itemize
The resulting population is age-structured so Pedigrees could be extracted
 from such a population.
\end_layout

\begin_layout Itemize
The penetrance function is age dependent.
 Because this penetrance function is applied to all individuals at each
 year and an individual will have the disease once he or she is affected,
 this penetrance function is more or less a hazard function.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ageStructured.log"
lstparams "caption={Example of the evolution of age-structured population.},label={ageStructured}"

\end_inset


\end_layout

\begin_layout Section
Tracing allelic lineage *
\end_layout

\begin_layout Standard
Lineage of alleles consists of information such as the distribution of alleles
 (how many people carry this allele, and the relationship between carriers)
 and age of alleles (when the alleles were introduced to the population).
 These information are important for the study of evolutionary history of
 mutants.
 They are not readily available for normal simulations, and even if you
 can track the generations when mutants are introduced, alleles in the present
 generation that are of the same type (Identity by Stat, IBS) do not necessarily
 have the same ancestral origin (Identity by Decent, IBD).
\end_layout

\begin_layout Standard
The lineage modules of simuPOP provides facilities to track allelic lineage.
 More specifically,
\end_layout

\begin_layout Itemize
Each allele is associated with an integer number (an allelic lineage) that
 identifies the origin, or the source of the allele.
\end_layout

\begin_layout Itemize
The lineage of each allele is transmitted along with the allele during evolution.
 New alleles will be introduced with their own lineage, even if they share
 the same states with existing alleles.
\end_layout

\begin_layout Itemize
Origin of alleles can be accessed using member functions of the 
\family typewriter
Individual
\family default
 and 
\family typewriter
Population
\family default
 classes.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "geneticContribution"

\end_inset

 demonstrates how to determine the contribution of genetic information from
 each ancestor.
 For this simulation, the alleles of each ancestor are associated with individua
l-specific numbers.
 During evolution, some alleles might get lost, some are copied, and pieces
 of chromosomes are mixed due to genetic recombination.
 At the end of simulation, the average number of 'contributors' of genetic
 information to each individual is calculated, as well as the percent of
 genetic information from each ancestor.
 Although this particular simulation can be mimicked using pure-genotype
 simulations by using special alleles for each ancestor, the combined informatio
n regarding the state and origin of each allele will be very useful for
 genetic studies that involve IBD and IBS.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/geneticContribution.log"
lstparams "caption={Contribution of genetic information from ancestors },label={geneticContribution}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "geneticContribution"

\end_inset

 uses operator 
\family typewriter
InitLineage
\family default
 to explictly assign lineage to alleles of each individual.
 You can also track the fate of finer genetic pieces by assigning different
 lineage values to chromosomes, or each loci using different 
\family typewriter
mode
\family default
.
 This operator can also assign lineage of alleles to an ID stored in an
 information field, which is usually 
\family typewriter
ind_id
\family default
, a field used by operators such as 
\family typewriter
IdTagger
\family default
 and 
\family typewriter
PedigreeTagger
\family default
 to assign and trace the pedigree (parentship) information during evolution.
 More interesting, when such a field is present, mutation operators will
 assign the IDs of recipients of mutants as the lineage of these mutants.
 This makes it possible to track the origin of mutants.
 Moreover, when a mode 
\family typewriter
FROM_INFO_SIGNED
\family default
 is used, additional ploidy information will be tagged to lineage values
 (negative values for mutants on the second homologous copy of chromosomes)
 so that you can track the inheritance of haplotypes.
\end_layout

\begin_layout Standard
To make use of these features, it is important to assign IDs to individuals
 before these operators are applied.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ageOfMutants"

\end_inset

 demonstrates how to use the lineage information to determine the age of
 mutants.
 This example evolves a constant population of size 10,000.
 An 
\family typewriter
IdTagger
\family default
 is used before 
\family typewriter
InitGenotype
\family default
 so individual IDs will be assigned as allelic lineages.
 Because all offspring get their own IDs during evolution, the IDs of individual
s are assigned to mutants as their lineages, and can be used to determine
 the age of these mutants.
 This is pretty easy to do in this example because of constant population
 size.
 For more complex demographic models, you might have to record the minimal
 and maximum IDs of each generation in order to determine the age of mutants.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ageOfMutants.log"
lstparams "caption={Distribution of age of mutants},label={ageOfMutants}"

\end_inset


\end_layout

\begin_layout Section
Pedigrees
\end_layout

\begin_layout Subsection
Create a pedigree object
\end_layout

\begin_layout Standard
A 
\family typewriter
Pedigree
\family default
 object is basically a static population object that is used to track relationsh
ip between individuals.
 An unique ID is required for all individuals so that individuals could
 be identified easily using their IDs.
 Individuals in a pedigree usually have one or two information fields to
 record the IDs of their parents.
 Operators 
\family typewriter
IdTagger
\family default
 and 
\family typewriter
PedigreeTagger
\family default
 are usually used to maintain these information fields which are, although
 customizable, almost always 
\family typewriter
ind_id
\family default
, 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
.
 After pedigrees are identified, population operations could be applied,
 for example, to extracted identified pedigrees from an existing population.
 This is basically how module 
\family typewriter
simuPOP.sampling
\family default
 works.
\end_layout

\begin_layout Standard
A new pedigree can be created from a population object with an ID field
 (default to 
\family typewriter
ind_id
\family default
), and two optional parental ID fields (default to 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
).
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ped = Pedigree(pop, infoFields=ALL_AVAIL)
\end_layout

\end_inset

will create a pedigree object from population 
\family typewriter
pop
\family default
 with information fields 
\family typewriter
ind_id
\family default
, 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
, copying all available information fields.
 The ID field should have an unique ID for each individual and the parental
 ID fields should record the ID of his or her parents.
 Genotype information and additional information fields can be copied to
 a pedigree object if needed.
 The population object is unchanged.
\end_layout

\begin_layout Standard
Another method is to directly convert a population object to a pedigree
 object, using member function 
\family typewriter
asPedigree
\family default
 of a population class.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.asPedigree()
\end_layout

\end_inset

will convert the existing population to a pedigree object.
 Object pop can then be able to call all pedigree member functions.
 Once your task is done, you can convert the object back to a population
 using the 
\family typewriter
Pedigree.asPopulation()
\family default
 member function of the object.
\end_layout

\begin_layout Standard
A pedigree object can also be created from a file saved by function 
\family typewriter
Pedigree.save()
\family default
 or operator 
\family typewriter
PedigreeTagger
\family default
 using function 
\family typewriter
loadPedigree
\family default
.
 Please refer to section 
\emph on
save and load pedigrees
\emph default
 in details.
\end_layout

\begin_layout Subsection
Locate close and remote relatives of each individual
\end_layout

\begin_layout Standard
A pedigree object provides several functions for you to identify spouse,
 sibling and more distant relatives of each individual.
 The results are stored to additional information fields of each individual.
 For example, if you would like to know the offspring of all individuals,
 you can call function 
\family typewriter
Pedigree.locateRelatives
\family default
 as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

offFields = ['off1', 'off2', 'off3']
\end_layout

\begin_layout Plain Layout

ped.addInfoFields(offFields)
\end_layout

\begin_layout Plain Layout

ped.locateRelatives(OFFSPRING, resultFields=offFields)
\end_layout

\end_inset

This function will locate up to 3 (determined by the length of 
\family typewriter
resultFields
\family default
) offspring of each individual and put their IDs in specified informaton
 fields.
 This function allows you to identify spouses (it is common to have multiple
 spouses when random mating is used), outbred spouse (exclude spouses who
 share at least one of the parents), offspring (all offspring) and common
 offspring with a specified spouse, siblings (share at least one parent)
 and full siblings (share two parents).
 It also allows you to limit the result by sex and affection status (e.g.
 find only affected female offspring).
\end_layout

\begin_layout Standard
More distant relationship can be derived from these relationship using function
 
\family typewriter
Pedigree.traceRelatives
\family default
.
 This function accepts a path of information fields and follows the path
 to identify relatives.
 For example 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sibFields = ['sib1', 'sib2']
\end_layout

\begin_layout Plain Layout

offFields = ['off1', 'off2', 'off3']
\end_layout

\begin_layout Plain Layout

cousinFields = ['cousin1', 'cousin2', 'cousin3']
\end_layout

\begin_layout Plain Layout

ped.addInfoFields(sibFields + offFields + cousinFields)
\end_layout

\begin_layout Plain Layout

ped.locateRelatives(FULLSIBLING, resultFields=sibFields)
\end_layout

\begin_layout Plain Layout

ped.locateRelatives(OFFSPRING, resultFields=offFields)
\end_layout

\begin_layout Plain Layout

ped.traceRelatives([['father_id', 'mother_id'], sibFields, offFields],
\end_layout

\begin_layout Plain Layout

    sex=[ANY_SEX, MALE_ONLY, FEMALE_ONLY],
\end_layout

\begin_layout Plain Layout

    resultField=cousinFields)
\end_layout

\end_inset

would first identify full siblings and offspring of all individuals and
 then locate father or mother's male sibling's daughters.
 As you can imagine, this function can be used to track very complicated
 relationships.
\end_layout

\begin_layout Standard
This function also provides a function for you to identify individuals with
 specified relatives.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "locateRelative"

\end_inset

 gives an example how to locate a grandfather with at least five grandchildren.
 With such information, functions such as 
\family typewriter
Population.extractIndividuals()
\family default
 could be used to extract Pedigrees from a population.
 This is basically how 
\family typewriter
simuPOP.sampling
\family default
 module works.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/locateRelative.log"
lstparams "caption={Locate close and distant relatives of individuals},label={locateRelative}"

\end_inset


\end_layout

\begin_layout Subsection
Identify pedigrees (related individuals)
\end_layout

\begin_layout Standard
The 
\family typewriter
Pedigree
\family default
 class provides some other functions that allows you to identify related
 individuals.
 For example,
\end_layout

\begin_layout Itemize
Function 
\family typewriter
Pedigree.identifyAncestors
\family default
 identifies all ancestors of specified individuals or all individuals at
 the present generation.
 In a diaploid population when there is only one parent, you can see that
 only a small portion of ancestors have offspring in the last generation.
\end_layout

\begin_layout Itemize
Function 
\family typewriter
Pedigree.identifyOffspring
\family default
 identifies all offspring of specified individuals across multiple generations.
 
\end_layout

\begin_layout Itemize
Function 
\family typewriter
Pedigree.identifyFamilies
\family default
 groups all related individuals into families and assign a family ID to
 all family members.
 You might be surprised by how large this kind of family can be when parents
 are allowed to have multiple spouses.
 
\end_layout

\begin_layout Standard
All these functions support parameters 
\family typewriter
subPops
\family default
 and 
\family typewriter
ancGens
\family default
 so that you can limit your search in specific subpopulations and ancestral
 generations.
 For example, you can limit your search to all male individuals to find
 out someone's male offspring.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "locateFamilies"

\end_inset

 demonstrates how to use these functions to analyze the structure of a complete
 pedigree.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/locateFamilies.log"
lstparams "caption={Identify all ancestors, offspring or all related individuals},label={locateFamilies}"

\end_inset


\end_layout

\begin_layout Subsection
Save and load pedigrees
\end_layout

\begin_layout Standard
A complete pedigree, including ID, sex and affection status of each individual,
 IDs of their parents, and optionally values of some information fields
 and genotypes at some loci could be saved to a file, and be loaded using
 function 
\family typewriter
loadPedigree
\family default
.
 The loaded pedigree could be analyzed using pedigree functions, or be used
 to direct the evolution of another evolutionary process using a pedigree
 mating scheme.
\end_layout

\begin_layout Standard
A pedigree could be saved in two ways.
 In the first method, a pedigree could be created using the methods described
 above and be saved using function 
\family typewriter
Pedigree.save()
\family default
.
 However, if the population is large, recording all ancestral generations
 may not be feasible.
 If this is the case, you can use a 
\family typewriter
PedigreeTagger
\family default
 operator to save individual information during the evolution.
 If you do not care about details of the top-most ancestral generation,
 a PedigreeTagger used in a mating scheme should be enough to record pedigree
 information of all offspring.
 Individual in the top-most generation who have offspring in the next generation
 will be constructed in 
\family typewriter
loadPedigree
\family default
.
 If you would like to include detailed information about all individuals
 in the top-most ancestral generation, you can use a 
\family typewriter
PedigreeTagger
\family default
 in the 
\family typewriter
initOps
\family default
 parameter of the 
\family typewriter
Simulator.evolve()
\family default
 or 
\family typewriter
Population.evolve()
\family default
 function.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveLoadPedigree"

\end_inset

 demonstrates how to use these functions to analyze the structure of a complete
 pedigree.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/saveLoadPedigree.log"
lstparams "caption={Save and load a complete pedigree},label={saveLoadPedigree}"

\end_inset


\end_layout

\begin_layout Section
Evolve a population following a specified pedigree structure **
\end_layout

\begin_layout Standard
There are some applications where you would like to repeat the same evolutionary
 process repeatedly using the same pedigree structure.
 For example, a gene-dropping simulation method basically initialize leaves
 of a pedigree with random genotypes and pass the genotypes along the pedigree
 according to Mendelian laws.
 This can be done in simuPOP using a pedigree mating scheme.
\end_layout

\begin_layout Standard
A pedigree mating scheme 
\series bold
PedigreeMating
\series default
 evolves a population following an existing pedigree structure.
 If the  
\family typewriter
Pedigree
\family default
 object has 
\family typewriter
N
\family default
 ancestral generations and a present generation, it can be used to evolve
 a population for 
\family typewriter
N
\family default
 generations, starting from the topmost ancestral generation.
 At the 
\emph on
k
\emph default
-th generation, this mating scheme produces an offspring generation according
 to subpopulation structure of the 
\family typewriter
N-k-1
\family default
 ancestral generation in the pedigree object (e.g.
 producing the offspring population of generation 0 according to the 
\family typewriter
N-1
\family default
 ancestral generation of the pedigree object).
 For each offspring, this mating scheme copies individual ID and sex from
 the corresponing individual in the pedigree object.
 It then locates the parents of each offspring using their IDs in the pedigree
 object.
 A list of during mating operators are then used to transmit parental genotype
 to the offspring.
\end_layout

\begin_layout Standard
To use this mating scheme, you should 
\end_layout

\begin_layout Itemize
Prepare a pedigree object with 
\family typewriter
N
\family default
 ancestral generations (and a present generation).
 Parental information should be available at the present, parental, ..., and
 
\family typewriter
N-1
\family default
 ancestral generations.
 This object could be created by evolving a population with 
\family typewriter
ancGen
\family default
 set to -1 with parental information tracked by operators 
\family typewriter
idTagger()
\family default
 and 
\family typewriter
pedigreeTagger()
\family default
.
\end_layout

\begin_layout Itemize
Prepare the population so that it contains individuals with IDs matching
 this generation, or at least individuals who have offspring in the next
 topmost ancestral generation.
 Because individuals in such a population will parent offsprings at the
 
\family typewriter
N-1
\family default
 ancestral generation of the pedigree object, it is a good idea to assign
 
\family typewriter
ind_id
\family default
 using 
\family typewriter
ped.indInfo('father_id')
\family default
 and 
\family typewriter
ped.infInfo('mother_id')
\family default
 of the 
\family typewriter
N-1
\family default
 ancestral generation of 
\family typewriter
ped
\family default
.
\end_layout

\begin_layout Itemize
Evolve the population using a 
\family typewriter
PedigreeMating
\family default
 mating scheme for 
\family typewriter
N
\family default
 or less generations.
 Because parents are chosen by their IDs, subpopulation structure is ignored
 and migration will have no effect on the evolutionary process.
 No 
\family typewriter
IdTagger
\family default
 should be used to assign IDs to offspring because re-labeling IDs will
 confuse this mating scheme.
 This mating scheme copies individual sex from pedigree individual to each
 offspring because individual sex may affect the way genotypes are transmitted
 (e.g.
 a 
\family typewriter
MendelianGenoTransmitter()
\family default
 with sex chromosomes).
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pedigreeMating"

\end_inset

 demonstrates how to create a complete pedigree by evolving a population
 without genotype, and then replay the evolutionary process using another
 population.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pedigreeMating.log"
lstparams "caption={Use a pedigree mating scheme to replay an evolutionary process.},label={pedigreeMating}"

\end_inset


\end_layout

\begin_layout Standard
As long as unique IDs are used for individuals in different generations,
 the same technique could be used for overlapping generations as well.
 Even if some individuals are copied from generation to generation, separate
 IDs should be assigned to these individuals so that a pedigree could be
 correctly constructed.
 Because these individuals are copied from a single parent, the pedigree
 object will have mixed number of parents (some individuals have one parent,
 some have two).
 If 
\family typewriter
PedigreeTagger
\family default
 operators are used to record parental information, such a pedigree could
 be loaded by function 
\family typewriter
loadPedigree
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pedigreeMatingAgeStructured"

\end_inset

 evolves an age-structured population.
 Instead of saving all ancestral generations to a population object and
 convert it to a pedigree, this example saves the complete pedigree to file
 
\family typewriter
structure.ped
\family default
 and load the pedigree using function 
\family typewriter
loadPedigree
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pedigreeMatingAgeStructured.log"
lstparams "caption={Replay an evolutionary process of an age-structured population},label={pedigreeMatingAgeStructured}"

\end_inset


\end_layout

\begin_layout Standard
The pedigree is then used to repeat the evolutionary process.
 However, because some individuals were produced sexually using 
\family typewriter
MendelianGenoTransmitter
\family default
 and some were copied using 
\family typewriter
CloneGenoTransitter
\family default
, an 
\family typewriter
IfElse
\family default
 operator has to be used to transmit genotypes correctly.
 This example uses the function condition of the 
\family typewriter
IfElse
\family default
 operator and makes use of the fact that parent 
\family typewriter
mom
\family default
 will be 
\family typewriter
None
\family default
 if an individual is copied from his or her father.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "simuPOP"
options "plainnat"

\end_inset


\end_layout

\begin_layout Section
Simulation of mitochondrial DNAs (mtDNAs) *
\end_layout

\begin_layout Standard
Mitochondrial DNAs resides in human mitochondrion.
 A zygote inherits its organelles from the cytoplasm of the egg, and thus
 organelle inheritance is generally maternal.
 Whereas there is only one copy of a nuclear chromosome per gamete, there
 are man copies of an organellar chromosome, forming a population of identical
 organelle chromosomes that is transmitted to the offspring through the
 egg.
 Because these organellar chromosomes are identical, they are modelled in
 simuPOP as a single chromosome with type 
\family typewriter
MITOCHONDRIAL
\family default
.
 In order to simulate mitochondrial DNAs, it is important to remember:
\end_layout

\begin_layout Itemize

\family typewriter
MendelianGenoTransmitter
\family default
 and 
\family typewriter
Recombinator
\family default
 do not handle mitochondrial DNAs so you will have to explicitly use 
\family typewriter
MitochondrialGenoTransmitter
\family default
 to transmit the mitochondrial DNAs from mother to offspring.
 Note that 
\family typewriter
CloneGenoTransmitter
\family default
 is a special transmitter that will copy everything including sex, information
 fields to offspring.
\end_layout

\begin_layout Itemize
The 
\family typewriter
Stat
\family default
 operator recognizes this chromosome type and will report allele, haplotype,
 and genotype counts, and other statistics correctly, although some diploid-spec
ific statistics are not applicable.
\end_layout

\begin_layout Itemize
Natural selections on mtDNAs is usually performed using operator 
\family typewriter
MapSelector
\family default
 where single alleles are assigned a fitness value.
 Operator 
\family typewriter
MaSelector
\family default
 assumes two alleles and is not applicable.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mitochondrial"

\end_inset

 demonstrates the use of a 
\family typewriter
Recombinator
\family default
 to recombine an autosome and two sex chromosomes, and a 
\family typewriter
MitochondrialGenoTransmitter
\family default
 to transmit mitochondrial chromosomes.
 Natural selection is applied to allele 3 at the 3rd locus on the mitochondrial
 DNA, whose frequency in the population decreases as a result.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mitochondrial.log"
lstparams "caption={Transmission of mitochondrial chromosomes},label={mitochondrial}"

\end_inset


\end_layout

\begin_layout Standard
You might wonder how a mutation can change the allele of all organelles
 in the mitochondrion.
 This is generally believed to be done through natural drift during cytoplasmic
 segreagation, which is not a mitotic process because it takes place in
 dividing asexual cells.
 Because only one mitochondrial chromosome is allowed in simuPOP, you will
 have to use customized chromosome types if you would like to simulate this
 process.
 Fortunately, operator 
\family typewriter
MitochondrialGenoTransmitter
\family default
 can select random organelles from multiple customized chromosomes, if no
 chromosome of type 
\family typewriter
MITOCHONDRIAL
\family default
 is present.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mtDNA_evolve"

\end_inset

 demonstrates the fixation of mutant in cells with multiple organelles.
 Althogh mutations are introduced to only one of the organelles, after a
 number of cell divisions, the majority of the cells now have only one type
 of allele.
 This example uses a 
\family typewriter
RandomSelection
\family default
 mating scheme to select cells randomly from the parental population.
 Because no sexual reproduction is involved, 
\family typewriter
MitochondrialGenoTransmitter
\family default
 passes the parental genotype to offspring regardless of sex of parent.
 This example also demonstrates a disadvantage of using customized chromosomes
 in that you will have to calculate statistics by yourself because only
 you know the meaning of these chromosomes.
 In this example, a function is written to count the number of mutants in
 each cell (individual), and summarize the number of cells with 0, 1, 2,
 3, 4, and 5 copies of the mutant.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/mtDNA_evolve.log"
lstparams "caption={Evolution of multiple organelles in mitochondrion},label={mtDNA_evolve}"

\end_inset


\end_layout

\begin_layout Chapter
Utility Modules 
\begin_inset CommandInset label
LatexCommand label
name "cha:Utility-Modules"

\end_inset


\end_layout

\begin_layout Section
Module 
\family typewriter
simuOpt
\family default
 (function 
\family typewriter
simuOpt.setOptions
\family default
)
\end_layout

\begin_layout Standard
Module 
\family typewriter
simuOpt
\family default
 handles options to specify which simuPOP module to load and how this module
 should be loaded, using function 
\family typewriter
simuOpt.setOptions 
\family default
with parameters 
\emph on
alleleType
\emph default
 (
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
, or 
\family typewriter
binary
\family default
 ), 
\emph on
optimized
\emph default
 (
\family typewriter
standard
\family default
 or 
\family typewriter
optimized
\family default
), 
\emph on
gui
\emph default
 (whether or not use a graphical user interface and which graphical toolkit
 to use), 
\emph on
revision
\emph default
 
\family typewriter
(
\family default
minimal required version/revision), 
\emph on
quiet
\emph default
 (with or without banner message, and 
\emph on
debug
\emph default
 (which debug code to turn on).
 These options have been discussed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 and other related sections.
 Note that 
\series bold
most options can be set by environmental variables and command line options
\series default
 which are sometimes more versatile to use.
\end_layout

\begin_layout Subsection
Class 
\family typewriter
simuOpt.Params
\family default
 (deprecated)
\end_layout

\begin_layout Standard
The 
\family typewriter
simuOpt
\family default
 module also provides a class 
\family typewriter
Params
\family default
 to help users handle and manage script parameters.
 There are many other standard or third-party parameter handling modules
 in Python but this class is designed to help users run a simuPOP script
 in both batch and GUI modes, using a combination of parameter determination
 methods.
 More specifically, if a script uses the 
\family typewriter
simuOpt.Params
\family default
 class to handle parameters,
\end_layout

\begin_layout Itemize
By default, a parameter input dialog is used to accept user input if the
 script is executed directly.
 Default values are given to each parameter and users are allowed to edit
 them using standard parameter input widgets (on/off button, edit box, dropdown
 list etc).
 Detailed explanations to parameters are available as tooltips of corresponding
 input widgets.
 A help button is provided that will display the usage of the script when
 clicked.
\end_layout

\begin_layout Itemize
If a configuration file is saved for a previous simulation, command line
 option 
\family typewriter
--config configFile
\family default
 can be used to load all parameters from that configuration file.
 The parameter input dialog is still used to review and modify parameters.
\end_layout

\begin_layout Itemize
Each parameter can also be set using command line options.
 Command line inputs will override values read from a configuration file.
\end_layout

\begin_layout Itemize
If command line option 
\family typewriter
--gui=interactive
\family default
 is given, the script will work in batch mode.
 If the value of a parameter cannot be determined through command line or
 a configuration file, and is set not to use its default value, users will
 be asked to enter its value interactively.
 For example, 
\family typewriter
myscript.py --gui=interactive --config configFile
\family default
 will execute a previous simulation directly.
\end_layout

\begin_layout Itemize
Using 
\family typewriter
--gui=batch
\family default
, the script will use all default variables unless some of them are specified
 from command line arguments.
\end_layout

\begin_layout Standard

\series bold
NOTE:
\series default
 
\family typewriter
simuOpt.Params
\family default
 was designed when 
\family typewriter
getopt
\family default
 was the only parameter handling module of python.
 Although it still has some unique features (gui mode, validation etc) compared
 to the newly introduced standard module 
\family typewriter
argparse
\family default
, it is less extensible and powerful than 
\family typewriter
argparse
\family default
.
 
\series bold
This class is therefore deprecated although it will be kept in simuPOP for
 backward-compatibility reasons.
\end_layout

\begin_layout Standard
The following sections describes how to use the 
\family typewriter
simuOpt
\family default
 class in a simuPOP script.
\end_layout

\begin_layout Subsubsection
Define a parameter specification list.
\end_layout

\begin_layout Standard
A 
\family typewriter
Params
\family default
 object is created from a list of parameter specification dictionaries,
 and optional short and long descriptions of a script.
 Each parameter specification dictionary consits of the following fields:
\end_layout

\begin_layout Itemize

\family typewriter
name
\family default
 (required): This field specifies the name of the argument.
 The argument can be specified from a commandline using 
\family typewriter
--name=value
\family default
, or 
\family typewriter
--name
\family default
 if this argument is of a boolean type.
\end_layout

\begin_layout Itemize

\family typewriter
default
\family default
 (required): default value for this parameter.
\end_layout

\begin_layout Itemize

\family typewriter
type
\family default
 (optional): Type of acceptable input, which can be 
\family typewriter
'boolean'
\family default
, 
\family typewriter
'integer'
\family default
, 
\family typewriter
'integers',
\family default
 
\family typewriter
'number'
\family default
, 
\family typewriter
'numbers'
\family default
, 
\family typewriter
'string'
\family default
, 
\family typewriter
'strings'
\family default
, 
\family typewriter
'filename'
\family default
, 
\family typewriter
'dirname'
\family default
, 
\family typewriter
('chooseOneOf', values)
\family default
, 
\family typewriter
('chooseFrom', values)
\family default
, and a list of acceptable types (e.g.
 
\family typewriter
types.ListType
\family default
).
 This type determines the GUI widget to accept a parameter (e.g.
 a checkbox for boolean type, and a listbox for choosing one or more values
 from list, a file browser to browser for filename), how to convert user
 input to appropriate format (e.g.
 convert a string to float and a single value to a list), and how to validate
 a parameter (e.g.
 a valid filename).
\end_layout

\begin_layout Itemize

\family typewriter
label
\family default
 (optional): A label to display in the parameter input dialog (when 
\family typewriter
--gui=True
\family default
) and as prompt for user input (when 
\family typewriter
--gui=False
\family default
).
 If this field is missing, a parameter will not be displayed in the parameter
 input dialog.
\end_layout

\begin_layout Itemize

\family typewriter
description
\family default
 (optional): A detailed description of the parameter, which will be displayed
 as tooltip of the parameter in the parameter input dialog, and be used
 to generate help messages of the script.
\end_layout

\begin_layout Itemize

\family typewriter
validator
\family default
 (optional): A function or an expression to validate if a user input is
 valid
\family typewriter
.
\end_layout

\begin_layout Standard
Field 
\family typewriter
validator
\family default
 is very useful in that it helps simuPOP determine whether or not a user
 input should be accepted.
 It accepts a function or an expression.
 Module 
\family typewriter
simuOpt
\family default
 defines a number of functions that you can use.
 For example, if a parameter defines a probability, you might want to use
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuOpt.valueBetween(0, 1)
\end_layout

\end_inset

to validate if the input is between 0 and 1.
 If a list of probabilities is needed, you can use 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuOpt.valueListOf(simuOpt.valueBetween(0, 1))
\end_layout

\end_inset

More complex logics can be defined using 
\family typewriter
simuOpt.valueOr
\family default
 or 
\family typewriter
simuOpt.valueAnd
\family default
.
 If validation of one parameter involves the values of other parameters,
 a Python expression can be used.
 For example, if two parameters need to have the same length, you can use
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'len(opt1) == len(opt2)'
\end_layout

\end_inset

to validate 
\family typewriter
opt1
\family default
 or 
\family typewriter
opt2
\family default
.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 shows a parameter specification list that defines parameter 
\family typewriter
help
\family default
, 
\family typewriter
rate
\family default
, 
\family typewriter
rep
\family default
 and 
\family typewriter
pops
\family default
.
 What is special about each parameter is that 
\family typewriter
help
\family default
 will not be listed in the parameter input dialog (no 
\family typewriter
label
\family default
) and setting 
\family typewriter
help
\family default
 to 
\family typewriter
True
\family default
 during interactive parameter input will ignore all other options (
\family typewriter
jump
\family default
); 
\family typewriter
rate
\family default
 has to be between 0 and 1 (using a validation function 
\family typewriter
valueBetween
\family default
), 
\family typewriter
rep
\family default
 has to be a positive integer, and 
\family typewriter
pops
\family default
 can be one of the three HapMap populations.
 Please refer to the simuPOP reference manual for details about each dictionary
 key.
 The 
\family typewriter
description
\family default
 of parameter 
\family typewriter
pop
\family default
 demonstrates a special rule in the formatting of such description texts,
 namely 
\series bold
lines with symbol '|' as the first non-space/tab character are outputed
 as a separate line without the leading '|' character.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.py"
lstparams "caption={A sample parameter specification list},label={paramSpec},lastline=34"

\end_inset


\end_layout

\begin_layout Standard
If you dislike an explicit list of dictionaries, you can use function 
\family typewriter
simuOpt.addOption
\family default
 to add options one by one.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "paramFunc"

\end_inset

 shows an equivalent way of specifying three options using this function.
 This style is used by Python modules such as 
\family typewriter
optparse
\family default
 and 
\family typewriter
argparse
\family default
, and is preferred by some simuPOP users.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/paramFunc.py"
lstparams "caption={Using simuOpt.param to specify parameters},label={paramFunc}"

\end_inset


\end_layout

\begin_layout Subsubsection
Get parameters (function 
\family typewriter
Params.getParam
\family default
)
\end_layout

\begin_layout Standard
A 
\family typewriter
Params
\family default
 object can be created from a parameter specification list.
 A few member functions are immediately usable.
 For example, 
\family typewriter
Params.usage()
\family default
 returns a detailed usage message about the script and all its parameters
 (although the usage message will be displayed automatically if command
 line option 
\family typewriter
-h
\family default
 or 
\family typewriter
--help
\family default
 is detected).
 The parameters become attributes of this object using 
\family typewriter
longarg
\family default
 names so that you can access them easily (e.g.
 
\family typewriter
par.rate
\family default
).
 Not surprosingly, all parameters now have the default value you assigned
 to them.
\end_layout

\begin_layout Standard
Function 
\family typewriter
Params.saveConfig(filename)
\family default
 saves current values of parameters to a configuraiton file 
\family typewriter
filename
\family default
.
 Parameters that do not have a label are ignored.
 This configuration file can be loaded later using command line option 
\family typewriter
--config filename
\family default
, perhaps with option 
\family typewriter
--gui=False
\family default
 to run the script in batch mode.
 A less noticed feature of this function is that it also writes a complete
 command that specifies the same parameters using command line options.
 This can be handy if you would like to use real parameter definitions instead
 of 
\family typewriter
--config filename
\family default
 in a batch file.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
params.Params
\family default
 class provides a number of member functions that allow you to acquire user
 input in a number of ways.
 For example 
\family typewriter
Params.loadConfig
\family default
 reads a configuration file, 
\family typewriter
Params.processArgs
\family default
 checks commandline options, 
\family typewriter
Params.termGetParam
\family default
 asks user input interactively, and 
\family typewriter
Params.guiGetParam
\family default
 generates and uses a parameter input dialog.
 These functions can be used several times, on different sets of parameters.
 In addition, new options could be added programmatically using function
 
\family typewriter
Params.addOption
\family default
 and allows further flexibility on how parameters are generated.
 Please refer to 
\emph on
the simuPOP reference manual
\emph default
 on how to use these functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Get prameters using function getParam},firstline=35,keywordstyle={\\small\\ttfamily},label={getParam},lastline=69"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 lists some methods to determine parameter values but the last function,
 
\family typewriter
Params.getParam()
\family default
, will be used most of the time.
 This function processes each parameter in the following order:
\end_layout

\begin_layout Itemize
If a short or a long command line argument exists, use the command line
 argument.
\end_layout

\begin_layout Itemize
If a configuration file is specified from command line (
\family typewriter
--config configFile
\family default
), look in this configuration file for a value.
\end_layout

\begin_layout Itemize
If 
\family typewriter
useDefault
\family default
 is specified, assign a default value to this parameter.
\end_layout

\begin_layout Itemize
If 
\family typewriter
--gui=False
\family default
 is specified, and the value of the parameter has not be determined, ask
 users interactively for a value.
 Otherwise, a parameter input dialog is displayed.
 A 
\emph on
Tkinter
\emph default
 dialog is usually used but a 
\emph on
wxPython
\emph default
 dialog will be used if 
\emph on
wxPython
\emph default
 is available (unless parameter 
\family typewriter
--gui=Tkinter
\family default
 is set).
\end_layout

\begin_layout Standard

\family typewriter
Params.getParam
\family default
 returns 
\family typewriter
False
\family default
 if this process fails (e.g.
 users click cancel in the parameter input dialog).
 The parameter input dialog for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

 is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parameter-input-dialog"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:parameter-input-dialog"

\end_inset

A sample parameter input dialog
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/getParam.png
	width 50line%

\end_inset


\end_layout

\begin_layout Plain Layout
A parameter input dialog for a script that uses the same parameter specification
 list as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "getParam"

\end_inset

.
 The command line is 
\family typewriter
simu.py --pop=YRI
\family default
.
 The first parameter is in red because its input is invalid.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Access, manipulate and extract parameters
\end_layout

\begin_layout Standard
If 
\family typewriter
Params.getParam
\family default
 runs successfully, the 
\family typewriter
Params
\family default
 object should have valid value for each parameter.
 They can be retrieved as attributes (such as 
\family typewriter
par.rate
\family default
) and manipulated easily.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "useSimuOpt"

\end_inset

 demonstrates how to extend parameter 
\family typewriter
par.rate
\family default
 to have the same length as 
\family typewriter
par.rep
\family default
.
 
\end_layout

\begin_layout Standard
When there are a large number of parameters, passing this 
\family typewriter
Params
\family default
 object, instead of tens of parameters, is a good way to provide clean interface
s.
 Alternatively, you can get a list or a dictionary of parameters using member
 functions 
\family typewriter
Params.asList()
\family default
 and 
\family typewriter
Params.asDict()
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/getParam.log"
lstparams "caption={Use the simuOpt object},firstline=70,label={useSimuOpt}"

\end_inset


\end_layout

\begin_layout Standard
It is easy to set 
\series bold
additional attributes
\series default
 to a 
\family typewriter
Params
\family default
 object, using either 
\family typewriter
par.name = value
\family default
 statement or additional 
\family typewriter
name=value
\family default
 pairs in the constructor of a 
\family typewriter
simuOpt
\family default
 object.
 These attributes are not considered as parameters of an 
\family typewriter
simuOpt
\family default
 object (e.g.
 they are not returned by function 
\family typewriter
Params.asDict()
\family default
) but could be used just like regular parameters.
 
\end_layout

\begin_layout Standard
Additional attributes can be used to create a 
\family typewriter
Params
\family default
 object without user interaction.
 For example, objects 
\family typewriter
par1
\family default
 and 
\family typewriter
par2
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "useSimuOpt"

\end_inset

 are created with needed attributes.
 They can be passed to functions where a 
\family typewriter
Params
\family default
 object is needed, although some of the attributes are not real parameters
 (in the sense that they are not created by a parameter specification dictionary
 and will not be used to handle user input).
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.utils
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.utils
\family default
 module provides a few utility functions and classes.
 They do not belong to the simuPOP core but are distributed with simuPOP
 because they are frequently used and play an important role in some specialized
 simulation techniques.
 Please refer to the simuPOP online cookbook (
\family typewriter
http://simupop.sourceforge.net/cookbook
\family default
) for more utility modules and functions.
\end_layout

\begin_layout Subsection
Trajectory simulation (classes 
\family typewriter
Trajectory
\family default
 and 
\family typewriter
TrajectorySimulator
\family default
)
\end_layout

\begin_layout Standard
A forward-time simulation, by its nature, is directly influenced by random
 genetic drift.
 Starting from the same parental generation, allele frequencies in the offspring
 generation would vary from simulation to simulation, with perhaps a predictable
 mean frequency which is determined by factors such as parental allele frequency
, natural selection, mutation and migration.
\end_layout

\begin_layout Standard
Genetic drift is unavoidable and is in many cases the target of theoretical
 and simulation studies.
 However, in certain types of studies, there is often a need to control
 the frequencies of certain alleles in the present generation.
 For example, if we are studying a particular penetrance model with pre-specifie
d frequencies of disease predisposing alleles, the simulated populations
 would better have consistent allele frequencies at the disease predisposing
 loci, and consequently consistent disease prevalence.
\end_layout

\begin_layout Standard
simuPOP provides a special offspring generator 
\family typewriter
ControlledOffspringGenerator
\family default
 and an associated mating scheme called 
\family typewriter
ControlledRandomMating
\family default
 that can be used to generate offspring generations conditioning on frequencies
 of one or more alleles.
 This offspring generator essentially uses a reject-sampling algorithm to
 select (or reject) offspring according to their genotypes at specified
 loci.
 A detailed description of this algorithm is given in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

.
\end_layout

\begin_layout Standard
The controlled random mating scheme accepts a user-defined trajectory function
 that tells the mating scheme the desired allele frequencies at each generation.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "controlledOffGenerator"

\end_inset

 uses a manually defined function that raises the frequency of an allele
 steadily.
 However, given known demographic and genetic factors, 
\series bold
a trajectory should be simulated randomly so that it represents a random
 sample from all possible trajectories that match the allele frequency requireme
nt
\series default
.
 If such a condition is met, the controlled evolutionary process can be
 considered as a random process conditioning on allele frequencies at the
 present generation.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007a"

\end_inset

 for a detailed discussion about the theoretical requirements of a valid
 trajectory simulator.
\end_layout

\begin_layout Standard
The 
\family typewriter
simuUtil
\family default
 module provides functions and classes that implement two trajectory simulation
 methods that can be used in different situations.
 The first class is 
\family typewriter
TrajectorySimulator
\family default
 which takes a demographic model and a selection model as its input and
 simulates allele frequency trajectories using a forward or backward algorithm.
 The demographic model is given by parameter 
\family typewriter
N
\family default
, which can be a constant (e.g.
 
\family typewriter
N=1000
\family default
) for constant population size, a list of subpopulation sizes (e.g.
 
\family typewriter
N=[1000, 2000]
\family default
) for a structured population with constant size, or a demographic function
 that returns population or subpopulation sizes at each generation.
 In the last case, subpopulations can be split or merged with the constrait
 that subpopulations can be merged into one, from split from one population.
\end_layout

\begin_layout Standard
A fitness model specifies the fitness of genotypes at one or more loci using
 parameter 
\family typewriter
fitness
\family default
.
 It can be a list of three numbers (e.g.
 
\family typewriter
fitness=[1, 1.001, 1.003]
\family default
), repsenting the fitness of genotype 
\family typewriter
AA
\family default
, 
\family typewriter
Aa
\family default
 and 
\family typewriter
aa
\family default
 at one or more loci; or different fitness for genotypes at each locus (e.g.
 
\family typewriter
fitness=[1, 1.001, 1.003, 1, 1, 1.002]
\family default
), or for each combination or genotype (interaction).
 In the last case, 
\begin_inset Formula $3^{n}$
\end_inset

 values are needed for each genotype if there are 
\begin_inset Formula $n$
\end_inset

 loci.
 This trajectory simulator also accepts generation-specific fitness values
 by accepting a function that returns fitness values at each generation.
\end_layout

\begin_layout Standard
The simulator then simulates trajectories of allele frequencies and return
 them as objects of class 
\family typewriter
Trajectory
\family default
.
 This object can be used provide a trajectory function that can be used
 directly in a 
\family typewriter
ControlledRandomMating
\family default
 mating scheme (function 
\family typewriter
Trajectory.func()
\family default
) or provide a list of 
\family typewriter
PointMutator
\family default
 to introduce mutants at appropriate generations (function 
\family typewriter
Trajectory.mutators()
\family default
).
 If a simulation failed after specified number of attempts, a 
\family typewriter
None
\family default
 object will be returned.
\end_layout

\begin_layout Subsubsection
Forward-time trajectory simulations (function 
\family typewriter
simulateForwardTrajectory
\family default
)
\end_layout

\begin_layout Standard
A forward simulation starts from a specified generation with specified allele
 frequencies at one or more loci.
 The simulator simulates allele frequencies forward-in-time, until it reaches
 a specified ending generation.
 A trajectory object will be returned if the simulated allele frequencies
 fall into specified ranges.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "forwardTrajectory"

\end_inset

 demonstrates how to use this simulation method to obtain and use a simulated
 trajectory, for two unlinked loci under different selection pressure.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/forwardTrajectory.log"
lstparams "caption={Simulation and use of forward-time simulated trajectories.},label={forwardTrajectory}"

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:forwardTrajectory"

\end_inset

 plots simulated trajectories of one locus in two subpopulations.
 The plot function uses either rpy or matplotlib as the underlying plotting
 library.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:forwardTrajectory"

\end_inset

Simulated trajectories of one locus in two subpopulations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/forwardTrajectory.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Backward-time trajectory simulations (function 
\family typewriter
simulateBackwardTrajectory
\family default
).
\end_layout

\begin_layout Standard
A backward simulation starts from specified frequencies at the present generatio
n.
 In the single-allele case, the simulations goes backward-in-time until
 an allele gets lost.
 The length of such a trajectory is random, which is usually a desired property
 because the age of a mutant in the present generation is usually unknown
 and is assumed to be random.
\end_layout

\begin_layout Standard
This trajectory simulation technique is usually used as follows:
\end_layout

\begin_layout Enumerate
Determine a demographic and a natural selection model using which a forward-time
 simulation will be performed.
\end_layout

\begin_layout Enumerate
Given current disease allele frequencies, simulate trajectories of allele
 frequencies at each DSL using a backward approach.
\end_layout

\begin_layout Enumerate
Evolve a population forward-in-time, using designed demographic and selection
 models.
 A 
\family typewriter
ControlledRandomMating
\family default
 scheme instead of the usual 
\family typewriter
RandomMating
\family default
 scheme should be used.
 
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:backTrajectory"

\end_inset

 plots simulated trajectories of two unlinked loci.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:backTrajectory"

\end_inset

Simulated trajectories of two unlinked loci
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/backTrajectory.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The trajectory is used in a 
\family typewriter
ControlledRandomMating
\family default
 scheme in the following evolutionary scenario:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/backTrajectory.log"
lstparams "caption={Simulation and use of backward-time simulated trajectories.},label={backTrajectory}"

\end_inset


\end_layout

\begin_layout Subsection
Graphical or text-based progress bar (class 
\family typewriter
ProgressBar
\family default
)
\end_layout

\begin_layout Standard
If your simulation takes a while to finish, you could use a progress bar
 to indicate its progress.
 The 
\family typewriter
ProgressBar
\family default
 class is provided for such a purpose.
 Basically, you create a 
\family typewriter
ProgressBar
\family default
 project with intended total steps, and calls its 
\family typewriter
update
\family default
 member function with each progress.
 Depending on available graphical toolkit and the global or local GUI settings,
 a 
\family typewriter
wxPython
\family default
 based dialog, a 
\family typewriter
Tkinter
\family default
 based dialog, or a text-based dialog will be used.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ProgressBar"

\end_inset

 demonstrates how to use a text-based progress bar.
 If the progress bar is updated at each step (such as in this example),
 function 
\family typewriter
update()
\family default
 can be called without parameter because it updates the progress bar at
 an increment of 1 in this case.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ProgressBar.log"
lstparams "caption={Using a text-based progress bar},label={ProgressBar}"

\end_inset


\end_layout

\begin_layout Subsection
Display population variables (function 
\family typewriter
viewVars
\family default
)
\end_layout

\begin_layout Standard
If a population has a large number of variables, or if you are not sure
 which variable to output, you could use function 
\family typewriter
viewVars
\family default
 to view the population variables in a tree form.
 If wxPython is available, a dialog could be used to view the variables
 interactively.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "viewVars"

\end_inset

 demonstrates how to use this function.
 The wxPython-based dialog is displayed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "viewVars"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/viewVars.py"
lstparams "caption={Using function viewVars to display population variables},label={viewVars}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:viewvars"

\end_inset

Using wxPython to display population variables
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/viewVars.png
	lyxscale 30
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Import simuPOP population from files in 
\family typewriter
GENEPOP, PHYLIP
\family default
 and 
\family typewriter
FSTAT
\family default
 formats (function 
\family typewriter
importPopulation
\family default
)
\end_layout

\begin_layout Standard
A function importPopulation is provided in the 
\family typewriter
simuPOP.utils
\family default
 module to import populations from files in 
\family typewriter
GENEPOP, PHYLIP
\family default
 and 
\family typewriter
FSTAT
\family default
 formats.
 Because these formats do not support many of the features of a simuPOP
 population, this function can only import genotype and basic information
 of a population.
 Because formats GENEPOP and FSTAT formats uses allele 0 to indicate missing
 value, true alleles in these formats start at value 1.
 If you would like to import alleles with starting value 0, you can use
 parameter adjust=-1 to adjust imported values, if you data do not have
 any missing value.
 
\end_layout

\begin_layout Subsection
Export simuPOP population to files in 
\family typewriter
STRUCTURE, GENEPOP
\family default
, 
\family typewriter
FSTAT, Phylip, PED, MAP, MS,
\family default
 and 
\family typewriter
CSV
\family default
 formats (function 
\family typewriter
export
\family default
 and operator 
\family typewriter
Exporter
\family default
)
\end_layout

\begin_layout Standard
simuPOP uses a program-specific binary format to save and load populations
 but you can use the 
\family typewriter
export
\family default
 function to export a simuPOP population in other formats if you would like
 to use other programs to analyze simulated populations.
 An operator Exporter is also provided so that you could export populations
 during evolution.
 Operator arameters such as output, begin, end, step, at, reps, and subPops
 are supported so that you could export subsets of individuals at multiple
 generations using different file names (e.g.
 
\family typewriter
output='!
\begin_inset Quotes erd
\end_inset

%d.ped
\begin_inset Quotes erd
\end_inset

 % gen'
\family default
 to output to different files at different generations).
\end_layout

\begin_layout Standard
Commonly used population genetics file formats such as GENEPOP, FSTAT, Phylip,
 MS, and STRUCTURE are supported.
 Because these formats cannot store all information in a simuPOP population,
 export and import operations can lose information.
 Also, because the processing application have different assumptions, some
 conversion of genotypes might be needed.
 For example, because GENEPOP uses allele 0 as missing genotype, function
 
\family typewriter
export(format='genepop')
\family default
 accepts a parameter 
\family typewriter
adjust
\family default
 with default value 
\family typewriter
1
\family default
 to export alleles 0, 1 etc to 1, 2, ....
 The same applies to function 
\family typewriter
importPopulation
\family default
 where some file formats accepts a parameter 
\family typewriter
adjust
\family default
 (with default value 1) to adjust allele values.
 Please refer to the simuPOP reference manual for a detailed list of acceptable
 parameters for each format.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "importExport"

\end_inset

 demonstrates how to import and export a population in formats FSTAT and
 STRUCTURE.
 For the FSTAT format, because the population is exported with allele values
 shifted by 1, the imported population has different alleles than the original
 population.
 This can be fixed by adding parameter 
\family typewriter
adjust=-1
\family default
 to the 
\family typewriter
importPopulation
\family default
 function.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/importExport.log"
lstparams "caption={Save and load a population},label={importExport}"

\end_inset


\end_layout

\begin_layout Standard
Because coalescent simulations are increasingly used to generate initial
 populations in equilibrium stats, importing data in MS format is very useful.
 Because MS only simulates haploid sequences with genotype only at segregating
 sites, you might have to simulate an even number of sequences and use option
 ploidy=2 to import the simulated data as a haploid population.
 In addition, a parameter mergeBy is provided to import multiple replicates
 as multiple subpopulations or chromosomes.
 This corresponds to the splitBy parameter when you export your data in
 MS format.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "importMS"

\end_inset

 demonstrates how to use these parameters.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/importMS.log"
lstparams "caption={Export and import in MS format},label={importMS}"

\end_inset


\end_layout

\begin_layout Standard
If the file format you are interested in is not supported, you can export
 data in csv format and convert the file by yourself.
 You can also try to write your own import or export functions as described
 in the advanced topics section of this guide.
 
\end_layout

\begin_layout Subsection
Export simuPOP population in csv format (function 
\family typewriter
saveCSV
\family default
, deprecated)
\end_layout

\begin_layout Standard
Function 
\family typewriter
saveCSV
\family default
 is provided in the 
\family typewriter
simuPOP.utils
\family default
 module to save (the present generation of) a simuPOP population in comma
 separated formats.
 It allows you to save individual information fields, sex, affection status
 and genotype (in that order).
 Because this function allows you to output these information in different
 formats using parameters 
\family typewriter
infoFormatter
\family default
, 
\family typewriter
sexFormatter
\family default
, 
\family typewriter
affectionFormatter
\family default
, and 
\family typewriter
genoFormatter
\family default
, this function can already be used to export a simuPOP population to formats
 that are recognizable by some populat software applications.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveCSV"

\end_inset

 creates a small population and demonstrates how to save it in different
 formats.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/saveCSV.log"
lstparams "caption={Using function saveCSV to save a simuPOP population in different formats},label={saveCSV}"

\end_inset


\end_layout

\begin_layout Standard

\series bold
This function is now deprecated with the introduction of function 
\family typewriter
export
\family default
 and operator 
\family typewriter
Exporter
\family default
.
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.demography
\end_layout

\begin_layout Subsection
Predefined migration models 
\begin_inset CommandInset label
LatexCommand label
name "sub:Predefined-migration-models"

\end_inset


\end_layout

\begin_layout Standard
The following functions are defined to generate migration matrixes for popular
 migration models.
 
\end_layout

\begin_layout Itemize

\family typewriter
migrIslandRates(r, n)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula 
\[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r
\end{array}\right)
\]

\end_inset

for a traditional 
\series bold
island model
\series default
 where individuals have equal probability of migrating to any other subpopulatio
ns.
 This model is also called a 
\series bold
migrant-pool island model
\series default
.
\end_layout

\begin_layout Itemize

\family typewriter
migrHierarchicalIslandRates(r1, r2, n)
\family default
 models a 
\series bold
hierarchical island model
\series default
 in which local populations are grouped into neighborhoods within which
 there is considerable gene flow and between which there is less gene flow.
 
\begin_inset Formula $n$
\end_inset

 should be a list of group size.
 
\begin_inset Formula $r_{1}$
\end_inset

 is the within-group migration rate and 
\begin_inset Formula $r_{2}$
\end_inset

 is the cross-group migration rate.
 That is to say, an individual in an island has probability 
\begin_inset Formula $1-r_{1}-r_{2}$
\end_inset

 to stay, 
\begin_inset Formula $r_{1}$
\end_inset

 to be a migratant to other islands in the group (migration rate depending
 on the size of group), and 
\begin_inset Formula $r_{2}$
\end_inset

 to be a migrant to other islands in another group (migration rate depending
 on the number of islands in other groups).
 Both 
\begin_inset Formula $r_{1}$
\end_inset

 and 
\begin_inset Formula $r_{2}$
\end_inset

 can vary across groups of islands.
 For example, 
\family typewriter
migrHierarchicalIslandRates([r11, r12], r2, [3, 2])
\family default
 returns a 
\begin_inset Formula $5\times5$
\end_inset

 migration matrix
\begin_inset Formula 
\[
\left(\begin{array}{ccccc}
1-r_{11}-r_{2} & \frac{r_{11}}{2} & \frac{r_{11}}{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{11}}{2} & 1-r_{11}-r_{2} & \frac{r_{11}}{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{11}}{2} & \frac{r_{11}}{2} & 1-r_{11}-r_{2} & \frac{r_{2}}{2} & \frac{r_{2}}{2}\\
\frac{r_{2}}{3} & \frac{r_{2}}{3} & \frac{r_{2}}{3} & 1-r_{12}-r_{2} & r_{12}\\
\frac{r_{2}}{3} & \frac{r_{2}}{3} & \frac{r_{2}}{3} & r_{12} & 1-r_{12}-r_{2}
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
migrSteppingStoneRates(r, n, circular=False)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula 
\[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r
\end{array}\right)
\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula 
\[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
migr2DSteppingStoneRates(r, m, n, diagonal=False, circular=False) 
\family default
models a 2D stepping stone model in which local populations are arranged
 into a lattice of 
\begin_inset Formula $m\times n$
\end_inset

 (
\begin_inset Formula $m$
\end_inset

 rows, 
\begin_inset Formula $n$
\end_inset

 columns) patches.
 The population thus needs to have 
\begin_inset Formula $m\times n$
\end_inset

 subpopulations with subpopulation indexes counted by row.
 In this model, an individual in a center patch has a probability of 
\begin_inset Formula $1-r$
\end_inset

 to stay, and 
\begin_inset Formula $r/4$
\end_inset

 to migrate to its neighbor patches if 
\family typewriter
diagonal
\family default
 is set to False, or 
\begin_inset Formula $r/8$
\end_inset

 to migrate to 8 neighbors (including diagnal ones) if 
\family typewriter
range
\family default
 is set to 8.
 If 
\family typewriter
circular
\family default
 is set to 
\family typewriter
False
\family default
, the corner patch has a probability of 
\begin_inset Formula $r/2$
\end_inset

 or 
\begin_inset Formula $r/3$
\end_inset

 (if range=8) to migrate, and a side patch has a probability 
\begin_inset Formula $r/3$
\end_inset

 or 
\begin_inset Formula $r/5$
\end_inset

 to migrate.
 If 
\family typewriter
circular
\family default
 is set to 
\family typewriter
True
\family default
, the lattice will be conceptually connected to a ball so that there is
 no boundary effect.
 For example, for a 3 by 2 lattice 
\begin_inset Formula 
\[
\left(\begin{array}{cc}
0 & 1\\
2 & 3\\
4 & 5
\end{array}\right)
\]

\end_inset

with 
\family typewriter
diagonal=False
\family default
 and 
\family typewriter
circular=False
\family default
, the migration matrix will be 
\begin_inset Formula 
\[
\left(\begin{array}{cccccc}
1-r & \frac{r}{2} & \frac{r}{2}\\
\frac{r}{2} & 1-r &  & \frac{r}{2}\\
\frac{r}{3} &  & 1-r & \frac{r}{3} & \frac{r}{3}\\
 & \frac{r}{3} & \frac{r}{3} & 1-r &  & \frac{r}{3}\\
 &  & \frac{r_{2}}{2} &  & 1-r & \frac{r}{2}\\
 &  &  & \frac{r}{2} & \frac{r}{2} & 1-r
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Many more migration models have been proposed and studied, sometimes under
 different names with slightly different definitions.
 If you cannot find your model there, it should not be too difficult to
 construct a migration rate matrix for it.
 I will be glad to add such functions to this module if you could provide
 a reference and your implementation of the model.
\end_layout

\begin_layout Subsection
Uniform interface of demographic models
\end_layout

\begin_layout Standard
A realistic demographic models can be very complex that involves population
 growth, population bottleneck, subdivided populations, migration, population
 split and admixture for a typical demographic model for human populations,
 and carrying capacity, fecunity, sex distribution and many more factors
 for more complex ones (e.g.
 models for animal populations under continuous habitat).
 The goal of this module is to provide a common interface for demographic
 models, classes for frequently used demographic models, and several pre-defined
 demographic models for some human populations.
 More complex demographic models will be added upon request.
\end_layout

\begin_layout Standard
A demographic model usually consists of the following components:
\end_layout

\begin_layout Itemize
An initial population size that is used to initialize a population (the
 
\family typewriter
size
\family default
 parameter of 
\family typewriter
sim.Population
\family default
)
\end_layout

\begin_layout Itemize
One or more operators to split and merge populations (e.g.
 Operators 
\family typewriter
SplitSubPops
\family default
)
\end_layout

\begin_layout Itemize
One or more operators to migrate individuals across subpopulations (e.g.
 operator 
\family typewriter
Migrator
\family default
)
\end_layout

\begin_layout Itemize
Determine sizes of subpopulations before mating (parameter 
\family typewriter
subPopSize
\family default
 of a mating scheme)
\end_layout

\begin_layout Itemize
Number of generations to evolve (parameter 
\family typewriter
gen
\family default
 of the 
\family typewriter
evolve
\family default
 function) or operators to terminate the evolution conditionally (e.g.
 operator 
\family typewriter
TerminateIf
\family default
)
\end_layout

\begin_layout Standard
Using an object-oriented approach, a demographic model defined in this module
 encapsulates all these in a single object.
 More specifically, a demographic object 
\family typewriter
model
\family default
 is a callable Python object that 
\end_layout

\begin_layout Itemize
has attribute 
\family typewriter
model.init_size
\family default
 and 
\family typewriter
model.info_fields
\family default
 to determine the initial population size and required information fields
 to construct an initial population (e.g., 
\family typewriter
sim.Population(size=model.init_size, infoFields=model.info_fields + ['my_fields'])
\family default
)
\end_layout

\begin_layout Itemize
handles population split, merge, migration etc internally before mating
 when it is passed to parameter 
\family typewriter
subPopSize
\family default
 of a mating scheme.
 (e.g.
 
\family typewriter
RandomMating(subPopSize=model)
\family default
)
\end_layout

\begin_layout Itemize
has attribute 
\family typewriter
model.num_gens
\family default
 to determine the number of generations to evolve (e.g.
 
\family typewriter
pop.evolve(..., gen=model.num_gens)
\family default
).
 The model can optionally terminate the evolution by returnning an empty
 offspring population size before mating.
\end_layout

\begin_layout Itemize
provides a function 
\family typewriter
model.plot(filename='', title='')
\family default
 to plot the demographic function.
 It by default prints out population sizes whenever population size changes.
 If a 
\family typewriter
filename
\family default
 is specified and if module 
\family typewriter
matplotlib
\family default
 is available, it will plot the demographic model and save it to filename.
 A 
\family typewriter
title
\family default
 can be specified for the figure.
 This function actually use the demographic model to evolve a haploid population
 using 
\family typewriter
RandomSelection
\family default
 mating scheme, which is a good way to test if your demographic model works
 properly.
\end_layout

\begin_layout Subsection
Simple demographic models
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.demography
\family default
 module defines a number of demographic models that can be used to implement
 many popular demographic models, including linear and exponential population
 growth with carrying capacity, shrink, split and merge, and bottleneck.
 
\end_layout

\begin_layout Standard
For example,
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeModel(T=1000, N0=1000, G=500, NG=2000)
\end_layout

\end_inset

defines an instant population growth model that expands a population of
 size 1000 to 2000 instantly at generation 500
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeModel(T=1000, N0=1000, G=[500, 600], NG=[100, 1000])
\end_layout

\end_inset

defines a bottleneck model that introduces a bottleneck of size 100 between
 generation 500 and 600 to a population of size 1000
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeModel(T=1000, N0=1000, G=500, NG=[[400, 600]])
\end_layout

\end_inset

defines a bottleneck model that split a population of size into two subpopulatio
ns of sizes 400 and 600 at generation 500 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ExponentialGrowthModel(T=100, N0=1000, NT=10000)
\end_layout

\end_inset

expands a population of size 1000 to 10000 in 100 generations
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ExponentialGrowthModel(T=100, N0=[200, 800], r=[0.02, 0.01],
\end_layout

\begin_layout Plain Layout

    ops=Migrator(rate=[[0, 0.1], [0.1, 0]])
\end_layout

\end_inset

expands a population of two subpopulation sizes at rate 
\family typewriter
0.02
\family default
 and 
\family typewriter
0.01
\family default
 for 
\family typewriter
100
\family default
 generations, with migration between these two subpopulations.
 The initial population will be resized (split if necessary) to two populations
 of sizes 200 and 800.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LinearGrowthModel(N0=(200, 'A'), r=0.02, NT=1000)
\end_layout

\end_inset

expands a population of size 
\family typewriter
200
\family default
 at a rate 0f 
\family typewriter
0.02
\family default
 (add 4 individuals at each generation) until it reaches size 
\family typewriter
1000
\family default
.
 Here the initial size is expressed as a size name tuple, which directs
 the demographic model to assign the name 
\family typewriter
A
\family default
 to the initial population.
 Such named size is acceptable for all places where population size is needed.
\end_layout

\begin_layout Standard
Here we specify only two of the three parameters for linear and exponential
 growth models and allow simuPOP to figure out the rest.
 If all three parameters are specified, the ending population size will
 be interpretted as carraying capacity, namely population growth (or decline
 of negative rates are specified) will stop after it reaches the specified
 size.
\end_layout

\begin_layout Standard
A demographic model does not have to have a fixed initial population size.
 If an initial population size is not provided, its size will be determined
 from the population when it is first applied to.
 For example 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeModel(T=100, G=50, NT=[0.5, 0.5])
\end_layout

\end_inset

split a population into two equally sized subpopulations at generation 50.
 The ending population size is set to 
\family typewriter
[0.5, 0.5]
\family default
, which means 50% of the size at time 
\family typewriter
G
\family default
.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeModel(T=100, G=50, NT=[None, 100])
\end_layout

\end_inset

forks a population of size 100 from the main population at generation 50.
 
\family typewriter
NT=[None, 100]
\family default
 is equivalent to 
\family typewriter
NT=[1.0, 100]
\family default
 in this case.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeMoel(T=0, removEmptySubPops=True)
\end_layout

\end_inset

removes all empty subpopulations from the existing subpopulation.
 Here we do not specify an input population size because the the size of
 the input population will be kept.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InstantChangeMoel(T=0, N0=[None, 0, None], removEmptySubPops=True)
\end_layout

\end_inset

removes the second of the three subpopulations while keep other two subpopulatio
ns intact.
 The input population of this demographic model must have three subpopulations.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ExponentialGrowthModel(T=100, NT=[10000, 20000])
\end_layout

\end_inset

expands a population of two subpopulations to sizes 
\family typewriter
10000
\family default
 and 
\family typewriter
20000
\family default
 in 
\family typewriter
100
\family default
 generations.
 An error will be raised if the population does not have two subpopulations.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ExponentialGrowthModel(T=100, N0=[1., 400], NT=[10000, 20000], 
\end_layout

\begin_layout Plain Layout

    ops=Migrator(rate=[[0, 0.1], [0.1, 0]])
\end_layout

\end_inset

split a population into two subpopulations.
 The first one keeps all individuals (100%), the second one with 400 individuals
, and then expands them, with migration, to sizes 
\family typewriter
10000
\family default
 and 
\family typewriter
20000
\family default
 in 
\family typewriter
100
\family default
 generations.
 
\end_layout

\begin_layout Standard
The demography model also defines two models for population admxture.
 The HI model (Hybrid Isolation) model creates a separate subpopulation
 with 
\begin_inset Formula $\mu$
\end_inset

 and 
\begin_inset Formula $1-\mu$
\end_inset

 individuals from two specified subpopulations.
 The CGF (Continuous Gene Flow) model replaces 
\begin_inset Formula $1-\mu$
\end_inset

 individuals from the doner population at each generation, thus keep both
 the recipient and doner population constant in size.
 For example,
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

AdmixtureModel(model=('HI', 1, 3, 0.5, 'Admixed'), T=10)
\end_layout

\end_inset

Creates a separate population with 50% of individuals from subpopulation
 1 and 50% of individuals from subpopulation 3, regardless if population
 sizes 1 and 3 have the same number of individuals.
 An optional name Admixed is assigned to the new subpopulation.
 The admixed population will evolve independently for 10 generations.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

AdmixtureModel(model=('CGF', 1, 3, 0.9), T=10)
\end_layout

\end_inset

Replaces 10% of individuals in subpopulation 1 with individuals from subpopulati
on 3 for 10 generations.
\end_layout

\begin_layout Standard
As you can imagine, these models do not provide a valid 
\family typewriter
init_size
\family default
 to initialize a population.
 As a matter of fact, they are mostly stacked to other demographic models
 to form more complex demographic models, in model 
\family typewriter
MultiStageModel
\family default
.
 For example,
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MultiStageModel([
\end_layout

\begin_layout Plain Layout

    InstantChangeModel(T=1000, N0=1000, G=[500, 600], NG=[100, 1000]), 
 
\end_layout

\begin_layout Plain Layout

    ExponentialGrowthModel(T=100, NT=10000)
\end_layout

\begin_layout Plain Layout

])
\end_layout

\end_inset

defines a demographic model with a bottleneck followed by exponential population
 growth.
 
\family typewriter
N0
\family default
 of the second stage is not specified because it is determined from its
 previous stage.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MultiStageModel([
\end_layout

\begin_layout Plain Layout

    LinearGrowthModel(T=100, N0=1000, r=0.01),  
\end_layout

\begin_layout Plain Layout

    ExponentialGrowthModel(T=100, N0=[0.4, 0.6], r=0.001),
\end_layout

\begin_layout Plain Layout

    ExponentialGrowthModel(r=0.01, NT=[2000, 4000]),
\end_layout

\begin_layout Plain Layout

    AdmixtureModel(model=('HI', 0, 1, 0.8, 'admixed'), T=10)
\end_layout

\begin_layout Plain Layout

])
\end_layout

\end_inset

defines a demographic model that expands a single population linearly for
 100 generations, split into two subpopulations and grow exponentially at
 a rate of 0.001, and growth at a higher rate of 0.01 until they reaches sizes
 5000 and 10000 respectively.
 The last stage is tricky because one of the subpopulations will reach its
 carrying capacity sooner and keep a contant population size afterwards.
 The model is depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:multi-stage"

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:multi-stage"

\end_inset

A linear and two stage exponential population growth model, followed by
 population admixture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/MultiStage.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "demoModel"

\end_inset

 defines a demographic model use it to evolve a population.
 The demographic model is depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:demoModel_example"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoModel.log"
lstparams "caption={A demographic model for human population},label={demoModel}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:demoModel_example"

\end_inset

A exponential population growth followed by bottleneck demographic model
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/demoModel.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Demographic model without predefined generations to evolve
\end_layout

\begin_layout Standard
All migration models accept one or more operators that will be applied to
 the population before population population changes are applied.
 The most frequently application of this operator is to pass a migrator
 to the model, but we can also pass an operator to terminate a demographic
 model under certain conditions.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "demoTerminate"

\end_inset

 defines a demographic model that starts with a burn-in stage with indefinite
 size and will stop if the average allele frequency at segregating sites
 exceeds 0.1.
 It splits to two equally sized subpopulations and expand rate a rate of
 0.01 to size 2000 and 5000 respectively.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/demoTerminate.log"
lstparams "caption={A demographic model with a terminator},label={demoTerminate}"

\end_inset


\end_layout

\begin_layout Subsection
Predefined demographic models for human populations
\end_layout

\begin_layout Standard
More demographic models are defined in this module using this method.
 The 
\family typewriter
simuPOP.demography
\family default
 module currently defines the following models
\end_layout

\begin_layout Itemize
Out of Africa model for YRI, CEU and CHB populations (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Out-of-Africa"

\end_inset

), 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

OutOfAfricaModel(10000).plot('OutOfAfrica.png')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Out-of-Africa"

\end_inset

Out of Africa model for YRI, CEU, and CHB populations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/OutOfAfrica.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The settlement of new world model for Mexican American (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Settlement-of-New"

\end_inset

) ( Gutenkunst, 2009, PLoS Genetics).
 In this model, the simulated CHB and MX populations are mixed to produce
 an admixed population at the last generation.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SettlementOfNewWorldModel(10000).plot('SettlementOfNewWorld.png')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Settlement-of-New"

\end_inset

Settlement of New World model for Mexican America population
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/SettlementOfNewWorld.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The demographic model developed by cosi (Schaffner, 2005, genome research).
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CosiModel(20000).plot('Cosi.png')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cosi"

\end_inset

Demographic models for African, Asian and European populations (cosi)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/Cosi.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
These functions all accept a parameter scale.
 If specified, it will scale all population sizes and generation numbers
 by the specified scaling factor.
 For example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CosiModel(20000, scale=10)
\end_layout

\end_inset

will result in a demographic model that evolves 2000 instead of 20000 generation
s, with all population sizes reduced by a factor of 10.
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.plotter
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.plotter
\family default
 module defines a few utility functions and Python operators that help you
 plot variables and information fields during evolution.
 A number of operators are defined that
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.VarPlotter
\family default
: Plot a dynamically evaluated expression with its history.
 Each expression and its history form a line in the plot.
 Multiple lines will be plotted for multiple replicates and/or for each
 element of the expression (if the evaluated value of the expression is
 a sequence), with options to separate lines to different subplots.
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.ScatterPlotter
\family default
: Plot individuals in specified (virtual) subpopulations using values at
 two information fields as x and y axes.
 individuals belonging to different (virtual) subpopulations will be plotted
 with different colors and shapes.
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.InfoPlotter
\family default
: Using a R function such as 
\family typewriter
hist
\family default
 and 
\family typewriter
qqnorm
\family default
 to plot one or more information fields of individuala in one or more (virtual)
 subpopulations.
 Two specialized operators 
\family typewriter
plotter.HistPlotter
\family default
 and 
\family typewriter
plotter.QQPlotter
\family default
 are provided to plot the histograms and qq plots.
 Other functions could also be used, and it is even possible to draw a figure
 completely by your own (with stratified data provided to you by this operator).
\end_layout

\begin_layout Itemize
Operator 
\family typewriter
plotter.BoxPlotter
\family default
: This operator uses R function 
\family typewriter
boxplot
\family default
 to plot boxplots of data of one or more information fields of individuals
 in one ore more (virtual) subpopulations.
 The whiskers could be grouped by information field or subpopulations.
\end_layout

\begin_layout Standard
These operators are derived from class 
\family typewriter
PyOperator
\family default
 and call R plot functions when they are applied to a population.
 For example, operator 
\family typewriter
plotter.VarPlotter
\family default
 collects expression values and use functions 
\family typewriter
plot
\family default
 and 
\family typewriter
lines
\family default
 to plot the data, with help from other functions such as 
\family typewriter
par
\family default
 (device property), 
\family typewriter
dev.print
\family default
 (save figure to files) and 
\family typewriter
legend
\family default
 (add legend).
 Some functions are called multiple times for different replicate, subpopulation
 or information fields.
\end_layout

\begin_layout Subsection
Derived keyword arguments *
\end_layout

\begin_layout Standard
One of the most interesting feature of this module is its use of derived
 keyword parameters to send arbitrary parameters to the underlying R functions,
 which usually accept a large number of parameters to customize every aspect
 of a figure.
 A 
\series bold
derived keyword argument
\series default
 is an argument that is prefixed with a function name and/or suffixed by
 an iterator name.
 The former specifies to which underlying R function this parameter will
 be passed to; the latter allows the users to specify a list of values that
 will be passed, for example, to lines representing different replicates.
 For example, parameter 
\family typewriter
par_mar=[1]*4
\family default
 will pass 
\family typewriter
mar=[1]*4
\family default
 to R function 
\family typewriter
par
\family default
, and 
\family typewriter
lty_rep=[1, 2, 3]
\family default
 will pass 
\family typewriter
lty=1
\family default
, 
\family typewriter
lty=2
\family default
 and 
\family typewriter
lty=3
\family default
 to different replicates.
 A class usually has one or two default functions (such as 
\family typewriter
plot
\family default
, 
\family typewriter
lines
\family default
) to which keyword aguments without function prefix will be sent.
\end_layout

\begin_layout Standard
In addition, the values of these keyword arguments could vary during evolution.
 More specifically, if the value is a string with a leading exclamation
 mark (
\family typewriter
!
\family default
), the remaining string will be considered as an expression.
 This expression will be evaluated against the current population during
 evolution and the return value will become the value of the parameter at
 that generation.
 For example, keyword parameter  
\family typewriter
main=
\begin_inset Quotes erd
\end_inset

!'Allele frequency at generation %d' % gen
\begin_inset Quotes erd
\end_inset


\family default
 will become 
\family typewriter
main='Allele frequency at generation 10'
\family default
 at generation 10.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Plot of expressions and their histories (operator 
\family typewriter
plotter.VarPlotter
\family default
)
\end_layout

\begin_layout Standard
Class 
\family typewriter
plotter.VarPlotter
\family default
 plots the current and historical values of a Python expression (
\family typewriter
expr
\family default
), which are evalulated (against each population's local namespace) and
 saved during evolution.
 The return value of the expression can be a number or a sequence, but should
 have the same type and length across all replicates and generations.
 Histories of each value (or each item in the returned sequence) of each
 replicate form a line, with generation numbers as its x-axis.
 Number of lines will be the number of replicates multiplied by dimension
 of the expression.
 Although complete histories are usually saved, you can use parameter 
\family typewriter
win
\family default
 to save histories only within the last 
\family typewriter
win
\family default
 generations.
 
\end_layout

\begin_layout Standard
This module uses either rpy or matplotlib as the underlying plotting library.
 rpy is used by defaut because it is easier to use and support more plotting
 options (
\family typewriter
InfoPlotter
\family default
, 
\family typewriter
BoxPlotter
\family default
, 
\family typewriter
HistPlotter
\family default
 and 
\family typewriter
QQPlotter
\family default
 are only available for rpy).
 matplotlib will be used if rpy is not available, or if matplotlib is set
 to be the system plotter (
\family typewriter
simuOpt.setOptions(plotter='matplotlib')
\family default
).
\end_layout

\begin_layout Standard
Except for the first generation where no line could be drawn, a figure will
 be drawn after this operator is applied to the last specified replicate
 (parameter 
\family typewriter
reps
\family default
 could be used to specify a subset of replicates).
 For example, although linkage disequilibrium values between the first two
 loci are evaluated and saved at the end of generations 0, 5, 10, ..., (
\family typewriter
step=5
\family default
) figures are only drawn at generations 40 and 80 (
\family typewriter
update=40
\family default
) in Exampe 
\begin_inset CommandInset ref
LatexCommand ref
reference "varplotter"

\end_inset

.
 This example also demonstrates the use of parameters 
\family typewriter
saveAs
\family default
 and 
\family typewriter
legend
\family default
.
 By given a filename 
\family typewriter
rpy.png
\family default
 to parameter 
\family typewriter
saveAs
\family default
, this operator will save figures (named 
\family typewriter
rpy_40.png
\family default
 and 
\family typewriter
rpy_80.png
\family default
) after they are drawn.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/VarPlotter.log"
lstparams "caption={Use rpy or matplotlib to plot an expression},label={varplotter}"

\end_inset


\end_layout

\begin_layout Standard
Parameters after 
\family typewriter
legend
\family default
 (
\family typewriter
xlab
\family default
, 
\family typewriter
ylab
\family default
, 
\family typewriter
ylim
\family default
, 
\family typewriter
main
\family default
, ...) deserve more attention here.
 These parameters are derived keyword arguments because they are not defined
 by 
\family typewriter
VarPlotter.

\family default
 Parameters without prefix are passed directly to the R functions 
\family typewriter
plot
\family default
 and 
\family typewriter
line
\family default
.
 They could be used to customize line type (
\family typewriter
lty
\family default
), color (
\family typewriter
col
\family default
), title (
\family typewriter
main
\family default
), limits of x and y axes (
\family typewriter
xlim
\family default
 and 
\family typewriter
ylim
\family default
) and many other graphical features (see R manual for details).
 If multiple lines are drawn, a list of values could be applied to these
 lines if you add 
\family typewriter
_rep
\family default
 (for each replicate) or 
\family typewriter
_dim
\family default
 (for each item of a sequence) after the name of the parameter.
 For example, 
\family typewriter
lty_rep=[1, 2, 3]
\family default
 is used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varplotter"

\end_inset

 to pass parameters 
\family typewriter
lty=1
\family default
, 
\family typewriter
lty=2
\family default
 and 
\family typewriter
lty=3
\family default
 to lines for three replicates.
 Suffix 
\family typewriter
_repdim
\family default
 can also be used to specify values for every replication and dimension.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpy"

\end_inset

 displayed 
\family typewriter
rpy_80.png
\family default
 that is saved at generation 80 for this example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpy"

\end_inset

rpy_80.png saved at generation 80 for Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varplotter"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/varplot_80.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the expression is multidimensional, the number of lines can be large
 and it is often desired to separate these lines into subplots.
 This can be done by parameters 
\family typewriter
byRep
\family default
 or 
\family typewriter
byDim
\family default
.
 The former plots lines replicate by replicate and the latter does it dimension
 by dimension.
 For example, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByRep"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByDim"

\end_inset

 both have three replicates and the expression has allele frequency for
 four loci.
 The total number of lines is therefore 12.
 In Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByRep"

\end_inset

, these lines are separated to three subplots, replicate by replicate, with
 different titles (parameter 
\family typewriter
main_rep
\family default
).
 In each subplot, allele frequency trajectories (histories) for different
 loci are plotted in different color (parameter 
\family typewriter
col_dim
\family default
).
 The last saved figure (
\family typewriter
rpy_byRep_90.png
\family default
) is displayed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpyByRep"

\end_inset

.
 In Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByDim"

\end_inset

, these lines are separated to four subplots, locus by locus, with different
 titles (parameter 
\family typewriter
main_dim
\family default
).
 In each subplot, allele frequency trajectories (histories) for different
 loci are plotted in different color (parameter 
\family typewriter
col_rep
\family default
) and line type (parameter 
\family typewriter
lty_rep
\family default
).
 The last saved figure (
\family typewriter
rpy_byDim_90.png
\family default
) is displayed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rpyByDim"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/varPlotByRep.log"
lstparams "caption={Separate figures by replicate},label={varPlotByRep}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpyByRep"

\end_inset

Allele frequency trajectories separated by replicates
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/varplot_byRep_90.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByDim"

\end_inset

 also demonstrates some advanced features of this plotter that allow further
 customization of the figures.
 More specifically,
\end_layout

\begin_layout Itemize
Function-specific parameters can be passed to the underlying R function
 by prefixing function names to parameter names.
 For example, 
\family typewriter
plot_axis=False
\family default
 is used to pass 
\family typewriter
axis=False
\family default
 to the 
\family typewriter
r.plot
\family default
 function (and not to function 
\family typewriter
lines
\family default
 which does not accept this parameter).
\end_layout

\begin_layout Itemize
Several hook function can be defined and passed to parameters 
\family typewriter
preHook
\family default
, 
\family typewriter
postHook
\family default
 and 
\family typewriter
plotHook
\family default
, which will be called, respectively, before a figure is drawn, after a
 figure is drawn, and after each 
\family typewriter
r.plot
\family default
 call.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "varPlotByDim"

\end_inset

 uses a 
\family typewriter
plotHook
\family default
 function to draw axes of the plots and call 
\family typewriter
mtext
\family default
 to add texts to the margins.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/varPlotByDim.log"
lstparams "caption={Separate figures by Dimension},label={varPlotByDim}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rpyByDim"

\end_inset

Allele frequency trajectories separated by loci
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/varplot_byDim_90.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scatter plots (operator 
\family typewriter
plotter.ScatterPlotter
\family default
)
\end_layout

\begin_layout Standard
Operator 
\family typewriter
plotter.ScatterPlotter
\family default
 plots individuals in all or selected (virtual) subpopulations in a 2-D
 plot, using values at two information fields as their x- and y-axis.
 In the most simplified form,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InfoPlotter(infoFields=['x', 'y'])
\end_layout

\end_inset

will plot all individuals according their values of information fields 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
.
 Additional parameters such as pch, 
\family typewriter
col
\family default
, and 
\family typewriter
cex
\family default
 can be used to control the shape, color and size of the points.
\end_layout

\begin_layout Standard
What makes this operator useful is its ability to differentiate points (individu
als) by (virtual) subpopulations (VSPs).
 If a list of VSPs are given, points representing individuals from these
 VSPs will be plotted with different colors and shapes.
 Because simulations that keep track of multiple information fields are
 usually complicated, let us simulate something interesting and examine
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ScatterPlotter"

\end_inset

 in details.
\end_layout

\begin_layout Standard
At the beginning of this example, all individuals are scattered randomly
 with 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 being their physical locations.
 We use 
\family typewriter
anc
\family default
 to record Individual ancestry and assign 0 and 1 each to half of the population.
 During evolution,
\end_layout

\begin_layout Itemize
Offspring ancestry values are the average of their parents.
\end_layout

\begin_layout Itemize
Offspring with higher ancestry value tend to move to the right.
 More specifically, locations of an offspring will be 
\begin_inset Formula 
\[
\frac{\left(x_{1}+x_{2}\right)}{2}+N\left(\frac{a_{1}+a_{2}}{2}-0.5,0.1\right),\frac{\left(y_{1}+y_{2}\right)}{2}+N\left(0,0.1\right)
\]

\end_inset

where 
\begin_inset Formula $\left(x_{1},y_{1}\right)$
\end_inset

 and 
\begin_inset Formula $\left(x_{2},y_{2}\right)$
\end_inset

 are locations of parents, 
\begin_inset Formula $a_{1}$
\end_inset

 and 
\begin_inset Formula $a_{2}$
\end_inset

 are ancestry values of the parents, and 
\begin_inset Formula $N\left(a,b\right)$
\end_inset

 are a random number with normal distribution.
\end_layout

\begin_layout Standard
An 
\family typewriter
ScatterPlotter
\family default
 is used to plot the physical location of all individuals.
 Individual ancestries are divided into five regions (0, 0.2, 0.4, 0.6, 0.8,
 1) indicated by small to larger points.
 MALE and female individuals are plotted by different symbol.
 This scripts uses the following techniques:
\end_layout

\begin_layout Itemize
Set individual information fields randomly using 
\family typewriter
setIndInfo
\family default
.
\end_layout

\begin_layout Itemize
Define virtual subpopulations using a 
\family typewriter
InfoSplitter
\family default
.
\end_layout

\begin_layout Itemize
Use 
\family typewriter
PyTagger
\family default
 to calculate offspring information fields from parental fields.
\end_layout

\begin_layout Itemize
Mark individuals in different VSPs using parameters 
\family typewriter
col_sp
\family default
 and 
\family typewriter
cex_sp
\family default
.
\end_layout

\begin_layout Itemize
Use 
\family typewriter
plot_axes=False
\family default
 and 
\family typewriter
par_mar=[0, 0, 2, 0]
\family default
 to pass parameters 
\family typewriter
axes=False
\family default
 and 
\family typewriter
mar=[0, 0, 2, 0]
\family default
 to functions 
\family typewriter
plot
\family default
 and 
\family typewriter
par
\family default
 respectively.
\end_layout

\begin_layout Standard
VSPs 0 and 4 appear at the beginning of generation 0, VSP 2 appears at the
 end of generation 0, and VSP 1 and 3 appear at the end of generation 1.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ScatterPlotter"

\end_inset

 displays a figure at the begging of generation 2.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ScatterPlotter.log"
lstparams "caption={Use ScatterPlotter to plot ancestry of individuals with geographic information.},label={ScatterPlotter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ScatterPlotter"

\end_inset

Plot of individuals with ancestry marked by different colors
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/ScatterPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Histograms, QQ plots and boxplots (operator 
\family typewriter
plotter.InfoPlotter
\family default
, 
\family typewriter
plotter.HistPlotter
\family default
, 
\family typewriter
plotter.QQPlotter
\family default
).
\end_layout

\begin_layout Standard
Class 
\family typewriter
plotter.InfoPlotter
\family default
 can be used to draw figures for information fields of individuals in one
 or more subpopulations.
 
\family typewriter
plotter.HistPlotter
\family default
 and 
\family typewriter
plotter.QQPlotter
\family default
 are two special cases of this class that uses functions 
\family typewriter
hist
\family default
 and 
\family typewriter
qqnorm
\family default
 respectively.
 Although an 
\family typewriter
InfoPlotter
\family default
 using a 
\family typewriter
boxplot
\family default
 function could be used, a specialized 
\family typewriter
plotter.BoxPlotter
\family default
 is defined so that mutliple boxplot whiskers could be drawn in the same
 plot.
\end_layout

\begin_layout Standard
Using the same evolutionary process as Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ScatterPlotter"

\end_inset

, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "HistPlotter"

\end_inset

 uses a 
\family typewriter
HistPlotter
\family default
 to plot the histograms (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HistPlotter"

\end_inset

), a 
\family typewriter
QQPlotter
\family default
 to plot QQ plot (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:QQPlotter"

\end_inset

), and a 
\family typewriter
BoxPlotter
\family default
 to plot the boxplots (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:BoxPlotter"

\end_inset

) of individual ancestry values.
 By defining two virtual subpopulations by sex, the 
\family typewriter
HistPlotter
\family default
 and 
\family typewriter
QQPlotter
\family default
 plots two histograms and two QQ plots, one for males and one for females.
 Different colors are used for these figures.
 Note that these plots use the special expression value for parameter 
\family typewriter
main
\family default
 so that generation number can appear in the titles.
 The same technique is used in the 
\family typewriter
dev_print_file
\family default
 parameter of the 
\family typewriter
BoxPlotter
\family default
, which overrides the default filename derived from parameter 
\family typewriter
saveAs
\family default
.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/HistPlotter.log"
lstparams "caption={Use HistPlotter to plot the histogram of individual ancestries.},label={HistPlotter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HistPlotter"

\end_inset

Histogram of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/HistPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:QQPlotter"

\end_inset

QQ plot of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/QQPlotter_2_0.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:BoxPlotter"

\end_inset

Boxplot of individual ancestry values
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/Gen2.png
	lyxscale 40
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.sampling
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Sampling, in simuPOP term, is the action of extracting individuals from
 a large, potentially multi-generational, population according to certain
 criteria.
 the 
\family typewriter
simuPOP.sampling
\family default
 module provides several classes and functions and allows you to define
 more complicated sampling schemes by deriving from its these class.
 For example, you can use 
\family typewriter
drawRandomSample(pop, size=100)
\family default
 to select 100 random individuals from a population, or use 
\family typewriter
drawAffectedSibpairSample(pop, families=100)
\family default
 to select 100 pairs of affected invididuals with their parents from a multi-gen
erational population, or a age-structured population with parents and offspring
 in the same generation.
\end_layout

\begin_layout Standard
The 
\family typewriter
simuPOP.sampling
\family default
 module currently support random, case control, affected sibpair, nuclear
 family and three-generation family sampling types, and a combined sampling
 type that allows you to draw different types of samples.
 For each sampling type 
\family typewriter
X
\family default
, a sampler class and two functions 
\family typewriter
DrawXSample
\family default
 and 
\family typewriter
DrawXSamples
\family default
 are provided The first function returns a population with all sampled individua
ls and the second function returns a list of sample populations.
 
\end_layout

\begin_layout Standard
If you would like to define your own sampling type, you can derive your
 sampler from one of the existing sampler classes.
 These sampler classes provide member functions 
\family typewriter
prepareSample
\family default
, 
\family typewriter
drawSample
\family default
 and 
\family typewriter
drawSamples
\family default
 and you typically only need to extend 
\family typewriter
prepareSample
\family default
 of an appropriate base class.
 
\end_layout

\begin_layout Subsection
Sampling individuals randomly (class 
\family typewriter
RandomSampler
\family default
, functions 
\family typewriter
drawRandomSample
\family default
 and 
\family typewriter
drawRandomSamples
\family default
)
\end_layout

\begin_layout Standard
Functions 
\family typewriter
drawRandomSample
\family default
 and 
\family typewriter
drawRandomSamples
\family default
 draw random invidiauls from a given population.
 If a simple number is given to parameter 
\family typewriter
size
\family default
, population structure will be ignored so individuals will be drawn from
 all subpopulations.
 If a list of numbers are given, this function will draw specified numbers
 of individuals from each subpopulation.
 This function does not need parental information.
 If your population does not have an ID field, you will not be able to locate
 extracted individuals in the original population.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "randomSample"

\end_inset

 demonstrates how to draw a random sample from the whole population, and
 from each subpopulation.
 Because sample populations keep the population structure of the source
 population (this might change when parameter 
\family typewriter
subPops
\family default
 is used, see a later section for details), we can use 
\family typewriter
sample.subPopSizes()
\family default
 to check how many individuals are sampled from each subpopulation.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/randomSample.log"
lstparams "caption={Draw random samples from a structured population},label={randomSample}"

\end_inset


\end_layout

\begin_layout Subsection
Sampling cases and controls (class 
\family typewriter
CaseControlSampler
\family default
, functions 
\family typewriter
CaseControlSample
\family default
 and 
\family typewriter
CaseControlSamples
\family default
)
\end_layout

\begin_layout Standard
Functions 
\family typewriter
drawCaseControlSample
\family default
 and 
\family typewriter
drawCaseControlSamples
\family default
 draw cases (affected individuals) and controls (unaffected invidiauls)
 from a given population.
 If a simple number is given to parameter 
\family typewriter
cases
\family default
 and 
\family typewriter
controls
\family default
, population structure will be ignored so individuals will be drawn from
 all subpopulations.
 If a list of numbers are given, this function will draw specified number
 of cases and controls from each subpopulation.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "caseControlSample"

\end_inset

 demonstrates how to draw multiple case-control samples from a population,
 and perform case-control assocition tests using the 
\family typewriter
stat
\family default
 function.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/caseControlSample.log"
lstparams "caption={Draw case control samples from a population and perform association test},label={caseControlSample}"

\end_inset


\end_layout

\begin_layout Subsection
Sampling Pedigrees (functions 
\family typewriter
indexToID
\family default
 and 
\family typewriter
plotPedigree
\family default
)
\end_layout

\begin_layout Standard
If your sampling scheme involves parental information, you need to prepare
 your population so that it has
\end_layout

\begin_layout Itemize
an ID field (usually 
\family typewriter
'ind_id'
\family default
) that stores a unique ID for each individual.
\end_layout

\begin_layout Itemize
two information fields (usually 
\family typewriter
'father_id'
\family default
, and 
\family typewriter
'mother_id'
\family default
) that stores the ID of parents of each individual.
 Although simuPOP supports one-parent Pedigrees, this feature will not be
 discussed in this guide.
\end_layout

\begin_layout Standard
The preferred method to prepare such a population is to add information
 fields 
\family typewriter
ind_id
\family default
, 
\family typewriter
father_id
\family default
 and 
\family typewriter
mother_id
\family default
 to a population and track ID based Pedigrees during evolution.
 More specifically, you can use operators 
\family typewriter
IdTagger
\family default
 and 
\family typewriter
PedigreeTagger
\family default
 to assign IDs and record parental IDs of each offspring during mating.
 This method supports age-structured population when parents and offspring
 can be stored in the same generation.
\end_layout

\begin_layout Standard
You can also use information fields 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 and operator 
\family typewriter
ParentsTagger
\family default
 to track indexes of parents in the parental generations.
 Before sampling, you can use function 
\family typewriter
sampling.indexToID
\family default
 to add needed information fields and convert index based parental relationship
 to ID based relationshop.
 Because parents have to stay in ancestral generations, this method does
 not support age-structured population.
\end_layout

\begin_layout Standard
If you have R and rpy installed on your system, you can install the 
\family typewriter
kinship
\family default
 library of R and use it to analyze Pedigree.
 The 
\family typewriter
simuPOP.sampling
\family default
 module provides a function 
\family typewriter
plotPedigree
\family default
 to use this library to plot Pedigrees.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "plotPedigree"

\end_inset

 demonstrates how to use function sampling.indexToID to prepare a pedigree
 and how to use sampling.DrawPedigree to plot it.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/plotPedigree.log"
lstparams "caption={Prepare and plot Pedigrees},label={plotPedigree}"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pedigree"

\end_inset

 plots a small three-generational population with 15 individuals at each
 generation.
 It is pretty clear that random mating produces bad pedigree structure because
 it is common that one parent would have multiple spouses.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pedigree"

\end_inset

Structure of a small complete pedigree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/pedigree.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sampling affected sibpairs (class 
\family typewriter
AffectedSibpairSampler
\family default
, functions 
\family typewriter
drawAffectedSibpairSample(s)
\family default
)
\end_layout

\begin_layout Standard
An affected sibpair family consists of two parents and their affected offspring.
 Such families are useful in linkage analysis because of high likelihood
 of shared disease predisposing alleles between siblings.
 
\family typewriter
simuPOP.sampling
\family default
 module provides functions 
\family typewriter
drawAffectedSibpairSample
\family default
 and 
\family typewriter
drawAffectedSibpairSamples
\family default
 to draw such families from a population.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sampleAffectedSibpair"

\end_inset

 draws two affected sibpair from the pedigree created in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "plotPedigree"

\end_inset

, with samples plotted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:affectedSibpair"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sampleAffectedSibpair.log"
lstparams "caption={Draw affected sibpairs from a population},label={sampleAffectedSibpair}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:affectedSibpair"

\end_inset

Affected sibpairs drawn from a small pedigree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/affectedSibpair.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sampling nuclear families (class 
\family typewriter
NuclearFamilySampler
\family default
, functions 
\family typewriter
drawNuclearFamilySample
\family default
 and 
\family typewriter
drawNuclearFamilySample
\family default
s)
\end_layout

\begin_layout Standard
A nuclear family consists of two parents and their offspring.
 Functions 
\family typewriter
drawNuclearFamilySample
\family default
 and 
\family typewriter
drawNuclearFamilySamples
\family default
 to draw such families from a population, with restrictions on number of
 offspring, number of affected parents and number of affected offspring.
 Although fixed numbers could be given, a range with minimal and maximal
 acceptable numbers are usually provided.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sampleNuclearFamily"

\end_inset

 draws two nuclear families from the pedigree created in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "plotPedigree"

\end_inset

.
 The samples are plotted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nuclearFamily"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sampleNuclearFamily.log"
lstparams "caption={Draw nuclear families from a population},label={sampleNuclearFamily}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nuclearFamily"

\end_inset

Nuclear families drawn from a small pedigree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/nuclerFamily.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sampling three-generation families (class 
\family typewriter
ThreeGenFamilySampler
\family default
, functions 
\family typewriter
drawThreeGenFamilySample and drawThreeGenFamilySamples
\family default
)
\end_layout

\begin_layout Standard
A three-generation family consists of two parents, their common offspring,
 offspring's spouses, and their common offspring (grandchidren).
 individuals in sampled families have either no or two parents.
 Functions 
\family typewriter
drawThreeGenFamilySample
\family default
 and 
\family typewriter
drawThreeGenFamilySamples
\family default
 to draw such families from a population, with restrictions on number of
 offspring, total number of individuals and number of affected individuals
 in the Pedigree.
 These parameters (
\family typewriter
numOffspring
\family default
, 
\family typewriter
pedSize
\family default
 and 
\family typewriter
numAffected
\family default
) could be a fixed number of a range with minimal and maximal acceptable
 numbers.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sampleNuclearFamily"

\end_inset

 draws two three generation families from the pedigree created in Example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "plotPedigree"

\end_inset

.
 The samples are plotted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nuclearFamily"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/sampleThreeGenFamily.log"
lstparams "caption={Draw three-generation families  from a population},label={sampleThreeGenFamily}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:threeGenFamily"

\end_inset

Three generation families drawn from a small pedigree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/threeGenFamily.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sampling different types of samples (class 
\family typewriter
CombinedSampler
\family default
, functions 
\family typewriter
drawCombinedSample
\family default
 and 
\family typewriter
drawCombinedSamples
\family default
)
\end_layout

\begin_layout Standard
Samples in real world studies sometimes do not have uniform types so it
 is useful to draw samples of different types from the same population.
 Although it is possible to draw samples using different functions and combine
 them, handling of overlapping individuals, namely individuals who are chosen
 by multiple samplers, can be a headache.
 The combined sampler of 
\family typewriter
simuPOP.sampling
\family default
 is designed to overcome this problem.
 This sampler takes a list of sampler objects and apply them to a population
 sequentially.
 The extracted sample will not have overlapping individuals.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "combinedSampling"

\end_inset

 draws an affected sibpair family and a nuclear family from the pedigree
 created in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "plotPedigree"

\end_inset

.
 The samples are plotted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "combinedSampling"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/combinedSampling.log"
lstparams "caption={Draw different types of samples from a population},label={combinedSampling}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:combinedSampling"

\end_inset

An affected sibpair and a nuclear family drawn from a small pedigree
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename log/combinedSampling.png
	lyxscale 40
	width 60text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sampling from subpopulations and virtual subpopulations *
\end_layout

\begin_layout Standard
Virtual subpopulations (VSPs) could be specified in the 
\family typewriter
subPops
\family default
 parameter of sampling classes and functions.
 This can be used to limit your samples to individuals with certain properties.
 For example, you may want to match the age of cases and controls in a case-cont
rol association study by selecting your samples from a certain age group.
 For examples, Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "samplingVSP"

\end_inset

 draws 500 cases and 500 controls from two a VSP with individual ages between
 40 and 60.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/samplingVSP.log"
lstparams "caption={Draw samples from a virtual subpopulation.},label={samplingVSP}"

\end_inset


\end_layout

\begin_layout Standard
If a list of sample sizes is given, specified number of samples will be
 drawn from each subpopulation.
 For example, if you have an age-structured population when individuals
 with different ages have different risk to a disease, you might want to
 draw affected individuals from different age groups and perform association
 analyses.
 Function 
\family typewriter
drawCaseControlSample
\family default
 cannot be used because both groups are affected, but you can 
\family typewriter
drawRandomSample
\family default
 from two VSPs defined by age.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "samplingSeparateVSPs"

\end_inset

 demonstrates how to use this method.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/samplingSeparateVSPs.log"
lstparams "caption={Sampling separately from different virtual subpopulations},label={samplingSeparateVSPs}"

\end_inset


\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.gsl
\end_layout

\begin_layout Standard
simuPOP makes use of many functions from the GUN Scientific Library.
 These functions are used to generate random number and perform statistical
 tests within simuPOP.
 Although these functions are not part of simuPOP, they can be useful to
 users of simuPOP from time to time and it makes sense to expose these functions
 directly to users.
\end_layout

\begin_layout Standard
Module 
\family typewriter
simuPOP.gsl
\family default
 contains a number of GSL functions.
 Because only a small proportion of GSL functions are used in simuPOP, this
 module is by no means a comprehensive wrapper of GSL.
 Please refer to the simuPOP reference manual for a list of functions included
 in this module, and the GSL manual for more details.
 Because random number generation functions such as 
\family typewriter
gsl_ran_gamma
\family default
 are already provided in the 
\family typewriter
simuPOP.RNG
\family default
 class (e.g.
 
\family typewriter
getRNG().randGamma
\family default
), they are not provided in this module.
\end_layout

\begin_layout Section
Module 
\family typewriter
simuPOP.sandbox
\end_layout

\begin_layout Standard
The simuPOP sandbox can be understood as the binary version of the simuPOP
 cookbook.
 It contains 
\series bold
experimental or specialized
\series default
 classes and functions that might or might not be formally adopted by simuPOP.
 For example, a mating scheme in which parents locate their spouses randomly
 but with probabilities that are related to geographic distances will be
 slow to implement at the Python level.
 It might be provided here because it relies on many assumptions such as
 the existence of certain information fields, and is unlikely to be adopted
 by simuPOP.
\end_layout

\begin_layout Standard
Because of the experiemental nature of this module, 
\series bold
compatibility is not guaranteed for classes and functions provided in this
 module
\series default
.
 If you use an operator from this module, your script might be locked to
 a particular version of simuPOP that provides this operator.
 On the other hand, if you have implemented some C/C++ level classes or
 functions for your own simulation, it can be a good idea to add them to
 this module so that they can be distributed with simuPOP (at least in certain
 versions of simuPOP).
 Please refer to the simuPOP reference manual for a list of classes and
 functions provided in the current version of simuPOP.
\end_layout

\begin_layout Chapter
A real world example
\begin_inset CommandInset label
LatexCommand label
name "cha:A-real-example"

\end_inset


\end_layout

\begin_layout Standard
Previous chapters use a lot of examples to demonstrate individual simuPOP
 features.
 However, it might not be clear how to integrate these features in longer
 scripts that address real world problems, which may involve larger populations,
 more complex genetic and demographic models and may run thousands of replicates
 with different parameters.
 This chapter will show you, step by step, how to write a complete simuPOP
 script that has been used in a real-world research topic.
\end_layout

\begin_layout Section
Simulation scenario
\end_layout

\begin_layout Standard
Reich and Lander 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
This example is a simplified version of the 
\family typewriter
simuCDCV.py
\family default
 script that simulates this evolution process and observe the allelic spectra
 of both types of diseases.
 The complete script is available at 
\begin_inset CommandInset href
LatexCommand href
name "the simuPOP online cookbook"
target "http://simupop.sourceforge.net/cookbook"

\end_inset

.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Section
Demographic model
\end_layout

\begin_layout Standard
The original paper used a very simple instant population growth model.
 Under the model assumption, a population with an initial population size
 
\begin_inset Formula $N_{0}$
\end_inset

 would evolve 
\begin_inset Formula $G_{0}$
\end_inset

 generations, instantly expand its population size to 
\begin_inset Formula $N_{1}$
\end_inset

 and evolve another 
\begin_inset Formula $G_{1}$
\end_inset

 generations.
 Such a model can be easily implemented as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ins_expansion(gen):
\end_layout

\begin_layout Plain Layout

    'An instant population growth model'
\end_layout

\begin_layout Plain Layout

    if gen < G0:
\end_layout

\begin_layout Plain Layout

        return N0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        return N1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other demographic models could be implemented similarly.
 For example, an exponential population growth model that expand the population
 size from 
\begin_inset Formula $N_{0}$
\end_inset

 to 
\begin_inset Formula $N_{1}$
\end_inset

 in 
\begin_inset Formula $G_{1}$
\end_inset

 generations could be defined as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def exp_expansion(gen):
\end_layout

\begin_layout Plain Layout

    'An exponential population growth model'
\end_layout

\begin_layout Plain Layout

    if gen < G0:
\end_layout

\begin_layout Plain Layout

        return N0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        rate = (math.log(N1) - math.log(N0))/G1
\end_layout

\begin_layout Plain Layout

        return int(N0 * math.exp((gen - G0) * rate))
\end_layout

\end_inset

That is to say, we first solve 
\begin_inset Formula $r$
\end_inset

 from 
\begin_inset Formula $N_{1}=N_{0}\exp\left(rG_{1}\right)$
\end_inset

 and then calculate 
\begin_inset Formula $N_{t}=N_{0}\exp\left(rG\right)$
\end_inset

 for a given generation.
\end_layout

\begin_layout Standard
There is a problem here: the above definitions treat 
\family typewriter
N0
\family default
, 
\family typewriter
G0
\family default
, 
\family typewriter
N1
\family default
 and 
\family typewriter
G1
\family default
 as global variables.
 This is OK for small scripts but is certainly not a good idea for larger
 scripts especially when different parameters will be used.
 A better way is to wrap these functions by another function that accept
 
\family typewriter
N0
\family default
, 
\family typewriter
G0
\family default
, 
\family typewriter
N1
\family default
 and 
\family typewriter
G1
\family default
 as parameters.
 That is demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichDemo"

\end_inset

 where a function 
\family typewriter
demo_model
\family default
 is defined to return either an instant or an exponential population growth
 demographic function.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichDemo.log"
lstparams "caption={A demographic function producer},label={reichDemo}"

\end_inset


\end_layout

\begin_layout Note
The defined demographic functions return the total population size (a number)
 at each generation beacuse no subpopulation is considered.
 A list of subpopulation sizes should be returned if there are more than
 one subpopulations.
\end_layout

\begin_layout Section
Mutation and selection models
\end_layout

\begin_layout Standard
The thoretical model empolyees an infinite allele model where there is a
 single wild type allele and an infinite number of disease alleles.
 Each mutation would introduce a new disease allele and there is no back
 mutation (mutation from disease allele to wild type allele).
\end_layout

\begin_layout Standard
This mutation model can be mimicked by a 
\begin_inset Formula $k$
\end_inset

-allele model with resaonably large 
\begin_inset Formula $k$
\end_inset

.
 We initialize all alleles to 0 which is the wild type (
\begin_inset Formula $A$
\end_inset

) and all other alleles are considered as disease alleles (
\begin_inset Formula $a$
\end_inset

).
 Because an allele in a 
\begin_inset Formula $k-$
\end_inset

allele mutation model can mutate to any other allele with equal probability,
 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more disease alleles than the wild type allele.
 If we choose a smaller 
\begin_inset Formula $k$
\end_inset

 (e.g.
 
\begin_inset Formula $k=20$
\end_inset

), recurrent and back mutations can on longer be ignored but it would be
 interesting to simulate such cases because they are more realistic than
 the infinite allele model in some cases.
\end_layout

\begin_layout Standard
A 
\begin_inset Formula $k$
\end_inset

-allele model can be simulated using the 
\family typewriter
KAlleleMutator
\family default
 operator which accepts a mutation rate and a maximum allelic state as parameter
s.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

KAlleleMutator(k=k, rates=mu)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because there are many possible disease alleles, a multi-allelic selector
 (
\family typewriter
MaSelector
\family default
) could be used to select against the disease alleles.
 This operator accept a single or a list of wild type alleles (
\family typewriter
[0]
\family default
 in this case) and treat all other alleles as disease alleles.
 A penetrance table is needed which specified the fitness of each individual
 when they have 0, 1 or 2 disease alleles respectively.
 In this example, we assume a recessive model in which only genotype 
\begin_inset Formula $aa$
\end_inset

 causes genetic disadvantages.
 If we assume a selection pressure parameter 
\begin_inset Formula $s$
\end_inset

, the operator to use is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MaSelector(loci=0, wildtype=0, penetrance=[1, 1, 1-s])
\end_layout

\end_inset

Note that the use of this selector requires a population information field
 
\family typewriter
fitness
\family default
.
\end_layout

\begin_layout Standard
This example uses a single-locus selection model but the complete script
 allows the use of different kinds of multi-locus selection model.
 If we assume a multiplicative multi-locus selection model where fitness
 values at different loci are combined (multiplied), a multi-locus selection
 model (
\family typewriter
MlSelector
\family default
) could be used as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MlSelector([
\end_layout

\begin_layout Plain Layout

    MaSelector(loci=loc1, fitness=[1,1,1-s1], wildtype=0),
\end_layout

\begin_layout Plain Layout

    MaSelector(loci=loc2, fitness=[1,1,1-s2], wildtype=0)],
\end_layout

\begin_layout Plain Layout

    mode=MULTIPLICATIVE
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These multi-locus model treat disease alleles at different loci more or
 less independently.
 If more complex multi-locus models (e.g.
 models involve gene - gene and/or gene - interaction) are involved, a multi-loc
us selector that uses a multi-locus penetrance table could be used.
\end_layout

\begin_layout Section
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy because 
\family typewriter
Stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use a 
\family typewriter
Stat()
\family default
 operator to calculate allele frequency and get the result from population
 variable 
\family typewriter
alleleFreq
\family default
.
 Because allele frequcies add up to one, we can get the total disease allele
 frequency using the allele frequency of the wild type allele 0 (
\begin_inset Formula $\sum_{i=1}^{\infty}f_{i}=1-f_{0}$
\end_inset

).
 The actual code would look more or less like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Stat(alleleFreq=[0,1]),
\end_layout

\begin_layout Plain Layout

PyEval(r'"%.2f" % (1-alleleFreq[0][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are also interested in the effective number of alleles 
\begin_inset CommandInset citation
LatexCommand citep
key "Reich2001a"

\end_inset

 at a locus.
 Because simuPOP does not provide an operator or function to calculate this
 statistic, we will have to calculate it manually.
 Fortunately, this is not difficult because effective number of alleles
 can be calculated from existing allele frequencies, using formula
\begin_inset Formula 
\[
n_{e}=\left(\sum_{i=1}^{\infty}\left(\frac{f_{i}}{1-f_{0}}\right)^{2}\right)^{-1}
\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
A quick-and-dirty way to output 
\begin_inset Formula $n_{e}$
\end_inset

 at a locus (e.g.
 locus 0) can be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyEval('1./sum([(alleleFreq[0][x]/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0].
keys() if x != 0])')
\end_layout

\end_inset

but this expression looks complicated and does not handle the case when
 
\begin_inset Formula $f_{0}=1$
\end_inset

.
 A more robust method would involve the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
PyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyEval(stmts='''if alleleFreq[0][0] == 1:
\end_layout

\begin_layout Plain Layout

    ne = 0
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    freq = [freq[0][x] for x in alleleFreq[0].keys() if x != 0]
\end_layout

\begin_layout Plain Layout

    ne = 1./sum([(f/(1-alleleFreq[0][0])**2 for x in freq])
\end_layout

\begin_layout Plain Layout

''', expr=r'"%.3f" % ne')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this piece of code does not look nice with the multi-line string,
 and the operator is not really reusable (only valid for locus o).
 It makes sense to define a function to calculate 
\begin_inset Formula $n_{e}$
\end_inset

 generally:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ne(pop, loci):
\end_layout

\begin_layout Plain Layout

    ' calculate effective number of alleles at given loci'
\end_layout

\begin_layout Plain Layout

    stat(pop, alleleFreq=loci)
\end_layout

\begin_layout Plain Layout

    ne = {}
\end_layout

\begin_layout Plain Layout

    for loc in loci:
\end_layout

\begin_layout Plain Layout

        freq = [y for x,y in pop.dvars().alleleFreq[loc].iteritems() if x !=
 0]
\end_layout

\begin_layout Plain Layout

        sumFreq = 1 - pop.dvars().alleleFreq[loc][0]
\end_layout

\begin_layout Plain Layout

        if sumFreq == 0:
\end_layout

\begin_layout Plain Layout

            ne[loc] = 0
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            ne[loc] = 1.
 / sum([(x/sumFreq)**2 for x in freq])
\end_layout

\begin_layout Plain Layout

    # save the result to the population.
\end_layout

\begin_layout Plain Layout

    pop.dvars().ne = ne
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When it is needed to calculate effective number of alleles, a Python operator
 that uses this function can be used.
 For example, operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyOperator(func=ne, param=[0], step=5)
\end_layout

\begin_layout Plain Layout

PyEval(r'"%.3f" % ne[0]', step=5)
\end_layout

\end_inset

would calculate effective number of alleles at locus 0 and output it.
 
\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
PyEval
\family default
 and 
\family typewriter
PyOperator
\family default
 is that 
\family typewriter
PyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the variables explicitly using the 
\family typewriter
pop.dvars()
\family default
 function, and the results have to be explicitly saved to the population's
 local namespace.
\end_layout

\begin_layout Standard
The final implementation, as a way to demonstrate how to define a new statistics
 that hides all the details, defines a new operator by inheriting a class
 from 
\family typewriter
PyOperator
\family default
.
 The resulting operator could be used as a regular operator (e.g., 
\family typewriter
ne(loci=[0])
\family default
).
 A function 
\family typewriter
Ne
\family default
 is also defined as the function form of this operator.
 The code is listed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichstat"

\end_inset

 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichstat.log"
lstparams "caption={A customized operator to calculate effective number of alleles},label={reichstat}"

\end_inset


\end_layout

\begin_layout Section
Initialize and evolve the population
\end_layout

\begin_layout Standard
With appropriate operators to perform mutation, selection and output statistics,
 it is relatively easy to write a simulator to perform a simulation.
 This simulator would create a population, initialize alleles with an initial
 allic spectrum, and then evolve it according to specified demographic model.
 During the evolution, mutation and selection will be applied, statistics
 will be calculated and outputed.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/reichEvolve.log"
lstparams "caption={Evolve a population subject to mutation and selection},label={reichEvolve}"

\end_inset


\end_layout

\begin_layout Section
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to 
\end_layout

\begin_layout Enumerate
Run more simulations with different parameters such as initial population
 size and mutaion rate.
 This requires the script to get its parameters from command line (or a
 configuration file) and executes in batch mode, perhaps on a cluster system.
\end_layout

\begin_layout Enumerate
Allow users who are not familiar with the script to run it.
 This would better be achieved by a graphical user interface.
\end_layout

\begin_layout Enumerate
Allow other Python scripts to import your script and run the simulation
 function directly.
\end_layout

\begin_layout Standard
Although a number of Python modules such as 
\family typewriter
getopt
\family default
 are available, the simuPOP 
\family typewriter
simuOpt
\family default
 module is especially designed to allow a simuPOP script to be run both
 in batch and in GUI mode, in standard and optimized mode.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich"

\end_inset

 makes use of this module.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuCDCV.py"
lstparams "caption={A complete simulation script},label={reich}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich"

\end_inset

 uses a programming style that is used by almost all simuPOP scripts.
 I highly recommend this style because it makes your script seld-documentary
 and work well under a variety of environments.
 A script written in this style follows the following order:
\end_layout

\begin_layout Enumerate
First comment block
\end_layout

\begin_deeper
\begin_layout Standard
The first line of the script should always be 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\end_inset

This line tells a Unix shell which program should be used to process this
 script if the script to set to be executable.
 This line is ignored under windows.
 It is customary to put author and date information at the top of a script
 as Python comments.
\end_layout

\end_deeper
\begin_layout Enumerate
Module doc string
\end_layout

\begin_deeper
\begin_layout Standard
The first string in a script is the module docstring, which can be referred
 by variable 
\family typewriter
__doc__
\family default
 in the script.
 It is a good idea to describe what this script does in detail here.
 As you will see later, this docstring will be used in the 
\family typewriter
simuOpt.getParam()
\family default
 function and be outputed in the usage information of the script.
\end_layout

\end_deeper
\begin_layout Enumerate
Loading simuPOP and other Python modules
\end_layout

\begin_deeper
\begin_layout Standard
simuPOP and other modules are usually imported after module docstring.
 This is where you specify which simuPOP module to use.
 Although a number of parameters could be used, usually only 
\family typewriter
alleleType
\family default
 is specified because other parameters such as 
\family typewriter
gui
\family default
 and 
\family typewriter
optimized
\family default
 should better be controlled from command line.
\end_layout

\end_deeper
\begin_layout Enumerate
Parameter description list
\end_layout

\begin_deeper
\begin_layout Standard
A list of parameter description dictionaries are given here.
 This list specifies what parameters will be used in this script and describes
 the type, default value, name of command line option, label of the parameter
 in the parameter input dialog in detail.
 Although some directionary items can be ignored, it is a good practice
 to give detailed information about each parameter here.
\end_layout

\end_deeper
\begin_layout Enumerate
Helper functions and classes
\end_layout

\begin_deeper
\begin_layout Standard
Helper functions and classes are given before the main simulation function.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation function
\end_layout

\begin_deeper
\begin_layout Standard
The main simulation function preforms the main functionality of the whole
 script.
 It is written as a function so that it can be imported and executed by
 another script.
 The parameter processing part of the script would be ignored in this case.
\end_layout

\end_deeper
\begin_layout Enumerate
Script execution part conditioned by 
\family typewriter
__name__ == '__main__'
\end_layout

\begin_deeper
\begin_layout Standard
The execution part of a script should always be inside of a 
\family typewriter
if __name__ == '__main__'
\family default
 block so that the script will not be executed when it is imported by another
 script.
 The first few lines of this execution block are almost always
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

par = simuOpt.Params(options, __doc__)
\end_layout

\begin_layout Plain Layout

if not par.getParam():
\end_layout

\begin_layout Plain Layout

    sys.exit(1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which creates a simuOpt object and tries to get parameters from command
 line option, a configuration file, a parameter input dialog or interactive
 user input, depending on how this script is executed.
 Optionally, you can use
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

par.saveConfig('file.cfg')
\end_layout

\end_inset

to save the current configuration to a file so that the same parameters
 could be retrieved later using parameter 
\family typewriter
--config file.cfg
\family default
.
\end_layout

\begin_layout Standard
After simply parameter validation, the main simulation function can be called.
 This example uses 
\family typewriter
simuCDCV(*par.asList())
\family default
 because the parameter list in the 
\family typewriter
par
\family default
 object match the parameter list of function 
\family typewriter
simuCDCV
\family default
 exactly.
 If there are a large number of parameters, it may be better to pass the
 
\family typewriter
simuOpt
\family default
 object directly in the main simulation function.
\end_layout

\end_deeper
\begin_layout Standard
The script written in this style could be executed in a number of ways.
\end_layout

\begin_layout Enumerate
If a user executes the script directly, a Tkinter or wxPython dialog will
 be displayed for users to input parameters.
 This parameter is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simuCDCV-dialog"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:simuCDCV-dialog"

\end_inset

Parameter input dialog of the simuCDCV script
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/simuCDCV.png
	lyxscale 40
	width 5in

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The help message of this script could be displayed using the Help button
 of the parameter input dialog, or using command 
\family typewriter
simuCDCV.py -h
\family default
.
 The help message is displayed in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reichHelp"

\end_inset

.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simuCDCV.hlp"
lstparams "caption={Help information for the simuCDCV script},label={reichHelp}"

\end_inset


\end_layout

\begin_layout Enumerate
Using parameter 
\family typewriter
--gui=False
\family default
, the script will be run in batch mode.
 You can specify parameters using
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuCDCV.py --gui=False --config file.cfg
\end_layout

\end_inset

if a parameter file is available, or use command line options such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simuCDCV.py --gui=False --demo='instant' --N0=10000 --N1=100000 
\backslash

\end_layout

\begin_layout Plain Layout

    --G0=500 --G1=500 --spec='[0.9]+[0.02]*5' --s=0.01 
\backslash

\end_layout

\begin_layout Plain Layout

    --mu='1e-4' --k=200
\end_layout

\end_inset

Note that parameters with 
\family typewriter
useDefault
\family default
 set to 
\family typewriter
True
\family default
 can be ignored if the default parameter is used.
 In addition, parameter 
\family typewriter
--optimized
\family default
 could be used to load the optimized version of a simuPOP module.
 For this particular configuration, the optimized module is 30% faster (62s
 vs.
 40s) than the standard module.
\end_layout

\begin_layout Enumerate
The simulation function could be imported to another script as follows
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

from simuCDCV import simuCDCV
\end_layout

\begin_layout Plain Layout

simuCDCV(model='instant', N0=10000, N1=10000, G0=500, G1=500,
\end_layout

\begin_layout Plain Layout

    spec=[0.9]+[0.02]*5, s=0.01, mu=1e-4, k=200)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
