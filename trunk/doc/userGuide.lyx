#LyX 1.5.4svn created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass manual
\begin_preamble
\usepackage{graphicx}
\usepackage{epsfig}
%\usepackage{hyperref}
%\hypersetup{
%pdfauthor={Bo Peng},
%pdftitle={simuPOP User's Guide},
%pdfcreator={lyx+pdflatex},
%pdfproducer={pdflatex},
%}

\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.8.4 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement h
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},language=Python,showspaces=false,showstringspaces=false,showtabs=false,xleftmargin=15pt"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
hspace{1cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{5in}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

{
\backslash
large
\backslash
textsf Acknowledgements: }
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
vspace{.2cm}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Marek Kimmel
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 Fran
\backslash
c cois Balloux
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Dr.
 William Amos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} SWIG user community
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Python user community 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} Keck Center for Computational and Structural Biology
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
hspace{.3cm} U.T.
 M.D.
 Anderson Cancer Center
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
vspace{.7in} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2007 Bo Peng 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
simuPOP can be used at two levels.
 The core of simuPOP is a scripting language (Python) that provides a large
 number of building blocks (populations, mating schemes, various genetic
 forces in the form of functions, operators, simulators and gene mapping
 methods) to construct a simulation.
 This provides a R/S-Plus or Matlab-like environment where users can interactive
ly create, manipulate and evolve populations; monitor and visualize population
 statistics and apply gene mapping methods.
 The full power of simuPOP and Python (even R) can be utilized to simulate
 arbitrarily complex evolutionary scenarios.
\end_layout

\begin_layout Abstract
simuPOP also comes with an increasing number of pre-defined simulation scenarios.
 If one of them happens to fit your need, all you need to do is running
 the script file with appropriate parameters.
 No knowledge of Python or simuPOP is required.
 To make simuPOP readily usable for time-limited users, users of simuPOP
 are strongly encouraged to submit their simulations to this collection.
 
\end_layout

\begin_layout Abstract
This user's guide covers the basic usage of simuPOP, including installation,
 basic usage, brief introduction to built-in scripts, and how to write simuPOP
 scripts.
 Detailed information about simuPOP components, functions and operators
 is available in the 
\emph on
simuPOP Reference Manual.

\emph default
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP: 
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
(18): 3686-3687
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 'runSampleCode.py splitMerge.py', and simuPOP_ref.tex generated by 'doxygen;
 cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard

\family typewriter
simuPOP
\family default
 is a forward-time population genetics simulation environment.
 Unlike coalescent-based simulation programs, simuPOP evolves population(s)
 forward in time, subject to arbitrary number of genetic and environmental
 forces (mutation, recombination, migration, population size change etc.).
 simuPOP allows users to control every aspects of the evolutionary process
 and observe the details at each generation.
 For example, users can start with a population of identical individuals,
 manually introduce a mutant and observe the spread of this mutant in the
 population from generation to generation.
 Population substructure, recombination, migration, selection etc can be
 added to the simulation as needed.
 
\end_layout

\begin_layout Standard
simuPOP consists of a number of Python objects and functions, including
 populations that store and provide access to individual genotypes; mating
 schemes that determine how populations evolve to the next generation; operators
 that manipulate populations and calculate population statistics; simulators
 that coordinate the evolution process and functions that perform tasks
 ranging from saving/loading populations to doing gene mapping.
 It is user's responsibility to write a Python script to glue these pieces
 together and form a simulation.
 Since these modules are mostly independent to each other, it is easy to
 add additional operators to an existing simulation.
 There is no limit on the number of operators, and thus no limit on the
 complexity of a simulation.
\end_layout

\begin_layout Standard
simuPOP does not aim at any specific result or outcome.
 It is more like a workshop, where users use various components and tools
 to assemble a simulation and study its properties, or manipulated populations
 without evolving them.
 Just like any such programming environments such as R/Splus and Matlab,
 users will have to learn how to use the environment (various Python IDE)
 and how to program in this language (Python and the simuPOP module).
 A graphic user interface of simuPOP is planned but its usefulness is in
 doubt (just like the R/GUI) and will not be available any time soon.
 
\end_layout

\begin_layout Standard
On the other hand, simuPOP also has an increasing number of built-in scripts.
 These script are written in simuPOP/Python language and can be used without
 knowing their underlying mechanism.
 It is strongly recommended that users of simuPOP submit their own scripts
 to his collection and so other users can learn and adapt their own simulations
 from these scripts.
\end_layout

\begin_layout Standard
As a summary, simuPOP is suitable for the following applications:
\end_layout

\begin_layout Itemize
Teaching tool for population genetics courses.
 Compared to other existing programs, the biggest advantage of simuPOP is
 its flexibility.
 There is no limit on the complexity of the simulation and students can
 change the script and try new things (such as viewing another statistics
 or adding another genetic force) at will.
\end_layout

\begin_layout Itemize
Observe the dynamics of population evolution.
 This is where the power of simuPOP lies and is where coalescent-based simulatio
ns frown.
 Coalescent, by its nature, focus only on samples, and ignore genealogy
 information that are irrelevant to the final sample.
 It is therefore impractical to trace the population properties of ancestral
 populations.
 Forward-based simulation does not have this problem, at a cost of performance.
\end_layout

\begin_layout Itemize
Generating samples that can be analyzed by other programs.
 This area is dominated by coalescent-based methods, but the facts that
 coalescent-based methods can not simulate complex (non-additive) selection
 or penetrance models and supports, at least till now, only one disease
 susceptibility locus, make it unsuitable to simulate the evolution of complex
 human diseases.
 A simuPOP script 
\family typewriter
simuComplexDisease.py
\family default
 provides a powerful alternative.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
Currently, simuPOP provides the following features:
\end_layout

\begin_layout Itemize
Population with arbitrary subpopulation structure.
 Sex chromosome is modeled.
\end_layout

\begin_layout Itemize
Arbitrary information, such as age, fitness, parents, can be attached to
 each individual.
\end_layout

\begin_layout Itemize
There is no limit on ploidy, number of chromosomes, number of loci and populatio
n size.
 For single-CPU versions of simuPOP, the size of population is limited by
 available RAM.
 The MPI version of simuPOP can spread populations to a cluster of machines
 and allows simulations of huge populations.
\end_layout

\begin_layout Itemize
Allele can be short (<255 allelic states), long ( 
\begin_inset Formula $2^{16}$
\end_inset

 allelic states) or binary (0 or 1).
 Binary alleles are stored as bits so a large number of SNP markers can
 be simulated.
\end_layout

\begin_layout Itemize
A population can hold arbitrary number of ancestral generations (default
 to none) for easy pedigree analyses.
 
\end_layout

\begin_layout Itemize
Population/subpopulation sizes can be changed during mating.
 Subpopulations can be created/changed as a result of migration.
 
\end_layout

\begin_layout Itemize
Several replicates of populations can be evolved simultaneously.
 
\end_layout

\begin_layout Itemize
Mating schemes include random mating, binomial selection etc.
 Number of offspring per mating can be constant, or follow a random distribution.
\end_layout

\begin_layout Itemize
Populations can be saved and loaded in text, binary, XML, Fstat, GC formats.
 Methods to deal with other formats are provided.
 
\end_layout

\begin_layout Itemize
Simulation can be paused, saved and resumed easily.
\end_layout

\begin_layout Itemize
Easy developing/debugging using Python interactive shell, or run in batch
 as python scripts.
\end_layout

\begin_layout Itemize
A wide variety of operators are provided.
 They can act on the populations at selected generations, at different stages
 of a life-cycle, on different replicate or replicate group.
 
\end_layout

\begin_layout Itemize
Built-in operators for arbitrary migration model.
\end_layout

\begin_layout Itemize
Operators for 
\begin_inset Formula $k$
\end_inset

-allele, stepwise and generalized stepwise mutation models.
 Hybrid operators can be used for more complicated mutation models.
\end_layout

\begin_layout Itemize
Support uniform or non-uniform (differ-by-loci) recombinations.
 Male/female individuals can have different recombination rates/intensities.
 
\end_layout

\begin_layout Itemize
Support many single-locus selection model and multiplicative/additive multi-loci
 selection models.
 Hybrid operator is provided for arbitrary selection model.
\end_layout

\begin_layout Itemize
Built-in support for allele, genotype, heterozygote, haplotype number/frequency
 calculation.
 As well as some more complicated statistics like 
\begin_inset Formula $F_{st}$
\end_inset

.
 Other statistics can be calculated from these basic statistics.
\end_layout

\begin_layout Itemize
Has support for plotting through RPy (use R through Python).
 Other methods are supported.
\end_layout

\begin_layout Itemize
Operators to calculate quantitative trait, penetrance and draw samples from
 current population.
\end_layout

\begin_layout Itemize
Built-in ascertainment methods including case/control, affected sibpair,
 random sample.
\end_layout

\begin_layout Itemize
Maybe most importantly: 
\emph on
a complete and detailed reference manual!
\end_layout

\begin_layout Standard
New in 0.8.2
\end_layout

\begin_layout Itemize
selfing is introduced as a way to produce offspring from a parent
\end_layout

\begin_layout Itemize
pyMating can work with different, including a hybrid, parent choosers and
 different offspring generator including selfing.
\end_layout

\begin_layout Itemize
recombinator works with selfing.
\end_layout

\begin_layout Section
Availability
\end_layout

\begin_layout Standard
Binary libraries of 
\family typewriter
simuPOP
\family default
 are provided for linux, windows, solaris and mac systems.
 Source code and development documentations are also available for easy
 porting to other platforms.
 Both source code and binaries can be distributed free-of-charge under GPL
 license.
 All resources, including a pdf version of this manual and a mailing list
 can be found at the simuPOP homepage.
\end_layout

\begin_layout Section
Special notes for windows users
\end_layout

\begin_layout Standard
Because large populations tend to take lots of disk spaces, simuPOP compresses
 text, binary or XML output in gzip format by default, despite the slower
 saving time.
 Because gzip format is not well supported under windows, this feature is
 disabled under windows.
 The 
\family typewriter
compress=True
\family default
 option of 
\family typewriter
savePopulation
\family default
 is ignored.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Naming Conventions
\end_layout

\begin_layout Standard

\family typewriter
simuPOP
\family default
 follows the following naming conventions.
\end_layout

\begin_layout Itemize
Classes (objects), member functions and parameter names start with small
 character and use capital character for the first character of each word
 afterward.
 For example
\end_layout

\begin_layout LyX-Code
population, population::subPopSize(), individual::setInfo()
\end_layout

\begin_layout Itemize
Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter
initByFreq(vars)
\family default
 is an operator and 
\family typewriter
InitByFreq(pop, vars)
\family default
 is its function version (equivalent to 
\family typewriter
initByFreq(vars).apply(pop)
\family default
).
\end_layout

\begin_layout Itemize
Constants start with Capital characters.
 For example
\end_layout

\begin_layout LyX-Code
MigrByProportion, StatNumOfFemale
\end_layout

\begin_layout Itemize
The following words in function names are abbreviated:
\end_layout

\begin_layout LyX-Code
pos (position),  info (information), migr (migration), subPop (subpopulation),
 
\newline
(rep) replicate, gen (generation), grp (group(s)), ops (operators), 
\newline
expr
 (expression), stmts (statements) 
\end_layout

\begin_layout Section
How to read this manual
\end_layout

\begin_layout Standard
There are a lot of functions/operators in simuPOP and there is no reason
 you should memorize all of them.
 (I admit that I can not.) If you are a first time simuPOP user, my suggestion
 is that you read through this manual quickly only to get the big picture
 of how simuPOP works and what simuPOP can do.
 Then, if you decide to write some simulations, you should
\end_layout

\begin_layout Itemize
Read some examples under 
\family typewriter
scripts
\family default
 directory.
 From easy to difficult, you can read 
\family typewriter
simuLDDecay.py, simuCDCV.py
\family default
 and 
\family typewriter
simuComplexDisease.py.

\family default
 Scripts from the 
\family typewriter
examples
\family default
 directory can also be studied.
\end_layout

\begin_layout Itemize
Copy one of the scripts as a template and modify it.
 For whatever function/operator you need, read the relevant sections in
 detail.
 
\end_layout

\begin_layout Chapter
Installing simuPOP
\end_layout

\begin_layout Section
Installing simuPOP
\end_layout

\begin_layout Standard
Compiled libraries for Linux (RHEL4 and Mandriva) and windows XP.
 Solaris and MacOSX binaries are currently not provided due to machine availabil
ity.
 In most cases, you will only need to download simuPOP and follow the usual
 installation process of your platform.
 For example, if you use a windows system and have Python 2.3.3 installed,
 you should download 
\family typewriter
simupop-x.x.x-py23-win32.exe
\family default
.
 Double click the 
\family typewriter
.exe
\family default
 file to install.
 
\end_layout

\begin_layout Standard
Things can get complicated when you have an earlier/later versions of OS,
 compiler or Python and have to compile simuPOP from source.
 The 
\family typewriter
installation
\family default
 section of simuPOP homepage has detailed instructions.
 A single command 
\family typewriter
python setup.py install
\family default
 will usually suffice.
\end_layout

\begin_layout Standard
Python has a large number of modules.
 For simple tasks like dataset generation, simuPOP modules alone are enough.
 However, it is highly recommended that you install 
\end_layout

\begin_layout Itemize
R and a python module rpy: although other piloting modules/methods can be
 used, simuPOP mainly uses R for this purpose.
 The advantage of this method is that R is not only an excellent plotting
 tool, but also a widely used statistical analysis package.
 It also has some genetic packages that can be used to analyze simuPOP generated
 datasets.
\end_layout

\begin_layout Itemize
wxPython: By default, simuPOP uses Tkinter to get parameters (the parameter
 dialog).
 It will use wxPython automatically if wxPython is available.
 This will enable a bunch of other GUI improvements including a nicer version
 of 
\family typewriter
ListVars()
\family default
 function.
 
\end_layout

\begin_layout Section
Starting simuPOP
\end_layout

\begin_layout Standard
After installation, you will have the following files and directories (use
 windows as an example)
\end_layout

\begin_layout Itemize
Many 
\family typewriter
simuXXX.py
\family default
 files under 
\family typewriter
c:
\backslash
python23
\backslash
Lib
\backslash
site-packages
\family default
.
 These are simuPOP modules.
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python23
\backslash
share
\backslash
simuPOP
\backslash
doc
\family default
: documentations in pdf format.
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python23
\backslash
share
\backslash
simuPOP
\backslash
test:
\family default
 all unit test cases.
 You can run run_tests.py to test if your simuPOP installation is correct.
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python23
\backslash
share
\backslash
simuPOP
\backslash
scripts
\series bold
\emph on
:
\family default
\series default
\emph default
 This directory has all the built-in scripts.
\end_layout

\begin_layout Standard
You should be able to load simuPOP library by running command 
\family typewriter
import simuPOP
\family default
 (example 
\begin_inset LatexCommand ref
reference "Import-simuPOP-module"

\end_inset

) from python interactive shell.
 From the initial output, you can see the version (and revision number)
 of simuPOP, type of module, random number generator, etc.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/importSimuPOP.log}[caption={Import simuPOP module},label={Import-simuPOP-module}]
preview false

\end_inset


\end_layout

\begin_layout Standard
In case that you do not have administrative privilege, you may not be able
 to install simuPOP to the system python directory.
 In this case, you can install simuPOP locally and load simuPOP as shown
 in example 
\begin_inset LatexCommand ref
reference "Import-simuPOP-module-add-path"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/addSysPath.log}[caption={Import locally installed simuPOP module},label={Import-simuPOP-module-add-path}]
preview false

\end_inset


\end_layout

\begin_layout Section
simuPOP Modules
\end_layout

\begin_layout Standard
simuPOP is composed of twelve libraries: standard short, long and binary
 alleles (3), each of them have standard and optimized (
\begin_inset Formula $\times2$
\end_inset

), and single-CPU and Message Passing Interface (MPI) versions (
\begin_inset Formula $\times2$
\end_inset

).
 The short libraries use 1 byte to store each allele which limits the possible
 allele states to 256.
 This is enough most of the times but not so if you need to simulate models
 like the infinite allele model.
 In those cases, you should use the long allele version of the modules,
 which use 2 bytes for each allele and can have 
\begin_inset Formula $2^{16}$
\end_inset

 possible allele states.
 On the other hand, if you would like to simulate a large number of binary
 (SNP) markers, binary libraries can save you a lot of RAM.
 Depending on applications, binary alleles can be faster or slower than
 regular modules.
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure the simulations run correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time checking varies from simulation to simulation
 but can be high under some extreme circumstances.
 Because of this, optimized versions for all libraries are provided.
 They bypass all parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confidenc
e that your simulation is running as expected.
\end_layout

\begin_layout Standard
The MPI modules are not provided in the binary distributions since many
 MPI implementations are available for different platforms.
 Also, as of version 0.7.9, the MPI modules are not yet fully implemented
 (and most likely unusable for your simulations).
 You will have to compile simuPOP by yourself to make use of them.Due to
 the overhead of inter-CPU communication, the MPI versions are not necessarily
 much faster than single-CPU modules.
 However, since the MPI version of the modules spread the populations across
 nodes, they can handle much larger populations then single-CPU modules,
 and can save you some time when you have multiple CPU/Core workstations.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/importSimuPOPOpt.log}[caption={set options through simuOpt}]
preview false

\end_inset


\end_layout

\begin_layout Standard
You can control the choice of modules in the following ways:
\end_layout

\begin_layout Itemize
Set environment variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset LatexCommand index
name "SIMUALLELETYPE"

\end_inset

 to be 'short', 'long' or 'binary', 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules, and 
\family typewriter
SIMUMPI
\family default
 to use MPI modules.
 The default module is the standard short module.
\end_layout

\begin_layout Itemize
Before you load simuPOP, set options using 
\family typewriter
simuOpt
\begin_inset LatexCommand index
name "simuOpt"

\end_inset

.setOptions(optimized, mpi, alleleType, quiet, debug)
\family default
.
 
\family typewriter
alleleType
\family default

\begin_inset LatexCommand index
name "alleleType"

\end_inset

 can be 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary.

\family default
 
\family typewriter
mpi
\family default
 can be 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
.
 
\family typewriter
quiet
\family default
 means suppress initial output, and 
\family typewriter
debug
\family default
 should be a comma-separated list of debug options specified by 
\family typewriter
listDebugCode
\family default

\begin_inset LatexCommand index
name "listDebugCode"

\end_inset

().
\end_layout

\begin_layout Itemize
If you are running a simuPOP script that conforms to simuPOP convention,
 you should be able to use optimized library using command line option 
\family typewriter
--optimized
\family default
, and the MPI version using 
\family typewriter
--mpi.
\end_layout

\begin_layout Chapter
simuPOP components
\end_layout

\begin_layout Standard
The core of simuPOP is a scripting language based on the Python programming
 language.
 Like any other python module, you can start a python session, import simuPOP
 module, create and evolve populations interactively.
 Or, you can create a python script and run it as a batch file.
 
\end_layout

\begin_layout Standard
In this chapter, I will start from an simple example and them explain several
 import simuPOP components.
 Detailed info about each components is given in the 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Section
A simple example
\begin_inset LatexCommand label
name "sec:A-Simple-Example"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "alg:A-simple-example"

\end_inset

 is a log file of an interactive Python session.
 User input text after the 
\family typewriter
>>>
\family default
 prompt and Python will interpret and run your command interactively.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/simpleExample.log}[caption={A simple example},label={alg:A-simple-example}]
preview false

\end_inset


\end_layout

\begin_layout Standard
This example demonstrates the dynamics of linkage disequilibrium when recombinat
ion is in effect.
\end_layout

\begin_layout Itemize
The 
\family typewriter
import
\family default
 line import simuPOP module (output suppressed).
 
\family typewriter
simuRPy
\family default
 defines a pure-python operator 
\family typewriter
varPlotter
\family default
 that plot given variable using R.
\end_layout

\begin_layout Itemize

\family typewriter
simulator
\family default
 creates a simulator from a population created by the 
\family typewriter
population
\family default
 function.
 The population is diploid (
\family typewriter
ploidy=2
\family default
), has 1000 individuals (
\family typewriter
size=1000
\family default
) each has two loci on the first chromosome (
\family typewriter
loci=[2]
\family default
).
 The simulator has three copies of this population (
\family typewriter
rep=3
\family default
) and will evolve through random mating (
\family typewriter
randomMating()
\family default
).
\end_layout

\begin_layout Itemize

\family typewriter
simu.evolve
\family default
 evolves these populations 100 generations subject to some operators.
 
\end_layout

\begin_layout Itemize

\family typewriter
preOps=[initByValue]
\family default
: operators in parameter 
\family typewriter
preOps
\family default
 (accept a list of operators) will be applied to the populations at the
 beginning of evolution.
 
\family typewriter
initByValue
\family default
 is an 
\family typewriter
initializer
\family default
 that set the same genotype to all individuals.
 In this case, everyone will have genotype 
\family typewriter
12/21
\family default
 (
\family typewriter
1 2
\family default
 on the first chromosome and 
\family typewriter
2 1
\family default
 on the second copy of the chromosome) so linkage disequilibrium is 0.25
 (maximum possible value).
\end_layout

\begin_layout Itemize
operators in 
\family typewriter
ops
\family default
 parameter will be applied to all populations at each generation.
 (Not exactly, operators can be inactive at certain generations.)
\end_layout

\begin_layout Itemize

\family typewriter
recombinator
\family default
 is a 
\emph on
during-mating operator
\emph default
 that recombine parental chromosomes with probability 0.1 during mating.
\end_layout

\begin_layout Itemize

\family typewriter
stat
\family default
 is a 
\emph on
post-mating
\emph default
 operator.
 Parameter 
\family typewriter
LD=[0,1]
\family default
 tells the operator to calculate the linkage disequilibrium between locus
 0 and 1 (note the 0 index of loci).
 When this operator is applied to a population, it will calculate the LD
 for the population and store the result in the population's local variable
 namespace.
 For this case, variables 
\family typewriter
LD
\family default
, 
\family typewriter
LD_prime
\family default
 and 
\family typewriter
R2
\family default
 will be set.
\end_layout

\begin_layout Itemize

\family typewriter
varPlotter
\family default
 is a pure python operator that plot variable 
\family typewriter
LD[0][1]
\family default
 for each replicate of the populations.
 Title, labels on the 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

 axis, and a wealth of other options can be set.
 This operator evaluate the expression in each population's local namespace
 to get the LD value of each population.
\end_layout

\begin_layout Itemize

\family typewriter
pyEval
\family default
 accepts any python expression, evaluate it in each replicates' local namespace
 and return the result.
 In this example, 
\family typewriter
pyEval
\family default
 get the value of 
\family typewriter
gen
\family default
 (generation number), 
\family typewriter
LD[0][1]
\family default
 and print them.
 Note the we use 
\family typewriter
rep
\family default
 parameter to let operators apply to first (
\family typewriter
rep=0
\family default
), last (
\family typewriter
rep=REP_LAST
\family default
) or all (no 
\family typewriter
rep
\family default
) replicates and result in a table.
 We also use step=25 to apply these operators at 25 generations interval.
\end_layout

\begin_layout Itemize

\family typewriter
end=100:
\family default
 evolve 100 generations (To be exact: 0 - 100, 101 generations).
\end_layout

\begin_layout Itemize

\family typewriter
r.dev_print
\family default
: is a direct call to the rpy module.
 This line saves the figure to a file 
\family typewriter
ld/LDdecay.eps
\family default
.
 Note that 
\family typewriter
'.'
\family default
 in R function names need to be replaced by 
\family typewriter
'_'
\family default
.
 (Refer to rpy manual).
\end_layout

\begin_layout Standard
The output is a table of LD values of each replicate at 0, 25, 50, 57 and
 100 generations, as well as a figure at generation 100.
\end_layout

\begin_layout Standard
Most simuPOP scripts have similar steps.
 You can add more operators to the 
\family typewriter
ops
\family default
 list to build more complicated simulations.
 Obvious choices are 
\family typewriter
mutator
\family default
, 
\family typewriter
migrator
\family default
, or some proper visualizer to plot the dynamics of variables.
\end_layout

\begin_layout Section
Genotype structure
\end_layout

\begin_layout Standard
Genotypic structure refers to the number of copies of basic number of chromosome
s
\family typewriter
,
\family default
 number of chromosomes, existence of sex chromosome, number of loci on each
 chromosome, locus location on chromosome and allele names.
 It presents the common genetic configuration for all the individuals in
 a population.
\end_layout

\begin_layout Standard
Individuals in the same population share the same genotypic structure.
 Consequently, 
\emph on
genotypic information can be retrieved from individual, population and simulator
\emph default
 (consists of populations with the same genotypic structure) 
\emph on
level
\emph default
.
 
\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard

\family typewriter
population
\begin_inset LatexCommand index
name "population"

\end_inset


\family default
 objects are essential to simuPOP.
 They are composed of subpopulations each with certain number of individuals,
 all have the same genotypic structure.
 A population can store arbitrary number of ancestral populations to facilitate
 pedigree analysis.
\end_layout

\begin_layout Standard
simuPOP uses one-level population structure, but aribitrary temprary subpopulati
on structure can be defined.
 Such temporary subpopulations are called
\emph on
 virtual subpopulations
\emph default
, where individuals can be grouped by sex, affection status, genotype, or
 values of information fields.
 Mating is within subpopulations only.
 Exchange of genetic information across subpopulations can only be done
 through migration.
 Population and subpopulation sizes can be changed, as a result of mating
 or migration.
\end_layout

\begin_layout Standard
A very important feature of this population object is that you can store
 many generations of the population in a single population object.
 You can choose to store all or a limited number of generations during evolution.
 In the latter case, the oldest generation will be removed if a new generation
 is pushed in and the number of stored generations has exceeded the specified
 level.
\end_layout

\begin_layout Standard
simuPOP provides a large number of population related functions, they are
 used to
\end_layout

\begin_layout Itemize
access genotype structure
\end_layout

\begin_layout Itemize
access individuals and their genotypes
\end_layout

\begin_layout Itemize
manipulate subpopulations
\end_layout

\begin_layout Itemize
access ancestral generations
\end_layout

\begin_layout Itemize
manipulate genotype
\end_layout

\begin_layout Itemize
sample (subset) from the population
\end_layout

\begin_layout Itemize
access population variables
\end_layout

\begin_layout Itemize
save/load populations in various formats
\end_layout

\begin_layout Itemize
control virtual subpopulation structure.
\end_layout

\begin_layout Standard
You usually do not need to use these functions explicitly unless you need
 to write pure python functions/operators that involves complicated manipulation
 of populations, or when you need to manipulate populations directly for
 gene mapping, import/export purposes.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Individuals"

\end_inset

Individuals
\end_layout

\begin_layout Standard
Individuals can not be created without population.
 You can create a population and access its individuals through the 
\family typewriter
individual
\begin_inset LatexCommand index
name "population!individual"

\end_inset

(), individuals()
\family default
 functions.
 The returned 
\family typewriter
individual
\family default
 object has its own member functions, with which you can 
\end_layout

\begin_layout Itemize
access genotype structure
\end_layout

\begin_layout Itemize
retrieve/set genotype
\end_layout

\begin_layout Itemize
retrieve/set sex, affected status and some other auxiliary information (informat
ion fields)
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Populations are associated with python variables.
 These variables are usually set by various operators.
 For example, 
\family typewriter
stat
\begin_inset LatexCommand index
name "operator!stat"

\end_inset


\family default
 operator calculates many population statistics and store results in population
 namespace.
 However, you can also make use of this mechanism to pass parameters, store
 variables etc.
 
\end_layout

\begin_layout Standard
The interface functions are 
\family typewriter
population::vars
\begin_inset LatexCommand index
name "population!vars"

\end_inset

()
\family default
 and 
\family typewriter
population::
\begin_inset LatexCommand index
name "population!population"

\end_inset

dvars()
\family default
 function.
 They are identical except that 
\family typewriter
vars()
\family default
 returns a python dictionary and 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is the same as 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 To have a look at all associated variables of a population, you can print
 
\family typewriter
pop.vars()
\family default
, or better pass 
\family typewriter
pop.vars()
\family default
 to a function 
\family typewriter
ListVars()
\family default
.
 A nice GUI will be used if wxPython is installed.
\end_layout

\begin_layout Standard
It is important to know that this dictionary forms a local namespace in
 which expressions can be evaluated.
 As we can see from example 
\begin_inset LatexCommand ref
reference "alg:A-simple-example"

\end_inset

, the same expression 
\family typewriter
``'%f ' % LD[0][1]''
\family default
 can be evaluated in each population's local namespace and yield different
 results.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout Section
Mating Scheme
\begin_inset LatexCommand index
name "mating scheme"

\end_inset


\end_layout

\begin_layout Standard
Mating schemes specify how to generate offspring from the current population.
 It must be provided when a simulator is created.
 Mating can perform the following tasks:
\end_layout

\begin_layout Itemize
Change population/subpopulation sizes.
 This is where demographic models are handled in simuPOP.
 There are a few methods to control population sizes.
 The most flexible one is through a user-provided function that returns
 population (subpopulation) sizes at each generation.
\end_layout

\begin_layout Itemize
Choose parent(s) to generate offspring to populate the next generation.
 The number of offspring per mating event can be a fixed number (default
 to 1), or a random number following one of geometric, Poisson or binomial
 distribution.
 Customized (hybrid) parent choosers can be used.
\end_layout

\begin_layout Itemize
During-mating operators are applied to all offspring.
 The most commonly used during mating operator is a recombinator that can
 recombine parental chromosomes and form offspring genotype.
\end_layout

\begin_layout Itemize
Apply selection if applicable.
 If individual fitness are given (usually returned by a selector operator),
 a mating scheme will choose an individual to mate, according to its relative
 fitness.
\end_layout

\begin_layout Standard
A few mating schemes are available, among which 
\family typewriter
randomMating()
\family default
 is the most important.
 Non-random mating can be achieved using 
\family typewriter
pyMating
\family default
 and 
\family typewriter
heteroMating
\family default
, which is explained in detailed in 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They (there are exceptions) can be applied to populations directly, but
 most of the time they are managed and applied by a simulator.
 There are three kinds of operators:
\end_layout

\begin_layout Itemize

\emph on
built-in:
\emph default
 written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\end_layout

\begin_layout Itemize

\emph on
hybrid
\emph default

\begin_inset LatexCommand index
name "hybrid"

\end_inset

: written in C++ but calls python function when execution.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter
pyMutator
\family default
 will determine if an allele will be mutated and call a user--defined Python
 function to mutate it.
\end_layout

\begin_layout Itemize

\emph on
pure python
\emph default
: written in python.
 Same speed as python.
 For example, a 
\family typewriter
varPlotter
\begin_inset LatexCommand index
name "varPlotter"

\end_inset


\family default
 can plot python variables that are set by other operators.
\end_layout

\begin_layout Standard
You do not have to know the type of an operator to use them.
 The interface of them are all the same.
 Namely, they all accept a standard set of parameters, and are used in the
 same fashion.
 Such parameters include 
\family typewriter
rep, grp, begin, step, end
\family default
 and 
\family typewriter
at
\family default
.
 The first two indicate that the operator only applies to one or a group
 of replicates, and the rest control which generation(s) the operator will
 be applied to.
 There are also parameters that redirect operator output to files.
 For details please refer to the reference manual.
\end_layout

\begin_layout Standard
A simuPOP life cycle (each generation) can be divided into pre-mating, during-ma
ting and post-mating and an operator can be applied to one or more of them.
 For example, a 
\family typewriter
stat
\family default
 operator usually applies post-mating, but if you prefer, you can change
 its 
\family typewriter
stage
\family default
 parameter to 
\family typewriter
preMating
\family default
 and apply it pre-mating.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
Simulators combine three important components of simuPOP: population, mating
 scheme and operators together.
 A simulator is usually created with an instance of population, a replicate
 number and a mating scheme.
 It makes '
\family typewriter
rep
\family default
' replicates of this population and control the evolution process of these
 populations.
\end_layout

\begin_layout Standard
The most important function of a simulator is 
\family typewriter
evolve()
\family default
.
 It accepts arrays of operators as its parameters, among which, '
\family typewriter
preOps
\family default

\begin_inset LatexCommand index
name "simulato!preOps"

\end_inset

' and '
\family typewriter
postOps
\family default

\begin_inset LatexCommand index
name "simulator!postOps"

\end_inset

' will be applied to the populations at the beginning and end of evolution,
 respectively, whereas '
\family typewriter
ops
\family default
' will be applied at every generation.
 Of course, a simulator will probe and respect each operator's 
\family typewriter
rep, grp, begin, end, step, at, stage
\family default
 properties and act accordingly.
 
\end_layout

\begin_layout Chapter
Writing simuPOP scripts
\end_layout

\begin_layout Standard
In this chapter, I will show you, step by step, how to write a simuPOP script.
 The example is a simplified version of 
\family typewriter
scripts/simuCDCV.py
\family default
 which uses a python operator to calculate and save many more statistics,
 and use rpy to display the dynamics of disease allele frequency.
 
\end_layout

\begin_layout Section
Simulation scenario
\end_layout

\begin_layout Standard
\begin_inset LatexCommand citet
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
I use simuPOP to simulate this evolution process and observe the allelic
 spectra of both types of diseases.
 The results are published in 
\begin_inset LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Subsection
Demographic model
\end_layout

\begin_layout Standard
The initial population size is set to 10,000, as suggested in the paper.
 The simulation will evolve 500 generations with constant population size
 to reach mutation-selection equilibrium.
 Then, the population size will increase by around 20,000 every 10 generations
 and reach 1,000,000 at generation 1000.
 The population growth takes around 12,500 years if we assume 25 years per
 generation.
 
\end_layout

\begin_layout Subsection
Mutation model
\end_layout

\begin_layout Standard
The maximum number of alleles at each locus is set to be 2000, a number
 that is hopefully big enough to mimic the infinite allele model.
 Allele 0 is the wild type (
\begin_inset Formula $A$
\end_inset

) and all others are disease alleles (
\begin_inset Formula $a$
\end_inset

).
 The 
\begin_inset Formula $k-$
\end_inset

allele mutation model is used.
 That is to say, an allele can mutate to any other allele with equal probability.
 An immediate implication of this model is that 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more 
\begin_inset Formula $a$
\end_inset

 than 
\begin_inset Formula $A$
\end_inset

.
 The mutation rate is set to 
\begin_inset Formula $\mu=3.2\times10^{-5}$
\end_inset

 per locus per generation.
\end_layout

\begin_layout Subsection
Selection on a common and a rare disease 
\end_layout

\begin_layout Standard
Two diseases are simulated: a common disease with initial allele frequency
 of 
\begin_inset Formula $f_{0}=0.2$
\end_inset

; and a rare disease with initial allele frequency of 
\begin_inset Formula $f_{0}=0.001$
\end_inset

.
 The diseases are unlinked in the sense that their corresponding loci reside
 on separated chromosomes.
 The allelic spectra of both diseases are set to be 
\begin_inset Formula $\left[.9,.02,.02,.02,.02,.02\right]$
\end_inset

.
 I.e., one allele accounts for 90% of the disease cases.
 
\end_layout

\begin_layout Standard
Both diseases are recessive in that their fitness values are 
\begin_inset Formula $\left[1,1,1-s\right]$
\end_inset

 for genotype 
\begin_inset Formula $AA$
\end_inset

, 
\begin_inset Formula $Aa$
\end_inset

 and 
\begin_inset Formula $aa$
\end_inset

 respectively.
 
\begin_inset Formula $s_{c}=0.1$
\end_inset

 , 
\begin_inset Formula $s_{r}=0.9$
\end_inset

 are used in the simulation which imply weak selection on the common disease
 and strong selection on the rare disease.
 If an individual has both diseases, his fitness value follows a multiplicative
 model, i.e., 
\begin_inset Formula $\left(1-s_{c}\right)\times\left(1-s_{r}\right)=0.09$
\end_inset

.
 
\end_layout

\begin_layout Standard
These parameters, translated to python, are shown in 
\begin_inset LatexCommand ref
reference "alg:reich0"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{reich0.py}[caption={Set parameters},label={alg:reich0}]
preview false

\end_inset


\end_layout

\begin_layout Section
Create a simulator
\end_layout

\begin_layout Standard
Several parameters are needed to create a population:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\family default
: 2, default
\end_layout

\begin_layout Itemize

\family typewriter
size
\family default
: initial population size, known
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: no subpopulation (or one single population).
 size can be ignored if 
\family typewriter
subPop
\family default
 is given.
\end_layout

\begin_layout Itemize

\family typewriter
loci
\family default
: number of chromosomes and number of loci on each chromosome: we use two
 unlinked loci.
 use 
\family typewriter
loci=[1,1]
\family default
.
 This array gives the number of loci on each chromosome.
\end_layout

\begin_layout Itemize
loci name and position: no need to specify
\end_layout

\begin_layout Itemize

\family typewriter
infoFields
\family default
: This parameter is tricky since you need to specify what auxiliary information
 to attach to each individual.
 During the simulation, 
\family typewriter
fitness
\family default
 is needed because all selectors generate this information and mating schemes
 will make use of it.
 If you forget to provide this parameter, never mind, the simulation will
 fail and tell you that a information field 
\family typewriter
fitness
\family default
 is needed.
 Similar information fields include 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 when you want to track each individual's parents using 
\family typewriter
taggers.
\end_layout

\begin_layout Standard
You can then create a population with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

population(size=1000, loci=[1,1], infoFields=['fitness'])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create simulator, we need to decide on a mating scheme.
 
\family typewriter
randomMating
\family default
 should of course be used, but we need to tell 
\family typewriter
randomMating
\family default
 how population size should be changed.
 By default, all mating schemes keep the population size of ancestral population
, but we need an instant population expansion model.
\end_layout

\begin_layout Standard
The easiest way to achieve this is defining a function that accept generation
 number and the population size of previous generation, and return the size
 of this generation.
 The input and output population sizes need to be arrays, indicating sizes
 of all subpopulations.
 In our case, something like 
\family typewriter
[1000]
\family default
 should be used.
 The instant population growth model is actually quite easy to write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def ins_exp(gen, oldSize=[]):
\end_layout

\begin_layout Standard

     if gen < burnin:
\end_layout

\begin_layout Standard

         return [initSize]
\end_layout

\begin_layout Standard

     else:
\end_layout

\begin_layout Standard

         return [finalSize] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a little adjustment of how population size is given to 
\family typewriter
population()
\family default
, and use demographic function as a parameter to allow other demographic
 models to be used, we end up with example 
\begin_inset LatexCommand ref
reference "reich1"

\end_inset

.
 Note that because we use loci with more than 255 allele states, the long
 allele module is used.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{reich1.py}[caption={Create a simulator},label={reich1}]
preview false

\end_inset


\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
We start the simulation with initial allele spectra at the two loci.
 This can be achieved by operator 
\family typewriter
initByFreq
\family default
, which allows you to initialize individuals with alleles proportional to
 given allele frequencies.
 Using a large number of parameters, this operator can initialize any subset
 of loci, for any subset(s) of individuals, even given ploidy.
 We need only to specify locus to initialize, and use it like
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Standard

# initialize locus 0 (for common disease)
\end_layout

\begin_layout Standard

initByFreq(atLoci=[0], alleleFreq=C_f),
\end_layout

\begin_layout Standard

# initialize locus 1 (for rare disease)
\end_layout

\begin_layout Standard

initByFreq(atLoci=[1], alleleFreq=R_f),
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mutation and selection
\end_layout

\begin_layout Standard
You will need to read the relative sections of the reference manual to pick
 suitable mutator and selectors.
 What we need in this case are
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

-allele mutator with given number of allele states (
\begin_inset Formula $k$
\end_inset

).
 This is exactly
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

kamMutator(rate=mu, maxAllele=max_allele)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
single locus selector that treat 0 as wildtype, and any other allele as
 mutant.
 The selector to use is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Because an individual has only one fitness value, fitness values obtained
 from two selectors need to be combined (another choice is that you can
 use a selector that handle multiple loci.).
 Therefore, we use a multi-locus selector as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

mlSelector([
\end_layout

\begin_layout Standard

    maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0]),
\end_layout

\begin_layout Standard

    maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\begin_layout Standard

    ], mode=SEL_Multiplicative)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
With these operators, the simulator can be started.
 It first initialize a population with given allelic spectra, and then evolve
 it, subject to mutation and selection, specific to each locus.
 The program is listed in example 
\begin_inset LatexCommand ref
reference "reich2"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{reich2.py}[caption={Run the simulator},label={reich2}]
preview false

\end_inset


\end_layout

\begin_layout Section
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy since 
\family typewriter
stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use 
\family typewriter
stat()
\family default
 operator to calculate allele frequency and set variable 
\family typewriter
alleleFreq
\family default
 (and 
\family typewriter
alleleNum
\family default
) in each population's local namespace,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

stat(alleleFreq=[0,1]),
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then use a 
\family typewriter
pyEval
\family default
 (python expression) operator to print out the values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyEval(r' %.3f
\backslash
t%.3f
\backslash
n % (1-alleleFreq[0][0], 1-alleleFreq[1][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
pyEval
\family default
 operator can accept any valid python expression so the above expression
 calculate 
\begin_inset Formula $f_{0}=\sum_{i=1}^{\infty}f_{i}$
\end_inset

 at each locus (0 and 1) and print it in the format of 
\family typewriter
'%.3f
\backslash
t%.3f
\backslash
n'
\family default
.
\end_layout

\begin_layout Standard
There is no operator to calculate effective number of alleles 
\begin_inset LatexCommand citep
key "Reich2001a"

\end_inset

 so we need to do that by ourselves, using allele frequencies.
 The formula to calculate effective number of alleles is
\begin_inset Formula \[
n_{e}=\left(\sum_{i}\left(\frac{f_{i}}{f_{0}}\right)^{2}\right)^{-1}\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

 , and 
\begin_inset Formula $f_{0}$
\end_inset

 is defined as above.
 To calculate 
\begin_inset Formula $n_{e}$
\end_inset

 at the first locus, we can use a 
\family typewriter
pyEval
\family default
 operator (a direct translation of the formula):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyEval('1./sum([(x/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0][1:]])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this expression looks complicated and can not handle the case when
 
\begin_inset Formula $f_{0}=0$
\end_inset

.
 A more complicated, and robust method is using the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
 ,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyEval(stmts='''ne = [0,0]
\end_layout

\begin_layout Standard

for i in range(2):
\end_layout

\begin_layout Standard

    freq = alleleFreq[i][1:]
\end_layout

\begin_layout Standard

    f0 = 1 - alleleFreq[i][0]
\end_layout

\begin_layout Standard

    if f0 == 0:
\end_layout

\begin_layout Standard

        ne[i] = 0
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

        ne[i] = 1./sum([(x/f0)**2 for x in freq])
\end_layout

\begin_layout Standard

''', expr=r'%.4f
\backslash
t%.4f
\backslash
n % (ne[0], ne[1])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the 
\family typewriter
pyEval
\family default
 can be really complicated and calculate any statistics.
 However, if you plan to calculate more statistics, a pure python operator
 may be easier to write.
 The simplest form of a python operator is just a python function that accept
 a population as the first parameter (and an optional parameter),
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def ne(pop):
\end_layout

\begin_layout Standard

    ' calculate effective number of alleles '
\end_layout

\begin_layout Standard

    Stat(pop, alleleFreq=[0,1])
\end_layout

\begin_layout Standard

    f0 = [0, 0]
\end_layout

\begin_layout Standard

    ne = [0, 0]
\end_layout

\begin_layout Standard

    for i in range(2):
\end_layout

\begin_layout Standard

        freq = pop.dvars().alleleFreq[i][1:]
\end_layout

\begin_layout Standard

        f0[i] = 1 - pop.dvars().alleleFreq[i][0]
\end_layout

\begin_layout Standard

        if f0[i] == 0:
\end_layout

\begin_layout Standard

            ne[i] = 0
\end_layout

\begin_layout Standard

        else:
\end_layout

\begin_layout Standard

            ne[i] = 1.
 / sum([(x/f0[i])**2 for x in freq])
\end_layout

\begin_layout Standard

    print '%d
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
n' % (pop.gen(), f0[0], f0[1], ne[0], ne[1])
\end_layout

\begin_layout Standard

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can use this function in a python operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyOperator(func=ne, step=5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOperator
\family default
 is that 
\family typewriter
pyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the vars explicitly using the 
\family typewriter
pop.dvars()
\family default
 function.
 (This also implies that you can do whatever you want to the population.).
 In this example, the function form of the 
\family typewriter
stat
\family default
 operator is used to explicitly calculate allele frequency.
 The results are also explicitly printed using the 
\family typewriter
print
\family default
 command.
 The explicities lead to longer, but clearer program.
 This becomes obvious when you need to calculate and print many statistics.
\end_layout

\begin_layout Standard
The following program (listing 
\begin_inset LatexCommand ref
reference "reich3"

\end_inset

) uses the 
\family typewriter
pyOperator
\family default

\begin_inset LatexCommand index
name "pyOperator"

\end_inset

 solution.
 In this program, user can input two demographic models as command line
 parameter.
 Two other operators are used
\end_layout

\begin_layout Itemize
A 
\family typewriter
ticToc
\family default
 operator that prints out elapsed time at every 100 generations
\end_layout

\begin_layout Itemize
A 
\family typewriter
pause
\family default
 operator that pause the simulation whenever you press a key.
 You can actually enter a python command shell to examine the results.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{reich3.py}[caption={The whole program},label={reich3}]
preview false

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Section
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to run more simulations with
 different parameters like initial population size.
 Editing the script again and again is out of the question.
 Since this script is a python script, it is tempting to use python modules
 like 
\family typewriter
getopt
\family default
 to parse options from command line.
 A better choice would be using the 
\family typewriter
simuOpt
\family default
 module.
 Using this module properly, your simuPOP should be able to get options
 from short or long command line option, from a configuration file, from
 a tkInter of wxPython dialog, or from user input.
 Taking 
\family typewriter
c:
\backslash
python
\backslash
share
\backslash
simuPOP
\backslash
scripts
\backslash
simuLDDecay.py
\family default
 as an example, you can run this script as follows:
\end_layout

\begin_layout Itemize
use command '
\family typewriter
simuLDDecay.py
\family default
' or double click the program
\end_layout

\begin_layout Itemize
click the help button on the dialog, or run 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

> simuLDDecay.py -h
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to view help information.
\end_layout

\end_deeper
\begin_layout Standard
enter parameters in a parameter dialog, or use short or long command arguments
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Standard

> simuLDDecay.py -s 500 -e 10 --recRate 0.1 --numRep 5 --noDialog
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
use the optimized module by
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

> simuLDDecay.py --optimized
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
save the parameters to a config file
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

> simuLDDecay.py --quiet -s 500 -e 10 --saveConfig decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this will result in a config file 
\family typewriter
decay.cfg
\family default
 with these parameters.
\end_layout

\begin_layout Itemize
and of course use 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
,
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Standard

> simuLDDecay.py --config decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to load parameters from the config file.
\end_layout

\end_deeper
\begin_layout Standard
The last function is very useful since you frequently need to run many slightly
 different simulations, saving a configuration file along with your results
 will make your life much easier.
\end_layout

\begin_layout Standard
To achieve all the above, you need to write your scripts in the following
 order:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

#!/usr/bin/env python
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Write the introduction of the whole script in a module-wise doc string.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

'''
\end_layout

\begin_layout Standard

This script will ....
\end_layout

\begin_layout Standard

'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Define an option data structure.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

options = [ 
\end_layout

\begin_layout Standard

...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout Standard

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
 The detailed description of this structure is given in simuPOP reference
 manual.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation functions
\end_layout

\begin_layout Enumerate
In the executable part of the script (under 
\family typewriter
__name__ == '__main__'
\family default
), you should call 
\family typewriter
simuOpt.getParam
\family default
 to let 
\family typewriter
simuOpt
\family default
 handle all parameter input for you and obtain a list of parameters.
 You usually need to handle some special cases (
\family typewriter
-h, --saveConfig
\family default
 etc), and they are all standard.
\end_layout

\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\begin_inset LatexCommand index
name "simuOpt"

\end_inset


\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, print usage, save configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
 The following example 
\begin_inset LatexCommand ref
reference "reich4"

\end_inset

 shows the beginning and the execution part of the complete 
\family typewriter
reich.py
\family default
 script, which can be found under the doc directory.
 For a complete reference of the Options structure, please refer to the
 reference manual.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{reich4.py}[caption={Option handling},label={reich4}]
preview false

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Chapter
Selected topics
\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 80 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), quantitative
 trait, selection, penetrance (single or multi-locus, hybrid), ascertainment
 (case-control, affected sibpairs, random), statistics calculation (allele,
 genotype, haplotype, heterozygote number and frequency; expected heterozygosity
; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules), load/save
 in text, XML, Fstat or Linkage format.
 In this chapter, I will discuss some practical usages of simuPOP.
\end_layout

\begin_layout Section
Hybrid
\begin_inset LatexCommand index
name "Hybrid operator"

\end_inset

 and pure-Python operator
\begin_inset LatexCommand index
name "python operator"

\end_inset


\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a simuPOP feature called 
\emph on
hybrid operator
\emph default
.
 Such operators accept a Python function and will call this function with
 appropriate parameter(s) when needed.
 For example, example 
\begin_inset LatexCommand ref
reference "hybrid"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability of being affected.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{hybrid.py}[caption={An example of hybrid operators},label={hybrid}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "hybrid"

\end_inset

 uses the function form of operator 
\family typewriter
pyPenetrance
\family default
 and 
\family typewriter
stat
\family default
 and you should use the operator form in a simulator.
 In these functions, operators are created with the same set of parameters
 as their operator form, applied to the population, and are destroyed afterward.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

PyPenetrance(pop, parameters)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is the same as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

pyPenetrance(parameters).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, parameters 
\family typewriter
begin, end, step
\family default
 etc become meaningless in the function form.
 Note that if you need to apply the same operator to dozens of populations,
 creating one operator and applying it to all populations is more efficient
 than using the function form, since dozens of operators will be created
 and destroyed for each population in the latter usage.
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can write operators
 in Python.
 Such operators will have full access to the evolving population, and can
 therefore perform arbitrary operations on it.
 A pure-python operator has been used in the previous chapter where complex
 statistics are calculated and printed.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "pyOperator"

\end_inset

 uses a python operator to define a frequency-dependent selection operator
 which has different selection pressures depending on current disease allele
 frequency.
 In this example, a population is initialized with disease allele frequency
 0.3 (allele 1).
 Then, at each generation, a python function 
\family typewriter
freqDependSelector
\family default
 is called.
 This function
\end_layout

\begin_layout Itemize
unpact parameters (
\family typewriter
DSL, min, max
\family default
)
\end_layout

\begin_layout Itemize
calculate allele frequency at the disease locus
\end_layout

\begin_layout Itemize
if disease allele frequency is less than 
\family typewriter
min
\family default
, apply a multi-allele selector and give disease allele strong advantage
 selection;
\end_layout

\begin_layout Itemize
if disease allele frequency is greater than 
\family typewriter
max
\family default
, apply a multi-allele selector and give disease allele strong purifying
 selection;
\end_layout

\begin_layout Standard
The result of this operator, unseen to users, is individual 
\family typewriter
fitness
\begin_inset LatexCommand index
name "fitness"

\end_inset


\family default
 values set by one of (maybe none of) the multi-allele selector, which will
 be used by 
\family typewriter
randomMating()
\family default
 to select individuals accordingly to population the next generation.
\end_layout

\begin_layout Standard
One tricky point of this python operator is that although selectors are
 
\family typewriter
PreMating
\family default
, namely fitness will be calculated before mating, 
\family typewriter
pyOperator
\family default
 is 
\family typewriter
PostMating
\family default
.
 To calculate 
\family typewriter
fitness
\family default
 before mating, a 
\family typewriter
stage=PreMating
\family default

\begin_inset LatexCommand index
name "PreMating"

\end_inset

 parameter should be used.
 Otherwise, the fitness will be calculated for the offspring generation,
 not the current generation, as shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

preMating | mating -> offspring generation | postMating, fitness calculated
\end_layout

\begin_layout Standard

preMating | mating -> ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, because the simulator clears selection flag at the beginning of each
 generation, the fitness will not be used.
 Tricky enough, right? The good news is that 
\end_layout

\begin_layout Itemize
If you are using non-optimization libraries, simulation will fail if selection
 flag is on at the beginning of a generation.
 This prevents the use of post-mating selectors.
\end_layout

\begin_layout Itemize
If you are not sure in which order the operators are applied, use the 
\family typewriter
dryrun
\begin_inset LatexCommand index
name "dryrun"

\end_inset

=True
\family default
 in the evolve function.
 
\family typewriter
evolve
\begin_inset LatexCommand index
name "evolve"

\end_inset

()
\family default
 function will do nothing but printing out when and in which order operators
 will be applied.
\end_layout

\begin_layout Standard
Pure-python operators are extremely flexible and even more complicated form
 can be used.
 For example, 
\family typewriter
varPlotter
\family default
 in 
\family typewriter
simuRPy.py
\family default
 is a class with an instance of different plotters, and a python operator
 is used to call one of them.
 Such advanced usage of pure Python operator is beyond the scope of this
 guide.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{pyOperator.py}[caption={A frequency dependent selection operator},label={pyOperator}]
preview false

\end_inset


\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
Information fields are, in short, double values attached to each individual.
 Since different applications require different information fields, simuPOP
 takes a minimal approach in that no information field will be used (to
 save RAM) by default.
 When you apply an operator that needs a particular field, and your population
 does not have it, an error message will be given so that you can add appropriat
e fields to the 
\family typewriter
infoFields
\family default
 parameter of 
\family typewriter
population()
\family default
, or use 
\family typewriter
setInfoFields(), addInfoField(), addInfoFields()
\family default
 member functions to add them.
 Commonly used information fields are
\end_layout

\begin_layout Itemize

\family typewriter
fitness:
\family default
 used by all selectors, and by mating schemes
\end_layout

\begin_layout Itemize

\family typewriter
father_idx, mother_id
\family default
x: used by taggers to track parental information
\end_layout

\begin_layout Itemize

\family typewriter
spouse, pedindex, oldindex:
\family default
 used by ascertainment operators to obtain pedigree information.
\end_layout

\begin_layout Standard
Besides these standard information fields, you can define any fields for
 your use.
 The most frequently used functions are 
\family typewriter
individual::setInfo
\begin_inset LatexCommand index
name "setInfo"

\end_inset

(value, field), individual::info
\begin_inset LatexCommand index
name "info"

\end_inset

(field), population::setIndInfo
\begin_inset LatexCommand index
name "setIndInfo"

\end_inset

(values, field)
\family default
 and 
\family typewriter
population::indInfo
\begin_inset LatexCommand index
name "indInfo"

\end_inset

(field).

\family default
 Here field can be the name of the field, or an id returned by 
\family typewriter
population::infoIdx
\begin_inset LatexCommand index
name "infoIdx"

\end_inset

(field)
\family default
.
 Accessing information fields using indices is faster than using names.
\end_layout

\begin_layout Standard
In the following example (Example 
\begin_inset LatexCommand ref
reference "infoFields"

\end_inset

), a proportional hazard model is used to determine the age of onset of
 an individual with given genotype.
 Briefly,
\end_layout

\begin_layout Itemize
The base hazard is 
\begin_inset Formula $h_{0}\left(t\right)=\beta_{0}t$
\end_inset

, the corresponding survival function is 
\begin_inset Formula $S\left(s\right)=\exp\left(-\int_{0}^{s}h\left(t\right)dt\right)$
\end_inset

.
 The age of onset is determined randomly by the survival function.
 (
\begin_inset Formula $F\left(x\right)=1-S\left(x\right)$
\end_inset

 is used in the example.) The relevant functions are 
\family typewriter
hazard, cumHazard, cdf, ageOfOnset
\family default
.
 In the last function, 
\begin_inset Formula $\beta$
\end_inset

 is the fold change of the hazard function so 
\begin_inset Formula $h\left(t,\beta\right)=\beta\beta_{0}t$
\end_inset

.
\end_layout

\begin_layout Itemize
Date of birth is calculated as 2005 - age, where age is 
\begin_inset Formula $U\left(0,75\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
The proportional hazard model is
\begin_inset Formula \[
h\left(t,X\right)=h_{0}\left(t\right)\exp\left(\beta X\right)\]

\end_inset

where 
\begin_inset Formula $X$
\end_inset

 is the number of disease alleles at the given disease susceptibility loci.
 The age of onset is determined by individual 
\begin_inset Formula $h\left(t,X\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Affection status is determined by date of birth + age of onset < 2005.
\end_layout

\begin_layout Standard
The program is pretty self-explainary so I do not comment on the code here.
 The resulting population has information fields 
\family typewriter
DateOfBirth
\family default
, 
\family typewriter
betaX
\family default
 and 
\family typewriter
ageOfOnset
\family default
.
 Note that this example does not any operator or simulator, and demonstrate
 simuPOP's ability to manipulation populations.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{infoFields.py}[caption={Proportional hazard model and use of information fields},label={infoFields}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Information fields can also be manipulated during evolution, using one of
 the Python operators, or operators 
\family typewriter
infoEval 
\family default
and 
\family typewriter
infoExec
\family default
 (new in version 0.8.4).
 Please refer to simuPOP reference manual for details.
\end_layout

\begin_layout LyX-Code

\lyxline

\end_layout

\begin_layout Section
Population structure and migration
\end_layout

\begin_layout Standard
You first need to understand that mating schemes populate subpopulations
 from their corresponding ancestral subpopulations one by one, so it can
 not change number of subpopulations.
 Split and merge of subpopulations are done by operators 
\family typewriter
splitSubPop
\begin_inset LatexCommand index
name "splitSubPop"

\end_inset


\family default
 and 
\family typewriter
mergeSubPops
\begin_inset LatexCommand index
name "mergeSubPops"

\end_inset


\family default
 respectively.
 In example 
\begin_inset LatexCommand ref
reference "splitAndMerge"

\end_inset

, these two operators are used to split and merge subpopulations, but keep
 total population size untouched.
 Note that after subpopulation merge, subpopulation 2 still exists, but
 with size 0.
 This is used to keep subpopulation id of other subpopulations unchanged.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{splitAndMerge.out}[caption={Population split and merge},label={splitAndMerge}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Migration can change subpopulation size, but not total population size.
 In example 
\begin_inset LatexCommand ref
reference "splitAndMerge"

\end_inset

, two migrators are used.
 The first migrator moves individuals from subpopulation 0 to subpopulation
 1.
 The second migrator moves individuals around, with given proportions.
 For example, the migration rate
\begin_inset Formula \[
\left(\begin{array}{ccc}
0. & 0.2 & 0.4\\
0. & 0. & 0.1\\
0.1 & 0.1 & 0.\end{array}\right)\]

\end_inset

means moving 20% of individuals from subpop 0 to 1, 40% of individuals from
 subpop 0 to 1, and keep 40% (automatically determined).
 Subpopulation sizes change accordingly.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{splitMigration.out}[caption={Population split and migration},label={splitMigration}]
preview false

\end_inset


\end_layout

\begin_layout Standard
But what if you need to control total population size? In this case, a demograph
ic function is needed to specify the size of each subpopulation, at each
 generation.
 In example 
\begin_inset LatexCommand ref
reference "splitMigration2"

\end_inset

, function 
\family typewriter
popSize
\family default
 returns exact subpopulation size at each generation, and the population
 will behave accordingly.
 It might surprise you that migration can no longer control the size of
 subpopulation sizes.
 What exactly happened is that, for example
\end_layout

\begin_layout Itemize
subpopulation size = [200, 400, 400], at the beginning of a generation
\end_layout

\begin_layout Itemize
apply migrator, subpopulation size changed to [100, 470, 430]
\end_layout

\begin_layout Itemize
pre mating operator 
\family typewriter
stat
\family default
 is applied and report subpopulation sizes
\end_layout

\begin_layout Itemize
during mating, with given subpopulation sizes 200, 400, 400 of the offspring
 generation, the mating scheme generate 200 offspring from 100 parents in
 subpopulation 0, 400 offspring from 470 parents in subpopulation 1, and
 400 offspring from 430 parents in subpopulation 2.
\end_layout

\begin_layout Itemize
post mating operator 
\family typewriter
stat
\family default
 is applied and get the new subpopulation size.
\end_layout

\begin_layout Standard
This example also demonstrates the use of stage parameter.
 As a matter of fact, you can use only one 
\family typewriter
stat
\family default
 operator by using 
\family typewriter
stage
\begin_inset LatexCommand index
name "stage"

\end_inset

=PrePostMating
\family default

\begin_inset LatexCommand index
name "PrePostMating"

\end_inset

.
 If you are confused by the order of operators, use the 
\family typewriter
dryrun=True
\family default
 parameter of 
\family typewriter
evolve
\family default
 to check.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{splitMigration2.out}[caption={Population split with changing population size},label={splitMigration2}]
preview false

\end_inset


\end_layout

\begin_layout Standard
You might say, OK, this looks nice, but how can I grow a population with
 migration acting freely? This is also easy, all you need to do is using
 the oldSize parameter of a demographic function in a clever way.
 The underlying story is that
\end_layout

\begin_layout Itemize
before mating, a mating scheme calculates current subpopulation sizes
\end_layout

\begin_layout Itemize
it calls the given demographic function with current generation number and
 current subpopulation sizes
\end_layout

\begin_layout Itemize
it uses the return value as the new subpopulation sizes.
\end_layout

\begin_layout Standard
Example 
\begin_inset LatexCommand ref
reference "splitMigration3"

\end_inset

 demonstrate an exponentially increase population with free migration between
 subpopulations.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{splitMigration3.out}[caption={Population split with changing population size},label={splitMigration3}]
preview false

\end_inset


\end_layout

\begin_layout Section
Non-random mating
\end_layout

\begin_layout Standard
Random-mating implies random choices of parents.
 Non-random mating is much more difficult to implement because there are
 numerous way to introduce non-randomness.
 One of the ways to achive non-random mating in simuPOP is to use a hybrid
 operator 
\family typewriter
pyMating
\family default
.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyMating
\family default
 mating scheme accepts a 
\emph on
parents chooser
\emph default
 and an 
\emph on
offspring generator
\emph default
.
 The parents chooser is responsible for choosing one or two parents from
 the parental generation, and the offspring generator is responsible for
 generating a number of offspring from the chosen parents.
 There are a number of default parents choosers and offspring generators
 and a 
\family typewriter
pyMating
\family default
 can be built with them.
 For example
\end_layout

\begin_layout LyX-Code
pyMating(randomParentsChooser(), mendelianOffspringGenerator())
\end_layout

\begin_layout Standard
works exactly as a 
\family typewriter
randomMating
\family default
 scheme, and
\end_layout

\begin_layout LyX-Code
pyMating(randomParentChooser(), selfingOffspringGenerator(numOffspring=2))
\end_layout

\begin_layout Standard
works as 
\family typewriter
selfMating(numOffspring=2)
\family default
.
 Note that parent chooser and offspring generator should be compatible ,
 meaning that if a parent chooser chooses one parent each time, the offspring
 generator should be able to produce offspring from a single parent.
\end_layout

\begin_layout Standard
The power of 
\family typewriter
pyMating 
\family default
lies in its 
\family typewriter
pyParentChooser()
\family default
, which accepts a user-defined Python generator function, instead of a normal
 python function.
 Generally speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when the 
\family typewriter
next()
\family default
 member function of this object is called, this function resumes where it
 was stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,10$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 in a sequence interface.
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/generator.log}[caption={A sample generator function},label={generator}]
preview false

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
parents chooser
\emph default
 takes two parameters, a population and a subpopulation index.
 It can return different generator objects for different subpopulations.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/generator_random.log}[caption={A generator function that mimicks random mating},label={generator_random}]
preview false

\end_inset


\end_layout

\begin_layout Standard
A user defined parents chooser can be very complicated, involving user defined
 information such as geometric locations.
 An example is given in 
\family typewriter
cookbook/Mating_pyMating_cpp.py
\family default
.
 In example 
\begin_inset LatexCommand ref
reference "generator_random"

\end_inset

, the parents chooser 
\family typewriter
randomChooser 
\family default
collects indexes of males and females and simply return a pair of random
 male and female repeatedly.
 This is exactly what 
\family typewriter
randomMating
\family default
 does if selection is not considered.
 It becomes obvious now that whereas a python function can return random
 male/famale pair, the generator interface is much more efficient because
 the identification of two sex groups is done only once.
 Example 
\begin_inset LatexCommand ref
reference "pyMating"

\end_inset

 demonstrates how to use this user-defined parent chooser.
 
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{log/pyMating.log}[caption={pyMating with a user-defined parent chooser},label={pyMating}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Because arbitrary information can be stored with an individual through informati
on fields, 
\family typewriter
pyMating
\family default
 can be very complicated.
 For example, one can choose individuals according their age, and/or geographic
 information.
 For populations with well-defined structure, virtual subpopulations can
 be used.
 Basically, one needs to specify a virtual subpopulation splitter to a subpopula
tion.
 Then, different mating schemes can be applied to different virtual subpopulatio
ns.
 A simple example is given in Example 
\begin_inset LatexCommand ref
reference "heteroMating"

\end_inset

 where the first subpopulation is divided into two parts.
 The first 20% of individuals undergo selfing, and the rest of the subpopulation
 undergoes usual sexed random mating.
 Note that two mating schemes produce different number of offspring per
 mating event, and the family sizes are recorded in a shared variable 
\family typewriter
famSizes
\family default
 when 
\family typewriter
DBG_MATING
\family default
 is turned on.
 
\begin_inset Include \lstinputlisting{log/heteroMating.log}[caption={A heterogeneous mating scheme},label={heteroMating}]
preview false

\end_inset


\end_layout

\begin_layout Section
Sex chromosomes
\end_layout

\begin_layout Standard
Supports for sex chromosomes are done in simuPOP in the following ways:
\end_layout

\begin_layout Itemize
If 
\family typewriter
sexChrom
\begin_inset LatexCommand index
name "sexChrom"

\end_inset

=True
\family default
 is specified in 
\family typewriter
population()
\family default
, the last chromosome is assumed to be the sex chromosome.
 For female, it is 
\family typewriter
XX,
\family default
 for male, it is 
\family typewriter
XY
\family default
, in that order.
\end_layout

\begin_layout Itemize
During mating, sex of offspring is determined by sex chromosome.
 (It is otherwise determined randomly with probability 0.5).
\end_layout

\begin_layout Itemize
Recombination can not happen between 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 chromosomes.
 That is to say, offspring can get recombined 
\family typewriter
X
\family default
 from his/her mother, but untouched 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 from father.
\end_layout

\begin_layout Standard
As of version 0.7.5, no other operator recognize sex chromosome.
 Most notably, 
\family typewriter
stat
\family default
 counts allele frequencies etc regardless sex chromosome and can not count
 allele frequency for 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 separately.
 
\end_layout

\begin_layout Section
Pedigree tracking
\end_layout

\begin_layout Standard
simuPOP provides the following functions to manipulate pedigrees
\end_layout

\begin_layout Itemize
If you set 
\family typewriter
ancestralDepth
\family default
 of a population to a positive number (default 0), 
\family typewriter
ancestralDepth
\family default
 number of ancestral generations will be saved to the population, which
 makes a total of 
\family typewriter
ancestralDepth + 1
\family default
 generations.
\end_layout

\begin_layout Itemize
You can use 
\family typewriter
population::useAncestralPop
\begin_inset LatexCommand index
name "useAncestralPop"

\end_inset

(idx)
\family default
 to use current (0), parental (1), grand-parental (2) generations etc.
 Just remember to call 
\family typewriter
population::useAncestralPop(0)
\family default
 to set current generation back.
\end_layout

\begin_layout Itemize
You can set 
\family typewriter
ancestralDepth
\family default
 dynamically using operator 
\family typewriter
setAncestralDepth
\begin_inset LatexCommand index
name "setAncestralDepth"

\end_inset

.

\family default
 Usually, this operator is called, for example, as 
\family typewriter
setAncestralDepth(at=[-2])
\family default
, to allow last several generations to be saved at the end of evolution.
\end_layout

\begin_layout Itemize
No parental information is saved by default we usually do not know the parents
 of an offspring.
 This can be changed by using the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields, and an appropriate tagger such as 
\family typewriter
parentTagger
\begin_inset LatexCommand index
name "parentTagger"

\end_inset

()
\family default
, which is a during mating operator that will record the parents' indices
 in the parental generation to offspring's information fields.
\end_layout

\begin_layout Itemize

\family typewriter
randomMating
\begin_inset LatexCommand index
name "randomMating"

\end_inset

()
\family default
 only produce one offspring per mating event.
 This makes full siblings very unlikely.
 You usually need to change this at the last several generations.
\end_layout

\begin_layout Standard
You can see that generating multi-generation populations are quite different
 from the usual evolutionary process where random mating is used, and one
 offspring is generated for each mating event.
 In practice (see 
\family typewriter
scripts/simuComplexDisease.py
\family default
), if we need to prepare a population for pedigree sampling, we can run
 a simulator like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
One-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(...., ancestralDepth=2,
\end_layout

\begin_layout Standard

    infoFields=['father_idx', 'mother_idx'])
\end_layout

\begin_layout Standard

simu = simulator(pop, randomMating(numOffspring=2))
\end_layout

\begin_layout Standard

simu.evolve(
\end_layout

\begin_layout Standard

    preOps=[...],
\end_layout

\begin_layout Standard

    ops = operators,
\end_layout

\begin_layout Standard

    end = 1000
\end_layout

\begin_layout Standard

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with this approach is that two generations are saved at all
 generations, and all mating events produce two offspring.
 The former is not a big deal but the latter will reduce effective population
 size of the resulting population.
 To avoid these problems, a two-stage simulation can be done 
\begin_inset listings
inline false
status open

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Two-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(....)
\end_layout

\begin_layout Standard

simu = simulator(pop, randomMating())
\end_layout

\begin_layout Standard

simu.evolve(
\end_layout

\begin_layout Standard

    preOps=[...],
\end_layout

\begin_layout Standard

    ops = operators,
\end_layout

\begin_layout Standard

    end = 1000 - 2
\end_layout

\begin_layout Standard

)
\end_layout

\begin_layout Standard

simu.setAncestralDepth(2)
\end_layout

\begin_layout Standard

simu.addInfoFields(['father_idx', 'mother_idx'])
\end_layout

\begin_layout Standard

simu.setMatingScheme(randomMating(numOffspring=2))
\end_layout

\begin_layout Standard

operators.append(parentsTagger())
\end_layout

\begin_layout Standard

simu.evolve(ops=operators, end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is to say, we separate the simulation into two parts.
 The first part is geared toward performance and maximum effective population
 size (use true random mating), and the second part is tweaked for the final
 multi-generation population.
 Note that 
\family typewriter
setAncestralDepth 
\family default
and 
\family typewriter
addInfoFields
\family default
 should be done at the simulator level so that every replicates in the simulator
 have the same new information fields.
 
\family typewriter
simu.population(0).addInfoFields(['father_idx', 'mother_idx']) 
\family default
will compromise the integrity of the simulator and is disallowed.
 (Integrity refers to the fact that all populations in a simulator should
 have the same genotypic structure as the simulator).
\end_layout

\begin_layout Standard
Now, at the end of the simulation, you get a population with multiple generation
s, with parental information.
 But it is still not easy to obtain pedigrees.
 As a matter of fact, since individuals can belong to multiple pedigrees,
 it is not even easy to define a pedigree.
 simuPOP provides a few pedigree ascertainment operators
\end_layout

\begin_layout Itemize

\family typewriter
AffectedSibpairSample
\family default
: sample affected sibpairs, along with their parents from a population.
 Affection status should have been set by other means such as a penetrance
 operator.
\end_layout

\begin_layout Itemize

\family typewriter
LargePedigreeSample:
\family default
 sample grand parents, their children, and the spouse and children of them.
 Affection status is ignored, although the minimal number of affected individual
s in each family can be specified.
\end_layout

\begin_layout Itemize

\family typewriter
NuclearFamilySample: 
\family default
sample two-generation pedigrees.
\end_layout

\begin_layout Standard
If you need to sample more complicated pedigrees, you should first use 
\family typewriter
sample::findOffspringAndSpouse
\family default
 to locate each individual's offspring and spouse, then use 
\family typewriter
useAncestralPop()
\family default
 to go through the generations and set 
\family typewriter
pedIndex
\family default
 for the pedigree you choose, and then use 
\family typewriter
setSubPopID()
\family default
, 
\family typewriter
newPopByIndID()
\family default
 to exclude and remove unneeded individuals.
 
\family typewriter
sample::resetParentalIndex()
\family default
 should also be used to reset the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 fields.
 Sound complicated? It is complicated! I hope that I can get some better
 idea and make this process a bit easier, but this is where simuPOP is at
 right now.
\end_layout

\begin_layout Standard
Finally, you can save the sample populations in a pedigree-aware format
 like Linkage or Merlin/QTDT format.
 simuPOP can do this easily for you.
\end_layout

\begin_layout Section
Save and load to other formats
\end_layout

\begin_layout Standard
simuPOP data structure is open in that many functions are provided to access
 every aspect of the population.
 This makes it easy to save and load populations in other formats.
 As an example, I will explain 
\family typewriter
SaveTDT
\family default
 function in detail here, which is available in 
\family typewriter
simuUtil.py
\family default
.
\end_layout

\begin_layout Standard
Although all file formats have different characteristics, 
\family typewriter
simuPOP
\family default
 tries to provide a uniform interface to them.
 Common parameters are
\end_layout

\begin_layout Itemize
pop: population to save, can be a file name, or a file object (loaded simuPOP
 population)
\end_layout

\begin_layout Itemize
output and outputExpr: output is the base filename, and outputExpr should
 be evaluated from pop's local namespace.
\end_layout

\begin_layout Itemize
loci: loci to output, default is [], meaning output all loci
\end_layout

\begin_layout Itemize
fields: information fields to output.
 
\end_layout

\begin_layout Itemize
combine: a python function, if given, used to combine two alleles at the
 same locus.
 For example
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

def comb(geno):
\end_layout

\begin_layout Standard

    return geno[0]+geno[1]+1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns 1 for genotype(0, 0), 2 for genotype (0, 1) and so on.
\end_layout

\end_deeper
\begin_layout Itemize
shift: default to 1.
 simuPOP uses 0 based allele and many formats use 1 based allele.
 Setting shift=1 output (1,2) for genotype (0,1).
\end_layout

\begin_layout Standard
The 
\family typewriter
Merlin/QTDT
\family default
 format uses several files to store genotype and phenotype information.
 Namely a 
\family typewriter
.dat
\family default
 file for phenotype, 
\family typewriter
.map
\family default
 file for chromosome structure, and 
\family typewriter
.ped
\family default
 for pedigree.
 The population given must have 
\family typewriter
pedindex, father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields to indicate family id and parents of each individual.
 These information fields will be available if the sample is obtained from
 
\family typewriter
affectedSibpairSample
\family default
 or 
\family typewriter
largePedigreeSample
\family default
 operators.
\end_layout

\begin_layout Standard
The first part of the function is the usual housekeeping part (see example
 
\begin_inset LatexCommand ref
reference "saveQTDT1"

\end_inset

).
 It loads population if 
\family typewriter
pop
\family default
 is a name, evaluate 
\family typewriter
outputExpr
\family default
 if needed, and open the files to write.
 This part is likely to be similar for all such functions.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{saveQTDT1.py}[caption={Function SaveQTDT, part one},label={saveQTDT1}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Part two of the code (example 
\begin_inset LatexCommand ref
reference "saveQTDT2"

\end_inset

) output data file.
 There are three kinds of phenotype, affection status, trait and markers.
 We determine if a user wants to output affection from the 
\family typewriter
fields
\family default
 parameter.
 We remove 
\family typewriter
affection
\family default
 from 
\family typewriter
fields
\family default
 because 
\family typewriter
affection
\family default
 is not a real information field (that can be retrieved by 
\family typewriter
info()
\family default
 function).
 You can learn how to use the 
\family typewriter
locusName
\family default
 function from this part.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{saveQTDT2.py}[caption={Function SaveQTDT, part two},label={saveQTDT2}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Part three (example 
\begin_inset LatexCommand ref
reference "saveQTDT3"

\end_inset

) of the function output a map file.
 We need to know the chromosome number (+1 to use 1 based index), locus
 name and locus position, all of which can be retrieved from simple 
\family typewriter
simuPOP
\family default
 functions.
 Note that if locus name, position are not given explicitly when a population
 is created, they all have default values.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{saveQTDT3.py}[caption={Function SaveQTDT, part three},label={saveQTDT3}]
preview false

\end_inset


\end_layout

\begin_layout Standard
The next part (example 
\begin_inset LatexCommand ref
reference "saveQTDT4"

\end_inset

) prepares pedigree output.
 It determines the code to output for sex and affection status.
 These are likely to be different from format to format so we define explicitly
 here.
 The 
\family typewriter
writeInd
\family default
 output the line for one individual, given family id, id, father and mother.
 For QTDT format, two alleles of a genotype are outputted separately so
 the 
\family typewriter
combine
\family default
 parameter is ignored.
 
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{saveQTDT4.py}[caption={Function SaveQTDT, part four},label={saveQTDT4}]
preview false

\end_inset


\end_layout

\begin_layout Standard
The last part of the code (example 
\begin_inset LatexCommand ref
reference "saveQTDT5"

\end_inset

) look most complicated.
 It first get the 
\family typewriter
pedindex
\family default
 information field of the whole population, and figure out how many pedigrees
 to output.
 Then, it go from ancestral generation 2, 1, 0 and look for individuals
 within each pedigree.
 A map is used to map absolute index to within pedigree index.
 Of course, this part would be easier if you do not need to handle pedigree,
 for example, when outputting case control samples.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{saveQTDT5.py}[caption={Function SaveQTDT, part five},label={saveQTDT5}]
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gene mapping
\end_layout

\begin_layout Standard
Once you output your sample into a format that can be processed by other
 applications, you can handle them in whatever way you want.
 If you are interested in processing the data in simuPOP (actually, in python),
 you can use python to call these programs.
 
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{mapping.py}[caption={Example of gene mapping},label={mapping}]
preview false

\end_inset


\end_layout

\begin_layout Standard
An example is given in example 
\begin_inset LatexCommand ref
reference "mapping"

\end_inset

.
 In this function, 
\family typewriter
merlin
\family default
 
\begin_inset LatexCommand citep
key "Abecasis2002"

\end_inset

 is called to process file produced by the 
\family typewriter
SaveQTDT
\family default
 function.
 The output is fed into a pipe (
\family typewriter
popen
\family default
) and be filtered by the python 
\family typewriter
re
\family default
 (regex) module.
 Only the 
\begin_inset Formula $p$
\end_inset

-values are obtained and returned.
\end_layout

\begin_layout Chapter
Introduction to bundled scripts
\end_layout

\begin_layout Standard
Several scripts are bundled with simuPOP, under the 
\family typewriter
/usr/share/simuPOP/scripts
\family default
 directory under a *nix system and 
\family typewriter
c:
\backslash
python25
\backslash
share
\backslash
simuPOP
\backslash
scripts
\family default
 under windows.
 These scripts all use 
\family typewriter
simuOpt
\family default
 module to organize help messages so you can get detailed information about
 the scripts and the parameter used by clicking on help button of the parameter
 dialog, or use commands like '
\family typewriter
simuComplexDisease.py -h'
\family default
 to get the help messages.
\end_layout

\begin_layout Standard
In this chapter, I will briefly explain what these scripts do, from a more
 methodology side of view.
 Be warned, though, that these scripts are less actively maintained than
 simuPOP core and I mostly rely on user bug report to identify problems
 in these scripts.
\end_layout

\begin_layout Section
Examples and teaching scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuLDDecay.py
\end_layout

\begin_layout Standard
This is the simplest script under the 
\family typewriter
scripts
\family default
 directory, showing the decay of linkage disequilibrium under recombination.
 It is intended to be a template for many more such simulations for teaching
 a population genetics course.
 
\end_layout

\begin_layout Subsection

\family typewriter
demoPyOperator.py
\end_layout

\begin_layout Standard
This script demonstrate the use of a during-mating pure-Python operator.
 Since such operator will be called very frequently (at each mating event),
 the performance of such operators tend to be bad.
 Since most of the task performed by such an operator can be achieved by
 other means (for example a post-mating operator), it is rarely used.
\end_layout

\begin_layout Section
Utility scripts
\end_layout

\begin_layout Standard
These scripts are not necessarily written in simuPOP.
 It is written to facilitate the use of simuPOP.
\end_layout

\begin_layout Subsection

\family typewriter
simuViewPop.py
\end_layout

\begin_layout Standard

\family typewriter
simuViewPop.py
\family default
 is a 
\family typewriter
wxPython
\family default
 application written to view simuPOP populations.
 You will need to have 
\family typewriter
wxPython
\family default
 installed to use it.
 There are two ways to use this script:
\end_layout

\begin_layout Itemize
Import this script and call 
\family typewriter
viewPop(pop)
\family default
 to view population 
\family typewriter
pop
\end_layout

\begin_layout Itemize
Run from command line
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

$ simuViewPop.py /path/to/population.txt
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This script shows four tabs to show the information of a population
\end_layout

\begin_layout Itemize
basic information
\end_layout

\begin_layout Itemize
a table view of all genotype
\end_layout

\begin_layout Itemize
calculation of statistics, with a tree-view of local name space
\end_layout

\begin_layout Itemize
save to other formats
\end_layout

\begin_layout Subsection

\family typewriter
simuCluster.py
\end_layout

\begin_layout Standard

\family typewriter
simuCluster.py
\family default
 helps you manage a large number of simulations on a cluster system.
 You only need to maintain a single job-description file and 
\family typewriter
simuCluster.py
\family default
 will help you submit them.
 The command line options are
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

$ simuCluster.py -l simulation.lst -a  -r -f key=val jobs
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Itemize

\family typewriter
-l (--list) list:
\family default
 a list file (actually a python file) that specifies variale 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\end_layout

\begin_layout Itemize

\family typewriter
-a (--all):
\family default
 use all jobs defined in the list file
\end_layout

\begin_layout Itemize

\family typewriter
-r (--run):
\family default
 run the jobs, by default, this script will only list the jobs and generate
 job file.
\end_layout

\begin_layout Itemize

\family typewriter
-p (--repeat) n:
\family default
 execute command 
\family typewriter
n
\family default
 times.
\end_layout

\begin_layout Itemize

\family typewriter
-f (--force):
\family default
 force the execution even if the generated job scripts have 
\family typewriter
$
\family default
 character.
\end_layout

\begin_layout Itemize

\family typewriter
key=val:
\family default
 additional subsitution key/value pair that will be used to replace 
\family typewriter
$key
\family default
 in the job scripts.
 Commonly used, or machine-specific, 
\family typewriter
key=val
\family default
 pairs can be defined in a configuration file 
\family typewriter
$HOME/.simuCluster
\family default
 with content like:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

command = 'bsub -J $name <'
\end_layout

\begin_layout Standard

queue = 'batch'
\end_layout

\begin_layout Standard

job_dir = '/scratch/jobs'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
job:
\family default
 a list of jobs, a simple form of regular expression can be used.
 Namely, 
\family typewriter
job1_3
\family default
 means 
\family typewriter
job1
\family default
, 
\family typewriter
job2
\family default
 and 
\family typewriter
job3
\family default
.
\end_layout

\begin_layout Standard
The list file can be any python script, that defines variables 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\family default
 after execution, where 
\family typewriter
script
\family default
 is a simple script with variables 
\family typewriter
$name
\family default
 or 
\family typewriter
${name}
\family default
.
 and 
\family typewriter
joblist
\family default
 is a string with lines of comma (can be other charater if you define a
 variable 
\family typewriter
separator
\family default
) separated fields, that will be used to replace 
\family typewriter
$0 (
\family default
also 
\family typewriter
$name
\family default
, the name of a job)
\family typewriter
, $1, $2, ...

\family default
 etc.
\end_layout

\begin_layout Standard
Then, what 
\family typewriter
simuCluster.py
\family default
 will do is process this list file, replace 
\family typewriter
$name, $var, $1, $2 ...

\family default
 etc with environmental variables, command line paramters, configuration
 file and joblist and generate job scripts.
 If 
\family typewriter
-r
\family default
 is given, the job will be submitted.
 Example 
\begin_inset LatexCommand ref
reference "joblist"

\end_inset

 gives a sample job list file.
 Command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

$ python scripts/simuCluster.py -l joblist.lst -a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will generate files 
\family typewriter
job1.pbs
\family default
, ...
 and if 
\family typewriter
-r
\family default
 option is given, these files will be submitted using 
\family typewriter
qsub job1
\family default
, unless you specify another 
\family typewriter
command
\family default
 variable.
\end_layout

\begin_layout LyX-Code
\begin_inset Include \lstinputlisting{joblist.lst}[caption={A sample job list file},label={joblist}]
preview false

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
simuUtil.py
\end_layout

\begin_layout Standard

\family typewriter
simuUtil.py
\family default
 is a standard part of simuPOP and is installed along with 
\family typewriter
simuPOP.py
\family default
 (other utility scripts are installed under 
\family typewriter
scripts
\family default
 directory).
 These function include
\end_layout

\begin_layout Enumerate
extra python operators, the two potentially useful ones are
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
tab
\end_layout

\begin_layout Itemize

\series bold
endl
\end_layout

\begin_layout Standard
These two operators output, as their names suggest, 
\family typewriter
'
\backslash
t'
\family default
 and 
\family typewriter
'
\backslash
n'
\family default
.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined demographic functions:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
constSize
\end_layout

\begin_layout Itemize

\family typewriter
LinearExpansion
\end_layout

\begin_layout Itemize

\family typewriter
ExponentialExpansion
\end_layout

\begin_layout Itemize

\family typewriter
InstantExpansion 
\end_layout

\begin_layout Standard
These functions return a demographic function with given event times.
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined migration rate functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
MigrIslandRates
\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates
\end_layout

\begin_layout Standard
These functions return a migration matrix of given migration model and parameter.
\end_layout

\end_deeper
\begin_layout Enumerate
Save and load from other formats
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
SaveFstat (saveFstat), LoadFstat
\end_layout

\begin_layout Itemize

\family typewriter
LoadGCData
\end_layout

\begin_layout Itemize

\family typewriter
SaveLinkage (saveLinkage), LoadLinkage
\end_layout

\begin_layout Itemize

\family typewriter
SaveQTDT
\end_layout

\begin_layout Itemize

\family typewriter
SaveCSV
\end_layout

\begin_layout Standard
These functions save and load simuPOP populations in various formats.
\end_layout

\end_deeper
\begin_layout Enumerate
Gene mapping functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
TDT_gh, LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
ChiSq_test
\end_layout

\begin_layout Itemize

\family typewriter
LOD_merlin, VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_TDT_gh, Sibpair_LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_LOD_merlin, QtraitSibs_Reg_Merlin, QtriatSibs_VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
LargePeds_Reg_merlin, LargePeds_VC_merlin
\end_layout

\begin_layout Standard
These functions call GENEHUNTER or MERLIN to map disease genes.
 Various parameters like penetrance, quantitative trait functions, sample
 size are needed.
 These functions are tested only under Linux and are subject to frequent
 changes.
\end_layout

\end_deeper
\begin_layout Standard
In general, these utility functions are provided as it is and you may need
 to read the source code to make it work should errors occur.
 Unit test will be added later when these functions are more or less stablized/s
tandardized.
\end_layout

\begin_layout Section
General simulation scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuCDCV.py
\end_layout

\begin_layout Standard
This script is used to simulate the evolution of allelic spectra (number
 and allele freqencies of alleles at a locus) for monogenic or polygenic,
 rare or common diseases.
 The goal of the simulations is to validate the common disease common variant
 hypothesis
\begin_inset LatexCommand citep
key "Lander1996"

\end_inset

.
 I used this script to verify two theoretical models proposed by Pritchard
 
\begin_inset LatexCommand citeyearpar
key "Pritchard2001"

\end_inset

 and Reich and Lander 
\begin_inset LatexCommand citeyearpar
key "Reich2001a"

\end_inset

.
 The results are published in 
\begin_inset LatexCommand citet
key "Peng2007"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuRecHotSpots.py
\end_layout

\begin_layout Standard
I wrote this script to simulate the evolution of a chromosome, subject to
 recombination of uniform recombination rate.
 Using this script, I would like to see how many recombination hotspots
 can be observed if there is no physical recombination hotspots, i.e.
 actual variation of recombination rate on the chromosome.
 The population is saved in LDhat format to be analyzed by LDhat 
\begin_inset LatexCommand citep
key "Myers2005"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuNeutralSNPs.py
\end_layout

\begin_layout Standard
This script is adapted from 
\family typewriter
simuRecHotSplots.py
\family default
, the main purpose is to observe the evolution of allele frequency under
 more complicated scenarios than classical population genetics theory can
 handle.
\end_layout

\begin_layout Section
Simulations of the evolution of complex human diseases
\end_layout

\begin_layout Subsection

\family typewriter
simuForward.py
\end_layout

\begin_layout Standard
This script presents my first attempt to simulate the evolution of complex
 human diseases in a forward-time manner and generate samples for gene mapping
 purposes.
 The script goes like this:
\end_layout

\begin_layout Itemize
initialize a small (likely 10K) founder population with a few haplotypes
\end_layout

\begin_layout Itemize
burn-in this founder population for a few thousands generations to break
 down linkage disequilibrium
\end_layout

\begin_layout Itemize
after this stage, the population starts to expand.
 It can be split into several subpopulations (simulate human subpopulations),
 with and/or without migration and be merged back to a single population.
\end_layout

\begin_layout Itemize
At the beginning of population expansion, several disease mutants are introduced
 to the population.
 Positive or negative selection is applied to individuals with disease mutants.
 We hope to harvest a final population with certain disease allele frequency.
\end_layout

\begin_layout Standard
This process is problematic in that
\end_layout

\begin_layout Itemize
The disease allele can get lost
\end_layout

\begin_layout Itemize
We can not control the disease allele frequency at the last generation
\end_layout

\begin_layout Standard
To solve the first problem, I re-introduce disease mutants if they get lost.
 I also apply, optionally, strong positive selection pressure during an
 disease-introduction stage to artificially boost the disease allele frequency,
 until it reach a designed range of allele frequencies.
 If the disease allele still get lost after the disease introduction stage,
 the simulation will be restarted.
 By manipulating parameters like designed allele frequency and population
 size, the impact of genetic drift can be moderate and give me a final populatio
n with designed disease allele frequency.
 This simulation scenario roughly follows that of Calafell et al 
\begin_inset LatexCommand citet
key "Calafell2001"

\end_inset

.
\end_layout

\begin_layout Standard
To save simulation time, population at the end of the burnin stage is reused
 if simulation gets restarted.
\end_layout

\begin_layout Subsection

\family typewriter
simuComplexDisease.py
\end_layout

\begin_layout Standard
The previous simulation scenario is not satisfactory in that
\end_layout

\begin_layout Itemize
The age of mutant is fixed, but they should be somehow random
\end_layout

\begin_layout Itemize
Mutants can get lost and the simulation needs to be restarted repeatedly.
 This problem can be severe if we simulate mutants under purifying selection.
\end_layout

\begin_layout Itemize
We still can not control the final disease allele frequency well.
 The variation of disease allele frequencies in the final generation makes
 fair comparison between gene mapping methods difficult.
\end_layout

\begin_layout Standard
Therefore, I propose a simulation method, which is still under review, that
\end_layout

\begin_layout Itemize
simulate, backward in time, the trajectory of disease allele frequencies.
 The age of mutant is determined by trajectory length, and is random.
\end_layout

\begin_layout Itemize
Then, the script simulate forward in time using a controlled random mating
 scheme that follow the pre-simulated disease allele trajectories.
 The resulting population will have exact designed allele frequency.
\end_layout

\begin_layout Standard
An obvious advantage of this approach is that the simulation does not have
 to be restarted, and the disease allele frequency at the last generation
 can be controlled exactly.
\end_layout

\begin_layout Subsection

\family typewriter
analComplexDisease.py
\end_layout

\begin_layout Standard
I use 
\family typewriter
simuComplexDiseas.py
\family default
 to simulate many population under various genetic and demographic models.
 The resulting populations are analyzed by this script.
 The analyses involved are
\end_layout

\begin_layout Itemize
merlin variance component method 
\begin_inset LatexCommand citep
key "Abecasis2002,Amos1994"

\end_inset


\end_layout

\begin_layout Itemize
merlin regression 
\begin_inset LatexCommand citep
key "sham2002"

\end_inset


\end_layout

\begin_layout Itemize
TDT 
\begin_inset LatexCommand citep
key "Spielman1993"

\end_inset


\end_layout

\begin_layout Itemize
Linkage, and
\end_layout

\begin_layout Itemize
Case control association study.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plainnat"
bibfiles "bib/all"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
