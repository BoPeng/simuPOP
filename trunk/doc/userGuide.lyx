#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass manual
\begin_preamble
\renewcommand{\py@ptsize}{12pt}

\setreleaseinfo{Release 0.8.8 (\mbox{$$Rev$$})}
\authoraddress{
{\bf Department of Epidemiology, U.T. M.D. Anderson Cancer Center}\\
{\bf Email: } \textsf{bpeng@mdanderson.org}\\
{\bf URL: } \textsf{http://simupop.sourceforge.net} \\
{\bf Mailing List: } \textsf{simupop-list@lists.sourceforge.net}
}
\author{Bo Peng}
\date{December 2004\\
\hfill{}\\
Last modified \\
\today }

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\renewcommand\lstlistlistingname{List of Examples}
\renewcommand\lstlistingname{Example}

\sloppy

\definecolor{TitleColor}{rgb}{0.126,0.263,0.361}
\definecolor{LinkColor}{rgb}{0.208,0.374,0.486}
\definecolor{VerbatimColor}{rgb}{0,0,0}
\definecolor{VerbatimBackgroundColor}{rgb}{0.98,0.941,0.902}
\definecolor{VerbatimBorderColor}{rgb}{0,0,0}
\definecolor{VerbatimStringColor}{rgb}{0,0.5,0}
\definecolor{VerbatimCommentColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimPromptColor}{rgb}{0.588,0.098,0.054}

\usepackage{sectsty}
\sectionfont{\color{TitleColor}}
\subsectionfont{\color{TitleColor}}
\subsubsectionfont{\color{TitleColor}}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "simuPOP User's Guide"
\pdf_author "Bo Peng"
\pdf_keywords "simuPOP"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=TitleColor,urlcolor=LinkColor"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "alsoletter={>.},backgroundcolor={\color{VerbatimBackgroundColor}},basicstyle={\small\ttfamily\color{VerbatimColor}},commentstyle={\color{VerbatimCommentColor}\slshape},emph={[2]>>>,...},emphstyle={[2]\color{VerbatimPromptColor}\bf},language=Python,otherkeywords={>>>,...},showspaces=false,showstringspaces=false,showtabs=false,stringstyle={\color{VerbatimStringColor}},xleftmargin=10pt"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
simuPOP User's Guide
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{7.5in} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
copyright{} 
\end_layout

\end_inset

 2004-2008 Bo Peng 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{.3cm} 
\backslash
hrule 
\backslash
vspace{0.1cm} 
\end_layout

\end_inset

Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved
 on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided also that the
 sections entitled Copying and GNU General Public License are included exactly
 as in the original, and provided that the entire resulting derived work
 is distributed under the terms of a permission notice identical to this
 one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
 by the Free Software Foundation.
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
simuPOP is a forward-time population genetics simulation environment.
 Unlike coalescent-based programs, simuPOP evolves populations forward in
 time, subject to arbitrary number of genetic and environmental forces such
 as mutation, recombination, migration and population/subpopulation size
 changes.
 Statistics of populations can be calculated and visualized dynamically
 which makes simuPOP an ideal tool to demonstrate population genetics models;
 generate datasets under various evolutionary settings, and more importantly,
 study complex evolutionary processes and evaluate gene mapping methods.
\end_layout

\begin_layout Abstract
simuPOP is provided as a number of Python modules, which provide of a large
 number of Python objects and functions, including population, mating schemes,
 operators (objects that manipulate populations) and simulators to coordinate
 the evolutionary processes.
 It is the users’ responsibility to write a Python script to glue these
 pieces together and form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 bundled scripts that perform simulations ranging from implementation of
 basic population genetics models to generating datasets under complex evolution
ary scenarios.
 No knowledge about Python or simuPOP would be needed to run these simulations,
 if they happen to fit your need.
\end_layout

\begin_layout Abstract
This user's guide shows you how to install and use simuPOP using a large
 number of examples.
 It describes all important concepts and features of simuPOP and shows you
 how to use them in a simuPOP script.
 For a complete and detailed desciprion about all simuPOP functions and
 classes, please refer to the 
\emph on
simuPOP Reference Manual.

\emph default
 All resources, including a pdf version of this guide and a mailing list
 can be found at the simuPOP homepage 
\family typewriter
http://simupop.sourceforge.net
\family default
.
\end_layout

\begin_layout Abstract

\series bold
How to cite simuPOP: 
\end_layout

\begin_deeper
\begin_layout Quote
Bo Peng and Marek Kimmal (2005) simuPOP: a forward-time population genetics
 simulation environment.
 
\emph on
bioinformatics
\emph default
, 
\series bold
21
\series default
(18): 3686-3687
\end_layout

\begin_layout Quote
Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
 mating populations using simuPOP.
 
\emph on
bioinformatics,
\emph default
 
\series bold
24
\series default
 (11)
\begin_inset Quotes erd
\end_inset

 1408-1409.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This reference manual uses examples generated by 'runSampleCode.py userGuide.py',
 'runSampleCode.py splitMerge.py', and simuPOP_ref.tex generated by 'doxygen;
 cd tools; doxy2swig.py'..
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
What is simuPOP?
\end_layout

\begin_layout Standard
simuPOP is an individual-based forward-time population genetics simulation
 environment based on Python, a dynamic object-oriented programming language
 that has been widely used in biological studies.
 simuPOP provides a large number of Python objects and functions, and a
 mechanism to evolve populations forward in time.
 It is the users’ responsibility to write a Python script to form a simulation.
 At a more user-friendly level, simuPOP provides an increasing number of
 built-in scripts so that users who are unfamiliar with Python and simuPOP
 can perform some pre-specified simulation processes.
 These scripts range from implementation of basic population genetics models
 to generating datasets under complex evolutionary scenarios.
 In addition, simuPOP modules and functions are provided to load and manipulate
 HapMap samples and to perform a number of popular gene-mapping methods.
\end_layout

\begin_layout Standard
Unlike other population genetics simulation applications that aim at specific
 evolutionary scenarios, simuPOP aims at providing a general purpose simulation
 program that can be used to write and study arbitrarily complex evolutionary
 scenarios.
 This makes simuPOP an ideal tool in a wide variety of applications ranging
 from demonstrating simple population genetics models to studying the evolution
 of complex human genetic diseases.
\end_layout

\begin_layout Section
An overview of simuPOP concepts
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
population
\series default
 consists of individuals of the same 
\series bold
genotype structure
\series default
, which include properties such as number of homologous sets of chromosomes
 (ploidy), number of chromosomes, and names and locations of markers on
 each chromosome.
 Individuals can be divided into 
\series bold
subpopulations
\series default
 that can be further divided into
\emph on
 
\series bold
\emph default
virtual subpopulations
\series default
 according to individual properties such as sex, affection status, or arbitrary
 auxiliary information such as age.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:life-cycle"

\end_inset

A life cycle of an evolutionary process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename evolve.png
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators
\series default
 are Python objects that act on a population.
 They can be applied to a population before or after mating during a life
 cycle of an evolutionary process (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), or to one or two parents during the production of each offspring.
 Arbitrary numbers of operators can be applied to an evolving population.
\end_layout

\begin_layout Standard
A simuPOP 
\series bold
mating scheme
\series default
 is responsible for choosing parent or parents from a parental (virtual)
 subpopulation and for populating an offspring subpopulation.
 simuPOP provides a number of pre-defined mating schemes, such as random,
 consanguineous, monogamous, or polygamous mating, selfing, and haplodiploid
 mating in hymenoptera.
 More complicated nonrandom mating schemes such as mating in age-structured
 populations can be constructed using 
\series bold
heterogeneous mating schemes
\series default
.
 
\end_layout

\begin_layout Standard
simuPOP evolves a population generation by generation, following the evolutionar
y cycle depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

.
 Briefly speaking, a number of 
\series bold
pre-mating operators
\series default
 such as a 
\emph on
mutator
\emph default
 are applied to a population before a mating scheme repeatedly chooses a
 parent or parents to produce offspring.
 
\series bold
During-mating operators
\series default
 such as 
\emph on
recombinator
\emph default
 can be used to adjust how offspring genotypes are formed from parental
 genotypes.
 After an offspring population is populated, 
\series bold
post-mating operators
\series default
 can be applied, for example, to calculate population statistics.
 The offspring population will then become the parental population of the
 next evolutionary cycle.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simpleExample.log"
lstparams "caption={A simple example},label={simple-example}"

\end_inset


\end_layout

\begin_layout Standard
These concepts are demonstrated in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

, where a standard diploid Wright-Fisher model with recombination is simulated.
 The first line imports the standard simuPOP module.
 The second line creates a diploid population with 1000 individuals, each
 having one chromosome with two loci.
 The third line creates a simulator with three replicates of this population.
 Random mating will be used to generate offspring.
 The last statement uses the 
\family typewriter
evolve()
\family default
 function to evolve the populations for 100 generations, subject to five
 operators.
\end_layout

\begin_layout Standard
The first operator 
\family typewriter
initByValue
\family default
 is applied to all populations before evolution.
 This operator initializes all individuals with the same genotype 
\family typewriter
12/21
\family default
.
 The other operators can be applied at every generation.
 
\family typewriter
recombinator
\family default
 is a during-mating operator that recombines parental chromosomes with the
 given recombination rate 
\family typewriter
0.01
\family default
 during the generation of offspring; 
\family typewriter
stat
\family default
 calculates linkage disequilibrium between the first and second loci.
 The results of this operator are stored in a local variable space of each
 population.
 The last two operators 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOutput
\family default
 are applied at the end of every 10 generations.
 
\family typewriter
pyEval
\family default
 is applied to all replicates to output calculated linkage disequilibrium
 values with a trailing tab, and the last operator outputs a newline after
 the last replicate.
 The result is a table of three columns, representing the decay of linkage
 disequilibrium of each replicate at 10 generation intervals.
 The return value of the 
\family typewriter
evolve
\family default
 function, which is the number of evolved generations for each replicate,
 is also printed.
\end_layout

\begin_layout Section
Features
\end_layout

\begin_layout Standard
simuPOP offers a long list of features, many of which are unique among all
 forward-time population genetics simulation programs.
 The most distinguished features include:
\end_layout

\begin_layout Enumerate
simuPOP provides three types of modules that use 1, 8 or 16 bits to store
 an allele.
 The binary module (1 bit) is suitable for simulating a large number of
 SNP markers and the long module (16 bits) is suitable for simulating some
 population genetics models such as the infinite allele mutation model.
 simuPOP supports different types of chromosomes such as autosome, sex chromosom
es and mitochondrial, with arbitrary number of markers.
\end_layout

\begin_layout Enumerate
An arbitrary number of float numbers, called information fields, can be
 attached to individuals of a population.
 For example, information field father_idx and mother_idx are used to track
 an individual’s parents, and pack_year can be used to simulate an environmental
 factor associated with smoking.
\end_layout

\begin_layout Enumerate
simuPOP does not impose any limit on number of homologous sets of chromosomes,
 the size of the genome, or the number of individuals in a population.
 During an evolutionary process, a population can hold more than one most-recent
 generations.
 Pedigrees can be sampled from such multi-generation populations.
\end_layout

\begin_layout Enumerate
An operator can be native (implemented in C++) or hybrid (Python assisted).
 A hybrid operator calls a user-provided Python function to implement arbitrary
 genetic effects.
 For example, a hybrid mutator passes to-be-mutated alleles to a user-provided
 function and mutates these alleles according to the returned values.
\end_layout

\begin_layout Enumerate
simuPOP provides more than 70 operators that cover all important aspects
 of genetic studies.
 These include mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise and hybrid), migration (arbitrary,
 can create new subpopulation), recombination and gene conversion (uniform
 or nonuniform, sex-specific), quantitative trait (single, multilocus or
 hybrid), selection (single-locus, additive, multiplicative or hybrid multi-locu
s models), penetrance (single, multi-locus or hybrid), ascertainment (case–contr
ol, affected sibpairs, random, nuclear and large pedigree), statistics calculati
on (including but not limited to allele, genotype, haplotype, heterozygote
 number and frequency; expected heterozygosity; bi-allelic and multi-allelic
 , and linkage disequilibrium measures), pedigree tracing, visualization
 (using R or other Python modules) and load/save in simuPOP’s native format
 and many external formats such as Linkage.
\end_layout

\begin_layout Enumerate
Mating schemes and many operators can work on virtual subpopulations of
 a subpopulation.
 For example, positive assortative mating can be implemented by mating individua
ls with similar properties such as ancestry.
 The number of offspring per mating event can be fixed, or can follow a
 statistical distribution.
\end_layout

\begin_layout Standard
A number of forward-time simulation programs are available.
 If we exclude early forward-time simulation applications developed primarily
 for teaching purposes, notable forward-time simulation programs include
 
\emph on
easyPOP
\emph default
, 
\emph on
FPG
\emph default
, 
\emph on
Nemo
\emph default
 and 
\emph on
quantiNemo
\emph default
, 
\emph on
genoSIM
\emph default
 and 
\emph on
genomeSIMLA
\emph default
, 
\emph on
FreGene
\emph default
, 
\emph on
GenomePop
\emph default
, 
\emph on
ForwSim
\emph default
, and 
\emph on
ForSim
\emph default
.
 These programs are designed with specific applications and specific evolutionar
y scenarios in mind, and excel in what they are designed for.
 For some applications, these programs may be easier to use than simuPOP.
 For example, using a special look-ahead algorithm, 
\emph on
ForwSim
\emph default
 is among the fastest programs to simulate a standard Wright-Fisher process,
 and should be used if such a simulation is needed.
 However, these programs are not flexible enough to be applied to problems
 outside of their designed application area.
 For example, none of these programs can be used to study the evolution
 of a disease predisposing mutant, a process that is of great importance
 in statistical genetics and genetic epidemiology.
 Compared to such programs, simuPOP has the following advantages:
\end_layout

\begin_layout Itemize
The scripting interface gives simuPOP the flexibility to create arbitrarily
 complex evolutionary scenarios.
 For example, it is easy to use simuPOP to explicitly introduce a disease
 predisposing mutant to an evolving population, trace the allele frequency
 of them, and restart the simulation if they got lost due to genetic drift.
\end_layout

\begin_layout Itemize
The Python interface allows users to define customized genetic effects in
 Python.
 In contrast, other programs either do not allow customized effects or force
 users to modify code at a lower (e.g.
 C++) level.
\end_layout

\begin_layout Itemize
simuPOP is the only application that embodies the concept of virtual subpopulati
on that allows evolutions at a finer scale.
 This is required for realistic simulations of complex evolutionary scenarios.
\end_layout

\begin_layout Itemize
simuPOP allows users to examine an evolutionary process very closely because
 all simuPOP objects are Python objects that can be assessed using their
 member functions.
 For example, users can keep track of genotype at particular loci during
 evolution.
 In contrast, other programs work more or less like a black box where only
 limited types of statistics can be outputted.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
simuPOP is distributed under a GPL license and is hosted on
\family typewriter
 http://simupop.sourceforge.net
\family default
, the world's largest development and download repository of Open Source
 code and applications.
 simuPOP is available on any platform where Python is available, and is
 currently tested under both 32 and 64 bit versions of Windows (Windows
 2000 and later), Linux (Redhat), MacOS X and Sun Solaris systems.
 Different C++ compilers such as Microsoft Visual C++, gcc and Intel icc
 are supported under different operating systems.
 Standard installation packages are provided for Windows, Linux, MacOS X,
 and Sun Solaris systems.
\end_layout

\begin_layout Standard
If a binary distribution is unavailable for a specific platform, it is usually
 easy to compile simuPOP from source, following the standard 
\family typewriter

\begin_inset Quotes eld
\end_inset

python setup.py install
\begin_inset Quotes erd
\end_inset


\family default
 procedure.
 Besides a C++ compiler, several supporting tools and libraries are needed.
 Please refer to the 
\family typewriter
INSTALL
\family default
 file for further information.
\end_layout

\begin_layout Standard
Thanks to the ‘glue language’ nature of Python, it is easy to interoperate
 Python with other applications within a simuPOP script.
 For example, users can call any R function from Python/simuPOP for the
 purposes of visualization and statistical analysis, using 
\series bold
R
\series default
 and a Python module 
\series bold
RPy
\series default
.
 This technique is widely used in simuPOP so it is highly recommended that
 you install R and rpy is your are familiar with R.
 In addition, although simuPOP uses the standard tkInter GUI toolkit when
 a graphical user interface is needed, it can make use of a 
\series bold
wxPython
\series default
 toolkit if it is available.
 Several functions, such as the graphical version of the 
\family typewriter
ListVars()
\family default
 function, are only available for wxPython.
\end_layout

\begin_layout Section
Getting help
\end_layout

\begin_layout Subsection
Online help system
\end_layout

\begin_layout Standard
Most of the help information contained in this document and 
\emph on
the simuPOP reference manual
\emph default
 is available from command line.
 For example, after you install and import the simuPOP module, you can use
 
\family typewriter
help(population.addInfoField) 
\family default
to view the help information of member function 
\family typewriter
addInfoField
\family default
 of class 
\family typewriter
population
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/help.log"
lstparams "caption={Getting help using the \\texttt{help()} function},keywordstyle={\\ttfamily}"

\end_inset


\end_layout

\begin_layout Standard
It is important that you understand that
\end_layout

\begin_layout Itemize
The constructor of a class is named 
\family typewriter
__init__
\family default
 in Python.
 That is to say, you should use the following command to display the help
 information of the constructor of class 
\family typewriter
population
\family default
: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> help(population.__init__)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some classes are derived from other classes and have access to member functions
 of their base classes.
 For example, class 
\family typewriter
population
\family default
, 
\family typewriter
individual
\family default
 and 
\family typewriter
simulator
\family default
 are all derived from class 
\family typewriter
GenoStruTrait
\family default
.
 Therefore, you can use all 
\family typewriter
GenoStruTrait
\family default
 member functions from these classes.
 
\end_layout

\begin_deeper
\begin_layout Standard
In addition, the constructor of a derived class also calls the constructor
 of its base class so you may have to refer to the base class for some parameter
 definitions.
 For example, parameters 
\family typewriter
begin, end, step, at 
\family default
etc are shared by all operators, and are explained in details only in class
 
\family typewriter
baseOperator.
\end_layout

\end_deeper
\begin_layout Subsection
Debug-related operators/functions
\end_layout

\begin_layout Standard
If your simuPOP session or script does not behave as expected, it might
 be helpful to let simuPOP print out some debug information.
 For example, the following code will crash simuPOP:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is unclear why this simple command causes us trouble, instead of outputting
 the genotype of the only individual of this population.
 However, the reason is clear if you turn on debug information:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Turn on/off debug information
\end_layout

\end_inset

>>> TurnOnDebug(DBG_POPULATION)
\end_layout

\begin_layout Plain Layout

>>> population(1, loci=[100]).individual(0).genotype()
\end_layout

\begin_layout Plain Layout

Constructor of population is called
\end_layout

\begin_layout Plain Layout

Destructor of population is called 
\end_layout

\begin_layout Plain Layout

Segmentation fault (core dumped)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
population(1, loci=[100])
\family default
 creates a temporary object that is destroyed right after the execution
 of the command.
 When Python tries to display the genotype, it will refer to an invalid
 location.
 The right way to do this is to create a persistent population object: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> pop = population(1, loci=[100])
\end_layout

\begin_layout Plain Layout

>>> pop.individual(0).genotype()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can use 
\family typewriter
TurnOnDebug(code) 
\family default
and 
\family typewriter
TurnOffDebug(code) 
\family default
to turn on and off debug information where 
\family typewriter
code 
\family default
can be any debug code listed in 
\family typewriter
ListDebugCode
\begin_inset Index
status collapsed

\begin_layout Plain Layout
listDebugCode
\end_layout

\end_inset

()
\family default
.
 If you would like to turn on debugging during an evolutionary process,
 you can use operators 
\family typewriter
turnOnDebug 
\family default
and 
\family typewriter
turnOffDebug
\family default
.
\end_layout

\begin_layout Subsection
Other help sources
\end_layout

\begin_layout Standard
If you are new to Python, it is recommended that you borrow a Python book,
 or at least go through the following online Python tutorials:
\end_layout

\begin_layout Enumerate
The Python tutorial (
\family typewriter
http://docs.python.org/tut/tut.html
\family default
)
\end_layout

\begin_layout Enumerate
Other online tutorials listed at 
\family typewriter
http://www.python.org/doc/
\end_layout

\begin_layout Standard
If you are new to simuPOP, please read this guide before you dive into 
\emph on
the simuPOP reference manual
\emph default
, which describes all the details of simuPOP but does not show you how to
 use it.
 The PDF versions of both documents are distributed with simuPOP.
 You can also get the latest version of the documents online, from the simuPOP
 subversion repository ( 
\family typewriter
http://simupop.sourceforge.net
\family default
, click
\family sans
 SF.net summary > Code > SVN Browse > trunk > doc
\family default
).
 However, because simuPOP is under active development, there may be discrepancie
s between your local simuPOP installation and these latest documents.
\end_layout

\begin_layout Standard
A number of bundled scripts are distributed with simuPOP.
 They range from simple demonstration of population genetics models to observing
 the evolution of complex human genetic diseases.
 These scripts can be a good source to learn how to write a simuPOP script.
 Of course, if any of these scripts happens to fit your need, you may be
 able to use them directly, with writting a line of code.
\end_layout

\begin_layout Standard
A 
\emph on
simuPOP cookbook
\emph default
 is under development.
 The goal of this book is to provide recipes of commonly used simulation
 scenarios.
 A number of recipes are currently available under the 
\family typewriter
doc/cookbook
\family default
 directory of a simuPOP distribution.
 This book might be made available online so that users can submit their
 own recipes.
\end_layout

\begin_layout Standard
If you cannot find the answer you need, or if you believe that you have
 located a bug, or if you would like to request a feature, please subscribe
 to the simuPOP mailinglist and send your questions there.
\end_layout

\begin_layout Section
Naming Conventions
\end_layout

\begin_layout Standard
Before we dive into the details of simuPOP, it is helpful to know a few
 name conventions that simuPOP tries to follow.
 Generally speaking, 
\end_layout

\begin_layout Itemize
All classes (objects, e.g.
 
\family typewriter
population
\family default
()), member functions (e.g.
 
\family typewriter
population::vars()
\family default
) and parameter names start with small character and use capital character
 for the first character of each word afterward (e.g.
 
\family typewriter
population::subPopSize(), individual::setInfo
\family default
()).
\end_layout

\begin_layout Itemize
Standalone functions start with capital character.
 This is how you can differ an operator from its function version.
 For example, 
\family typewriter
TurnOnDebug(DBG_POPULATION)
\family default
 is the function to turn on debug mode for population related functions
 and 
\family typewriter
turnOnDebug(DBG_POPULATION) 
\family default
will do nothing apparently, because it creates an operator.
 
\end_layout

\begin_layout Itemize
Constants start with Capital characters as well.
 They are usually prefixed with a category name.
 For example, 
\family typewriter
MigrByProportion
\family default
 specifies a migration mode.
\end_layout

\begin_layout Standard
Finally, simuPOP uses the abbreviated forms of the following words in function
 and parameter names:
\end_layout

\begin_layout Quote

\family typewriter
pos 
\family default
(position)
\family typewriter
,  info 
\family default
(information)
\family typewriter
, migr 
\family default
(migration)
\family typewriter
, subPop 
\family default
(subpopulation(s) and virtual subpopulation(s))
\family typewriter
, rep 
\family default
(replicate)
\family typewriter
, gen 
\family default
(generation)
\family typewriter
, ops 
\family default
(operators)
\family typewriter
, expr 
\family default
(expression),
\family typewriter
 stmts 
\family default
(statements).
\end_layout

\begin_layout Chapter
simuPOP components
\end_layout

\begin_layout Section
simuPOP modules
\end_layout

\begin_layout Standard
simuPOP consists of a number of Python modules, documents, tests and examples.
 Using windows as an example, simuPOP installs the following files to your
 operating system:
\end_layout

\begin_layout Itemize
Core simuPOP modules (
\family typewriter
simuPOP_XXX.py
\family default
, 
\family typewriter
_simuPOP_XXX.pyd
\family default
) and a number of utility modules (
\family typewriter
simuUtil.py, simuOpt.py
\family default
 etc) under 
\family typewriter
c:
\backslash
python2X
\backslash
Lib
\backslash
site-packages
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
doc
\family default
: This directory contains the pdf version of this user's guide and the 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
test:
\family default
 This directory contains all unit test cases.
 It is recommended that you test your simuPOP installation using these scripts
 if you compile simuPOP from source.
 
\end_layout

\begin_layout Itemize

\family typewriter
c:
\backslash
python2X
\backslash
share
\backslash
simuPOP
\backslash
scripts
\series bold
\emph on
:
\family default
\series default
\emph default
 This directory contains all the bundled scripts.
 It is worth noting that although these scripts are distributed with simuPOP,
 they are not tested as rigorously and as frequently as the simuPOP core.
 Please send an email to the simuPOP mailinglist if you notice any problem
 with them.
\end_layout

\begin_layout Standard
There are six flavors of the core simuPOP module: short, long and binary
 allele modules, and their optimized versions.
 The short allele modules use 8 bits to store each allele which limits the
 possible allele states to 256.
 This is enough most of the times but not so if you need to simulate models
 such as the infinite allele model.
 In those cases, you should use the long allele version of the modules,
 which use 16 bits for each allele and can have 
\begin_inset Formula $2^{16}$
\end_inset

 possible allele states.
 On the other hand, if you would like to simulate a large number of binary
 (SNP) markers, binary libraries can save you a lot of RAM because they
 use 1 bit for each allele.
 Despite of differences in internal memory layout, all these modules have
 the same interface.
\end_layout

\begin_layout Standard
Standard libraries have detailed debug and run-time validation mechanism
 to make sure a simulation executes correctly.
 Whenever something unusual is detected, simuPOP would terminate with detailed
 error messages.
 The cost of such run-time validation varies from case to case but can be
 high under some extreme circumstances.
 Because of this, optimized versions for all modules are provided.
 They bypass all parameter checking and run-time validations and will simply
 crash if things go wrong.
 It is recommended that you use standard libraries whenever possible and
 only use the optimized version when performance is needed and you are confident
 that your simulation is running as expected.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-standard-module"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 demonstrate the differences between standard and optimized modules, by
 executing two invalid commands.
 A standard module returns proper error messages, while an optimized module
 returns erroneous results and or simply crashes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/standard.log"
lstparams "caption={Use of standard simuPOP modules},keywords={from,import},label={lst:Use-of-standard-module}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Use-of-optimized-module"

\end_inset

Use of optimized simuPOP modules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

% python
\end_layout

\begin_layout Plain Layout

>>> from simuOpt import setOptions
\end_layout

\begin_layout Plain Layout

>>> setOptions(optimized=True, alleleType='long', quiet=True)
\end_layout

\begin_layout Plain Layout

>>> from simuPOP import *
\end_layout

\begin_layout Plain Layout

>>> pop = population(10, loci=[2])
\end_layout

\begin_layout Plain Layout

>>> pop.locusPos(10)
\end_layout

\begin_layout Plain Layout

1.2731974748756028e-313
\end_layout

\begin_layout Plain Layout

>>> pop.individual(20).setAllele(1, 0)
\end_layout

\begin_layout Plain Layout

Segmentation fault
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Use-of-optimized-module"

\end_inset

 also demonstrates how to use the 
\family typewriter
setOptions
\family default
 function in the 
\family typewriter
simuOpt
\family default
 module to control the choice of one of the six simuPOP modules.
 By specifying one of 
\family typewriter
short, long
\family default
 or 
\family typewriter
binary 
\family default
for option 
\family typewriter
alleleType
\family default
, and setting
\family typewriter
 optimized
\family default
 to 
\family typewriter
True
\family default
 or 
\family typewriter
False
\family default
, the right flavor of module will be chosen when simuPOP is loaded.
 In addition, option 
\family typewriter
quiet
\family default
 can be used supress initial output.
 An alternative method is to set environmental variable 
\family typewriter
SIMUALLELETYPE
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
SIMUALLELETYPE
\end_layout

\end_inset

 to 
\family typewriter
short
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
binary
\family default
 to use the standard short, long or binary module, and variable 
\family typewriter
SIMUOPTIMIZED
\family default
 to use the optimized modules.
\end_layout

\begin_layout Standard
When simuPOP is loaded, it creates a default random number generator (RNG)
 of type 
\family typewriter
mt19937
\family default
 using a random seed from a system random number generator that gurantees
 random seeds for all instances of simuPOP even if they are initialized
 at the same time.
 After simuPOP is loaded, you can reset this system RNG with a different
 random number generator (c.f.
 
\family typewriter
AvailableRNG
\begin_inset Index
status collapsed

\begin_layout Plain Layout

\family typewriter
AvailableRNG
\end_layout

\end_inset

()
\family default
, 
\family typewriter
SetRNG
\begin_inset Index
status open

\begin_layout Plain Layout

\family typewriter
SetRNG
\end_layout

\end_inset

(name, seed)
\family default
).
 It is also possible to save the random seed of a simuPOP session (c.f.
 
\family typewriter
rng().seed()
\family default
) and use it to replay the session later.
\end_layout

\begin_layout Section
Pythonic issues
\end_layout

\begin_layout Subsection
References and the 
\family typewriter
clone() 
\family default
member function
\end_layout

\begin_layout Standard
Assignment in Python only creates a new refernce to an exsting object.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop = population()
\end_layout

\begin_layout Plain Layout

pop1 = pop
\end_layout

\end_inset

will create a reference 
\family typewriter
pop1
\family default
 to population 
\family typewriter
pop
\family default
.
 Modifying 
\family typewriter
pop1
\family default
 will modify 
\family typewriter
pop
\family default
 as well and the removal of 
\family typewriter
pop
\family default
 will invalidate 
\family typewriter
pop1
\family default
.
 For example, a reference to the first population in a simulator is returned
 from function 
\family typewriter
func()
\family default
 in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

.
 The subsequent use of this 
\family typewriter
pop
\family default
 object may crash simuPOP because the simulator 
\family typewriter
simu
\family default
 is destroyed, along with all its internal populations, after 
\family typewriter
func()
\family default
 is finished, leaving 
\family typewriter
pop
\family default
 referring to an invalid object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lst:Reference-to-population"

\end_inset

Reference to a population in a simulator
\end_layout

\end_inset

def func():
\end_layout

\begin_layout Plain Layout

    simu = simulator(population(10), randomMating(), rep=5)
\end_layout

\begin_layout Plain Layout

    # return a reference to the first population in the simulator
\end_layout

\begin_layout Plain Layout

    return simu.population(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pop = func()
\end_layout

\begin_layout Plain Layout

# simuPOP will crash because pop refers to an invalid population.
\end_layout

\begin_layout Plain Layout

pop.popSize()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you would like to have an independent copy of a population, you can use
 the 
\family typewriter
clone()
\family default
 member function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:Reference-to-population"

\end_inset

 would behave properly if the 
\family typewriter
return
\family default
 statement is replaced by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.population(0).clone()
\end_layout

\end_inset

although in this specific case, extracting the first population from the
 simulator using the 
\family typewriter
extract
\family default
 function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return simu.extract(0)
\end_layout

\end_inset

would be more efficient because we do not need to copy the first population
 from 
\family typewriter
simu
\family default
 if it will be destroyed soon.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
clone()
\family default
 function exists for all simuPOP classes (objects) such as 
\emph on
simulator
\emph default
, 
\emph on
mating schemes
\emph default
 and 
\emph on
operators
\emph default
.
 simuPOP also supports the standard Python shallow and deep copy operations
 so you can also make a cloned copy of 
\family typewriter
pop
\family default
 using the
\family typewriter
 deepcopy
\family default
 function defined in the Python 
\family typewriter
copy 
\family default
module
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy
\end_layout

\begin_layout Plain Layout

pop1 = copy.deepcopy(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zero-based indexes, absolute and relative indexes
\end_layout

\begin_layout Standard

\series bold
All arrays in simuPOP start at index 0
\series default
.
 This conforms to Python and C++ indexes.
 To avoid confusion, I will refer the first locus as locus zero, the second
 locus as locus one; the first individual in a population as individual
 zero, and so on.
\end_layout

\begin_layout Standard
Another two important concepts are the
\emph on
 absolute index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset


\emph default
 and
\emph on
 
\emph default
the
\emph on
 relative index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 
\emph default
of a locus.
 The former index ignores chromosome structure.

\emph on
 
\emph default
For example, if there are 5 and 7 loci on the first two chromosomes, the
 absolute indexes of the two chromosomes are (0, 1, 2, 3, 4), (5, 6, 7,
 8, 9, 10, 11) and the relative indexes are (0, 1, 2, 3, 4), (0, 1, 2, 3,
 4, 5, 6).
 Absolute indexes are more frequently used because they avoid the trouble
 of having to use two numbers (chrom, index) to refer to a locus.
 Two functions 
\family typewriter
chromLocusPair(idx)
\family default
 and 
\family typewriter
absLocusIndex(chrom,index)
\family default
 are provided to convert between these two kinds of indexes.
 An individual can also be referred by its 
\emph on
absolute index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!absolute
\end_layout

\end_inset


\emph default
 and
\emph on
 relative index
\begin_inset Index
status collapsed

\begin_layout Plain Layout
index!relative
\end_layout

\end_inset

 
\emph default
where 
\emph on
relative index 
\emph default
is the index in its subpopulation.
 Related member functions are 
\family typewriter
subPopIndPair(idx)
\family default
 and 
\family typewriter
absIndIndex(idx, subPop)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/absIndex.log"
lstparams "caption={Conversion between absolute and relative indexes},label={absIndex}"

\end_inset


\end_layout

\begin_layout Subsection
Ranges and iterators
\end_layout

\begin_layout Standard
Ranges in simuPOP also conform to Python ranges.
 That is to say, a range has the form of 
\family typewriter
[a,b) 
\family default
where 
\family typewriter
a 
\family default
belongs to the range, and 
\family typewriter
b 
\family default
does not.
 For example, 
\family typewriter
pop.chromBegin(1) 
\family default
refers to the index of the first locus on chromosome 1 (actually exists),
 and 
\family typewriter
pop.chromEnd(1) 
\family default
refers to the index of the last locus on chromosome 1
\series bold
 plus 1
\series default
, which might or might not be a valid index.
\end_layout

\begin_layout Standard
A number of simuPOP functions return Python iterators that can be used to
 iterate through an internal array of objects.
 For example, 
\family typewriter
population::individuals([subPop])
\family default
 returns an iterator that can be used to iterate through all individuals,
 or all individuals in a (virtual) subpoulation.
 
\family typewriter
simulator::populations()
\family default
 can be used to iterate through all populations in a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of ranges and iterators in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/iterator.log"
lstparams "caption={Ranges and iterators},label={iterator.log}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
\series medium
\size normal
carray
\family default
\series default
\size default
 datatype
\begin_inset CommandInset label
LatexCommand label
name "sub:carray-datatype"

\end_inset


\end_layout

\begin_layout Standard
simuPOP uses mostly standard Python types such as tuples, lists and dictionaries.
 However, for efficiency considerations, simuPOP defines and uses a new
 
\family typewriter
carray 
\family default
datatype to refer to an internal array of genotypes.
 Such an object can only be returned from 
\family typewriter
individual::genotype
\family default
 and 
\family typewriter
population::genotype
\family default
 functions.
 Instead of copying all genotypes to a Python tuple or list, these functions
 return a 
\family typewriter
carray 
\family default
object that directly reflect the underlying genotype.
 This object behaves like a regular Python list except that the underlying
 genotype will be changed if elements of this object are changed.
 In addition, elements in this array will be changed if the underlying genotype
 is changed using another method.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the use of this datatype.
 It also shows how to get an independent list of alleles using the 
\family typewriter
list()
\family default
 built-in function.
 Compare to 
\family typewriter
allele()
\family default
, 
\family typewriter
setAllele()
\family default
 and 
\family typewriter
setGenotype()
\family default
 functions, it is usually more efficient and more convenient to read and
 write genotypes using carray objects, although this usage is usually less
 readable.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/carray.log"
lstparams "caption={The carray datatype},label={carraydatatype}"

\end_inset


\end_layout

\begin_layout Section
Genotypic structure 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
genotypic structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genotypic structure refers to stuctural information shared by all individuals
 in a population, including number of homologous copies of chromosomes (c.f.
 
\family typewriter
ploidy
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidy
\end_layout

\end_inset

(), ploidyName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!ploidyName
\end_layout

\end_inset

()
\family default
), chromosome types and names (c.f.
 
\family typewriter
numChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numChrom
\end_layout

\end_inset

(), chromType()
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromType
\end_layout

\end_inset

, chromName
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!chromName
\end_layout

\end_inset

()
\family default
), position and name of each locus (c.f.
 
\family typewriter
numLoci
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!numLoci
\end_layout

\end_inset

(ch),
\family default
 
\family typewriter
locusPos
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!locusPos
\end_layout

\end_inset

(loc),
\family default
 
\family typewriter
locusName(loc)
\family default
), and auxillary information attached to each individual (c.f.
 
\family typewriter
infoField
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoField
\end_layout

\end_inset

(idx), infoFields
\begin_inset Index
status collapsed

\begin_layout Plain Layout
GenoStruTrait!infoFields
\end_layout

\end_inset

()
\family default
).
 In addition to property access functions, a number of utility functions
 are provided to, for example, look up the index of a locus by its name
 (c.f.
 
\family typewriter
locusByName()
\family default
, 
\family typewriter
chromBegin()
\family default
, 
\family typewriter
chromLocusPair()
\family default
).
\end_layout

\begin_layout Standard
A genotypic structure can be retrieved from 
\emph on
individual, population 
\emph default
and 
\emph on
simulator
\emph default
 objects.
 Because a population consists of individuals of the same type, and a simulator
 consists of populations of the same type, genotypic information
\emph on
 
\emph default
can only be changed for all individuals at the population level, or for
 all populations at the simulator level.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to access genotypic structure functions at the population
 and individual levels.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/genoStru.log"
lstparams "caption={Genotypic structure functions},label={genostructure}"

\end_inset


\end_layout

\begin_layout Subsection
Haploid, diploid and haplodiploid populations
\end_layout

\begin_layout Standard
simuPOP is most widely used to study human (diploid) populations.
 A large number of mating schemes, operators and population statistics are
 designed around the evolution of such a population.
 simuPOP also supports haploid and haplodiploid populations although there
 are fewer choices of mating schemes and operators.
 simuPOP can also support other types of populations such as triploid and
 tetraploid populations, but these features are largely untested due to
 their limited usage.
 It is expected that supports for these population would be enhanced over
 time.
\end_layout

\begin_layout Standard
For efficiency considerations, simuPOP saves the same numbers of homologous
 sets of chromosomes even if some individuals have different numbers of
 homologous sets in a population.
 For example, in a haplodiploid population, because male individuals have
 only one set of chromosomes, their second homologous set of chromosomes
 are 
\emph on
unused
\emph default
, which are labelled as 
\family typewriter
'_'
\family default
, as shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/haplodiploid.log"
lstparams "caption={An example of haplodiploid population},keywordstyle={\\ttfamily},label={haplodiploid}"

\end_inset


\end_layout

\begin_layout Subsection
Autosomes, sex chromosomes, and other types of chromosomes
\end_layout

\begin_layout Standard
The default chromosome type is autosome, which is the 
\emph on
normal
\emph default
 chromosomes in diploid, and in haploid populations.
 simuPOP supports three other types of chromosomes, namely 
\emph on
ChromosomeX
\emph default
, 
\emph on
ChromosomeY 
\emph default
and 
\emph on
Customized
\emph default
.
 Sex chromosomes are only valid in haploid populations where chromosomes
 X and Y are used to determine the sex of an offspring.
 Customized chromosomes rely on user defined functions and operators to
 be passed from parents to offspring.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 shows how to specify different chromosome types, and how genotypes of these
 special chromosomes are arranged.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/chromType.log"
lstparams "caption={Different chromosome types},keywordstyle={\\ttfamily},label={chromtypes}"

\end_inset


\end_layout

\begin_layout Standard
The evolution of sex chromosomes follow the following rules
\end_layout

\begin_layout Itemize
There can be only one X chromosome and one Y chromosome.
 It is not allowed to have only one kind of sex chromosome.
\end_layout

\begin_layout Itemize
The Y chromosome of female individuals are ignored.
 The second homologous copy of the X chromosome and the first copy of the
 Y chromosome are ignored for male individuals.
\end_layout

\begin_layout Itemize
During mating, female parent pass one of her X chromosome to her offspring,
 male parent pass chromosome X or Y to his offspring.
 Recombination is allowed for the X chromosomes of females, but not allowed
 for males.
\end_layout

\begin_layout Itemize
The sex of offspring is determined by the types of sex chromosomes he/she
 inherits, XX for female, and XY for male.
\end_layout

\begin_layout Standard
As an advanced feature of simuPOP, chromosomes that do not follow the inheritanc
e patterns of autosomes or sex chromosomes can be handled separately.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:chromTypes"

\end_inset

 depicts the possible chromosome structure of two diploid parents, and how
 offspring chromosomes are formed.
 It uses two customized chromosomes to model multiple copies of mitochondrial
 chromosomes that are passed randomly from mother to offspring.
 The second homologous copy of customized chromosomes are unused in this
 example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chromTypes"

\end_inset

Inheritance of different types of chromosomes in a diploid population
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename chromType.pdf
	lyxscale 40
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
Individuals in this population have five chromosomes, one autosome (A),
 one X chromosome (X), one Y chromosome (Y) and two customized chromosomes
 (C).
 The customized chromosomes model multiple copies of mitochondrial chromosomes
 that are passed randomly from mother to offspring.
 Y chromosomes for the female parent, the second copy of chromosome X and
 the first copy of chromosome Y for the male parent, and the second copy
 of customized chromosomes are unused (gray chromosome regions).
 A male offspring inherits one copy of autosome from his mother (with recombinat
ion), one copy of autosome from his father (with recombination), an X chromosome
 from his mother (with recombination), a Y chromosome from his father (without
 recombination), and two copies of the first customized chromosome.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sub:stru-infoFields"

\end_inset


\end_layout

\begin_layout Standard
Different kinds of simulations require different kinds of individuals.
 Individuals with only genotype information are sufficient to simulate the
 basic Wright-Fisher model.
 Sex is needed to simulate such a model in diploid populations with sex.
 Individual fitness may be needed if selection is induced, and age may be
 needed if the population is age-structured.
 In addition, different types of quantitative traits or affection status
 may be needed to study the impact of genotype on individual phenotype.
 Because it is infeasible to provide all such information to an individual,
 simuPOP keeps genotype, sex (
\family typewriter
Male
\family default
 or 
\family typewriter
Female
\family default
) and affection status as 
\emph on
built-in properties
\emph default
 of an individual, and all others as optional 
\emph on
information fields
\emph default
 (float numbers) attached to each individual.
\end_layout

\begin_layout Standard
Information fields can be specified when a population is created, or added
 later using relevant function.
 They are essential for the function of many simuPOP operators.
 For example, all selection operators require information field 
\family typewriter
fitness
\family default
 to store evaluated fitness values for each individual.
 Operator 
\family typewriter
migrator
\family default
 uses information field 
\family typewriter
migrate_to
\family default
 to store the ID of subpopulation an individual will migrate to.
 An error will be raised if these operators are applied to a population
 without needed information fields.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/infoField.log"
lstparams "caption={Basic usage of information fields},label={basicInfoFields}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates the basic usage of information fields.
 In this example, a population with two information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 are created.
 It can hold one ancestral generations (
\family typewriter
ancGen=1
\family default
, see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details) so the most recent parental generations will be kept in a
 population object.
 After initializing each individual with two chromosomes with all zero and
 all one alleles respectively, the population evolves one generation, suject
 to recombination at rate 0.01.
 Parents of each individual are recorded, by operator 
\family typewriter
parentsTagger
\family default
, to information fields 
\family typewriter
mother_idx
\family default
 and 
\family typewriter
father_idx
\family default
 of each offspring
\family typewriter
.
\end_layout

\begin_layout Standard
After evolution, the population is extracted from the simulator, and the
 values of information field 
\family typewriter
mother_idx
\family default
 of all individuals are printed.
 The next several statements get the first individual from the population,
 and his mother from the parental generation using the index stored in this
 individual's information field.
 Genotypes at the first homologous copy of this individual's chromosome
 is printed, along with two parental chromosomes.
\end_layout

\begin_layout Section
Individual
\end_layout

\begin_layout Standard
Individuals are building blocks of populations.
 An individual object cannot be created independently, but refences to inidividu
als can be retrieved using member functions of a population object.
 In addition to structural information shared by all individuals in a population
, the individual class provides member functions to get and set 
\emph on
genotype
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
affection status
\emph default
 and 
\emph on
information fields
\emph default
 of an individual.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates how to access and modify individual sex, affection status
 and information fields.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual.log"
lstparams "caption={Access Individual properties},label={individuals}"

\end_inset


\end_layout

\begin_layout Standard
Genotypes of an individual are stored sequentially and can be accessed locus
 by locus, or in batch.
 The alleles are arranged by position, chromosome and ploidy.
 That is to say, the first allele on the first chromosome of the first homologou
s set is followed by alleles at other loci on the same chromsome, then markers
 on the second and later chromosomes, followed by alleles on the second
 homologous set of the chromosomes for a diploid individual.
 A consequence of this memory layout is that alleles at the same locus of
 a non-haploid individual are separated by 
\family typewriter
individual::totNumLoci()
\family default
 loci.
 The memory layout of a diploid individual with two chromosomes is illustrated
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:genotype-layout"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:genotype-layout"

\end_inset

Memory layout of individual genotype
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename genotype.pdf
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
simuPOP provies several functions to read/write individual genotype.
 It is worth noting that, instead of copying genotypes of an individual
 to a Python tuple or list, the return value of function 
\family typewriter
genotype([p, [ch]])
\family default
 is a special python carray object that reflects the underlying genotypes.
 Modifying elements of this array will change the genotype of an individual
 directly.
 Only 
\family typewriter
count
\family default
 and
\family typewriter
 index
\family default
 list functions can be used, but all comparison, assignment and slice operations
 are allowed.
 If you would like to copy the content of this 
\family typewriter
carray
\family default
 to a Python list, use the 
\family typewriter
list()
\family default
 function.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "individual_genotype"

\end_inset

 demonstrates the use of these functions.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/individual_genotype.log"
lstparams "caption={Access individual genotype},label={individual_genotype}"

\end_inset


\end_layout

\begin_layout Section
Population
\end_layout

\begin_layout Standard
The 
\family typewriter
population
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population
\end_layout

\end_inset


\family default
 object is the most important object of simuPOP.
 It consists of one or more generations of individuals, grouped by subpopulation
s, and a local Python dictionary to hold arbitrary population information.
 This class provides a large number of functions to access and modify population
 structure, individuals and their genotypes and information fields.
 The following sections explain these features in detail.
\end_layout

\begin_layout Subsection
Subpopulations
\end_layout

\begin_layout Standard
A simuPOP population consists of one or more subpopulations.
 Subpopulations serve as barriers of individuals in the sense that mating
 only happens between individuals in the same subpopulation.
 A number of functions are provided to merge, remove, resize subpopulations,
 and move individuals between subpopulations (migration).
 You will rarely get a chance to use them directly because such operations
 are usually handled by operators.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subPopName"

\end_inset

 demonstrates how to use subpopulation related functions.
 Of particular interest is the 
\family typewriter
setSubPopByIndInfo()
\family default
 function.
 This function takes an information field as parameter and rearrange individuals
 according to their values at this information field.
 Individuals with invalid (nagative) values at this information field are
 removed.
 This is essentially how migration is implemented in simuPOP.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPop.log"
lstparams "caption={Manipulation of subpopulations},label={subPop}"

\end_inset


\end_layout

\begin_layout Standard
Some population operations change the IDs of subpopulations.
 For example, if a population has three subpopulations 0, 1, and 2, and
 subpopulation 1 is split into two subpouplations, subpopulation 2 will
 become subpopulation 3.
 Tracking the ID of a subpopulation can be problematic, especially when
 conditional or random subpopulation operations are involved.
 In this case, you can specify names to subpopulations.
 These names will follow their associated subpopulations during population
 operations so you can identify the ID of a subpopulation by its name.
 Note that simuPOP allows duplicate subpopulation names.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/subPopName.log"
lstparams "caption={Use of subpopulation names},label={subPopName}"

\end_inset


\end_layout

\begin_layout Subsection
Virtual subpopulations
\end_layout

\begin_layout Standard
simuPOP subpopulations can be further divided into virtual subpopulations
 (VSP), which are groups of individuals who share certain properties.
 For example, all male individuals, all unaffected individuals, all individuals
 with information field age > 20, all individuals with genotype 0, 0 at
 a given locus, can form VSPs.
 VPSs do not have to add up to the whole subpopulation, nor do they have
 to be nonoverlapping.
 Unlike subpopulations that have strict boundaries, VSPs change easily with
 the changes of individual properties.
\end_layout

\begin_layout Standard
VSPs are defined by virtual splitters.
 A splitter defines the same number of VSPs in all subpopulations, although
 sizes of these VSPs vary across subpopulations due to subpopulation differences.
 For example, a 
\family typewriter
sexSplitter()
\family default
 defines two VSPs, the first with all male individuals and the second with
 all female individuals, and a 
\family typewriter
infoSplitter(field='x', values=[1, 2, 4])
\family default
 defines three VSPs whose members have values 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 and 
\family typewriter
4
\family default
 at information field 
\family typewriter
x
\family default
, respectively.
 If different types of VSPs are needed, a combined splitter can be used
 to combine VSPs defined by several splitters.
\end_layout

\begin_layout Standard
A VSP is represented by a 
\family typewriter
[spID, vspID]
\family default
 pair.
 Its name and size can be obtained using functions 
\family typewriter
subPopName()
\family default
 and 
\family typewriter
subPopSize()
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "virtualSplitter"

\end_inset

 demonstrates how to apply virtual splitters to a population, and how to
 check VSP names and sizes.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSplitter.log"
lstparams "caption={Define virtual subpopulations in a population},label={virtualSplitter}"

\end_inset


\end_layout

\begin_layout Standard
VSP provides an easy way to access groups of individuals in a subpopulation
 and allows finer control of an evolutionary process.
 For example, mating schemes can be applied to VSPs which makes it possible
 to apply different mating schemes to, for example, individuals with different
 ages.
 By applying migration, mutation etc to VSPs, it is easy to implement advanced
 features such as sex-biased migrations, different mutation rates for individual
s at different stages of a disease.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to initialize genotype and information fields to individuals
 in male and female VSPs.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/virtualSubPop.log"
lstparams "caption={Applications of virtual subpopulations},label={virtualSubPop}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Individuals"

\end_inset

Access individuals and their properties
\end_layout

\begin_layout Standard
There are many ways to access individuals of a population.
 For example, function 
\family typewriter
population::individual(idx)
\family default
 returns a reference to the 
\family typewriter
idx
\family default
-th individual in a population.
 An optional parameter 
\family typewriter
subPop
\family default
 can be specified to return the 
\family typewriter
idx
\family default
-th individual in the 
\family typewriter
subPop
\family default
-th subpopulation.
\end_layout

\begin_layout Standard
If you would like to access a group of individuals, either from a whole
 population, a subpopulation, or from a virtual subpopulation, 
\family typewriter
population::individuals([subPop])
\family default
 is easier to use.
 This function returns a Python iterator that can be used to iterate through
 individuals.
 An advantage of this function is that 
\family typewriter
subPop 
\family default
can be a virtual subpopulation which makes it easy to iterate through individual
s with certain properties (such as all male individuals).
\end_layout

\begin_layout Standard
If more then one generations are stored in a population, function 
\family typewriter
ancestor(idx, [subPop], gen)
\family default
 can be used to access individual from an ancestral generation (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ancestral-populations"

\end_inset

 for details).
 Because there is no group access function for ancestors, it may be more
 convenient to use 
\family typewriter
useAncestralGen
\family default
 to make an 
\emph on
ancestral
\emph default
 generation the 
\emph on
current
\emph default
 generation, and use 
\family typewriter
population::individuals
\family default
.
 Note that ancestor() function can always access individuals at a certain
 generation, regardless which generation the current generation is.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates how to use all these individual-access functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/accessIndividual.log"
lstparams "caption={Access individuals of a population},label={accessIndividual}"

\end_inset


\end_layout

\begin_layout Standard
Although it is easy to access individuals in a population, it is often more
 efficient to access genotypes and information fields in batch mode.
 For example, functions 
\family typewriter
genotype()
\family default
 and
\family typewriter
 setGenotype()
\family default
 can read/write genotype of all individuals in a population or (virtual)
 subpopulation, functions 
\family typewriter
indInfo()
\family default
 and 
\family typewriter
setIndInfo()
\family default
 can read/write certain information fields in a population or (virtual)
 subpopulation.
 The write functions work in a circular manner in the sense that provided
 values are reused if they are not enough to fill all genotypes or information
 fields.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "batchAccess"

\end_inset

 demonstrates the use of such functions.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/batchAccess.log"
lstparams "caption={Access individual properties in batch mode},label={batchAccess}"

\end_inset


\end_layout

\begin_layout Subsection
Information fields
\begin_inset CommandInset label
LatexCommand label
name "sec:Information-fields"

\end_inset


\end_layout

\begin_layout Standard
Information fields are usually set during population creation, using the
 
\family typewriter
infoFields
\family default
 parameter of the population constructor.
 It can also be set or added using functions 
\family typewriter
setInfoFields, addInfoField 
\family default
and 
\family typewriter
addInfoFields
\family default
.
 Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:stru-infoFields"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Individuals"

\end_inset

 have demonstrated how to read and write information fields from an individual,
 or from a population in batch mode.
\end_layout

\begin_layout Standard
Information fields can not located by their names or indexes.
 We have always used field names for clarity, at a cost of performance because
 these names have to be translated into indexes each time.
 When performance is a concern, you can use
\family typewriter
 idx=pop.infoIdx(name)
\family default
 to get and use the index of an information field.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popInfo.log"
lstparams "caption={Add and use of information fields in a population},label={popInfo}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ancestral-populations"

\end_inset

Ancestral populations
\end_layout

\begin_layout Standard
A simuPOP population usually holds individuals in one generation.
 During evolution, an offspring generation will replace the parental generation
 and become the present generation (population), after it is populated from
 a parental population.
 The parental generation is discarded.
\end_layout

\begin_layout Standard
This is usually enough when only the present generation is of interest.
 However, parental generations can provide useful information on how genotype
 and other information are passed from parental to offspring generations.
 simuPOP provides a mechanism to store and access arbitrary number of ancestral
 generations in a population object.
 Applications of this feature include pedigree tracking, reconstruction,
 and pedigree ascertainments.
\end_layout

\begin_layout Standard
A parameter 
\family typewriter
ancGen
\family default
 is used to specify how many generations a population object 
\emph on
can
\emph default
 store (which is usually called the 
\emph on
ancestral depth
\emph default
 of a population).
 This parameter is default to 
\family typewriter
0
\family default
, meaning keeping no ancestral population.
 You can specify a positive number 
\family typewriter
n
\family default
 to store n most recent generations; or -
\family typewriter
1
\family default
 to store all generations.
 Of course, storing all generations during an evolutionary process is likely
 to exhaust the RAM of your computer quickly.
\end_layout

\begin_layout Standard
Several member functions can be used to manipulate ancestral generations:
\end_layout

\begin_layout Itemize

\family typewriter
ancestralGens() 
\family default
returns the number of ancestral generations stored in a population.
\end_layout

\begin_layout Itemize

\family typewriter
setAncestralDepth(depth)
\family default
 resets the number of generations a population can store.
\end_layout

\begin_layout Itemize

\family typewriter
push(pop)
\family default
 will push population 
\family typewriter
pop
\family default
 into the current population.
 
\family typewriter
pop
\family default
 will become the current generation, and the current generation will either
 be removed (if ancGen == 0), or become the parental generation of pop.
 The greatest ancestral generation may be removed.
 This function is rarely used because populations with ancestral generations
 are usually created during an evolutionary process.
\end_layout

\begin_layout Itemize

\family typewriter
useAncestralGen(idx)
\family default
 set the present generation to 
\family typewriter
idx
\family default
 generation.
 
\family typewriter
idx
\family default
 
\family typewriter
= 1
\family default
 for the parental generation, 
\family typewriter
2
\family default
 for grandparental, ..., and 
\family typewriter
0
\family default
 for the present generation.
 This is useful because most population functions act on the 
\emph on
present
\emph default
 generation.
 You should always call 
\family typewriter
setAncestralPop(0)
\family default
 after you examined the ancestral generations.
 
\end_layout

\begin_layout Standard
A typical use of ancestral generations is demonstrated in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

.
 In this example, a population is created and is initialized with allele
 frequency 0.5.
 Its ancestral depth is set to 2 at the beginning of generation 18 so that
 it can hold parental generations at generation 18 and 19.
 The allele frequency at each generation is calculated and displayed, both
 during evolution using a 
\family typewriter
stat
\family default
 operator, and after evolution using the function form this operator.
 Note that setting the ancestral depth at the end of an evolutionary process
 is a common practise because we are usually only interested in the last
 few generations.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/ancestralPop.log"
lstparams "caption={Ancestral populations},label={ancestralPop}"

\end_inset


\end_layout

\begin_layout Subsection
Add and remove loci
\end_layout

\begin_layout Standard
Several functions are provided to remove, add empty loci or chromosomes,
 and to merge loci or chromosomes from another population.
 They can be used to trim unneeded loci, expand exisiting population or
 merge two populations.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates how to use these populations.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/addRemoveLoci.log"
lstparams "caption={Add and remove loci and chromosomes},keywordstyle={\\ttfamily},label={addRemoveLoci}"

\end_inset


\end_layout

\begin_layout Subsection
Population extraction
\end_layout

\begin_layout Standard
Another import population member function is 
\family typewriter
population::extract(field=None, loci=None, info=None, ancGen=-1, ped=None)
\family default
.
 It is a powerful function that can extract subset of individuals, loci,
 information fields and ancestral generations from an existing population.
 This function is widely used in ascertainment operators where individuals
 or pedigrees are extracted from an existing population and form a sample.
\end_layout

\begin_layout Standard
If all default parameters are used, this function is equivalent to 
\family typewriter
population::clone()
\family default
.
 If a list of loci or information fields are given to parameters 
\family typewriter
loci
\family default
 and 
\family typewriter
info
\family default
, other specified loci and information fields will be copied to the extracted
 population.
 If a positive 
\family typewriter
ancGen
\family default
 is given, only generations 
\family typewriter
0
\family default
 -
\family typewriter
 ancGen
\family default
 will be extracted.
 The most interesting parameter is 
\family typewriter
ind
\family default
.
 Instead of given a list of individuals that will be extract, an information
 field is expected.
 This information field is expected to hold the new subpopulation ID to
 which each individual will belong in the extracted population.
 Individuals with negative values (invalid subpopulation ID) at this information
 field will not be extracted.
 If another population (or pedigree) with the same number of individuals
 is given, the information field from that population is used.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "extract"

\end_inset

 demonstrates the use of this powerful function.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/extract.log"
lstparams "caption={Extract individuals, loci and information fields from an existing population},keywordstyle={\\ttfamily},label={extract}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Population-Variables"

\end_inset

Population Variables
\end_layout

\begin_layout Standard
Each simuPOP population has a Python dictionary that can be used to store
 arbitrary Python variables.
 These variables are usually used by various operators to share information
 between them.
 For example, the 
\family typewriter
stat
\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!stat
\end_layout

\end_inset


\family default
 operator calculates population statistics and stores the results in this
 Python dictionary.
 Other operators such as the 
\family typewriter
pyEval
\family default
 and 
\family typewriter
terminateIf 
\family default
read from this dictionary and act upon its information.
\end_layout

\begin_layout Standard
simuPOP provides two functions, namely 
\family typewriter
population::vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!vars
\end_layout

\end_inset

()
\family default
 and 
\family typewriter
population::
\begin_inset Index
status collapsed

\begin_layout Plain Layout
population!population
\end_layout

\end_inset

dvars()
\family default
 to access a population dictionary.
 These functions return the same dictionary object but 
\family typewriter
dvars()
\family default
 returns a wrapper class so that you can access this dictionary as attributes.
 For example, 
\family typewriter
pop.vars()['alleleFreq'][0]
\family default
 is equivalent to 
\family typewriter
pop.dvars().alleleFreq[0]
\family default
.
 Because dictionary 
\family typewriter
subPop[spID]
\family default
 is frequently used by operators to store variables related to a particular
 (virtual) subpopulation, function 
\family typewriter
pop.vars(subPop)
\family default
 is provided as a shortcut to 
\family typewriter
pop.vars()['subPop'][spID]
\family default
.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "popVars"

\end_inset

 demonstrates how to set and access Population variables.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/popVars.log"
lstparams "caption={Population variables},label={popVars}"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that this dictionary forms a 
\series bold
local namespace
\series default
 in which Python expressions can be evaluated.
 This is the basis of how expression-based operators work.
 For example, the 
\family typewriter
pyEval 
\family default
operator in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "simple-example"

\end_inset

 evaluates expression 
\family typewriter
``'%.2f
\backslash
t' % LD[0][1]''
\family default
 in each population's local namespace when it is applied to that population.
 This yields different results for different population because their LD
 values are different.
 In addition to Python expressions, Python statements can also be executed
 in the local namespace of a population, using the 
\family typewriter
stmts
\family default
 parameter of the 
\family typewriter
pyEval
\family default
 or 
\family typewriter
pyExec
\family default
 operator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 demonstrates the use of a simuPOP terminator, which terminates the evolution
 of a population when its expression is evaluated as 
\family typewriter
True
\family default
.
 Note that The 
\family typewriter
evolve() 
\family default
function of this example does not specify how many generations to evolve
 so it will stop only after all replicates stop.
 The return value of this function indicates how many generations each replicate
 has evolved.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/expression.log"
lstparams "caption={Expression evaluation in the local namespace of a population},label={expression}"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Save-and-Load"

\end_inset

Save and load a population
\end_layout

\begin_layout Standard
simuPOP populations can be saved to and loaded from disk files using 
\family typewriter
population::save
\begin_inset Index
status open

\begin_layout Plain Layout
population!save
\end_layout

\end_inset

(file)
\family default
 member function and global function 
\family typewriter
LoadPopulation
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
function!LoadPopulation
\end_layout

\end_inset

.
 (Yes, it is 
\family typewriter
Load..

\family default
 not 
\family typewriter
load..

\family default
 because 
\family typewriter
LoadPopulation
\family default
 is a global function.).
 Although files in any extension can be used, extension 
\family typewriter
.pop
\family default
 is recommended.
\end_layout

\begin_layout Standard
The native simuPOP format is not human readable and is not recognized by
 other applications.
 Other formats such as the one used by the popular 
\family typewriter
FSTAT 
\family default
software is supported.
 They are implemented in Python in a Python utility module 
\family typewriter
simuUtil.py
\family default
.
 simuPOP cannot use one of such formats because none of them can handle
 huge populations that simuPOP can handle, and unique features such as populatio
n variables.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 demonstrates how to save and load a population in the native simuPOP format.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/savePop.log"
lstparams "caption={Save and load a population},label={savePop}"

\end_inset


\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are objects that act on populations.
 They can be used in the following ways:
\end_layout

\begin_layout Itemize
Operators are usually passed to the 
\family typewriter
ops
\family default
, 
\family typewriter
preOps 
\family default
and 
\family typewriter
postOps
\family default
 parameters the 
\family typewriter
evolve
\family default
 function of a simulator.
 The simulator will apply these operators before (
\family typewriter
preOps
\family default
), after (
\family typewriter
postPos
\family default
) or during (
\family typewriter
ops
\family default
) an evolutionary process.
 Depending on parameters of an operator, it can be applied before, during,
 and/or after mating in a life cycle of a generation (parameter 
\family typewriter
stage
\family default
, see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:life-cycle"

\end_inset

), to a subset of generations (parameters 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
, 
\family typewriter
at
\family default
), a subset of populations in a simulator (parameter 
\family typewriter
rep
\family default
), a subset of (virtual) subpopulations in each replicate (parameter 
\family typewriter
subPop
\family default
).
\end_layout

\begin_layout Itemize
During-mating operators are used by mating schemes to transmit parental
 genotype (and sometimes information fields) to offspring.
 Applicability parameters such as 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
rep
\family default
 are ignored.
\end_layout

\begin_layout Itemize
Most of the operators can be applied to a population directly, using their
 function forms.
 Applicability parameters are ignored.
\end_layout

\begin_layout Standard
The following sections will introduce common features of all operators.
 The next chapter will explain some of the operators in detail.
\end_layout

\begin_layout Subsection
Applicable stages and generations
\end_layout

\begin_layout Standard
A simuPOP life cycle (a 
\emph on
generation
\emph default
) can be divided into 
\emph on
pre-mating
\emph default
, 
\emph on
during-mating
\emph default
 and 
\emph on
post-mating
\emph default
.
 In the pre-mating stage, the present generation is the parental generation.
 In the during-mating stage, an offspring generation is populated from the
 parental generation.
 In the post-mating stage, the offspring generation has become the present
 generation.
 An operator can be applied at one or more stages at a life cycle.
 However, each operator has its own default value for the 
\family typewriter
stage
\family default
 parameter and changes to this parameter are not always allowed.
 For example, a 
\family typewriter
recombinator
\family default
 can only be applied 
\family typewriter
DuringMating
\family default
 and it will ignore your attemp to apply it at another stage.
\end_layout

\begin_layout Standard
Operators that are passed to the 
\family typewriter
ops
\family default
 parameter of the 
\family typewriter
simulator::evolve
\family default
 function are, by default, applied to all generations during an evolutionary
 process.
 This can be changed using the 
\family typewriter
begin
\family default
, 
\family typewriter
end
\family default
, 
\family typewriter
step
\family default
 and 
\family typewriter
at
\family default
 parameters.
 As their names indicate, these parameters control the starting generation
 (
\family typewriter
begin
\family default
), ending generation (
\family typewriter
end
\family default
), generations between two applicable generations (
\family typewriter
step
\family default
), and an explicit list of applicable generations (
\family typewriter
at
\family default
).
 Other parameters will be ignored if 
\family typewriter
at
\family default
 is specified.
 It is worth noting that,, if the simulator has an ending generation, negative
 generations numbers are allowed.
 They are counted backward from the ending generation.
 For example, if a simulator starts at generation 
\family typewriter
0
\family default
, and the 
\family typewriter
evolve
\family default
 function has parameter 
\family typewriter
gen=10
\family default
, the simulator will stop at the 
\emph on
beginning
\emph default
 of generation 
\family typewriter
10
\family default
.
 Generation 
\family typewriter
-1
\family default
 refers to generation 
\family typewriter
9
\family default
, and generation 
\family typewriter
-2
\family default
 refers to generation 
\family typewriter
8
\family default
, and so on.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 demonstrates how to set applicable stages and generations of an operator.
 In this example, a population is initialized before evolution using a 
\family typewriter
initByFreq
\family default
 operator.
 allele frequency at locus 
\family typewriter
0
\family default
 is calculated at generation 
\family typewriter
80
\family default
, 
\family typewriter
90
\family default
, but not 
\family typewriter
100
\family default
 because the evolution stops at the beginning of generation 
\family typewriter
100
\family default
.
 A 
\family typewriter
pyEval
\family default
 operator outputs generation number and allele frequency at the end of generatio
n 
\family typewriter
80
\family default
 and 
\family typewriter
90
\family default
.
 Another 
\family typewriter
pyEval
\family default
 operator outputs similar information at generation 
\family typewriter
90
\family default
 and 
\family typewriter
99
\family default
, before and after mating.
 Note, however, because allele frequencies are only calculated twice, the
 pre-mating allele frequency at generation 
\family typewriter
90
\family default
 is actually calculated at generation 
\family typewriter
80
\family default
, and the allele frequencies display for generation 
\family typewriter
99
\family default
 are calculated at generation 
\family typewriter
90
\family default
.
 At the end of the evolution, the population is saved to a file using a
 
\family typewriter
savePopulation
\family default
 operator.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/stageAndGen.log"
lstparams "caption={Applicable stages and generations of an operator.},label={stageAndGen}"

\end_inset


\end_layout

\begin_layout Standard
Because it is not always clear which stage(s) an operator can be applied
 and in which order they will be applied, a parameter 
\family typewriter
dryrun
\family default
 is provided to the 
\family typewriter
simulator::evolve()
\family default
 function.
 If set to 
\family typewriter
True
\family default
, the 
\family typewriter
evolve
\family default
 function will list all operators in the order at which they will be applied.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/dryrun.log"
lstparams "caption={List the order at which operators are applied},label={dryrun}"

\end_inset


\end_layout

\begin_layout Subsection
Applicable populations
\end_layout

\begin_layout Standard
A simulator can evolve multiple replicates of a population simutaneously.
 Different operators can be applied to different replicates of this population.
 This allows side by side comparison between simulations.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
rep
\family default
 is used to control which replicate(s) an operator can be applied to.
 This parameter can be a list of replicate numbers or a single replicate
 number.
 Negative index is allowed where 
\family typewriter
-1
\family default
 refers to the last replicate.
 This technique has been widely used to produce table-like output where
 a 
\family typewriter
pyOutput
\family default
 outputs a newline when it is applied to the last replicate of a simulator.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 demonstrates how to use this 
\family typewriter
rep
\family default
 parameter.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/replicate.log"
lstparams "caption={Apply operators to a subset of populations},label={replicate}"

\end_inset


\end_layout

\begin_layout Standard
An operator can also be applied to only one or more (virtual) subpopulations.
 For example, an 
\family typewriter
initializer
\family default
 can be applied to male individuals in the first subpopulation, and everyone
 in the second subpopulation using parameter 
\family typewriter
subPop=[(0,0)
\family default
, 1], if a virtual subpopulation is defined.
 However, not all operators support this parameter, and even if they do,
 their intrepretation of parameter input may vary.
 Please refer to 
\emph on
the simuPOP reference manual
\emph default
 for details.
\end_layout

\begin_layout Subsection
Operator output
\end_layout

\begin_layout Standard
All operators we have seen, except for the 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

, write their output to the standard output, namely your terminal window.
 However, it would be much easier for bookkeeping and further analysis if
 these output can be redirected to disk files.
 The 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
 parameters are designed for this purpose.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
output
\family default
 can take the following values:
\end_layout

\begin_layout Itemize

\family typewriter
''
\family default
 (an empty string): No output.
\end_layout

\begin_layout Itemize

\family typewriter
'>'
\family default
: Write to standard output.
\end_layout

\begin_layout Itemize

\family typewriter
'filename'
\family default
 or 
\family typewriter
'>filename'
\family default
: Write the output to a file named filename.
 If multiple operators write to the same file, or if the same operator writes
 to the file file several times, only the last write operation will succeed.
\end_layout

\begin_layout Itemize

\family typewriter
'>>filename'
\family default
: Append the output to a file named filename.
 The file will be opened at the beginning of 
\family typewriter
evolve
\family default
 function and closed at the end.
 An existing file will be cleared.
\end_layout

\begin_layout Itemize

\family typewriter
'>>>filename'
\family default
: This is similar to the 
\family typewriter
'>>'
\family default
 form but the file will not be cleared at the beginning of the 
\family typewriter
evolve
\family default
 function.
\end_layout

\begin_layout Standard
Because a table output such as the one in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "output"

\end_inset

 is written by several operators, it is clear that all of them need to use
 the 
\family typewriter
'>>'
\family default
 output format.
\end_layout

\begin_layout Standard
A question naturally arises: what if I would like to write to different
 output for different replicate, or at different generation? For example,
 the 
\family typewriter
savePopulation
\family default
 operator in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "stageAndGen"

\end_inset

 write to file 
\family typewriter
sample.pop
\family default
.
 This works well if there is only one replicate but not so when the operator
 is applied to multiple populations.
 Only the last population will be saved successfully! In this case, parameter
 
\family typewriter
outputExpr
\family default
 should be used.
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
outputExpr
\family default
, similar to what is used in operator 
\family typewriter
pyEval
\family default
, accepts a Python expression.
 Whenever a filename is needed, this expression is evaluated against the
 local namespace of the population it is applied to.
 Because the 
\family typewriter
evolve
\family default
 function automatically sets variables 
\family typewriter
gen
\family default
 and 
\family typewriter
rep
\family default
 in a population's local namespace, such information can be used to produce
 an output string.
 Of course, any variable in this namespace can be used so you are not limited
 to these two variable.
\end_layout

\begin_layout Standard
Example demonstrates the use of this two parameters.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/output.log"
lstparams "caption={Use the output and outputExpr parameters},label={output}"

\end_inset


\end_layout

\begin_layout Subsection
During-mating operators
\end_layout

\begin_layout Subsection
Hybrid operators
\end_layout

\begin_layout Itemize

\emph on
built-in:
\emph default
 written in C++, fastest.
 They do not interact with Python shell except that some of them set variables
 that are accessible from Python.
\end_layout

\begin_layout Itemize

\emph on
hybrid
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
hybrid
\end_layout

\end_inset

: written in C++ but calls python function when execution.
 Less efficient.
 For example, a hybrid mutator 
\family typewriter
pyMutator
\family default
 will determine if an allele will be mutated and call a user--defined Python
 function to mutate it.
\end_layout

\begin_layout Itemize

\emph on
pure python
\emph default
: written in python.
 Same speed as python.
 For example, a 
\family typewriter
varPlotter
\begin_inset Index
status collapsed

\begin_layout Plain Layout
varPlotter
\end_layout

\end_inset


\family default
 can plot python variables that are set by other operators.
\end_layout

\begin_layout Subsection
Python operators
\end_layout

\begin_layout Subsection
Derived Python operators
\end_layout

\begin_layout Subsection
Function form of an operator
\end_layout

\begin_layout Standard
Operators are usually applied to populations through a simulator.
 They are created and passed as parameters to the 
\family typewriter
evolve 
\family default
function of a simulator.
 During evolution, the 
\family typewriter
evolve()
\family default
 function determines if an operator can be applied to a population and apply
 it when appropriate.
 More details about operators will be described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Operators"

\end_inset

.
\end_layout

\begin_layout Standard
You can ignore the specialties of an operator and call its 
\family typewriter
apply()
\family default
 function directly.
 For example, you can initialize a population outside a simulator by 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

initByFreq( [.3, .2, .5] ).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or dump the content of a population by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dumper().apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This usage is used so often that it deserves some simplification.
 Equivalent functions are defined for most of the operators.
 For example, function 
\family typewriter
InitByFreq
\family default
 is defined for operator 
\family typewriter
initByFreq
\family default
 as follows
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/InitByFreq.log"
lstparams "caption={Function \\texttt{InitByFreq}},label={InitByFreq}"

\end_inset


\end_layout

\begin_layout Standard
The function form of an operator is listed after its class name in this
 reference manual.
\end_layout

\begin_layout Section
Mating Scheme
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mating schemes specify how to generate offspring from the current population.
 It must be provided when a simulator is created.
 Mating can perform the following tasks:
\end_layout

\begin_layout Itemize
Choose parent(s) to generate offspring to populate the next generation.
 The number of offspring per mating event can be a fixed number (default
 to 1), or a random number following one of geometric, Poisson or binomial
 distribution.
 Customized (hybrid) parent choosers can be used.
 Offspring sex can be assigned randomly, with specified or default (0.5)
 probability, or arranged to have certain number of males/females per mating
 event.
\end_layout

\begin_layout Itemize
Change population/subpopulation sizes.
 This is where demographic models are handled in simuPOP.
 There are a few methods to control population sizes.
 The most flexible one is through a user-provided function that returns
 population (subpopulation) sizes at each generation.
\end_layout

\begin_layout Itemize
During-mating operators are applied to all offspring.
 The most commonly used during mating operator is a recombinator that can
 recombine parental chromosomes and form offspring genotype.
\end_layout

\begin_layout Itemize
Apply selection if applicable.
 If individual fitness are given (usually returned by a selector operator),
 a mating scheme will choose an individual to mate, according to its relative
 fitness.
\end_layout

\begin_layout Standard
A few mating schemes are available, among which 
\family typewriter
randomMating()
\family default
 is the most important.
 Non-random mating can be achieved using 
\family typewriter
pyMating
\family default
 and 
\family typewriter
heteroMating
\family default
, which is explained in detailed in 
\emph on
simuPOP reference manual
\emph default
.
\end_layout

\begin_layout Subsection
Parent choosers and offspring generators
\end_layout

\begin_layout Standard
To implement more complex mating schemes, some concepts need to be understood.
 The first one is 
\emph on
parent chooser
\emph default
.
 Parent chooser determines how parent or parents are chosen from a given
 subpopulation.
 There are several predefined parent choosers such as 
\family typewriter
linearParentChooser
\family default
, 
\family typewriter
randomParentChooser, randomParentsChooser
\family default
, and the most powerful one is called 
\family typewriter
pyParentsChooser.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyParensChooser
\family default
 accepts a Python generator function, instead of a normal Python function.
 When this generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when the 
\family typewriter
next()
\family default
 member function of this object is called, this function resumes where it
 was stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 An example of generator is given in simuPOP user's guide.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator_random.log"
lstparams "caption={A generator function that mimicks random mating},label={generator_random}"

\end_inset


\end_layout

\begin_layout Standard
A user defined parents chooser can be very complicated, involving user defined
 information such as geometric locations.
 An example is given in 
\family typewriter
scripts/demoNonRandomMating.py
\family default
.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator_random"

\end_inset

, the parents chooser 
\family typewriter
randomChooser 
\family default
collects indexes of males and females that are over the age of 30 and return
 a pair of random male and female repeatedly.
 That is to say, individuals with age < 30 is not involved in mating.
 Of course, to completely implement age-dependent mating, other factors
 need to be considered.
 For example, a 
\family typewriter
pyTagger
\family default
 is likely to be used to assign age to offspring.
\end_layout

\begin_layout Standard
A parents chooser can yield a pair of parents, or a single parent.
 Obviously, a single diploid parent can not produce offspring using the
 usual Medelian fashion, so here comes another concept: 
\emph on
offspring generator
\emph default
, which determines how to produce offspring from given parent or parents.
 Currently, there are three standard offspring generators.
\end_layout

\begin_layout Standard
These offspring generator defines only the default way to fill offspring
 genotype.
 When a during-mating operator is involved, it may override what an offspring
 generator does.
 For example, a 
\family typewriter
recombinator
\family default
 recombines parental chromosomes to fill offspring genotype.
 In the diploid case, it will behave the same for 
\family typewriter
cloneOffspringGenerator
\family default
 and 
\family typewriter
selfingOffspringGenerator.
\end_layout

\begin_layout Subsection
Determine the number of offspring during mating
\end_layout

\begin_layout Standard
Parameters 
\family typewriter
numOffspring, maxNumOffspring, numOffspringFunc 
\family default
and 
\family typewriter
mode
\family default
 are provided for each mating scheme (each offspring generator, to be exact)
 to determine the number of offspring produced at each mating event.
\end_layout

\begin_layout Standard
The default value of 
\family typewriter
numOffspring
\family default
 parameter makes a mating scheme produces one offspring per mating event.
 This is required by random mating schemes and should be used whenever possible.
 However, various situations require a larger family size or even changing
 family sizes.
 simuPOP provides a comprehensive way to deal with this problem.
\end_layout

\begin_layout Standard
As described in the class reference, the method to determine the number
 of offspring is to set the 
\family typewriter
mode
\family default
 parameter:
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOffspring:
\family default
 Produce 
\family typewriter
numOffspring
\family default
 offspring all the time.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_PyNumOffspring:
\family default
 When 
\family typewriter
numOffspringFunc
\family default
 is defined, this mode is automatically used.
 A user provided function is called whenever a mating event happens.
 The return value determins the number of offpspring to use.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_GeometricDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a geometric distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=p\left(1-p\right)^{k-1}\;\textrm{ for }k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_PoissonDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a Poission distribution.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{p^{k-1}}{\left(k-1\right)!}e^{-p}\;\textrm{ for}k\geq1\]

\end_inset

Since the mean of this shifted Poisson distribution is 
\begin_inset Formula $p+1$
\end_inset

, you need to specify, for example, 2, if you want a mean family size 3.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_BinomialDistribution: numOffspring
\family default
 is considered as 
\begin_inset Formula $p$
\end_inset

 for a Binomial distribution.
 Let 
\begin_inset Formula $N$
\end_inset

=
\family typewriter
maxNumOffspring
\family default
, the number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{\left(n-1\right)!}{\left(k-1\right)!\left(n-k\right)!}p^{k-1}\left(1-p\right)^{n-k}\;\textrm{ for }N\geq k\geq1\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MATE_UniformDistribution:
\family default
 
\family typewriter
numOffspring
\family default
 is be considered as 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 for a Uniform distribution, respectively.
 The number of offspring for each mating is determined by
\begin_inset Formula \[
P\left(k\right)=\frac{1}{b-a}\;\textrm{ for }b\geq k\geq a\]

\end_inset


\end_layout

\begin_layout Standard
Note that all these distributions are adjusted to produce at least one offspring.
 
\end_layout

\begin_layout Subsection
Determine offspring sex
\end_layout

\begin_layout Standard
When the last chromosome is a sex chromosome (
\family typewriter
sexChrom=True
\family default
), offspring sex is determined by his/her genotype.
 If an offspring is cloned from his/her parent using a 
\family typewriter
cloneOffspringGenerator()
\family default
, offspring sex is the same as his/her parent.
 Otherwise, offspring is by default assigned to Male and Female with equal
 probability 0.5.
\end_layout

\begin_layout Standard
More advanced sex assignment mode is determined by parameters 
\family typewriter
sexMode 
\family default
and 
\family typewriter
sexParam
\family default
 of a mating scheme or an offspring generator (see later section).
 
\family typewriter
sexMode
\family default
 can be
\end_layout

\begin_layout Itemize

\family typewriter
MATE_RandomSex
\family default
 This is the default mode where offspring can be Male or Female with equal
 probability.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_ProbOfMale
\family default
 In this mode, parameter 
\family typewriter
sexParam
\family default
 is considered as the probability of a Male offspring.
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOfMale
\family default
 In this mode, parameter 
\family typewriter
sexParam
\family default
 is the number of male in the family.
 If the number of offspring at a mating event is less than this number,
 all offspring will be male.
 
\end_layout

\begin_layout Itemize

\family typewriter
MATE_NumOfFemale
\family default
 Similar to 
\family typewriter
MATE_NumOfMale
\family default
 but parameter 
\family typewriter
sexParam
\family default
 is considered as the number of female in the family.
\end_layout

\begin_layout Standard

\family typewriter
MATE_NumOfMale
\family default
 and 
\family typewriter
MATE_NumOfFemale
\family default
 are useful in theoretical studies where the sex ratio of a population needs
 to be controlled strictly, or in special mating schemes, usually for animal
 populations, where only a certain number of male or female individuals
 are allowed in a family.
\end_layout

\begin_layout Subsection
Determine subpopulation sizes of the next generation
\end_layout

\begin_layout Standard
The default behavior of simuPOP is to use the same population/subpopulation
 sizes as those of the parent generation.
 You can change this behavior by setting one of 
\family typewriter
newSubPopSize
\family default
, 
\family typewriter
newSubPopSizeExpr
\family default
, and 
\family typewriter
newSubPopSizeFunc
\family default
 parameters:
\end_layout

\begin_layout Itemize
If you would like to have fixed subpopulation sizes, use 
\family typewriter
newSubPopSize=some_fixed_values
\family default
.
 This is useful when subpopulation sizes are changed by migration and you
 do want to keep constant subpopulation sizes.
\end_layout

\begin_layout Itemize
If subpopulation sizes can be easily calculated through an expression, you
 can use 
\family typewriter
newSubPopSizeExpr
\family default
 to determine the new subpopulation sizes.
 For example, 
\family typewriter
newSubPopSizeExpr='[gen+10]'
\family default
 uses the generation number + 10 as the new population size.
 More complicated expressions can be used, maybe along with 
\family typewriter
pyExec
\family default
 operators, but in these cases, a specialized function and 
\family typewriter
newSubPopSizeFunc
\family default
 are recommended.
\end_layout

\begin_layout Itemize
A more organized (and thus recommended) way to set new population/subpopulation
 sizes is through parameter 
\family typewriter
newSubPopSizeFunc
\family default
.
 To use this parameter, you need to define a Python function that takes
 two parameters: the generation number and the current subpopulation sizes,
 and return an array of new subpopulation sizes (return 
\family typewriter
[newsize]
\family default
 instead of 
\family typewriter
newsize
\family default
 when you do not have any subpopulation structure).
 The example of 
\family typewriter
class Mating 
\family default
demonstrates the use of this parameter.
\end_layout

\begin_layout Subsection
Demographic change functions
\end_layout

\begin_layout Standard

\family typewriter
newSubPopSizeFunc
\family default
 can take a function with parameters 
\family typewriter
gen
\family default
 and 
\family typewriter
oldSize.

\family default
 A few functions are defined in 
\family typewriter
simuUtil.py
\family default
 that will return such a function with given parameters.
 All these functions support a burnin stage and then split to equal sized
 subpopulations.
 For all these functions, you can test them by
\end_layout

\begin_layout Subsection
Homogeneous and hybrid mating schemes
\end_layout

\begin_layout Standard
Parent choosers and offspring generators can be combined to form homogeneous
 mating schemes, which work identically on all (virtual) subpopulations
 it is applied.
 The only limit is that they have to be compatible in that a parent chooser
 that choose one parent can not be used with an offspring generator that
 needs two parents.
 A homogenou mating scheme is illustrated in Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:homogeneous-mating-scheme"

\end_inset

A homogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename HomoMatingScheme.eps
	lyxscale 20
	width 6in

\end_inset


\end_layout

\begin_layout Plain Layout
A homogeneous mating scheme is responsible to choose parent(s) from a subpopulat
ion or a virtual subpopulation, and population part or all of the corresponding
 offspring subpopulation.
 A parent chooser is used to choose one or two parents from the parental
 generation, and pass it to an offspring generator, which produces one or
 more offspring.
 During mating operators such as taggers and recombinator can be applied
 when offspring is generated.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic usage of a 
\family typewriter
pyMating 
\family default
operator is as follows
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyMating(randomParentChooser(),
\end_layout

\begin_layout Plain Layout

    selfingOffspringGenerator(numOffspring=2))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyMating(linearParentChooser(),
\end_layout

\begin_layout Plain Layout

    cloneOffspringGenerator())
\end_layout

\end_inset

The later simply copy everyone from the parental to the offspring genertion.
\end_layout

\begin_layout Subsection
Python parents chooser
\end_layout

\begin_layout Subsection
Using C++ to implement a parents chooser
\end_layout

\begin_layout Subsection
Heterogeneous mating schemes
\end_layout

\begin_layout Standard
Non-random mating can also be introduced by mating individuals from different
 groups differently.
 Different subpopulations, or different virtual subpopulations, can have
 varying fecundity, represented by different numbers of offspring generated
 per mating event.
 For example, it is possible that only adults (may be defined by age > 30
 and age < 50) in a subpopulation can produce offspring, where other individual
 will either be copied to the offspring generation or die.
 It is also quite common in plant genetics that a certain portion of trees
 go through selfing, while others go through random mating.
\end_layout

\begin_layout Standard
A 
\family typewriter
heteroMating
\family default
 mating scheme accepts a list of mating schemes that works separately on
 different subpopulation, or virtual subpopulations.
 In this way, many homogenous mating schemes can be applied to different
 (virtual) subpopulations.
 This is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:heterogenous-mating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:heterogenous-mating"

\end_inset

Illustration of a heteogeneous mating scheme
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename MatingScheme.eps
	lyxscale 30
	width 6in

\end_inset


\end_layout

\begin_layout Plain Layout
A heterogeneous mating scheme that applies homogenous mating schemes MS0,
 MS0.0, MS0.1, MS1, MS2.0 and MS2.1 to subpopulation 0, the first and second
 virtual subpopulation in subpopulation 0, subpopulation 1, the first and
 second virtual subpopulation in subpopulation 2, respectively.
 Note that VSP 0 and 1 in subpopulation 0 overlap, and do not add up to
 subpopulation 0.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

heteroMating([randomMating(numOffspring=2, subPop=0),
\end_layout

\begin_layout Plain Layout

    randomMating(numOffspring=4, subPop=1)])
\end_layout

\end_inset

define a heterogeneous mating scheme that mating events in subpopulation
 0 produces two offspring, while producing four in subpopulation 1.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pop.setVirtualSplitter(proportionSplitter([0.2, 0.8]), 0)
\end_layout

\begin_layout Plain Layout

heteroMating([selfMating(numOffspring=2, subPop=0, virtualSubPop=0),
\end_layout

\begin_layout Plain Layout

    randomMating(subPop=0, virtualSubPop=1)],
\end_layout

\begin_layout Plain Layout

    shuffleOffspring=True
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

allows different mating schems in one subpopulation.
 In this example, the first subpopulation is splitted into two virtual subpopula
tions by proportion.
 Then, a selfing mating scheme is applied to the first virtual subpopulation,
 and a random mating scheme is applied to the second.
 In case that there are more than one mating schemes working on the same
 subpopulation, offspring are shuffled randomly by default, unless this
 is turned off by 
\family typewriter
shuffleOffspring=False
\family default
.
 Randomization of the order of offspring is usually desired because otherwise,
 taking this example, the first 20% of individuals will always go through
 selfing, and the rest will always go through random mating.
 When offspring are shuffled, each individual will have probability 0.2 to
 be selfing, and probability 0.8 to mate randomly.
\end_layout

\begin_layout Standard
simuPOP determines if a mating scheme will be applied to a particular subpopulat
ion using the following rules
\end_layout

\begin_layout Itemize
If neither 
\family typewriter
subPop
\family default
, nor 
\family typewriter
virtualSubPop
\family default
 is specified, the mating scheme is applied to all subpoulations (as a whole,
 not any virtual subpopulation).
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
, but not 
\family typewriter
virtualSubPop
\family default
 is specified, the mating scheme is applied to the specified subpopulation
 (as a whole).
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
 and 
\family typewriter
virtualSubPop
\family default
 are both specified, the mating scheme is applied to the specified virtual
 subpopulation.
\end_layout

\begin_layout Itemize
If 
\family typewriter
subPop
\family default
 is not specified, but
\family typewriter
 virtualSubPop
\family default
 is, the mating scheme is applied to spcified virtual subpopulation of all
 subpopulations.
 Note that simuPOP will report an error if a subpopulation does not define
 such a virtual subpopulation.
\end_layout

\begin_layout Standard
If one mating scheme is specified for each parental subpopulation, offspring
 subpopulation sizes are determined as usual, through parameters 
\family typewriter
newSubPopSize, newSubPopSizeFunc
\family default
, etc.
 However, if multiple mating schemes will be applied to the same subpopulation,
 they have to share the same offspring subpopulation.
 This problem is addressed by a weight system.
 That is to say, each mating scheme can be given a weight using parameter
 
\family typewriter
weight
\family default
.
 A weight can be positive, zero (default) or negative.
 The number of offspring each mating scheme will produce is determined by
 these weights.
 
\end_layout

\begin_layout Standard
This weighting scheme is best explained by an example.
 Assuming that there are three mating schemes working on the same parental
 subpopulation
\end_layout

\begin_layout Itemize
Mating scheme A works on the whole subpopulation of size 1000
\end_layout

\begin_layout Itemize
Mating scheme B works on a virtual subpopulation of size 500
\end_layout

\begin_layout Itemize
Mating scheme C works on another virtual subpopulation of size 800
\end_layout

\begin_layout Standard
Assuming the corresponding offspring subpopulation has 
\begin_inset Formula $N$
\end_inset

 individuals, 
\end_layout

\begin_layout Itemize
If all weights are 0, the offspring subpopulation is divided in proportion
 to parental (virtual) subpopulation sizes.
 In this example, the mating schemes will produce 
\begin_inset Formula $\frac{10}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{5}{23}N$
\end_inset

, 
\begin_inset Formula $\frac{8}{23}N$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Itemize
If all weights are negative, they are multiplied to their parental (virtual)
 subpopulation sizes to get a fixed size.
 For example, weight (-1, -2, -0.5) will lead to sizes (1000, 1000, 400)
 in the offspring subpopulation.
 If 
\begin_inset Formula $N\ne2400$
\end_inset

 in this case, an error will be raised.
\end_layout

\begin_layout Itemize
If all weights are positive, the number of offspring produced from each
 mating scheme is proportional to these weights.
 For example, weights (1, 2, 3) will lead to 
\begin_inset Formula $\frac{1}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{2}{6}N$
\end_inset

, 
\begin_inset Formula $\frac{1}{3}N$
\end_inset

 individuals respectively.
 In this case, 0 weights will produce no offspring.
\end_layout

\begin_layout Itemize
If there are mixed positive and negative weights, the negative weights are
 first processed, and the rest of the individuals are divided using positive
 weights.
 For example, three mating schemes with weights (-1, 2, 3) will produce
 1000, 
\begin_inset Formula $\frac{2}{5}\left(N-1000\right)$
\end_inset

, 
\begin_inset Formula $\frac{3}{5}\left(N-1000\right)$
\end_inset

 individuals respectively.
\end_layout

\begin_layout Section
Simulator
\end_layout

\begin_layout Standard
Simulators combine three important components of simuPOP: population, mating
 scheme and operators together.
 A simulator is usually created with an instance of population, a replicate
 number and a mating scheme.
 It makes '
\family typewriter
rep
\family default
' replicates of this population and control the evolution process of these
 populations.
\end_layout

\begin_layout Standard
The most important function of a simulator is 
\family typewriter
evolve()
\family default
.
 It accepts arrays of operators as its parameters, among which, '
\family typewriter
preOps
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulato!preOps
\end_layout

\end_inset

' and '
\family typewriter
postOps
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulator!postOps
\end_layout

\end_inset

' will be applied to the populations at the beginning and end of evolution,
 respectively, whereas '
\family typewriter
ops
\family default
' will be applied at every generation.
 Of course, a simulator will probe and respect each operator's 
\family typewriter
rep, begin, end, step, at, stage
\family default
 properties and act accordingly.
 
\end_layout

\begin_layout Subsection
Generation number
\end_layout

\begin_layout Standard
Several aspects of the generation number may cause confusion:
\end_layout

\begin_layout Itemize
generation starts from zero
\end_layout

\begin_layout Itemize
a generation number presents a 'to-be-evolved' generation
\end_layout

\begin_layout Itemize
the ending generation specified in 
\family typewriter
evolve()
\family default
 will be executed
\end_layout

\begin_layout Standard
That is to say, a new simulator will have generation 0 (at the beginning
 of generation 0).
 If you do 
\family typewriter
evolve(..., end=0), evolve
\family default
 will evolve one generation and stop at the beginning of generation 1.
\end_layout

\begin_layout Standard
It may sound strange that 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

evolve(end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
evolve the population 3 generations.
 Generation 0, generation 1, and generation 2.
 When you use 
\family typewriter
start=0, step=5, end=10
\family default
 for your operator, it will be applied at generations 
\family typewriter
0,5,10
\family default
 etc.
 At the end of the simulation, current generation number is 3! (If you are
 familiar with C, this is like a 
\family typewriter
for
\family default
 loop index).
 This is why you should test if a simulation is finished correctly by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(simu.gen() == endGen+1)
\end_layout

\end_inset

instead of 
\family typewriter
simu.gen() == endGen.

\family default
 (endGen is the value for parameter 
\family typewriter
end
\family default
).
\end_layout

\begin_layout Subsection
Operator calling sequence
\end_layout

\begin_layout Standard
In a simulation, operators are applied at different stages, pre-, during-,
 and post-mating (controlled by 
\family typewriter
stage
\family default
 parameter), at specified generations (controlled by 
\family typewriter
begin, end, step, at
\family default
 parameters), and to specified replicates (controlled by 
\family typewriter
rep
\family default
 parameter).
 The order of applying operators usually does not matter but errors may
 occur if you are not careful.
 For example, 
\family typewriter
stat(...)
\family default
 calculates the statistics of the current population.
 It is a pre-mating operator so you should set 
\family typewriter
stage=PostMating
\family default
 and put it after all operators if you would like to measure a post-mating
 population.
 It also should be put before any operator (such as an terminator) that
 uses the shared variable set by 
\family typewriter
stat(...).
\end_layout

\begin_layout Standard
If you are not sure about the calling sequence of operators, you can set
 the 
\family typewriter
dryrun
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
simulator!dryun
\end_layout

\end_inset

 parameter of 
\family typewriter
evolve()
\family default
 function to 
\family typewriter
True
\family default
.
 
\family typewriter
evolve
\family default
 will then print out the order of operators to apply.
 Consider that operators can be 
\family typewriter
PreMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PreMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PreMating
\end_layout

\end_inset

, PostMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PostMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PostMating
\end_layout

\end_inset

, PrePostMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!PrePostMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!PrePostMating
\end_layout

\end_inset

, DuringMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
constant!DuringMating
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
operator!DuringMating
\end_layout

\end_inset


\family default
 and the default value (parameter 
\family typewriter
stage
\family default
) may not be what you expect.
 Having a look at the calling sequence before the real evolution is always
 a good idea.
\end_layout

\begin_layout Subsection
Terminate a simulator
\end_layout

\begin_layout Subsection
Save and Load
\end_layout

\begin_layout Standard
Using function 
\family typewriter
saveSimulator
\family default
, we can save a simulator to a file.
 Although files with any extension can be correctly saved/loaded, extension
 
\family typewriter
.sim
\family default
 is usually used.
 Note that a mating scheme can not be saved and has to be re-specified in
 
\family typewriter
LoadSimulator
\begin_inset Index
status collapsed

\begin_layout Plain Layout
loadSimulator
\end_layout

\end_inset

()
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/simulatorsaveload.log"
lstparams "caption={Save and load a simulator},label={simulatorsaveload}"

\end_inset


\end_layout

\begin_layout Section
Utilities
\end_layout

\begin_layout Chapter
Selected topics
\end_layout

\begin_layout Standard
simuPOP is large, consisting of more than 80 operators and various functions
 that covers all important aspects of genetic studies.
 These includes mutation (
\emph on
k
\emph default
-allele, stepwise, generalized stepwise), migration (arbitrary, can create
 new subpopulation), recombination (uniform or nonuniform), gene conversion
 (new in v 0.8.5), quantitative trait, selection, penetrance (single or multi-locu
s, hybrid), ascertainment (case-control, affected sibpairs, random), statistics
 calculation (allele, genotype, haplotype, heterozygote number and frequency;
 expected heterozygosity; bi-allelic and multi-allelic 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $D'$
\end_inset

 and 
\begin_inset Formula $r^{2}$
\end_inset

 linkage disequilibrium measures; 
\begin_inset Formula $F_{st}$
\end_inset

, 
\begin_inset Formula $F_{it}$
\end_inset

 and 
\begin_inset Formula $F_{is}$
\end_inset

); pedigree tracing, visualization (using R or other Python modules), load/save
 in text, XML, Fstat or Linkage format.
 In this chapter, I will discuss some practical usages of simuPOP.
\end_layout

\begin_layout Section
Selection
\end_layout

\begin_layout Standard
It is not very clear that our method agrees with the traditional 'average
 number of offspring' definition of fitness.
 (Note that this concept is very difficult to simulate because we do not
 know who will determine the number of offspring if two parents are involved.)
 We can, instead, look at the consequence of selection in a simple case
 (as derived in any population genetics textbook):
\end_layout

\begin_layout Quote
At generation 
\begin_inset Formula $t$
\end_inset

, genotype 
\begin_inset Formula $P_{11},P_{12},P_{22}$
\end_inset

 has fitness values 
\begin_inset Formula $w_{11},w_{12,}w_{22}$
\end_inset

 respectively.
 In the next generation the proportion of genotype 
\begin_inset Formula $P_{11}$
\end_inset

 etc., should be
\end_layout

\begin_layout Quote
\begin_inset Formula \[
\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset


\end_layout

\begin_layout Standard
Now, using the 'ability-to-mate' approach, for the sexless case, the proportion
 of genotype 
\begin_inset Formula $11$
\end_inset

 will be the number of 
\begin_inset Formula $11$
\end_inset

 individuals times its probability to be chosen: 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}\]

\end_inset

This is, however, exactly 
\begin_inset Formula \[
n_{11}\frac{w_{11}}{\sum_{n=1}^{N}w_{n}}=n_{11}\frac{w_{11}}{n_{11}w_{11}+n_{12}w_{12}+n_{22}w_{22}}=\frac{P_{11}w_{11}}{P_{11}w_{11}+P_{12}w_{12}+P_{22}w_{22}}\]

\end_inset

The same argument applies to the case of arbitrary number of genotypes and
 random mating.
 
\end_layout

\begin_layout Standard
The following operators, when applied, will set a variable 
\family typewriter
fitness
\family default
 and an indicator so that selector-aware mating scheme can select individuals
 according to these values.
 This has two consequences:
\end_layout

\begin_layout Itemize
Selector only set information field and mark subpopulations as selection
 ready.
 However, how these information are used to select parents can vary from
 mating scheme to mating scheme.
 As a matter of fact, some mating schemes do not support selection at all.
\end_layout

\begin_layout Itemize
selector has to be 
\family typewriter
PreMating
\family default
 operator.
 This is not a problem when you use the operator form of the selectors since
 their default stage is 
\family typewriter
PreMating
\family default
.
 However, if you use the function form of these selectors in a 
\family typewriter
pyOperator
\family default
, make sure to set the stage of 
\family typewriter
pyOperator
\family default
 to 
\family typewriter
PreMating
\family default
.
 
\end_layout

\begin_layout Standard
The example for 
\family typewriter
class mapSelector
\family default
 is a typical example of heterozygote superiority.
 When 
\begin_inset Formula $w_{11}<w_{12}>w_{22},$
\end_inset

 the genotype frequencies will go to an equilibrium state.
 Theoretically, if
\begin_inset Formula \begin{eqnarray*}
s_{1} & = & w_{12}-w_{11}\\
s_{2} & = & w_{12}-w_{22}\end{eqnarray*}

\end_inset

the stable allele frequency of allele 1 is
\begin_inset Formula \[
p=\frac{s_{2}}{s_{1}+s_{2}}\]

\end_inset

Which is 
\begin_inset Formula $.677$
\end_inset

 in the example (
\begin_inset Formula $s_{1}=.1$
\end_inset

, 
\begin_inset Formula $s_{2}=.2$
\end_inset

).
 
\end_layout

\begin_layout Section
Gene conversion
\end_layout

\begin_layout Standard
simuPOP uses the Holliday junction model to simulate gene conversion.
 This model treats recombination and conversion as a unified process.
 The key features of this model is
\end_layout

\begin_layout Itemize
Two (out of four) chromatids pair and a single strand cut is made in each
 chromatid
\end_layout

\begin_layout Itemize
Strand exchange takes place between the chromatids
\end_layout

\begin_layout Itemize
Ligation occurs yielding two completely intact DNA molecules
\end_layout

\begin_layout Itemize
Branch migration occurs, giving regions of heteroduplex DNA
\end_layout

\begin_layout Itemize
Resulution of the Holliday junction gives two DNA molecules with heteroduplex
 DNA.
 Depending upon how the holliday junction is resolved, we either observe
 no exchange of flanking markers, or an exchange of flanking markers.
 The former forms a conversion event, which can be considered as a double
 recombination.
\end_layout

\begin_layout Standard
Translated to simulation, recombination and conversion are performed in
 the following steps
\end_layout

\begin_layout Enumerate
Users specify the following paremters to a recombinator:
\end_layout

\begin_deeper
\begin_layout Enumerate
recombination points (recombinations are allowed after specified markers)
 (
\family typewriter
loci
\family default
),
\end_layout

\begin_layout Enumerate
recombination rates (can vary from marker to marker) (
\family typewriter
rates
\family default
),
\end_layout

\begin_layout Enumerate
probability of conversion if a recombination event happens (
\family typewriter
convProb
\family default
),
\end_layout

\begin_layout Enumerate
track length parameters (
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
, will discuss later).
\end_layout

\end_deeper
\begin_layout Enumerate
Starting with two parental chromosomes, randomly choose one of them to copy
 to an offspring chromosome until a recombination event happens.
\end_layout

\begin_layout Enumerate
This recombination event is a conversion event if
\end_layout

\begin_deeper
\begin_layout Enumerate
A random uniform number U(0,1) is less than the probability of conversion
\end_layout

\begin_layout Enumerate
The length of flanking regions does not exceed the end of chromosome 
\end_layout

\begin_layout Standard
If a conversion happens, record the end of flanking region as another recombinat
ion event.
\end_layout

\end_deeper
\begin_layout Enumerate
Copy from another copy of parental chromosome (recombination happens), until
 the recorded second recombination event is reached, or another recombination
 event happens.
 
\end_layout

\begin_layout Enumerate
Repeat these steps for all chromosomes.
\end_layout

\begin_layout Standard
The tract length of a flanking region is determined by parameters 
\family typewriter
convMode
\family default
 and 
\family typewriter
convParam
\family default
.
 
\family typewriter
convMode 
\family default
can be
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_NumMarkers
\family default
 Convert a fixed number (
\family typewriter
convParam
\family default
) of markers.
 This is the default mode with
\family typewriter
 convParam=1
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_TractLength
\family default
 Convert a fixed length (
\family typewriter
convParam
\family default
) of chromosome regions.
 This can be used when markers are not equally spaced on chromosomes.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_GeometricDistribution
\family default
 Convert a random number of markers, with a geometric distribution with
 parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
CONVERT_ExponentialDistribution
\family default
 Convert Convert a random length of chromosome region, using a exponential
 distribution with parameter 
\family typewriter
convParam
\family default
.
\end_layout

\begin_layout Standard
Note that
\end_layout

\begin_layout Itemize
If tract length is determined by length (
\family typewriter
CONVERT_TractLength
\family default
 or 
\family typewriter
CONVERT_ExponentialDistribution
\family default
), the starting point of the flanking region is uniformly distributed between
 marker 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

, if the recombination happens at marker 
\begin_inset Formula $i$
\end_inset

.
 That is to say, it is possible that no marker is converted with positive
 tract length.
\end_layout

\begin_layout Itemize
A conversion event will act like a recombination event if its flanking region
 exceeds the end of chromosome, or if another recombination event happens
 before the end of the flanking region.
\end_layout

\begin_layout Standard
Although any parameters can be used in a recombinator, it is worth noting
 that
\end_layout

\begin_layout Itemize
The probability of conversion event among all recombination events if usually
 expressed as ratio of conversion to recombination events in the literature.
 This varies greatly from study to study, ranging from 0.1 to 15 (Chen et
 al, Nature Review Genetics, 2007).
 This translate to 0.1/0.9~0.1 to 15/16~0.94 of this parameter.
 When 
\backslash
c convProb is 1, all recombination events will be conversion events.
 The default value if 
\family typewriter
convProb=0
\family default
, meaning no conversion.
\end_layout

\begin_layout Itemize
Conversion tract length is usually short, and is estimated to be between
 337 and 456 bp, with overall range between maybe 50 - 2500 bp.
 simuPOP does not impose a unit for marker distance so your choice of 
\family typewriter
convParam
\family default
 needs to be consistent with your unit.
 In the HapMap dataset, cM is usually assumed and marker distances are around
 10kb (0.001cM ~- 1kb).
 At this marker density, gene conversion can largely be ignored.
\end_layout

\begin_layout Section
Migration
\end_layout

\begin_layout Standard
Migrator is very flexible.
 It can accept arbitrary migration matrix, from any subset of subpopulations
 to any (even new) other subset of subpopulations.
 To facilitate the use of common theoretical migration models, several functions
 are defined in
\family typewriter
 simuUtil.py.
\end_layout

\begin_layout Itemize

\family typewriter
MigrIslandRates(r, n)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & \frac{r}{n-1} & ... & ... & \frac{r}{n-1}\\
\frac{r}{n-1} & 1-r & ... & ... & \frac{r}{n-1}\\
 &  & ...\\
\frac{r}{n-1} & ... & ... & 1-r & \frac{r}{n-1}\\
\frac{r}{n-1} & ... & ... & \frac{r}{n-1} & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates(r, n, circular=False)
\family default
 returns a 
\begin_inset Formula $n\times n$
\end_inset

 migration matrix
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
 &  &  & r & 1-r\end{array}\right)\]

\end_inset

and if 
\family typewriter
circular=True
\family default
, returns
\begin_inset Formula \[
\left(\begin{array}{ccccc}
1-r & r/2 &  &  & r/2\\
r/2 & 1-r & r/2\\
 &  & ...\\
 &  & r/2 & 1-r & r/2\\
r/2 &  &  & r/2 & 1-r\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Section
Hybrid
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Hybrid operator
\end_layout

\end_inset

 and pure-Python operator
\begin_inset Index
status collapsed

\begin_layout Plain Layout
python operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the large number of built-in operators, it is obviously not possible
 to implement every genetics models available.
 For example, although simuPOP provides several penetrance models, a user
 may want to try a customized one.
 In this case, one can use a simuPOP feature called 
\emph on
hybrid operator
\emph default
.
 Such operators accept a Python function and will call this function with
 appropriate parameter(s) when needed.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybrid"

\end_inset

 defines a three-locus heterogeneity penetrance model 
\begin_inset CommandInset citation
LatexCommand citep
key "Risch1990"

\end_inset

 that yields positive penetrance only when at least two disease susceptibility
 alleles are available.
 The underlying mechanism of this operator is that for each individual,
 simuPOP will collect genotype at specified loci (
\family typewriter
loci
\family default
) and send them to function 
\family typewriter
myPenetrance
\family default
 and evaluate.
 The return values are used as the penetrance value of the individual, which
 is then interpreted as the probability of being affected.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "hybrid.py"
lstparams "caption={An example of hybrid operators},label={hybrid}"

\end_inset


\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "hybrid"

\end_inset

 uses the function form of operator 
\family typewriter
pyPenetrance
\family default
 and 
\family typewriter
stat
\family default
 and you should use the operator form in a simulator.
 In these functions, operators are created with the same set of parameters
 as their operator form, applied to the population, and are destroyed afterward.
 For example,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PyPenetrance(pop, parameters)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is the same as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyPenetrance(parameters).apply(pop)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, parameters 
\family typewriter
begin, end, step
\family default
 etc become meaningless in the function form.
 Note that if you need to apply the same operator to dozens of populations,
 creating one operator and applying it to all populations is more efficient
 than using the function form, since dozens of operators will be created
 and destroyed for each population in the latter usage.
\end_layout

\begin_layout Standard
If hybrid operators are still not flexible enough, you can write operators
 in Python.
 Such operators will have full access to the evolving population, and can
 therefore perform arbitrary operations on it.
 A pure-python operator has been used in the previous chapter where complex
 statistics are calculated and printed.
 
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyOperator"

\end_inset

 uses a python operator to define a frequency-dependent selection operator
 which has different selection pressures depending on current disease allele
 frequency.
 In this example, a population is initialized with disease allele frequency
 0.3 (allele 1).
 Then, at each generation, a python function 
\family typewriter
freqDependSelector
\family default
 is called.
 This function
\end_layout

\begin_layout Itemize
unpact parameters (
\family typewriter
DSL, min, max
\family default
)
\end_layout

\begin_layout Itemize
calculate allele frequency at the disease locus
\end_layout

\begin_layout Itemize
if disease allele frequency is less than 
\family typewriter
min
\family default
, apply a multi-allele selector and give disease allele strong advantage
 selection;
\end_layout

\begin_layout Itemize
if disease allele frequency is greater than 
\family typewriter
max
\family default
, apply a multi-allele selector and give disease allele strong purifying
 selection;
\end_layout

\begin_layout Standard
The result of this operator, unseen to users, is individual 
\family typewriter
fitness
\begin_inset Index
status collapsed

\begin_layout Plain Layout
fitness
\end_layout

\end_inset


\family default
 values set by one of (maybe none of) the multi-allele selector, which will
 be used by 
\family typewriter
randomMating()
\family default
 to select individuals accordingly to population the next generation.
\end_layout

\begin_layout Standard
One tricky point of this python operator is that although selectors are
 
\family typewriter
PreMating
\family default
, namely fitness will be calculated before mating, 
\family typewriter
pyOperator
\family default
 is 
\family typewriter
PostMating
\family default
.
 To calculate 
\family typewriter
fitness
\family default
 before mating, a 
\family typewriter
stage=PreMating
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
PreMating
\end_layout

\end_inset

 parameter should be used.
 Otherwise, the fitness will be calculated for the offspring generation,
 not the current generation, as shown below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

preMating | mating -> offspring generation | postMating, fitness calculated
\end_layout

\begin_layout Plain Layout

preMating | mating -> ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, because the simulator clears selection flag at the beginning of each
 generation, the fitness will not be used.
 Tricky enough, right? The good news is that 
\end_layout

\begin_layout Itemize
If you are using non-optimization libraries, simulation will fail if selection
 flag is on at the beginning of a generation.
 This prevents the use of post-mating selectors.
\end_layout

\begin_layout Itemize
If you are not sure in which order the operators are applied, use the 
\family typewriter
dryrun
\begin_inset Index
status collapsed

\begin_layout Plain Layout
dryrun
\end_layout

\end_inset

=True
\family default
 in the evolve function.
 
\family typewriter
evolve
\begin_inset Index
status collapsed

\begin_layout Plain Layout
evolve
\end_layout

\end_inset

()
\family default
 function will do nothing but printing out when and in which order operators
 will be applied.
\end_layout

\begin_layout Standard
Pure-python operators are extremely flexible and even more complicated form
 can be used.
 For example, 
\family typewriter
varPlotter
\family default
 in 
\family typewriter
simuRPy.py
\family default
 is a class with an instance of different plotters, and a python operator
 is used to call one of them.
 Such advanced usage of pure Python operator is beyond the scope of this
 guide.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "pyOperator.py"
lstparams "caption={A frequency dependent selection operator},label={pyOperator}"

\end_inset


\end_layout

\begin_layout Section
Python Individual operator (moved from refManual.lyx)
\end_layout

\begin_layout Standard
A Python operator accepts a function and an optional parameter.
 When 
\family typewriter
pyOperator
\family default
 is called, it will simply pass the accepted population (or parents and
 offspring in the case of 
\family typewriter
stage=DuringMating
\family default
) to the function.
 To use this operator, in case of 
\family typewriter
stage=PostMating
\family default
, you will need to 
\end_layout

\begin_layout Itemize
define a function that handle a population as you wish.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def myOperator(pop, para):
\end_layout

\begin_layout Plain Layout

    'do whatever you want'
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you return 
\family typewriter
False
\family default
, this operator will work like a terminator.
\end_layout

\end_deeper
\begin_layout Itemize
use 
\family typewriter
pyOperator
\family default
 in the form of
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(mfunc=pyOperator, param=para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
all parameters of an operator are supported except for 
\family typewriter
output
\family default
 and 
\family typewriter
outputExpr
\family default
 which are ignored for now.
\end_layout

\end_deeper
\begin_layout Standard
This operator allows implementation of arbitrarily complicated operators,.
 To use this operator, you will have to know how to use population-related
 functions.
 The following example shows how to implement a dynamic mutator which mutate
 loci according to their allele frequencies.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperator.log"
lstparams "caption={Define a python operator},label={pyOperator}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyOperatorUse.log"
lstparams "caption={Use of python operator},label={pyOperatorUse}"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
pyOperator
\family default
 can also be a during-mating operator.
 You will need to define a function 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def Func(pop, off, dad, mom, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def shortFunc(off, para)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
para
\family default
 can be ignored.
 To use this operator, you can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(stage=DuringMating, func=Func, param=someparam, formOffGenotype=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(stage=DuringMating, func=shortFunc, param=someparam,
\end_layout

\begin_layout Plain Layout

formOffGenotype=False, passOffspringOnly=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If your during-mating 
\family typewriter
pyOpeartor
\family default
 returns 
\family typewriter
False
\family default
, the individual will be discarded.
 Therefore, you can write a filter in this way.
 However, since the Python function will be called for each mating event,
 the cost of using such an operator is high, especially when population
 size is large.
\end_layout

\begin_layout Standard
An example of during-mating 
\family typewriter
pyOperator
\family default
 can be found in 
\family typewriter
scripts/demoPyOperator.py
\family default
.
\end_layout

\begin_layout Section
Information fields
\end_layout

\begin_layout Standard
Information fields are, in short, double values attached to each individual.
 Since different applications require different information fields, simuPOP
 takes a minimal approach in that no information field will be used (to
 save RAM) by default.
 When you apply an operator that needs a particular field, and your population
 does not have it, an error message will be given so that you can add appropriat
e fields to the 
\family typewriter
infoFields
\family default
 parameter of 
\family typewriter
population()
\family default
, or use 
\family typewriter
setInfoFields(), addInfoField(), addInfoFields()
\family default
 member functions to add them.
 Commonly used information fields are
\end_layout

\begin_layout Itemize

\family typewriter
fitness:
\family default
 used by all selectors, and by mating schemes
\end_layout

\begin_layout Itemize

\family typewriter
father_idx, mother_id
\family default
x: used by taggers to track parental information
\end_layout

\begin_layout Itemize

\family typewriter
spouse, pedindex, oldindex:
\family default
 used by ascertainment operators to obtain pedigree information.
\end_layout

\begin_layout Standard
Besides these standard information fields, you can define any fields for
 your use.
 The most frequently used functions are 
\family typewriter
individual::setInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setInfo
\end_layout

\end_inset

(value, field), individual::info
\begin_inset Index
status collapsed

\begin_layout Plain Layout
info
\end_layout

\end_inset

(field), population::setIndInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setIndInfo
\end_layout

\end_inset

(values, field)
\family default
 and 
\family typewriter
population::indInfo
\begin_inset Index
status collapsed

\begin_layout Plain Layout
indInfo
\end_layout

\end_inset

(field).

\family default
 Here field can be the name of the field, or an id returned by 
\family typewriter
population::infoIdx
\begin_inset Index
status collapsed

\begin_layout Plain Layout
infoIdx
\end_layout

\end_inset

(field)
\family default
.
 Accessing information fields using indices is faster than using names.
\end_layout

\begin_layout Standard
In the following example (Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "infoFields"

\end_inset

), a proportional hazard model is used to determine the age of onset of
 an individual with given genotype.
 Briefly,
\end_layout

\begin_layout Itemize
The base hazard is 
\begin_inset Formula $h_{0}\left(t\right)=\beta_{0}t$
\end_inset

, the corresponding survival function is 
\begin_inset Formula $S\left(s\right)=\exp\left(-\int_{0}^{s}h\left(t\right)dt\right)$
\end_inset

.
 The age of onset is determined randomly by the survival function.
 (
\begin_inset Formula $F\left(x\right)=1-S\left(x\right)$
\end_inset

 is used in the example.) The relevant functions are 
\family typewriter
hazard, cumHazard, cdf, ageOfOnset
\family default
.
 In the last function, 
\begin_inset Formula $\beta$
\end_inset

 is the fold change of the hazard function so 
\begin_inset Formula $h\left(t,\beta\right)=\beta\beta_{0}t$
\end_inset

.
\end_layout

\begin_layout Itemize
Date of birth is calculated as 2005 - age, where age is 
\begin_inset Formula $U\left(0,75\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
The proportional hazard model is
\begin_inset Formula \[
h\left(t,X\right)=h_{0}\left(t\right)\exp\left(\beta X\right)\]

\end_inset

where 
\begin_inset Formula $X$
\end_inset

 is the number of disease alleles at the given disease susceptibility loci.
 The age of onset is determined by individual 
\begin_inset Formula $h\left(t,X\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Affection status is determined by date of birth + age of onset < 2005.
\end_layout

\begin_layout Standard
The program is pretty self-explainary so I do not comment on the code here.
 The resulting population has information fields 
\family typewriter
DateOfBirth
\family default
, 
\family typewriter
betaX
\family default
 and 
\family typewriter
ageOfOnset
\family default
.
 Note that this example does not any operator or simulator, and demonstrate
 simuPOP's ability to manipulation populations.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "infoFields.py"
lstparams "caption={Proportional hazard model and use of information fields},label={infoFields}"

\end_inset


\end_layout

\begin_layout Standard
Information fields can also be manipulated during evolution, using one of
 the Python operators, or operators 
\family typewriter
infoEval 
\family default
and 
\family typewriter
infoExec
\family default
 (new in version 0.8.4).
 Please refer to simuPOP reference manual for details.
\end_layout

\begin_layout Section
Pedigree
\end_layout

\begin_layout Standard
A pedigree records the parent(s) of each individual during evolution.
 It can be created manually or using tagging operators 
\family typewriter
parentTagger
\family default
 (tagging one parent) and 
\family typewriter
parentsTagger 
\family default
(tagging both parents).
 The pedigree can be analyzed to study various properties of the evolutionary
 process, manipulated (e.g.
 removing individuals without offspring), and used to re-realize the evolutionar
y process using 
\family typewriter
pedigreeMating
\family default
.
\end_layout

\begin_layout Standard
A pedigree file has the following format:
\end_layout

\begin_layout LyX-Code
p1 p2 p3 p4 .....
 # sp1 sp2 sp3
\end_layout

\begin_layout LyX-Code
p1 p2 p3 p4 .....
 # sp1 sp2 sp3
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Standard
Numbers before # of each line of a pedigree file are the parent(s) of individual
s, starting from generation 0.
 If only one parent is used to produce offspring (e.g.
 using the 
\family typewriter
selfMating
\family default
 mating scheme), 
\family typewriter
parentTagger(output, outputExpr)
\family default
 records the index of the parent of each individual (
\family typewriter
p...
\family default
) in the parental generation.
 Otherwise, 
\family typewriter
parentsTagger(output, outputExpr)
\family default
 records the indexes of both parents.
\end_layout

\begin_layout Standard
The generation number and the size of subpopulations are listed after the
 # character.
 The sum of subpopulation sizes should match the individuals listed before
 #.
\end_layout

\begin_layout Standard
A number of auxillary information pedigrees can be loaded after a pedigree
 is created.
 These information pedigree files does not have subpopulation and generation
 information (does not have character # and numbers after it).
 If there are 
\begin_inset Formula $n$
\end_inset

 individuals at a generation, the corresponding line in an information pedigree
 file should have 
\begin_inset Formula $m*n$
\end_inset

 numbers where 
\begin_inset Formula $m$
\end_inset

 is the number of properties for each individual.
 Information pedigrees can be created by other tagging operators such as
 
\family typewriter
pyTagger(output, outputExpr)
\family default
.
 
\end_layout

\begin_layout Standard
These auxiliary information will be attached to individuals in a pedigree.
 They will be removed if an individual is removed from the pedigree.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Population structure and migration
\end_layout

\begin_layout Standard
You first need to understand that mating schemes populate subpopulations
 from their corresponding ancestral subpopulations one by one, so it can
 not change number of subpopulations.
 Split and merge of subpopulations are done by operators 
\family typewriter
splitSubPop
\begin_inset Index
status collapsed

\begin_layout Plain Layout
splitSubPop
\end_layout

\end_inset


\family default
 and 
\family typewriter
mergeSubPops
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mergeSubPops
\end_layout

\end_inset


\family default
 respectively.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitAndMerge"

\end_inset

, these two operators are used to split and merge subpopulations, but keep
 total population size untouched.
 Note that after subpopulation merge, subpopulation 2 still exists, but
 with size 0.
 This is used to keep subpopulation id of other subpopulations unchanged.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitAndMerge.out"
lstparams "caption={Population split and merge},label={splitAndMerge}"

\end_inset


\end_layout

\begin_layout Standard
Migration can change subpopulation size, but not total population size.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitAndMerge"

\end_inset

, two migrators are used.
 The first migrator moves individuals from subpopulation 0 to subpopulation
 1.
 The second migrator moves individuals around, with given proportions.
 For example, the migration rate
\begin_inset Formula \[
\left(\begin{array}{ccc}
0. & 0.2 & 0.4\\
0. & 0. & 0.1\\
0.1 & 0.1 & 0.\end{array}\right)\]

\end_inset

means moving 20% of individuals from subpop 0 to 1, 40% of individuals from
 subpop 0 to 1, and keep 40% (automatically determined).
 Subpopulation sizes change accordingly.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration.out"
lstparams "caption={Population split and migration},label={splitMigration}"

\end_inset


\end_layout

\begin_layout Standard
But what if you need to control total population size? In this case, a demograph
ic function is needed to specify the size of each subpopulation, at each
 generation.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration2"

\end_inset

, function 
\family typewriter
popSize
\family default
 returns exact subpopulation size at each generation, and the population
 will behave accordingly.
 It might surprise you that migration can no longer control the size of
 subpopulation sizes.
 What exactly happened is that, for example
\end_layout

\begin_layout Itemize
subpopulation size = [200, 400, 400], at the beginning of a generation
\end_layout

\begin_layout Itemize
apply migrator, subpopulation size changed to [100, 470, 430]
\end_layout

\begin_layout Itemize
pre mating operator 
\family typewriter
stat
\family default
 is applied and report subpopulation sizes
\end_layout

\begin_layout Itemize
during mating, with given subpopulation sizes 200, 400, 400 of the offspring
 generation, the mating scheme generate 200 offspring from 100 parents in
 subpopulation 0, 400 offspring from 470 parents in subpopulation 1, and
 400 offspring from 430 parents in subpopulation 2.
\end_layout

\begin_layout Itemize
post mating operator 
\family typewriter
stat
\family default
 is applied and get the new subpopulation size.
\end_layout

\begin_layout Standard
This example also demonstrates the use of stage parameter.
 As a matter of fact, you can use only one 
\family typewriter
stat
\family default
 operator by using 
\family typewriter
stage
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stage
\end_layout

\end_inset

=PrePostMating
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
PrePostMating
\end_layout

\end_inset

.
 If you are confused by the order of operators, use the 
\family typewriter
dryrun=True
\family default
 parameter of 
\family typewriter
evolve
\family default
 to check.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration2.out"
lstparams "caption={Population split with changing population size},label={splitMigration2}"

\end_inset


\end_layout

\begin_layout Standard
You might say, OK, this looks nice, but how can I grow a population with
 migration acting freely? This is also easy, all you need to do is using
 the oldSize parameter of a demographic function in a clever way.
 The underlying story is that
\end_layout

\begin_layout Itemize
before mating, a mating scheme calculates current subpopulation sizes
\end_layout

\begin_layout Itemize
it calls the given demographic function with current generation number and
 current subpopulation sizes
\end_layout

\begin_layout Itemize
it uses the return value as the new subpopulation sizes.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "splitMigration3"

\end_inset

 demonstrate an exponentially increase population with free migration between
 subpopulations.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "splitMigration3.out"
lstparams "caption={Population split with changing population size},label={splitMigration3}"

\end_inset


\end_layout

\begin_layout Section
Non-random mating
\end_layout

\begin_layout Standard
Random-mating implies random choices of parents.
 Non-random mating is much more difficult to implement because there are
 numerous way to introduce non-randomness.
 One of the ways to achive non-random mating in simuPOP is to use a hybrid
 operator 
\family typewriter
pyMating
\family default
.
\end_layout

\begin_layout Standard
A 
\family typewriter
pyMating
\family default
 mating scheme accepts a 
\emph on
parents chooser
\emph default
 and an 
\emph on
offspring generator
\emph default
.
 The parents chooser is responsible for choosing one or two parents from
 the parental generation, and the offspring generator is responsible for
 generating a number of offspring from the chosen parents.
 There are a number of default parents choosers and offspring generators
 and a 
\family typewriter
pyMating
\family default
 can be built with them.
 For example
\end_layout

\begin_layout LyX-Code
pyMating(randomParentsChooser(), mendelianOffspringGenerator())
\end_layout

\begin_layout Standard
works exactly as a 
\family typewriter
randomMating
\family default
 scheme, and
\end_layout

\begin_layout LyX-Code
pyMating(randomParentChooser(), selfingOffspringGenerator(numOffspring=2))
\end_layout

\begin_layout Standard
works as 
\family typewriter
selfMating(numOffspring=2)
\family default
.
 Note that parent chooser and offspring generator should be compatible ,
 meaning that if a parent chooser chooses one parent each time, the offspring
 generator should be able to produce offspring from a single parent.
\end_layout

\begin_layout Standard
The power of 
\family typewriter
pyMating 
\family default
lies in its 
\family typewriter
pyParentChooser()
\family default
, which accepts a user-defined Python generator function, instead of a normal
 python function.
 Generally speaking, when a generator function is called, it returns a 
\emph on
generator
\emph default
 object that provides an iterator interface.
 Each time when the 
\family typewriter
next()
\family default
 member function of this object is called, this function resumes where it
 was stopped last time, executes and returns what the next 
\emph on
yield
\emph default
 statement returns.
 For example, example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator"

\end_inset

 defines a function that calculate 
\begin_inset Formula $f\left(k\right)=\sum_{i=1}^{k}\frac{1}{i}$
\end_inset

 for 
\begin_inset Formula $k=1,...,10$
\end_inset

.
 It does not calculate each 
\begin_inset Formula $f\left(k\right)$
\end_inset

 repeatedly but returns 
\begin_inset Formula $f\left(1\right)$
\end_inset

, 
\begin_inset Formula $f\left(2\right)$
\end_inset

, ...
 in a sequence interface.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator.log"
lstparams "caption={A sample generator function},label={generator}"

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
parents chooser
\emph default
 takes two parameters, a population and a subpopulation index.
 It can return different generator objects for different subpopulations.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/generator_random.log"
lstparams "caption={A generator function that mimicks random mating},label={generator_random}"

\end_inset


\end_layout

\begin_layout Standard
A user defined parents chooser can be very complicated, involving user defined
 information such as geometric locations.
 An example is given in 
\family typewriter
cookbook/Mating_pyMating_cpp.py
\family default
.
 In example 
\begin_inset CommandInset ref
LatexCommand ref
reference "generator_random"

\end_inset

, the parents chooser 
\family typewriter
randomChooser 
\family default
collects indexes of males and females and simply return a pair of random
 male and female repeatedly.
 This is exactly what 
\family typewriter
randomMating
\family default
 does if selection is not considered.
 It becomes obvious now that whereas a python function can return random
 male/famale pair, the generator interface is much more efficient because
 the identification of two sex groups is done only once.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "pyMating"

\end_inset

 demonstrates how to use this user-defined parent chooser.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/pyMating.log"
lstparams "caption={pyMating with a user-defined parent chooser},label={pyMating}"

\end_inset


\end_layout

\begin_layout Standard
Because arbitrary information can be stored with an individual through informati
on fields, 
\family typewriter
pyMating
\family default
 can be very complicated.
 For example, one can choose individuals according their age, and/or geographic
 information.
 For populations with well-defined structure, virtual subpopulations can
 be used.
 Basically, one needs to specify a virtual subpopulation splitter to a subpopula
tion.
 Then, different mating schemes can be applied to different virtual subpopulatio
ns.
 A simple example is given in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "heteroMating"

\end_inset

 where the first subpopulation is divided into two parts.
 The first 20% of individuals undergo selfing, and the rest of the subpopulation
 undergoes usual sexed random mating.
 Note that two mating schemes produce different number of offspring per
 mating event, and the family sizes are recorded in a shared variable 
\family typewriter
famSizes
\family default
 when 
\family typewriter
DBG_MATING
\family default
 is turned on.
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "log/heteroMating.log"
lstparams "caption={A heterogeneous mating scheme},label={heteroMating}"

\end_inset


\end_layout

\begin_layout Section
Sex chromosomes
\end_layout

\begin_layout Standard
Supports for sex chromosomes are done in simuPOP in the following ways:
\end_layout

\begin_layout Itemize
If 
\family typewriter
sexChrom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sexChrom
\end_layout

\end_inset

=True
\family default
 is specified in 
\family typewriter
population()
\family default
, the last chromosome is assumed to be the sex chromosome.
 For female, it is 
\family typewriter
XX,
\family default
 for male, it is 
\family typewriter
XY
\family default
, in that order.
\end_layout

\begin_layout Itemize
During mating, sex of offspring is determined by sex chromosome.
 (It is otherwise determined randomly with probability 0.5).
\end_layout

\begin_layout Itemize
Recombination can not happen between 
\family typewriter
X
\family default
 and 
\family typewriter
Y
\family default
 chromosomes.
 That is to say, offspring can get recombined 
\family typewriter
X
\family default
 from his/her mother, but untouched 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 from father.
\end_layout

\begin_layout Standard
As of version 0.7.5, no other operator recognize sex chromosome.
 Most notably, 
\family typewriter
stat
\family default
 counts allele frequencies etc regardless sex chromosome and can not count
 allele frequency for 
\family typewriter
X
\family default
 or 
\family typewriter
Y
\family default
 separately.
 
\end_layout

\begin_layout Section
Pedigree tracking
\end_layout

\begin_layout Standard
simuPOP provides the following functions to manipulate pedigrees
\end_layout

\begin_layout Itemize
If you set 
\family typewriter
ancestralDepth
\family default
 of a population to a positive number (default 0), 
\family typewriter
ancestralDepth
\family default
 number of ancestral generations will be saved to the population, which
 makes a total of 
\family typewriter
ancestralDepth + 1
\family default
 generations.
\end_layout

\begin_layout Itemize
You can use 
\family typewriter
population::useAncestralPop
\begin_inset Index
status collapsed

\begin_layout Plain Layout
useAncestralPop
\end_layout

\end_inset

(idx)
\family default
 to use current (0), parental (1), grand-parental (2) generations etc.
 Just remember to call 
\family typewriter
population::useAncestralPop(0)
\family default
 to set current generation back.
\end_layout

\begin_layout Itemize
You can set 
\family typewriter
ancestralDepth
\family default
 dynamically using operator 
\family typewriter
setAncestralDepth
\begin_inset Index
status collapsed

\begin_layout Plain Layout
setAncestralDepth
\end_layout

\end_inset

.

\family default
 Usually, this operator is called, for example, as 
\family typewriter
setAncestralDepth(at=[-2])
\family default
, to allow last several generations to be saved at the end of evolution.
\end_layout

\begin_layout Itemize
No parental information is saved by default we usually do not know the parents
 of an offspring.
 This can be changed by using the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields, and an appropriate tagger such as 
\family typewriter
parentTagger
\begin_inset Index
status collapsed

\begin_layout Plain Layout
parentTagger
\end_layout

\end_inset

()
\family default
, which is a during mating operator that will record the parents' indices
 in the parental generation to offspring's information fields.
\end_layout

\begin_layout Itemize

\family typewriter
randomMating
\begin_inset Index
status collapsed

\begin_layout Plain Layout
randomMating
\end_layout

\end_inset

()
\family default
 only produce one offspring per mating event.
 This makes full siblings very unlikely.
 You usually need to change this at the last several generations.
\end_layout

\begin_layout Standard
You can see that generating multi-generation populations are quite different
 from the usual evolutionary process where random mating is used, and one
 offspring is generated for each mating event.
 In practice (see 
\family typewriter
scripts/simuComplexDisease.py
\family default
), if we need to prepare a population for pedigree sampling, we can run
 a simulator like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
One-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(...., ancestralDepth=2,
\end_layout

\begin_layout Plain Layout

    infoFields=['father_idx', 'mother_idx'])
\end_layout

\begin_layout Plain Layout

simu = simulator(pop, randomMating(numOffspring=2))
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    preOps=[...],
\end_layout

\begin_layout Plain Layout

    ops = operators,
\end_layout

\begin_layout Plain Layout

    end = 1000
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with this approach is that two generations are saved at all
 generations, and all mating events produce two offspring.
 The former is not a big deal but the latter will reduce effective population
 size of the resulting population.
 To avoid these problems, a two-stage simulation can be done 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Two-stage simulation for pedigree tracking
\end_layout

\end_inset

pop = population(....)
\end_layout

\begin_layout Plain Layout

simu = simulator(pop, randomMating())
\end_layout

\begin_layout Plain Layout

simu.evolve(
\end_layout

\begin_layout Plain Layout

    preOps=[...],
\end_layout

\begin_layout Plain Layout

    ops = operators,
\end_layout

\begin_layout Plain Layout

    end = 1000 - 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

simu.setAncestralDepth(2)
\end_layout

\begin_layout Plain Layout

simu.addInfoFields(['father_idx', 'mother_idx'])
\end_layout

\begin_layout Plain Layout

simu.setMatingScheme(randomMating(numOffspring=2))
\end_layout

\begin_layout Plain Layout

operators.append(parentsTagger())
\end_layout

\begin_layout Plain Layout

simu.evolve(ops=operators, end=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is to say, we separate the simulation into two parts.
 The first part is geared toward performance and maximum effective population
 size (use true random mating), and the second part is tweaked for the final
 multi-generation population.
 Note that 
\family typewriter
setAncestralDepth 
\family default
and 
\family typewriter
addInfoFields
\family default
 should be done at the simulator level so that every replicates in the simulator
 have the same new information fields.
 
\family typewriter
simu.population(0).addInfoFields(['father_idx', 'mother_idx']) 
\family default
will compromise the integrity of the simulator and is disallowed.
 (Integrity refers to the fact that all populations in a simulator should
 have the same genotypic structure as the simulator).
\end_layout

\begin_layout Standard
Now, at the end of the simulation, you get a population with multiple generation
s, with parental information.
 But it is still not easy to obtain pedigrees.
 As a matter of fact, since individuals can belong to multiple pedigrees,
 it is not even easy to define a pedigree.
 simuPOP provides a few pedigree ascertainment operators
\end_layout

\begin_layout Itemize

\family typewriter
AffectedSibpairSample
\family default
: sample affected sibpairs, along with their parents from a population.
 Affection status should have been set by other means such as a penetrance
 operator.
\end_layout

\begin_layout Itemize

\family typewriter
LargePedigreeSample:
\family default
 sample grand parents, their children, and the spouse and children of them.
 Affection status is ignored, although the minimal number of affected individual
s in each family can be specified.
\end_layout

\begin_layout Itemize

\family typewriter
NuclearFamilySample: 
\family default
sample two-generation pedigrees.
\end_layout

\begin_layout Standard
If you need to sample more complicated pedigrees, you should first use 
\family typewriter
sample::findOffspringAndSpouse
\family default
 to locate each individual's offspring and spouse, then use 
\family typewriter
useAncestralPop()
\family default
 to go through the generations and set 
\family typewriter
pedIndex
\family default
 for the pedigree you choose, and then use 
\family typewriter
setSubPopID()
\family default
, 
\family typewriter
newPopByIndID()
\family default
 to exclude and remove unneeded individuals.
 
\family typewriter
sample::resetParentalIndex()
\family default
 should also be used to reset the 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 fields.
 Sound complicated? It is complicated! I hope that I can get some better
 idea and make this process a bit easier, but this is where simuPOP is at
 right now.
\end_layout

\begin_layout Standard
Finally, you can save the sample populations in a pedigree-aware format
 like Linkage or Merlin/QTDT format.
 simuPOP can do this easily for you.
\end_layout

\begin_layout Section
Save and load to other formats
\end_layout

\begin_layout Standard
simuPOP data structure is open in that many functions are provided to access
 every aspect of the population.
 This makes it easy to save and load populations in other formats.
 As an example, I will explain 
\family typewriter
SaveTDT
\family default
 function in detail here, which is available in 
\family typewriter
simuUtil.py
\family default
.
\end_layout

\begin_layout Standard
Although all file formats have different characteristics, 
\family typewriter
simuPOP
\family default
 tries to provide a uniform interface to them.
 Common parameters are
\end_layout

\begin_layout Itemize
pop: population to save, can be a file name, or a file object (loaded simuPOP
 population)
\end_layout

\begin_layout Itemize
output and outputExpr: output is the base filename, and outputExpr should
 be evaluated from pop's local namespace.
\end_layout

\begin_layout Itemize
loci: loci to output, default is [], meaning output all loci
\end_layout

\begin_layout Itemize
fields: information fields to output.
 
\end_layout

\begin_layout Itemize
combine: a python function, if given, used to combine two alleles at the
 same locus.
 For example
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def comb(geno):
\end_layout

\begin_layout Plain Layout

    return geno[0]+geno[1]+1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns 1 for genotype(0, 0), 2 for genotype (0, 1) and so on.
\end_layout

\end_deeper
\begin_layout Itemize
shift: default to 1.
 simuPOP uses 0 based allele and many formats use 1 based allele.
 Setting shift=1 output (1,2) for genotype (0,1).
\end_layout

\begin_layout Standard
The 
\family typewriter
Merlin/QTDT
\family default
 format uses several files to store genotype and phenotype information.
 Namely a 
\family typewriter
.dat
\family default
 file for phenotype, 
\family typewriter
.map
\family default
 file for chromosome structure, and 
\family typewriter
.ped
\family default
 for pedigree.
 The population given must have 
\family typewriter
pedindex, father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 information fields to indicate family id and parents of each individual.
 These information fields will be available if the sample is obtained from
 
\family typewriter
affectedSibpairSample
\family default
 or 
\family typewriter
largePedigreeSample
\family default
 operators.
\end_layout

\begin_layout Standard
The first part of the function is the usual housekeeping part (see example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT1"

\end_inset

).
 It loads population if 
\family typewriter
pop
\family default
 is a name, evaluate 
\family typewriter
outputExpr
\family default
 if needed, and open the files to write.
 This part is likely to be similar for all such functions.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT1.py"
lstparams "caption={Function SaveQTDT, part one},label={saveQTDT1}"

\end_inset


\end_layout

\begin_layout Standard
Part two of the code (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT2"

\end_inset

) output data file.
 There are three kinds of phenotype, affection status, trait and markers.
 We determine if a user wants to output affection from the 
\family typewriter
fields
\family default
 parameter.
 We remove 
\family typewriter
affection
\family default
 from 
\family typewriter
fields
\family default
 because 
\family typewriter
affection
\family default
 is not a real information field (that can be retrieved by 
\family typewriter
info()
\family default
 function).
 You can learn how to use the 
\family typewriter
locusName
\family default
 function from this part.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT2.py"
lstparams "caption={Function SaveQTDT, part two},label={saveQTDT2}"

\end_inset


\end_layout

\begin_layout Standard
Part three (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT3"

\end_inset

) of the function output a map file.
 We need to know the chromosome number (+1 to use 1 based index), locus
 name and locus position, all of which can be retrieved from simple 
\family typewriter
simuPOP
\family default
 functions.
 Note that if locus name, position are not given explicitly when a population
 is created, they all have default values.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT3.py"
lstparams "caption={Function SaveQTDT, part three},label={saveQTDT3}"

\end_inset


\end_layout

\begin_layout Standard
The next part (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT4"

\end_inset

) prepares pedigree output.
 It determines the code to output for sex and affection status.
 These are likely to be different from format to format so we define explicitly
 here.
 The 
\family typewriter
writeInd
\family default
 output the line for one individual, given family id, id, father and mother.
 For QTDT format, two alleles of a genotype are outputted separately so
 the 
\family typewriter
combine
\family default
 parameter is ignored.
 
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT4.py"
lstparams "caption={Function SaveQTDT, part four},label={saveQTDT4}"

\end_inset


\end_layout

\begin_layout Standard
The last part of the code (example 
\begin_inset CommandInset ref
LatexCommand ref
reference "saveQTDT5"

\end_inset

) look most complicated.
 It first get the 
\family typewriter
pedindex
\family default
 information field of the whole population, and figure out how many pedigrees
 to output.
 Then, it go from ancestral generation 2, 1, 0 and look for individuals
 within each pedigree.
 A map is used to map absolute index to within pedigree index.
 Of course, this part would be easier if you do not need to handle pedigree,
 for example, when outputting case control samples.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "saveQTDT5.py"
lstparams "caption={Function SaveQTDT, part five},label={saveQTDT5}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gene mapping
\end_layout

\begin_layout Standard
Once you output your sample into a format that can be processed by other
 applications, you can handle them in whatever way you want.
 If you are interested in processing the data in simuPOP (actually, in python),
 you can use python to call these programs.
 
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "mapping.py"
lstparams "caption={Example of gene mapping},label={mapping}"

\end_inset


\end_layout

\begin_layout Standard
An example is given in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "mapping"

\end_inset

.
 In this function, 
\family typewriter
merlin
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Abecasis2002"

\end_inset

 is called to process file produced by the 
\family typewriter
SaveQTDT
\family default
 function.
 The output is fed into a pipe (
\family typewriter
popen
\family default
) and be filtered by the python 
\family typewriter
re
\family default
 (regex) module.
 Only the 
\begin_inset Formula $p$
\end_inset

-values are obtained and returned.
\end_layout

\begin_layout Chapter
A real example
\end_layout

\begin_layout Standard
In this chapter, I will show you, step by step, how to write a simuPOP script.
 The example is a simplified version of 
\family typewriter
scripts/simuCDCV.py
\family default
 which uses a python operator to calculate and save many more statistics,
 and use rpy to display the dynamics of disease allele frequency.
 
\end_layout

\begin_layout Section
Simulation scenario
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Reich2001a"

\end_inset

 proposed a population genetics framework to model the evolution of allelic
 spectra (the number and population frequency of alleles at a locus).
 The model is based on the fact that human population grew quickly from
 around 10,000 to 6 billion in 18,000 -150,000 years.
 His analysis showed that at the founder population, both common and rare
 diseases have simple spectra.
 After the sudden expansion of population size, the allelic spectra of simple
 diseases become complex; while those of complex diseases remained simple.
\end_layout

\begin_layout Standard
I use simuPOP to simulate this evolution process and observe the allelic
 spectra of both types of diseases.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

, which has much more detailed discussion about the simulations, and the
 parameters used.
 
\end_layout

\begin_layout Section
Demographic model
\end_layout

\begin_layout Standard
The initial population size is set to 10,000, as suggested in the paper.
 The simulation will evolve 500 generations with constant population size
 to reach mutation-selection equilibrium.
 Then, the population size will increase by around 20,000 every 10 generations
 and reach 1,000,000 at generation 1000.
 The population growth takes around 12,500 years if we assume 25 years per
 generation.
 
\end_layout

\begin_layout Section
Mutation model
\end_layout

\begin_layout Standard
The maximum number of alleles at each locus is set to be 2000, a number
 that is hopefully big enough to mimic the infinite allele model.
 Allele 0 is the wild type (
\begin_inset Formula $A$
\end_inset

) and all others are disease alleles (
\begin_inset Formula $a$
\end_inset

).
 The 
\begin_inset Formula $k-$
\end_inset

allele mutation model is used.
 That is to say, an allele can mutate to any other allele with equal probability.
 An immediate implication of this model is that 
\begin_inset Formula $P\left(A\rightarrow a\right)\gg P\left(a\rightarrow A\right)$
\end_inset

 since there are many more 
\begin_inset Formula $a$
\end_inset

 than 
\begin_inset Formula $A$
\end_inset

.
 The mutation rate is set to 
\begin_inset Formula $\mu=3.2\times10^{-5}$
\end_inset

 per locus per generation.
\end_layout

\begin_layout Section
Selection on a common and a rare disease 
\end_layout

\begin_layout Standard
Two diseases are simulated: a common disease with initial allele frequency
 of 
\begin_inset Formula $f_{0}=0.2$
\end_inset

; and a rare disease with initial allele frequency of 
\begin_inset Formula $f_{0}=0.001$
\end_inset

.
 The diseases are unlinked in the sense that their corresponding loci reside
 on separated chromosomes.
 The allelic spectra of both diseases are set to be 
\begin_inset Formula $\left[.9,.02,.02,.02,.02,.02\right]$
\end_inset

.
 I.e., one allele accounts for 90% of the disease cases.
 
\end_layout

\begin_layout Standard
Both diseases are recessive in that their fitness values are 
\begin_inset Formula $\left[1,1,1-s\right]$
\end_inset

 for genotype 
\begin_inset Formula $AA$
\end_inset

, 
\begin_inset Formula $Aa$
\end_inset

 and 
\begin_inset Formula $aa$
\end_inset

 respectively.
 
\begin_inset Formula $s_{c}=0.1$
\end_inset

 , 
\begin_inset Formula $s_{r}=0.9$
\end_inset

 are used in the simulation which imply weak selection on the common disease
 and strong selection on the rare disease.
 If an individual has both diseases, his fitness value follows a multiplicative
 model, i.e., 
\begin_inset Formula $\left(1-s_{c}\right)\times\left(1-s_{r}\right)=0.09$
\end_inset

.
 
\end_layout

\begin_layout Standard
These parameters, translated to python, are shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:reich0"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich0.py"
lstparams "caption={Set parameters},label={alg:reich0}"

\end_inset


\end_layout

\begin_layout Section
Create a simulator
\end_layout

\begin_layout Standard
Several parameters are needed to create a population:
\end_layout

\begin_layout Itemize

\family typewriter
ploidy
\family default
: 2, default
\end_layout

\begin_layout Itemize

\family typewriter
size
\family default
: initial population size, known
\end_layout

\begin_layout Itemize

\family typewriter
subPop
\family default
: no subpopulation (or one single population).
 size can be ignored if 
\family typewriter
subPop
\family default
 is given.
\end_layout

\begin_layout Itemize

\family typewriter
loci
\family default
: number of chromosomes and number of loci on each chromosome: we use two
 unlinked loci.
 use 
\family typewriter
loci=[1,1]
\family default
.
 This array gives the number of loci on each chromosome.
\end_layout

\begin_layout Itemize
loci name and position: no need to specify
\end_layout

\begin_layout Itemize

\family typewriter
infoFields
\family default
: This parameter is tricky since you need to specify what auxiliary information
 to attach to each individual.
 During the simulation, 
\family typewriter
fitness
\family default
 is needed because all selectors generate this information and mating schemes
 will make use of it.
 If you forget to provide this parameter, never mind, the simulation will
 fail and tell you that a information field 
\family typewriter
fitness
\family default
 is needed.
 Similar information fields include 
\family typewriter
father_idx
\family default
 and 
\family typewriter
mother_idx
\family default
 when you want to track each individual's parents using 
\family typewriter
taggers.
\end_layout

\begin_layout Standard
You can then create a population with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

population(size=1000, loci=[1,1], infoFields=['fitness'])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create simulator, we need to decide on a mating scheme.
 
\family typewriter
randomMating
\family default
 should of course be used, but we need to tell 
\family typewriter
randomMating
\family default
 how population size should be changed.
 By default, all mating schemes keep the population size of ancestral population
, but we need an instant population expansion model.
\end_layout

\begin_layout Standard
The easiest way to achieve this is defining a function that accept generation
 number and the population size of previous generation, and return the size
 of this generation.
 The input and output population sizes need to be arrays, indicating sizes
 of all subpopulations.
 In our case, something like 
\family typewriter
[1000]
\family default
 should be used.
 The instant population growth model is actually quite easy to write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ins_exp(gen, oldSize=[]):
\end_layout

\begin_layout Plain Layout

     if gen < burnin:
\end_layout

\begin_layout Plain Layout

         return [initSize]
\end_layout

\begin_layout Plain Layout

     else:
\end_layout

\begin_layout Plain Layout

         return [finalSize] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a little adjustment of how population size is given to 
\family typewriter
population()
\family default
, and use demographic function as a parameter to allow other demographic
 models to be used, we end up with example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich1"

\end_inset

.
 Note that because we use loci with more than 255 allele states, the long
 allele module is used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich1.py"
lstparams "caption={Create a simulator},label={reich1}"

\end_inset


\end_layout

\begin_layout Section
Initialization
\end_layout

\begin_layout Standard
We start the simulation with initial allele spectra at the two loci.
 This can be achieved by operator 
\family typewriter
initByFreq
\family default
, which allows you to initialize individuals with alleles proportional to
 given allele frequencies.
 Using a large number of parameters, this operator can initialize any subset
 of loci, for any subset(s) of individuals, even given ploidy.
 We need only to specify locus to initialize, and use it like
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# initialize locus 0 (for common disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[0], alleleFreq=C_f),
\end_layout

\begin_layout Plain Layout

# initialize locus 1 (for rare disease)
\end_layout

\begin_layout Plain Layout

initByFreq(atLoci=[1], alleleFreq=R_f),
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mutation and selection
\end_layout

\begin_layout Standard
You will need to read the relative sections of the reference manual to pick
 suitable mutator and selectors.
 What we need in this case are
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

-allele mutator with given number of allele states (
\begin_inset Formula $k$
\end_inset

).
 This is exactly
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kamMutator(rate=mu, maxAllele=max_allele)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
single locus selector that treat 0 as wildtype, and any other allele as
 mutant.
 The selector to use is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Because an individual has only one fitness value, fitness values obtained
 from two selectors need to be combined (another choice is that you can
 use a selector that handle multiple loci.).
 Therefore, we use a multi-locus selector as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mlSelector([
\end_layout

\begin_layout Plain Layout

    maSelector(locus=0, fitness=[1,1,1-C_s], wildtype=[0]),
\end_layout

\begin_layout Plain Layout

    maSelector(locus=1, fitness=[1,1,1-R_s], wildtype=[0])
\end_layout

\begin_layout Plain Layout

    ], mode=SEL_Multiplicative)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
With these operators, the simulator can be started.
 It first initialize a population with given allelic spectra, and then evolve
 it, subject to mutation and selection, specific to each locus.
 The program is listed in example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich2"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich2.py"
lstparams "caption={Run the simulator},label={reich2}"

\end_inset


\end_layout

\begin_layout Section
Output statistics
\end_layout

\begin_layout Standard
We first want to output total disease allele frequency of each locus.
 This is easy since 
\family typewriter
stat()
\family default
 operator can calculate allele frequency for us.
 What we need to do is use 
\family typewriter
stat()
\family default
 operator to calculate allele frequency and set variable 
\family typewriter
alleleFreq
\family default
 (and 
\family typewriter
alleleNum
\family default
) in each population's local namespace,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stat(alleleFreq=[0,1]),
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then use a 
\family typewriter
pyEval
\family default
 (python expression) operator to print out the values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(r' %.3f
\backslash
t%.3f
\backslash
n % (1-alleleFreq[0][0], 1-alleleFreq[1][0])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
pyEval
\family default
 operator can accept any valid python expression so the above expression
 calculate 
\begin_inset Formula $f_{0}=\sum_{i=1}^{\infty}f_{i}$
\end_inset

 at each locus (0 and 1) and print it in the format of 
\family typewriter
'%.3f
\backslash
t%.3f
\backslash
n'
\family default
.
\end_layout

\begin_layout Standard
There is no operator to calculate effective number of alleles 
\begin_inset CommandInset citation
LatexCommand citep
key "Reich2001a"

\end_inset

 so we need to do that by ourselves, using allele frequencies.
 The formula to calculate effective number of alleles is
\begin_inset Formula \[
n_{e}=\left(\sum_{i}\left(\frac{f_{i}}{f_{0}}\right)^{2}\right)^{-1}\]

\end_inset

where 
\begin_inset Formula $f_{i}$
\end_inset

 is the allele frequency of disease allele 
\begin_inset Formula $i$
\end_inset

 , and 
\begin_inset Formula $f_{0}$
\end_inset

 is defined as above.
 To calculate 
\begin_inset Formula $n_{e}$
\end_inset

 at the first locus, we can use a 
\family typewriter
pyEval
\family default
 operator (a direct translation of the formula):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval('1./sum([(x/(1-alleleFreq[0][0]))**2 for x in alleleFreq[0][1:]])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this expression looks complicated and can not handle the case when
 
\begin_inset Formula $f_{0}=0$
\end_inset

.
 A more complicated, and robust method is using the 
\family typewriter
stmts
\family default
 parameter of 
\family typewriter
pyEval
\family default
, which will be evaluated before parameter 
\family typewriter
expr
\family default
 ,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyEval(stmts='''ne = [0,0]
\end_layout

\begin_layout Plain Layout

for i in range(2):
\end_layout

\begin_layout Plain Layout

    freq = alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

    f0 = 1 - alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

    if f0 == 0:
\end_layout

\begin_layout Plain Layout

        ne[i] = 0
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        ne[i] = 1./sum([(x/f0)**2 for x in freq])
\end_layout

\begin_layout Plain Layout

''', expr=r'%.4f
\backslash
t%.4f
\backslash
n % (ne[0], ne[1])')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the 
\family typewriter
pyEval
\family default
 can be really complicated and calculate any statistics.
 However, if you plan to calculate more statistics, a pure python operator
 may be easier to write.
 The simplest form of a python operator is just a python function that accept
 a population as the first parameter (and an optional parameter),
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ne(pop):
\end_layout

\begin_layout Plain Layout

    ' calculate effective number of alleles '
\end_layout

\begin_layout Plain Layout

    Stat(pop, alleleFreq=[0,1])
\end_layout

\begin_layout Plain Layout

    f0 = [0, 0]
\end_layout

\begin_layout Plain Layout

    ne = [0, 0]
\end_layout

\begin_layout Plain Layout

    for i in range(2):
\end_layout

\begin_layout Plain Layout

        freq = pop.dvars().alleleFreq[i][1:]
\end_layout

\begin_layout Plain Layout

        f0[i] = 1 - pop.dvars().alleleFreq[i][0]
\end_layout

\begin_layout Plain Layout

        if f0[i] == 0:
\end_layout

\begin_layout Plain Layout

            ne[i] = 0
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            ne[i] = 1.
 / sum([(x/f0[i])**2 for x in freq])
\end_layout

\begin_layout Plain Layout

    print '%d
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
t%.3f
\backslash
n' % (pop.gen(), f0[0], f0[1], ne[0], ne[1])
\end_layout

\begin_layout Plain Layout

    return True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can use this function in a python operator
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pyOperator(func=ne, step=5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The biggest difference between 
\family typewriter
pyEval
\family default
 and 
\family typewriter
pyOperator
\family default
 is that 
\family typewriter
pyOperator
\family default
 is no longer evaluated in the population's local namespace.
 You will have to get the vars explicitly using the 
\family typewriter
pop.dvars()
\family default
 function.
 (This also implies that you can do whatever you want to the population.).
 In this example, the function form of the 
\family typewriter
stat
\family default
 operator is used to explicitly calculate allele frequency.
 The results are also explicitly printed using the 
\family typewriter
print
\family default
 command.
 The explicities lead to longer, but clearer program.
 This becomes obvious when you need to calculate and print many statistics.
\end_layout

\begin_layout Standard
The following program (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich3"

\end_inset

) uses the 
\family typewriter
pyOperator
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
pyOperator
\end_layout

\end_inset

 solution.
 In this program, user can input two demographic models as command line
 parameter.
 Two other operators are used
\end_layout

\begin_layout Itemize
A 
\family typewriter
ticToc
\family default
 operator that prints out elapsed time at every 100 generations
\end_layout

\begin_layout Itemize
A 
\family typewriter
pause
\family default
 operator that pause the simulation whenever you press a key.
 You can actually enter a python command shell to examine the results.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich3.py"
lstparams "caption={The whole program},label={reich3}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Section
Option handling
\end_layout

\begin_layout Standard
Everything seems to be perfect until you need to run more simulations with
 different parameters like initial population size.
 Editing the script again and again is out of the question.
 Since this script is a python script, it is tempting to use python modules
 like 
\family typewriter
getopt
\family default
 to parse options from command line.
 A better choice would be using the 
\family typewriter
simuOpt
\family default
 module.
 Using this module properly, your simuPOP should be able to get options
 from short or long command line option, from a configuration file, from
 a tkInter of wxPython dialog, or from user input.
 Taking 
\family typewriter
c:
\backslash
python
\backslash
share
\backslash
simuPOP
\backslash
scripts
\backslash
simuLDDecay.py
\family default
 as an example, you can run this script as follows:
\end_layout

\begin_layout Itemize
use command '
\family typewriter
simuLDDecay.py
\family default
' or double click the program
\end_layout

\begin_layout Itemize
click the help button on the dialog, or run 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -h
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to view help information.
\end_layout

\end_deeper
\begin_layout Standard
enter parameters in a parameter dialog, or use short or long command arguments
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py -s 500 -e 10 --recRate 0.1 --numRep 5 --noDialog
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
use the optimized module by
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --optimized
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
save the parameters to a config file
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --quiet -s 500 -e 10 --saveConfig decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this will result in a config file 
\family typewriter
decay.cfg
\family default
 with these parameters.
\end_layout

\begin_layout Itemize
and of course use 
\family typewriter
-c
\family default
 or 
\family typewriter
--config
\family default
,
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> simuLDDecay.py --config decay.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to load parameters from the config file.
\end_layout

\end_deeper
\begin_layout Standard
The last function is very useful since you frequently need to run many slightly
 different simulations, saving a configuration file along with your results
 will make your life much easier.
\end_layout

\begin_layout Standard
To achieve all the above, you need to write your scripts in the following
 order:
\end_layout

\begin_layout Enumerate
First line:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Write the introduction of the whole script in a module-wise doc string.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'''
\end_layout

\begin_layout Plain Layout

This script will ....
\end_layout

\begin_layout Plain Layout

'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These comments can be accessed as module 
\family typewriter
__doc__
\family default
 and will be displayed as help message.
\end_layout

\end_deeper
\begin_layout Enumerate
Define an option data structure.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

options = [ 
\end_layout

\begin_layout Plain Layout

...
 a dictionary of all user input parameters ...
\end_layout

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These parameters will be handled by simuPOP automatically.
 Users will be able to set them through command line, configuration file,
 Tkinter- or wxPython-based GUI.
 The detailed description of this structure is given in simuPOP reference
 manual.
\end_layout

\end_deeper
\begin_layout Enumerate
Main simulation functions
\end_layout

\begin_layout Enumerate
In the executable part of the script (under 
\family typewriter
__name__ == '__main__'
\family default
), you should call 
\family typewriter
simuOpt.getParam
\family default
 to let 
\family typewriter
simuOpt
\family default
 handle all parameter input for you and obtain a list of parameters.
 You usually need to handle some special cases (
\family typewriter
-h, --saveConfig
\family default
 etc), and they are all standard.
\end_layout

\begin_layout Standard
You will notice that 
\family typewriter
simuOpt
\begin_inset Index
status collapsed

\begin_layout Plain Layout
simuOpt
\end_layout

\end_inset


\family default
 does all the housekeeping things for you, including parameter reading,
 conversion, validation, print usage, save configuration file.
 Since most of the parts are pretty standard, you can actually copy any
 of the scripts under the 
\family typewriter
scripts
\family default
 directory as a template for your new script.
 The following example 
\begin_inset CommandInset ref
LatexCommand ref
reference "reich4"

\end_inset

 shows the beginning and the execution part of the complete 
\family typewriter
reich.py
\family default
 script, which can be found under the doc directory.
 For a complete reference of the Options structure, please refer to the
 reference manual.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "reich4.py"
lstparams "caption={Option handling},label={reich4}"

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Chapter
Introduction to bundled scripts
\end_layout

\begin_layout Standard
Several scripts are bundled with simuPOP, under the 
\family typewriter
/usr/share/simuPOP/scripts
\family default
 directory under a *nix system and 
\family typewriter
c:
\backslash
python25
\backslash
share
\backslash
simuPOP
\backslash
scripts
\family default
 under windows.
 These scripts all use 
\family typewriter
simuOpt
\family default
 module to organize help messages so you can get detailed information about
 the scripts and the parameter used by clicking on help button of the parameter
 dialog, or use commands like '
\family typewriter
simuComplexDisease.py -h'
\family default
 to get the help messages.
\end_layout

\begin_layout Standard
In this chapter, I will briefly explain what these scripts do, from a more
 methodology side of view.
 Be warned, though, that these scripts are less actively maintained than
 simuPOP core and I mostly rely on user bug report to identify problems
 in these scripts.
\end_layout

\begin_layout Section
Examples and teaching scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuLDDecay.py
\end_layout

\begin_layout Standard
This is the simplest script under the 
\family typewriter
scripts
\family default
 directory, showing the decay of linkage disequilibrium under recombination.
 It is intended to be a template for many more such simulations for teaching
 a population genetics course.
 
\end_layout

\begin_layout Subsection

\family typewriter
demoPyOperator.py
\end_layout

\begin_layout Standard
This script demonstrate the use of a during-mating pure-Python operator.
 Since such operator will be called very frequently (at each mating event),
 the performance of such operators tend to be bad.
 Since most of the task performed by such an operator can be achieved by
 other means (for example a post-mating operator), it is rarely used.
\end_layout

\begin_layout Section
Utility scripts
\end_layout

\begin_layout Standard
These scripts are not necessarily written in simuPOP.
 It is written to facilitate the use of simuPOP.
\end_layout

\begin_layout Subsection

\family typewriter
simuViewPop.py
\end_layout

\begin_layout Standard

\family typewriter
simuViewPop.py
\family default
 is a 
\family typewriter
wxPython
\family default
 application written to view simuPOP populations.
 You will need to have 
\family typewriter
wxPython
\family default
 installed to use it.
 There are two ways to use this script:
\end_layout

\begin_layout Itemize
Import this script and call 
\family typewriter
viewPop(pop)
\family default
 to view population 
\family typewriter
pop
\end_layout

\begin_layout Itemize
Run from command line
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ simuViewPop.py /path/to/population.txt
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This script shows four tabs to show the information of a population
\end_layout

\begin_layout Itemize
basic information
\end_layout

\begin_layout Itemize
a table view of all genotype
\end_layout

\begin_layout Itemize
calculation of statistics, with a tree-view of local name space
\end_layout

\begin_layout Itemize
save to other formats
\end_layout

\begin_layout Subsection

\family typewriter
simuCluster.py
\end_layout

\begin_layout Standard

\family typewriter
simuCluster.py
\family default
 helps you manage a large number of simulations on a cluster system.
 You only need to maintain a single job-description file and 
\family typewriter
simuCluster.py
\family default
 will help you submit them.
 The command line options are
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ simuCluster.py -l simulation.lst -a  -r -f key=val jobs
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Itemize

\family typewriter
-l (--list) list:
\family default
 a list file (actually a python file) that specifies variale 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\end_layout

\begin_layout Itemize

\family typewriter
-a (--all):
\family default
 use all jobs defined in the list file
\end_layout

\begin_layout Itemize

\family typewriter
-r (--run):
\family default
 run the jobs, by default, this script will only list the jobs and generate
 job file.
\end_layout

\begin_layout Itemize

\family typewriter
-p (--repeat) n:
\family default
 execute command 
\family typewriter
n
\family default
 times.
\end_layout

\begin_layout Itemize

\family typewriter
-f (--force):
\family default
 force the execution even if the generated job scripts have 
\family typewriter
$
\family default
 character.
\end_layout

\begin_layout Itemize

\family typewriter
key=val:
\family default
 additional subsitution key/value pair that will be used to replace 
\family typewriter
$key
\family default
 in the job scripts.
 Commonly used, or machine-specific, 
\family typewriter
key=val
\family default
 pairs can be defined in a configuration file 
\family typewriter
$HOME/.simuCluster
\family default
 with content like:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

command = 'bsub -J $name <'
\end_layout

\begin_layout Plain Layout

queue = 'batch'
\end_layout

\begin_layout Plain Layout

job_dir = '/scratch/jobs'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
job:
\family default
 a list of jobs, a simple form of regular expression can be used.
 Namely, 
\family typewriter
job1_3
\family default
 means 
\family typewriter
job1
\family default
, 
\family typewriter
job2
\family default
 and 
\family typewriter
job3
\family default
.
\end_layout

\begin_layout Standard
The list file can be any python script, that defines variables 
\family typewriter
script
\family default
 and 
\family typewriter
joblist
\family default
 after execution, where 
\family typewriter
script
\family default
 is a simple script with variables 
\family typewriter
$name
\family default
 or 
\family typewriter
${name}
\family default
.
 and 
\family typewriter
joblist
\family default
 is a string with lines of comma (can be other charater if you define a
 variable 
\family typewriter
separator
\family default
) separated fields, that will be used to replace 
\family typewriter
$0 (
\family default
also 
\family typewriter
$name
\family default
, the name of a job)
\family typewriter
, $1, $2, ...

\family default
 etc.
\end_layout

\begin_layout Standard
Then, what 
\family typewriter
simuCluster.py
\family default
 will do is process this list file, replace 
\family typewriter
$name, $var, $1, $2 ...

\family default
 etc with environmental variables, command line paramters, configuration
 file and joblist and generate job scripts.
 If 
\family typewriter
-r
\family default
 is given, the job will be submitted.
 Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "joblist"

\end_inset

 gives a sample job list file.
 Command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ python scripts/simuCluster.py -l joblist.lst -a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will generate files 
\family typewriter
job1.pbs
\family default
, ...
 and if 
\family typewriter
-r
\family default
 option is given, these files will be submitted using 
\family typewriter
qsub job1
\family default
, unless you specify another 
\family typewriter
command
\family default
 variable.
\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "joblist.lst"
lstparams "caption={A sample job list file},label={joblist}"

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
simuUtil.py
\end_layout

\begin_layout Standard

\family typewriter
simuUtil.py
\family default
 is a standard part of simuPOP and is installed along with 
\family typewriter
simuPOP.py
\family default
 (other utility scripts are installed under 
\family typewriter
scripts
\family default
 directory).
 These function include
\end_layout

\begin_layout Enumerate
extra python operators, the two potentially useful ones are
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
tab
\end_layout

\begin_layout Itemize

\series bold
endl
\end_layout

\begin_layout Standard
These two operators output, as their names suggest, 
\family typewriter
'
\backslash
t'
\family default
 and 
\family typewriter
'
\backslash
n'
\family default
.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined demographic functions:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
constSize
\end_layout

\begin_layout Itemize

\family typewriter
LinearExpansion
\end_layout

\begin_layout Itemize

\family typewriter
ExponentialExpansion
\end_layout

\begin_layout Itemize

\family typewriter
InstantExpansion 
\end_layout

\begin_layout Standard
These functions return a demographic function with given event times.
\end_layout

\end_deeper
\begin_layout Enumerate
Pre-defined migration rate functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
MigrIslandRates
\end_layout

\begin_layout Itemize

\family typewriter
MigrSteppingStoneRates
\end_layout

\begin_layout Standard
These functions return a migration matrix of given migration model and parameter.
\end_layout

\end_deeper
\begin_layout Enumerate
Save and load from other formats
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
SaveFstat (saveFstat), LoadFstat
\end_layout

\begin_layout Itemize

\family typewriter
LoadGCData
\end_layout

\begin_layout Itemize

\family typewriter
SaveLinkage (saveLinkage), LoadLinkage
\end_layout

\begin_layout Itemize

\family typewriter
SaveQTDT
\end_layout

\begin_layout Itemize

\family typewriter
SaveCSV
\end_layout

\begin_layout Standard
These functions save and load simuPOP populations in various formats.
\end_layout

\end_deeper
\begin_layout Enumerate
Gene mapping functions
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
TDT_gh, LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
ChiSq_test
\end_layout

\begin_layout Itemize

\family typewriter
LOD_merlin, VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_TDT_gh, Sibpair_LOD_gh
\end_layout

\begin_layout Itemize

\family typewriter
Sibpair_LOD_merlin, QtraitSibs_Reg_Merlin, QtriatSibs_VC_merlin
\end_layout

\begin_layout Itemize

\family typewriter
LargePeds_Reg_merlin, LargePeds_VC_merlin
\end_layout

\begin_layout Standard
These functions call GENEHUNTER or MERLIN to map disease genes.
 Various parameters like penetrance, quantitative trait functions, sample
 size are needed.
 These functions are tested only under Linux and are subject to frequent
 changes.
\end_layout

\end_deeper
\begin_layout Standard
In general, these utility functions are provided as it is and you may need
 to read the source code to make it work should errors occur.
 Unit test will be added later when these functions are more or less stablized/s
tandardized.
\end_layout

\begin_layout Section
General simulation scripts
\end_layout

\begin_layout Subsection

\family typewriter
simuCDCV.py
\end_layout

\begin_layout Standard
This script is used to simulate the evolution of allelic spectra (number
 and allele freqencies of alleles at a locus) for monogenic or polygenic,
 rare or common diseases.
 The goal of the simulations is to validate the common disease common variant
 hypothesis
\begin_inset CommandInset citation
LatexCommand citep
key "Lander1996"

\end_inset

.
 I used this script to verify two theoretical models proposed by Pritchard
 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Pritchard2001"

\end_inset

 and Reich and Lander 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "Reich2001a"

\end_inset

.
 The results are published in 
\begin_inset CommandInset citation
LatexCommand citet
key "Peng2007"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuRecHotSpots.py
\end_layout

\begin_layout Standard
I wrote this script to simulate the evolution of a chromosome, subject to
 recombination of uniform recombination rate.
 Using this script, I would like to see how many recombination hotspots
 can be observed if there is no physical recombination hotspots, i.e.
 actual variation of recombination rate on the chromosome.
 The population is saved in LDhat format to be analyzed by LDhat 
\begin_inset CommandInset citation
LatexCommand citep
key "Myers2005"

\end_inset

.
\end_layout

\begin_layout Subsection

\family typewriter
simuNeutralSNPs.py
\end_layout

\begin_layout Standard
This script is adapted from 
\family typewriter
simuRecHotSplots.py
\family default
, the main purpose is to observe the evolution of allele frequency under
 more complicated scenarios than classical population genetics theory can
 handle.
\end_layout

\begin_layout Section
Simulations of the evolution of complex human diseases
\end_layout

\begin_layout Subsection

\family typewriter
simuForward.py
\end_layout

\begin_layout Standard
This script presents my first attempt to simulate the evolution of complex
 human diseases in a forward-time manner and generate samples for gene mapping
 purposes.
 The script goes like this:
\end_layout

\begin_layout Itemize
initialize a small (likely 10K) founder population with a few haplotypes
\end_layout

\begin_layout Itemize
burn-in this founder population for a few thousands generations to break
 down linkage disequilibrium
\end_layout

\begin_layout Itemize
after this stage, the population starts to expand.
 It can be split into several subpopulations (simulate human subpopulations),
 with and/or without migration and be merged back to a single population.
\end_layout

\begin_layout Itemize
At the beginning of population expansion, several disease mutants are introduced
 to the population.
 Positive or negative selection is applied to individuals with disease mutants.
 We hope to harvest a final population with certain disease allele frequency.
\end_layout

\begin_layout Standard
This process is problematic in that
\end_layout

\begin_layout Itemize
The disease allele can get lost
\end_layout

\begin_layout Itemize
We can not control the disease allele frequency at the last generation
\end_layout

\begin_layout Standard
To solve the first problem, I re-introduce disease mutants if they get lost.
 I also apply, optionally, strong positive selection pressure during an
 disease-introduction stage to artificially boost the disease allele frequency,
 until it reach a designed range of allele frequencies.
 If the disease allele still get lost after the disease introduction stage,
 the simulation will be restarted.
 By manipulating parameters like designed allele frequency and population
 size, the impact of genetic drift can be moderate and give me a final populatio
n with designed disease allele frequency.
 This simulation scenario roughly follows that of Calafell et al 
\begin_inset CommandInset citation
LatexCommand citet
key "Calafell2001"

\end_inset

.
\end_layout

\begin_layout Standard
To save simulation time, population at the end of the burnin stage is reused
 if simulation gets restarted.
\end_layout

\begin_layout Subsection

\family typewriter
simuComplexDisease.py
\end_layout

\begin_layout Standard
The previous simulation scenario is not satisfactory in that
\end_layout

\begin_layout Itemize
The age of mutant is fixed, but they should be somehow random
\end_layout

\begin_layout Itemize
Mutants can get lost and the simulation needs to be restarted repeatedly.
 This problem can be severe if we simulate mutants under purifying selection.
\end_layout

\begin_layout Itemize
We still can not control the final disease allele frequency well.
 The variation of disease allele frequencies in the final generation makes
 fair comparison between gene mapping methods difficult.
\end_layout

\begin_layout Standard
Therefore, I propose a simulation method, which is still under review, that
\end_layout

\begin_layout Itemize
simulate, backward in time, the trajectory of disease allele frequencies.
 The age of mutant is determined by trajectory length, and is random.
\end_layout

\begin_layout Itemize
Then, the script simulate forward in time using a controlled random mating
 scheme that follow the pre-simulated disease allele trajectories.
 The resulting population will have exact designed allele frequency.
\end_layout

\begin_layout Standard
An obvious advantage of this approach is that the simulation does not have
 to be restarted, and the disease allele frequency at the last generation
 can be controlled exactly.
\end_layout

\begin_layout Subsection

\family typewriter
analComplexDisease.py
\end_layout

\begin_layout Standard
I use 
\family typewriter
simuComplexDiseas.py
\family default
 to simulate many population under various genetic and demographic models.
 The resulting populations are analyzed by this script.
 The analyses involved are
\end_layout

\begin_layout Itemize
merlin variance component method 
\begin_inset CommandInset citation
LatexCommand citep
key "Abecasis2002,Amos1994"

\end_inset


\end_layout

\begin_layout Itemize
merlin regression 
\begin_inset CommandInset citation
LatexCommand citep
key "sham2002"

\end_inset


\end_layout

\begin_layout Itemize
TDT 
\begin_inset CommandInset citation
LatexCommand citep
key "Spielman1993"

\end_inset


\end_layout

\begin_layout Itemize
Linkage, and
\end_layout

\begin_layout Itemize
Case control association study.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "simuPOP"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
