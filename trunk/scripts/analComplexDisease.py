#!/usr/bin/env python
#
# Purpose:    generate dataset for common complex disease 
#                     with certain number of disease susceptibility
#                     loci.
#
# Bo Peng (bpeng@rice.edu)
#
# $LastChangedDate: 2005-10-31 17:29:34 -0600 (Mon, 31 Oct 2005) $
# $Rev: 78 $
#
# Known bugs:
#     None
# 

"""

Introduction
=============

This program analyze the dataset generated by simuComplexDisease.py, it will

    1. Apply single or multi-locus penetrance function to determine 
       affectedness of each individual. Note that the penetrance model would
       better be compatible to the fitness model. You would not want to assign
       affectedness to individuals according to disease susceptibility locus 
       (DSL) one while selection was working on DSL two.
    2. Case control and affected sibpair samples are drawn and saved in simuPOP
       and Linkage format, using parameters given.
    3. If geneHunter is available, it will be used to analyze affected sibpair 
       samples using TDT and Linkage method. Association mapping will also be
       done for SNP datasets if rpy is available.

Please refer to simuComplexDisease.py and see how the dataset is generated.

The program is written in Python using simuPOP modules. For more information,
please visit simuPOP website http://simupop.sourceforge.net .


Penetrance
==========

Since we assume that fitness only depends on genotype, not affectedness status,
we do not care who are affected during evolution. This has to change at the 
last generation where different sampling schemes will be applied to the 
population. Several customizable penetrance schemes will be used. As a matter
of fact, if there is no selection against any DS allele, we can use any
of the penetrance functions:

    1. recessive single-locus and heterogeneity multi-locus model: 
       At DSL i, penetrance P_i will be computed as
           0, 0, p_i
       for genotype
           AA, Aa, aa    (A is wild type)
       where p_i are penetrance factors (that can vary between DSL).

       The overall penetrance is 
           1 - Prod(1-P_i)
    
    2. additive single-locus and heterogeneity multi-locus model: 
       For each DSL, the penetrance P_i is
            0, p_i/2, p_i
       for genotype
            AA, Aa, aa
       where the overall penetrance takes the form of
            1 - Prod( 1- P_i)
       This is the heterogeneity model proposed by Neil Risch (1990).
         
    3. Customized, you can write your own penetrance function. Which means that 
       you will have to modify analComplexDisease.py itself.
    

Samples and Output
==================

Different kinds of samples will be draw from the final large population.

    1. population based case control sample: 
       Regardless of family structure, N cases and N controls will
       be drawn randomly.
    
    2. affected and unaffected sibpairs:
       N/4 affected and N/4 unaffected (sibling) families (two siblings and
       two parents) will be drawn. (Sample size is N cases and N controls
       when counting individuals.)

The datasets are saved in native simuPOP format and in Linkage format.
DSL markers are removed so there will be no marker that is directly 
linked to the disease.

All files are put under a specified folder. They are organized by
penetrance methods. The result will be written in a file result.sav
which can be loaded into python using the pickle module.


Gene mapping
============

If the location of genehunter is specified. It will be applied to all affected
sibpair samples. If R/Rpy is availablem, the basic chi-sq assocition tests will
be applied to case control samples. No adjustment for multiple testing is done.

"""

import simuOpt, simuUtil
import os, sys, types, exceptions, os.path, re, math, time, copy, operator

#
# declare all options. getParam will use these information to get parameters
# from a tk/wxPython-based dialog, command line, config file or user input
#
# detailed information about these fields is given in the simuPOP reference
# manual.
options = [
    {'arg': 'h',
     'longarg': 'help',
     'default': False, 
     'description': 'Print this usage message.',
     'allowedTypes': [types.NoneType, type(True)],
     'jump': -1                    # if -h is specified, ignore any other parameters.
    },
    {'longarg': 'markerType=',
     'default': 'microsatellite',
     'allowedTypes': [types.StringType],
     'configName': 'Marker type used',
     'prompt': 'Marker type used (microsatellite)',
     'description': '''Marker type used to generated the sample. This is important
        since the file formats are not compatible between binary and standard
        simuPOP modules''',
     'validate':    simuOpt.valueOneOf([ 'microsatellite', 'SNP']),
     'chooseOneOf': ['microsatellite', 'SNP']
    }, 
    {'longarg': 'dataset=',
     'default': 'simu.bin',
     'allowedTypes': [types.StringType],
     'configName': 'Dataset to analyze',
     'prompt': 'Dataset to analyze (simu.bin):    ',
     'description': 'Dataset generated by simuComplexDisease.py. ',
     'validate':    simuOpt.valueValidFile()
    },
    {'longarg': 'peneFunc=',
     'default': ['additive'],
     'configName': 'Penetrance function',
     'allowedTypes': [types.StringListType],
     'prompt': 'Penetrance to be used: (recessive):    ',
     'description': ''' Penetrance functions to be applied to the final
        population. Two penetrance fucntions are provided, namely recessive or additive
        single-locus model with heterogeneity multi-locus model. You can define another
        customized penetrance functions by modifying this script. ''',
     'allowedTypes': [types.ListType, types.TupleType],
     'validate':    simuOpt.valueListOf( simuOpt.valueOneOf(['recessive', 'additive', 'custom'])),
     'chooseOneOf': [ 'recessive', 'additive', 'custom']
    },
    {'longarg': 'penePara=',
     'default': [0.5],
     'configName': 'Penetrance parameters',
     'prompt': 'Penetrance parameter used by penetrance functions. \n' + 
            "Can be an array (for each DSL). (0.5) ",
     'description': '''Penetrance parameter for all DSL. An array of parameter 
        can be given to each DSL. The meaning of this parameter differ by penetrance model.
        For a recessive model, the penetrance is 0,0,p for genotype AA,Aa,aa (a is disease
        allele) respectively. For an additive model, the penetrance is 0,p/2,p respectively.''',
     'allowedTypes': [types.ListType, types.TupleType],
     'validate':   simuOpt.valueOneOf([ 
             simuOpt.valueBetween(0,1), simuOpt.valueListOf(simuOpt.valueBetween(0,1))] )
    },
    {'longarg': 'sampleSize=',
     'default': 800,
     'configName':    'Sample size',
     'allowedTypes':    [types.IntType, types.LongType],
     'prompt':    'Size of the samples (800):    ',
     'description':    '''Size of the samples, that will mean N/4 affected sibpair families (of size 4),
                N/2 cases and controls etc. ''',
     'validate':    simuOpt.valueGT(1)
    },
    {'longarg': 'numSample=',
     'default': 2,
     'configName':    'Sample number',
     'allowedTypes':    [types.IntType, types.LongType],
     'prompt':    'Number of samples for each penetrance function (2): ',
     'description':    '''Number of samples to draw for each penetrance function. ''',
     'validate':    simuOpt.valueGT(0)
    },
    {'longarg': 'outputDir=',
     'default': '.',
     'allowedTypes': [types.StringType],
     'configName': 'Output directory',
     'prompt': 'Save datasets into directory (.):    ',
     'description': 'Directory into which the datasets will be saved. ',
     'validate':    simuOpt.valueValidDir()
    },
    {'longarg': 'geneHunter=',
     'default': 'gh',
     'allowedTypes': [types.StringType],
     'configName': 'Location of gene hunter',
     'prompt': 'Provide location of gene hunter ():    ',
     'description': '''Location of gene hunter executable. If provided,
                the TDT and Linkage method of genehunter will be applied to affected sibpair 
                samples.'''
    },
    # another two hidden parameter
    {'longarg': 'reAnalyzeOnly=',
     'default': False,
     'allowedTypes': [type(True)],
     'description': '''If given in command line, redo the analysis.'''
    },
    {'longarg': 'saveConfig=',
     'default': 'anal.cfg',
     'allowedTypes': [types.StringType, types.NoneType],
     'configName': 'Save configuration',
     'prompt': 'Save current configuration to file (anal.cfg):    ',
     'description': 'Save current paremeter set to specified file.'
    },
    {'arg': 'v',
     'longarg': 'verbose',
     'default': False,
     'allowedTypes': [types.NoneType, types.IntType],
     'description': 'Verbose mode.'
    },
]


# penetrance generator functions. They will return a penetrance function
# with given penetrance parameter
def recessive(pen):
    ''' recessive single-locus, heterogeneity multi-locus '''
    def func(geno):
        val = 1
        for i in range(len(geno)/2):
            if geno[i*2] + geno[i*2+1] == 2:
                val *= 1 - pen
        return 1-val
    return func
    

def additive(pen):
    ''' additive single-locus, heterogeneity multi-locus '''
    def func(geno):
        val = 1
        for i in range(len(geno)/2):
            val *= 1 - (geno[i*2]+geno[i*2+1])*pen/2.
        return 1-val
    return func


# if you need some specialized penetrance function, modify this
# function here.
# NOTE:
# 
# 1. geno is the genptype at DSL. For example, if your DSL is [5,10]
#     geno will be something like [0,1,1,1] where 0,1 is the genotype at 
#     locus 5 and 1,1 is the genotype at locus 10.
# 2. in simuComplexDisease.py, 0 is wild type, 1 is disease allele.
def custom(pen):
    ''' a penetrance function that focus on the first DSL '''
    def func(geno):
        return 1
    return func


def getOptions(details=__doc__):
    ''' get options from options structure,
        if this module is imported, instead of ran directly,
        user can specify parameter in some other way.
    '''
    # get all parameters, __doc__ is used for help info
    allParam = simuOpt.getParam(options, 
        '''    This program simulates the evolution of a complex common disease, subject 
     to the impact of mutation, migration, recombination and population size change. 
     Click 'help' for more information about the evolutionary scenario.''', details, nCol=2)
    # when user click cancel ...
    if len(allParam) == 0:
        sys.exit(1)
    # -h or --help
    if allParam[0]:    
        print simuOpt.usage(options, __doc__)
        sys.exit(0)
    # --saveConfig
    simuOpt.saveConfig(options, allParam[-2], allParam)
    # --verbose or -v (these is no beautifying of [floats]
    if allParam[-1]:                 # verbose
        simuOpt.printConfig(options, allParam)
    # return the rest of the parameters
    return allParam[1:-2]



def drawSamples(pop, peneFunc, penePara, numSample, saveFormat, dataDir, reAnalyzeOnly ):
    ''' get samples of different type using a penetrance function,
        and save samples in dataDir in saveFormat
        
        pop: population
        peneFunc: penetrance function name, can be recessive1 etc
        penePara: parameter of the penetrance function
        numSample: number of samples for each penetrance settings
        saveFormat: a list of format to save
        dataDir: where to save samples        
        reAnalyzeOnly: load populations only

        return a report
    '''
    # first, apply peneFunction
    #
    if 'recessive' in peneFunc:    # start with recessive
        print "Using recessive penetrance function"
        penFun = recessive(penePara)
    elif 'additive' in peneFunc: # start with additive
        print "Using additive penetrance function"
        penFun = additive(penePara)
    elif 'custom' in peneFunc: # start with custom
        print "Using customized penetrance function"
        penFun = custom(penePara)    
    # this may or may not be important. Previously, we only
    # set penetrance for the final genetion but linkage methods
    # may need penetrance info for parents as well.
    for i in range(0, pop.ancestralDepth()+1):
        # apply penetrance function to all current and ancestral generations
        pop.useAncestralPop(i)
        PyPenetrance(pop, loci=pop.dvars().DSL, func=penFun)
    # reset population to current generation.
    pop.useAncestralPop(0)
    #
    if saveFormat == []:
        return report
    # 
    report += "<ul>"
    # here we are facing a problem of using which allele frequency for the sample
    # In reality, if it is difficult to estimate population allele frequency,
    # sample frequency has to be used. Otherwise, population frequency should 
    # be used whenever possible. Here, we use population allele frequency, with only
    # one problem in that we need to remove frequencies at DSL (since samples do not
    # have DSL).
    af = []
    Stat(pop, alleleFreq=range(pop.totNumLoci()))
    for x in range( pop.totNumLoci() ):
        if x not in pop.dvars().DSL:
            af.append( pop.dvars().alleleFreq[x] )
    # start sampling
    for ns in range(numSample):
        report += "<li> sample %d <ul>" % (ns+1)
        penDir = "%s%s%s%d%s" % (dataDir, os.sep, peneFunc, ns, os.sep)
        # relative path used in report
        relDir = '%s%s%s%d%s' % (dataDir.split(os.sep)[-1], os.sep, peneFunc, ns, os.sep)
        # 
        _mkdir(penDir)
        if reAnalyzeOnly:
            print "Loading sample ", ns+1, ' of ', numSample
        else:
            print "Generating sample ", ns+1, ' of ', numSample
        # 1. population based case control
        # get number of affected
        Stat(pop, numOfAffected=True)
        print "Number of affected individuals: ", pop.dvars().numOfAffected
        print "Number of unaffected individuals: ", pop.dvars().numOfUnaffected
        nCase = min(pop.dvars().numOfAffected , N/2)
        nControl = min(pop.dvars().numOfUnaffected, N/2)
            
        try:
            # if N=800, 400 case and 400 controls
            binFile =    penDir + "caseControl.bin"
            if reAnalyzeOnly:
                try:
                    # try to load previous sample
                    s = [LoadPopulation(binFile)]
                except Exception, err:
                    print "Can not load exisiting sample. Can not use --reAnalyzeOnly option"
                    raise err
            else:
                s = CaseControlSample(pop, nCase, nControl)
                # remove DSL
                s[0].removeLoci(remove=pop.dvars().DSL)
            report += "<li> Case control sample of size %d, " % s[0].popSize()
            # process sample
            if 'simuPOP' in saveFormat:
                report += 'saved in simuPOP binary format:'
                if not reAnalyzeOnly:
                    print "Write to simuPOP binary format"
                    s[0].savePopulation(binFile)
                report += '<a href="%scaseControl.bin"> caseControl.bin</a> ' % relDir
            report += '</li>'
        except Exception, err:
            print "Can not draw case control sample. "
            print type(err), err
        #
        # 2. affected and unaffected sibpairs
        # this is difficult since simuPOP only has
        # methods to draw one kind of sibpairs and 
        try:
            # get number of affected/unaffected sibpairs
            # There may not be enough to be sampled
            AffectedSibpairSample(pop, countOnly=True)
            nAff = min(pop.dvars().numAffectedSibpairs, N/4)
            print "Number of (both) affected sibpairs: ", pop.dvars().numAffectedSibpairs
            AffectedSibpairSample(pop, chooseUnaffected=True, countOnly=True)
            print "Number of unaffected sibpairs: ", pop.dvars().numAffectedSibpairs
            nUnaff = min(pop.dvars().numAffectedSibpairs, N/4)
            # generate or load sample
            binFile1 = penDir + "affectedSibpairs.bin"
            binFile2 = penDir + "unaffectedSibpairs.bin"
            if reAnalyzeOnly:
                try:
                    affected = [LoadPopulation(binFile1) ]
                    unaffected = [LoadPopulation(binFile2) ]
                except Exception, err:
                    print "can not load sample, please do not use --reAnalyzeOnly option"
                    raise err
            else:
                #
                affected = AffectedSibpairSample(pop, name='sample1',
                    size=nAff)
                # now chose unaffected. These samples will not overlap
                # 
                # NOTE: however, you may not be able to easily merge these two 
                # samples since they may shared parents.
                #
                # Use another name to avoid conflict since these sampled are stored
                # in local namespace
                unaffected = AffectedSibpairSample(pop, chooseUnaffected=True,
                    name='sample2', size=nUnaff)
                # remove DSL
                affected[0].removeLoci(remove=pop.dvars().DSL)
                unaffected[0].removeLoci(remove=pop.dvars().DSL)
            # return sample
            #
            report += "<li> Affected sibpair sample of size %d (affected) %d (unaffected)" % \
                ( affected[0].popSize(), unaffected[0].popSize() ) 
            if 'simuPOP' in saveFormat:
                report += ' saved in simuPOP binary format:'
                report += '<a href="%saffectedSibpairs.bin"> affectedSibpairs.bin</a>, ' % relDir
                if not reAnalyzeOnly:
                    print "Write to simuPOP binary format"
                    affected[0].savePopulation(binFile1)
                    unaffected[0].savePopulation(binFile2)
                report += '<a href="%sunaffectedSibpairs.bin"> unaffectedSibpirs.bin</a>, ' % relDir
            if 'Linkage' in saveFormat:
                report += ' saved in linkage format by chromosome:'
                linDir = penDir + "Linkage" + os.sep
                _mkdir(linDir)
                report +=    '<a href="%sLinkage">affected</a>, ' % relDir
                if not reAnalyzeOnly:
                    print "Write to linkage format"
                    for ch in range(0, pop.numChrom() ):
                        SaveLinkage(pop=affected[0], popType='sibpair', output = linDir+"/Aff_%d" % ch,
                            chrom=ch, recombination=pop.dvars().recRate[0],
                            alleleFreq=af, daf=0.1)                
                    for ch in range(0,pop.numChrom() ):
                        SaveLinkage(pop=unaffected[0], popType='sibpair', output = linDir+"/Unaff_%d" % ch,
                            chrom=ch, recombination=pop.dvars().recRate[0],                                                        
                            alleleFreq=af, daf=0.1)                
                report += '<a href="%sLinkage">unaffected</a>' % relDir
            report += '</li>'
        except Exception, err:
            print type(err)
            print err
            print "Can not draw affected sibpars."
        report += "</ul></li>"
        # save these samples
    report += "</ul>"
    return report


# create output directory if necessary
# a more friendly version of mkdir
def _mkdir(d):
    try:
        if not os.path.isdir(d):
            os.makedirs(d)
    except:
        print "Can not make output directory ", d
        sys.exit(1)


def popStat(pop, p, wt):
    'Calculate population statistics '
    # K -- populaiton prevalance
    print "Calculating population statistics "
    Stat(pop, numOfAffected=True)
    result = {}
    result[p+'_K'] = pop.dvars().numOfAffected * 1.0 / pop.popSize()
    # P11 = [ ] = proportion of 11 | affected, 
    # P12 = [ ] = proportion of 12 | affected
    DSL = pop.dvars().DSL
    P11 = [0.]*len(DSL)
    P12 = [0.]*len(DSL)
    P22 = [0.]*len(DSL)
    for ind in range(pop.popSize()):
        if pop.individual(ind).affected():
            for x in range(len(DSL)):
                s1 = pop.individual(ind).allele(DSL[x], 0)
                s2 = pop.individual(ind).allele(DSL[x], 1)
                if s1 == wt and s2 == wt:
                    P11[x] += 1
                elif s1 == wt+1 and s2 == wt+1:
                    P22[x] += 1
                else:
                    P12[x] += 1
                    
    N = pop.dvars().numOfAffected
    result[p+'_P11'] = [ x/N for x in P11 ]
    result[p+'_P12'] = [ x/N for x in P12 ]
    result[p+'_P22'] = [ x/N for x in P22 ]
    result[p+'_Fprime'] = [ (P12[x]/2. + P22[x])/N for x in range(len(DSL)) ]
    # Ks = Pr(Xs=1 | Xp=1 ) = Pr(Xs=1, Xp=1) | P(Xp=1)
    Xsp = 0.
    for ind in range(pop.popSize()/2):
        s1 = pop.individual(ind*2).affected()
        s2 = pop.individual(ind*2+1).affected()
        if s1 and s2:
            Xsp += 1
    result[p+'_Ks'] = 2*Xsp / pop.dvars().numOfAffected
    # Lambda = Ks/K
    result[p+'_Ls'] = result[p+'_Ks'] / result[p+'_K']
    return result
     
    
def analyzePopulation(dataset, peneFunc, penePara, N, 
        numSample, outputDir, geneHunter, reAnalyzeOnly):
    '''
    This function organize all previous functions and
        1. Load a population
        2. apply different kinds of penetrance functions
        3. draw sample
        4. save samples
        5. apply TDT, Linkage and chi-sq tests
        6. return a result dictionary
    '''
    res = {}
    # load population
    pop = LoadPopulation(dataset)
    #
    res.update({
        'dataset':  dataset,
        'logfile':  dataset[0:-4] + '.log',
        'alleleFreq':   [1- pop.dvars().alleleFreq[i][0] for i in pop.dvars().DSL],
        'pene==Func':   peneFunc,
    })
    # get all the variables from pop
    res.update(pop.vars())
    #
    # apply penetrance and get numSample for each sample
    summary += "<h3>Samples using different penetrance function</h3>\n"
    # now, deal with each penetrance ...
    drawSamples(pop, 
        peneFunc, penePara, # penetrance and parameter
        numSample,        # number of sample for each setting
        saveFormat,     # save samples in which format
        outputDir,            # directory to save files
        reAnalyzeOnly # whether or not load sample directly
    )
    # calculate population statistics like prevalence
    res.update( popStat(pop, peneFunc[p]) )
    # for each sample
    for sn in range(numSample):
        print "Processing sample %s%d" % ( peneFunc, sn)
        # save these samples
        penDir = outputDir + "/" + peneFunc + str(sn)
        relDir = '%s/%s%d/' % (outputDir, peneFunc, sn)
        _mkdir(penDir)

        # if there is a valid gene hunter program, run it
        (suc,res) = TDT_gh(pop, geneHunter, -math.log10(0.05/pop.totNumLoci()), 
            penDir, "/Linkage/Aff", penDir + "/TDT.eps", penDir + "/TDT.jpg")
     return (pop, res)


if __name__ == '__main__':
    allParam = getOptions()
    # unpack options
    (markerType, dataset, peneFunc, peneParaTmp, N, numSample, outputDir,
        geneHunter, reAnalyzeOnly) = allParam
    # load simuPOP libraries
    if markerType == 'microsatellite':
        simuOpt.setOptions(alleleType='short', quiet=True)
    else:
        simuOpt.setOptions(alleleType='binary', quiet=True)
    #
    from simuPOP import *
    from simuUtil import *
    #
    # construct peneFunc and penePara in case that penePara is a list
    expandedPeneFunc = []
    expandedPenePara = []
    for p in range(len(peneFunc)):
        if type(penePara[p]) in [types.IntType, types.FloatType, types.LongType]:
            expandedPeneFunc.append( peneFunc[p])
            expandedPenePara.append( penePara[p])
        elif type(penePara[p]) in [types.TupleType, types.ListType]:
            for x in penePara[p]:
                expandedPeneFunc.append( peneFunc[p] + str(x) )
                expandedPenePara.append( x )
    #
    # outputDir should already exist
    (pop, res) = analyzePopulation(dataset,
        expandedPeneFunc, expandedPenePara, N, numSample, outputDir, 
        geneHunter, reAnalyzeOnly)




