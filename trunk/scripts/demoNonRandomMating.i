%module demoNonRandomMating_cpp

/*
 This file demonstrates how to implement some functions in C++, and wrap
 them so that they can be imported into python. This is basically how simuPOP
 is written, and is an important technique to improve the efficiency of
 your simuPOP script.

 simuPOP's hybrid- and pure- Python operators and mating schemes provide a
 very powerful and flexible interface to implement cutsomized genetic effects
 and mating schemes. However, because these functions are implemented in Python,
 they can significantly reduce the performance of your simuPOP script if complex
 algorithms are involved, and are called repeatedly. This problem can be 
 addressed by implementing these functions in C++.

 This file is a SWIG interface file. It is usually used to wrap another C/C++
 header file. However, for simple functions, one can 'inline' the C/C++ 
 functions in this file. Please refer to the SWIG website for details on
 how to use SWIG. Note that debugging is easier if separate files are used.

 To compile and load functions defined in this interface file, you will need
 to:

 1. download and install SWIG.
 2. compile this interface file using command
	A wrapper file demoNonRandomMating_wrap.cxx will be generated.
	> swig -python -templatereduce -c++ -shadow -nodefaultctor  -keyword demoNonRandomMating.i
	Under unix/linux, using g++, you can compile this file using
	> g++ -fpic -c demoNonRandomMating_wrap.cxx -I /usr/local/include/python2.5/
	> g++ -shared demoNonRandomMating_wrap.o /usr/lib64/libstdc++.so.5 -o _demoNonRandomMating_cpp.so
	You can then try to import your module using
	> python -c 'import demoNonRandomMating_cpp'

Note that options used are system dependent. It is important to note the _ before the .so
module name. XXX.py is generated by swig, which import _XXX.so.

*/

/*
 To pass Python lists to C++ functions, and to return C++ vectors to Python,
 you will need to tell SWIG how to convert between them. The following
 code includes SWIG's STL (standard template libraries) header files, and
 instantialize the types of vectors you will use.

 In this example, we will pass the location of individuals as std::vector<double>,
 and return chosen parents as std::pair.
*/

// std_vector.i for std::vector
%include "std_vector.i"
%template() std::vector<double>;

// stl.i for std::pair
%include "stl.i"
%template() std::pair<unsigned long, unsigned long>;

%inline
%{
/*
You can put arbitrary regular C/C++ code in this 'inline' block.
*/

#include <vector>
using std::vector;

#include <utility>
using std::pair;

// for rand and srand
#include <stdlib.h>

/*
The following can be implemented in C or C++. The C++ way of using a class
is presented. An object of this class will be created from Python, and be used
like a regular Python class.

You can also define C functions and call them from Python.

*/
class parentsChooser_cpp
{

public:
	vector<double> male_x;
	vector<double> male_y;
	vector<double> female_x;
	vector<double> female_y;

	// a constructor takes all locations of male and female.
	parentsChooser_cpp(const vector<double> & mx, const vector<double> & my,
		const vector<double> & fx, const vector<double> & fy,
		unsigned int seed) 
		: male_x(mx), male_y(my), female_x(fx), female_y(fy)
	{
		// set random seed
		srand(seed);
	}
	
	// the destructor releases the memory.
	~parentsChooser_cpp()
	{
		male_x.clear();
		male_y.clear();
		female_x.clear();
		female_y.clear();
	}

	// choose a male, and find a female in his vincinity.
	// Of course, some of probability density function can be used.
	// In this example, I am using the system rand() function,
	// just for demonstration. Any serious simulation should use a qualified
	// random number generator library. You may want to have a look at
	// 1. GNU Scientific Library (what simuPOP uses)
	// 2. boost C++ library
	// 3. Numeric Recipes (C or C++ version)
	pair<unsigned long, unsigned long> chooseParent()
	{
		// index of male.
		unsigned long male = rand() % male_x.size();
		
		// calculate distance between this male, and all female, and choose
		// the closest one.
		double dist;
		double mx = male_x[male];
		double my = male_y[male];
		double mindist = -1;
		unsigned long female = 0;
		for (size_t i = 0; i < female_x.size(); ++i) {
			dist = (female_x[i]-mx)*(female_x[i]-mx) + (female_y[i]-my)*(female_y[i]-my);
			if (mindist == -1 || mindist > dist) {
			    mindist = dist;
				female = i;
			}
		}
		return std::make_pair(male, female);
	}
};
	
%}
