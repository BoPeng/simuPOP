version=pmwiki-2.2.0 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.0.5) Gecko/2008120908 Red Hat/3.0.5-1.el5_2 Firefox/3.0.5
author=
charset=ISO-8859-1
csum=
ctime=1232492103
host=127.0.0.1
name=Cookbook.CppLevelParentChooser
rev=4
targets=
text=(:title A Python parent chooser implemented at the C++ level:)%0a%0a%25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:cppParentChooser.zip | http://simupop.sourceforge.net/images/download.jpg]]|cppParentChooser.zip%0a%0aThis file demonstrate the use of @@homoMating@@, using a parent choosr that choose a female that is geographically closest to a random male. A hybrid parent chooser pyParentsChooser is used, which will call a Python generator function repeatedly to get parents.%0a%0aSuch hybrid- and pure- Python operators and mating schemes provide a very powerful and flexible interface to implement customized genetic effects and mating schemes. However, because these functions are implemented in Python, they can significantly reduce the performance of your simuPOP script if complex algorithms are involved, especially when the Python functions are called repeatedly. This problem can be addressed by implementing these functions in C++.%0a%0aThis example demonstrates how to implement some functions in C++, and wrap them so that they can be imported into python. This is basically how simuPOP is written, and is an important technique to improve the efficiency of your simuPOP scripts.%0a%0aSeveral files are involved in this process:%0a%0a# This python file that import the C++ module.%0a%0a# @@.h@@ and/or @@.cpp@@ files to re-impmenent the most time-consuming parts in C++.%0a%0a# An interface file @@cppParentChooser.i@@, which tells an automatic wrapper generating program SWIG how to wrap the code.%0a%0aTo compile and load functions defined in this interface file, you will need%0ato:%0a%0a# download and install SWIG.%0a%0a# Build and install module cppParentChooser by running%0a%0a->@@> python setup.py install@@%0a%0a->For a previous version of Python (%3c2.4), you may need to pass swig options%0a  using command line:%0a%0a->@@> python setup.py build_ext --swig-opts='-O -templatereduce -shadow -c++ -keyword -nodefaultctor' install @@%0a%0a# You can then try to import your module using%0a%0a->@@> python -c 'import cppParentChooser'@@%0a%0aA parent generator is defined as, in C++%0a%0a=cpp [=%0aclass parentsChooser_cpp%0a{%0a%0apublic:%0a	// a constructor takes all locations of male and female.%0a	parentsChooser_cpp(const std::vector%3cdouble> & mx, const std::vector%3cdouble> & my,%0a		const std::vector%3cdouble> & fx, const std::vector%3cdouble> & fy,%0a		unsigned int seed) %0a		: male_x(mx), male_y(my), female_x(fx), female_y(fy)%0a	{%0a		if (male_x.size() != male_y.size() || female_x.size() != female_y.size()) {%0a			cout %3c%3c "Wrong male or female locations";%0a			// it is recommended to throw an exception here.%0a		}%0a		srand(seed);%0a	}%0a	%0a	// choose a male, and find a female in his vincinity.%0a	// Of course, some of probability density function can be used.%0a	// In this example, I am using the system rand() function,%0a	// just for demonstration. Any serious simulation should use a qualified%0a	// random number generator library. You may want to have a look at%0a	// 1. GNU Scientific Library (what simuPOP uses)%0a	// 2. boost C++ library%0a	// 3. Numeric Recipes (C or C++ version)%0a	pair%3cunsigned long, unsigned long> chooseParents()%0a	{%0a		// index of male.%0a		unsigned long male = rand() %25 male_x.size();%0a		%0a		// calculate distance between this male, and all female, and choose%0a		// the closest one.%0a		double dist;%0a		double mx = male_x[male];%0a		double my = male_y[male];%0a		double mindist = -1;%0a		unsigned long female = 0;%0a		for (size_t i = 0; i %3c female_x.size(); ++i) {%0a			dist = (female_x[i]-mx)*(female_x[i]-mx) + (female_y[i]-my)*(female_y[i]-my);%0a			if (mindist == -1 || mindist > dist) {%0a			    mindist = dist;%0a				female = i;%0a			}%0a		}%0a		return std::make_pair(male, female);%0a	}%0a%0aprivate:%0a	std::vector%3cdouble> male_x;%0a	std::vector%3cdouble> male_y;%0a	std::vector%3cdouble> female_x;%0a	std::vector%3cdouble> female_y;%0a};%0a=]%0a%0aand is called in Python as%0a%0a=python [=%0adef parentsChooser(pop, sp):%0a    '''Choose parents according to their locations. Because this is only a%0a       demonstration, performance is not under consideration.%0a    '''%0a    males = [x for x in range(pop.subPopSize(sp)) if pop.individual(x, sp).sex() == Male]%0a    females = [x for x in range(pop.subPopSize(sp)) if pop.individual(x, sp).sex() == Female]%0a    # create an object with needed information ...%0a    pc = parentsChooser_cpp(%0a            [x.info('x') for x in pop.individuals(sp) if x.sex() == Male],%0a            [x.info('y') for x in pop.individuals(sp) if x.sex() == Male],%0a            [x.info('x') for x in pop.individuals(sp) if x.sex() == Female],%0a            [x.info('y') for x in pop.individuals(sp) if x.sex() == Female],%0a            randint(0, 1e8))%0a    while True:%0a        # and return indexes of parents%0a        m, f = pc.chooseParents()%0a        yield males[m], females[f]%0a=]%0a%0aThe C++ level parent chooser is wrapped into Python using an interface file%0a%0a=python [=%0a%25module cppParentChooser%0a%25{%0a#include "cppParentChooser.h"%0a%25}%0a%0a/*%0a To pass Python lists to C++ functions, and to return C++ vectors to Python,%0a you will need to tell SWIG how to convert between them. The following%0a code includes SWIG's STL (standard template libraries) header files, and%0a instantialize the types of vectors cppParentChooser.h uses.%0a*/%0a%0a// std_vector.i for std::vector%0a%25include "std_vector.i"%0a%25template() std::vector%3cdouble>;%0a%0a// stl.i for std::pair%0a%25include "stl.i"%0a%25template() std::pair%3cunsigned long, unsigned long>;%0a%0a%25include "cppParentChooser.h"%0a=]%0a%0aand a @@setup.py@@ file that compiles and installs the cpp module.%0a%0a=python [=%0afrom distutils.core import setup, Extension%0aimport sys%0a# Under linux/gcc, lib stdc++ is needed for C++ based extension.%0aif sys.platform == 'linux2':%0a    libs = ['stdc++']%0aelse:%0a    libs = []%0a%0asetup(name = "cppParentChooser",%0a    description = "A sample parent chooser",%0a    py_modules = ['cppParentChooser'],  # will be generated by SWIG%0a    ext_modules = [%0a        Extension('_cppParentChooser',%0a            sources = ['cppParentChooser.i'],%0a            swig_opts = ['-O', '-templatereduce', '-shadow',%0a                '-python', '-c++', '-keyword', '-nodefaultctor'],%0a            include_dirs = ["."],%0a    )%0a  ]%0a)%0a%0a=]%0a%0a%0aThe way to use this parent chooser is as usual%0a%0a=python [=%0adef simuGeoMating(size, gen):%0a    '''%0a    size  population size%0a    gen   number of generations to run%0a    '''%0a    pop = population(size, loci=[1], infoFields=['x', 'y'])%0a    simu = simulator(pop,%0a        homoMating(pyParentsChooser(parentsChooser), mendelianOffspringGenerator())%0a    )%0a    simu.evolve(%0a        preOps = [initByFreq([0.5, 0.5])],%0a        ops = [%0a            pyEval(r'"%25s\n" %25 gen'),%0a            pyTagger(func=locOfOffspring, infoFields=['x', 'y']),%0a            pyOperator(func=plotInds),%0a        ],%0a        gen = gen%0a    )%0a=]%0a%0aThe @@plotInds@@ function is a Python function that calls R to plot locations of individuals, which is defined as%0a%0a=python [=%0adef plotInds(pop):%0a    '''plot the location of individuals. This requires R and rpy. '''%0a    if not has_rpy:%0a        return True%0a    r.postscript('loc_%25d.eps' %25 pop.dvars().gen)%0a    r.plot(0, 0, xlim=[-5, 5], ylim=[-5, 5], type='n',%0a        xlab='x', ylab='y',%0a        main='Locations of individuals at generation %25d' %25 pop.dvars().gen)%0a    for ind in pop.individuals():%0a        r.points(ind.info(0), ind.info(1))%0a    r.dev_off()%0a    return True%0a=]%0a%0aThe locations of offspring are calculated using a during-mating Python operator%0a%0a=python [=%0a%0adef locOfOffspring(loc):%0a    '''set offspring loc from parental locs'''%0a    # loc = (dad_x, dad_y, mom_x, mom_y)%0a    #%0a    # move to (dad_x + mom_x)/2 + N(0, 1), (dad_y + mom_y)/2 + N(0,1)%0a    new_x = (loc[0]+loc[2])/2. + normalvariate(0, 1)%0a    new_y = (loc[1]+loc[3])/2. + normalvariate(0, 1)%0a    # limit to region [-5, 5] x [-5, 5]%0a    new_x = min(new_x, 5)%0a    new_x = max(new_x, -5)%0a    new_y = min(new_y, 5)%0a    new_y = max(new_y, -5)%0a    return (new_x, new_y)%0a%0a%0a=]%0a
time=1232493581
title=A Python parent chooser implemented at the C++ level
author:1232493581=
diff:1232493581:1232493521:=143c143%0a%3c and a @@setup.py@@ file that compiles and installs the cpp module.%0a---%0a> and a @@setup.py@@ file that compile and install the cpp module.%0a
host:1232493581=127.0.0.1
author:1232493521=
diff:1232493521:1232492968:=5,229d4%0a%3c This file demonstrate the use of @@homoMating@@, using a parent choosr that choose a female that is geographically closest to a random male. A hybrid parent chooser pyParentsChooser is used, which will call a Python generator function repeatedly to get parents.%0a%3c %0a%3c Such hybrid- and pure- Python operators and mating schemes provide a very powerful and flexible interface to implement customized genetic effects and mating schemes. However, because these functions are implemented in Python, they can significantly reduce the performance of your simuPOP script if complex algorithms are involved, especially when the Python functions are called repeatedly. This problem can be addressed by implementing these functions in C++.%0a%3c %0a%3c This example demonstrates how to implement some functions in C++, and wrap them so that they can be imported into python. This is basically how simuPOP is written, and is an important technique to improve the efficiency of your simuPOP scripts.%0a%3c %0a%3c Several files are involved in this process:%0a%3c %0a%3c # This python file that import the C++ module.%0a%3c %0a%3c # @@.h@@ and/or @@.cpp@@ files to re-impmenent the most time-consuming parts in C++.%0a%3c %0a%3c # An interface file @@cppParentChooser.i@@, which tells an automatic wrapper generating program SWIG how to wrap the code.%0a%3c %0a%3c To compile and load functions defined in this interface file, you will need%0a%3c to:%0a%3c %0a%3c # download and install SWIG.%0a%3c %0a%3c # Build and install module cppParentChooser by running%0a%3c %0a%3c ->@@> python setup.py install@@%0a%3c %0a%3c ->For a previous version of Python (%3c2.4), you may need to pass swig options%0a%3c   using command line:%0a%3c %0a%3c ->@@> python setup.py build_ext --swig-opts='-O -templatereduce -shadow -c++ -keyword -nodefaultctor' install @@%0a%3c %0a%3c # You can then try to import your module using%0a%3c %0a%3c ->@@> python -c 'import cppParentChooser'@@%0a%3c %0a%3c A parent generator is defined as, in C++%0a%3c %0a%3c =cpp [=%0a%3c class parentsChooser_cpp%0a%3c {%0a%3c %0a%3c public:%0a%3c 	// a constructor takes all locations of male and female.%0a%3c 	parentsChooser_cpp(const std::vector%3cdouble> & mx, const std::vector%3cdouble> & my,%0a%3c 		const std::vector%3cdouble> & fx, const std::vector%3cdouble> & fy,%0a%3c 		unsigned int seed) %0a%3c 		: male_x(mx), male_y(my), female_x(fx), female_y(fy)%0a%3c 	{%0a%3c 		if (male_x.size() != male_y.size() || female_x.size() != female_y.size()) {%0a%3c 			cout %3c%3c "Wrong male or female locations";%0a%3c 			// it is recommended to throw an exception here.%0a%3c 		}%0a%3c 		srand(seed);%0a%3c 	}%0a%3c 	%0a%3c 	// choose a male, and find a female in his vincinity.%0a%3c 	// Of course, some of probability density function can be used.%0a%3c 	// In this example, I am using the system rand() function,%0a%3c 	// just for demonstration. Any serious simulation should use a qualified%0a%3c 	// random number generator library. You may want to have a look at%0a%3c 	// 1. GNU Scientific Library (what simuPOP uses)%0a%3c 	// 2. boost C++ library%0a%3c 	// 3. Numeric Recipes (C or C++ version)%0a%3c 	pair%3cunsigned long, unsigned long> chooseParents()%0a%3c 	{%0a%3c 		// index of male.%0a%3c 		unsigned long male = rand() %25 male_x.size();%0a%3c 		%0a%3c 		// calculate distance between this male, and all female, and choose%0a%3c 		// the closest one.%0a%3c 		double dist;%0a%3c 		double mx = male_x[male];%0a%3c 		double my = male_y[male];%0a%3c 		double mindist = -1;%0a%3c 		unsigned long female = 0;%0a%3c 		for (size_t i = 0; i %3c female_x.size(); ++i) {%0a%3c 			dist = (female_x[i]-mx)*(female_x[i]-mx) + (female_y[i]-my)*(female_y[i]-my);%0a%3c 			if (mindist == -1 || mindist > dist) {%0a%3c 			    mindist = dist;%0a%3c 				female = i;%0a%3c 			}%0a%3c 		}%0a%3c 		return std::make_pair(male, female);%0a%3c 	}%0a%3c %0a%3c private:%0a%3c 	std::vector%3cdouble> male_x;%0a%3c 	std::vector%3cdouble> male_y;%0a%3c 	std::vector%3cdouble> female_x;%0a%3c 	std::vector%3cdouble> female_y;%0a%3c };%0a%3c =]%0a%3c %0a%3c and is called in Python as%0a%3c %0a%3c =python [=%0a%3c def parentsChooser(pop, sp):%0a%3c     '''Choose parents according to their locations. Because this is only a%0a%3c        demonstration, performance is not under consideration.%0a%3c     '''%0a%3c     males = [x for x in range(pop.subPopSize(sp)) if pop.individual(x, sp).sex() == Male]%0a%3c     females = [x for x in range(pop.subPopSize(sp)) if pop.individual(x, sp).sex() == Female]%0a%3c     # create an object with needed information ...%0a%3c     pc = parentsChooser_cpp(%0a%3c             [x.info('x') for x in pop.individuals(sp) if x.sex() == Male],%0a%3c             [x.info('y') for x in pop.individuals(sp) if x.sex() == Male],%0a%3c             [x.info('x') for x in pop.individuals(sp) if x.sex() == Female],%0a%3c             [x.info('y') for x in pop.individuals(sp) if x.sex() == Female],%0a%3c             randint(0, 1e8))%0a%3c     while True:%0a%3c         # and return indexes of parents%0a%3c         m, f = pc.chooseParents()%0a%3c         yield males[m], females[f]%0a%3c =]%0a%3c %0a%3c The C++ level parent chooser is wrapped into Python using an interface file%0a%3c %0a%3c =python [=%0a%3c %25module cppParentChooser%0a%3c %25{%0a%3c #include "cppParentChooser.h"%0a%3c %25}%0a%3c %0a%3c /*%0a%3c  To pass Python lists to C++ functions, and to return C++ vectors to Python,%0a%3c  you will need to tell SWIG how to convert between them. The following%0a%3c  code includes SWIG's STL (standard template libraries) header files, and%0a%3c  instantialize the types of vectors cppParentChooser.h uses.%0a%3c */%0a%3c %0a%3c // std_vector.i for std::vector%0a%3c %25include "std_vector.i"%0a%3c %25template() std::vector%3cdouble>;%0a%3c %0a%3c // stl.i for std::pair%0a%3c %25include "stl.i"%0a%3c %25template() std::pair%3cunsigned long, unsigned long>;%0a%3c %0a%3c %25include "cppParentChooser.h"%0a%3c =]%0a%3c %0a%3c and a @@setup.py@@ file that compile and install the cpp module.%0a%3c %0a%3c =python [=%0a%3c from distutils.core import setup, Extension%0a%3c import sys%0a%3c # Under linux/gcc, lib stdc++ is needed for C++ based extension.%0a%3c if sys.platform == 'linux2':%0a%3c     libs = ['stdc++']%0a%3c else:%0a%3c     libs = []%0a%3c %0a%3c setup(name = "cppParentChooser",%0a%3c     description = "A sample parent chooser",%0a%3c     py_modules = ['cppParentChooser'],  # will be generated by SWIG%0a%3c     ext_modules = [%0a%3c         Extension('_cppParentChooser',%0a%3c             sources = ['cppParentChooser.i'],%0a%3c             swig_opts = ['-O', '-templatereduce', '-shadow',%0a%3c                 '-python', '-c++', '-keyword', '-nodefaultctor'],%0a%3c             include_dirs = ["."],%0a%3c     )%0a%3c   ]%0a%3c )%0a%3c %0a%3c =]%0a%3c %0a%3c %0a%3c The way to use this parent chooser is as usual%0a%3c %0a%3c =python [=%0a%3c def simuGeoMating(size, gen):%0a%3c     '''%0a%3c     size  population size%0a%3c     gen   number of generations to run%0a%3c     '''%0a%3c     pop = population(size, loci=[1], infoFields=['x', 'y'])%0a%3c     simu = simulator(pop,%0a%3c         homoMating(pyParentsChooser(parentsChooser), mendelianOffspringGenerator())%0a%3c     )%0a%3c     simu.evolve(%0a%3c         preOps = [initByFreq([0.5, 0.5])],%0a%3c         ops = [%0a%3c             pyEval(r'"%25s\n" %25 gen'),%0a%3c             pyTagger(func=locOfOffspring, infoFields=['x', 'y']),%0a%3c             pyOperator(func=plotInds),%0a%3c         ],%0a%3c         gen = gen%0a%3c     )%0a%3c =]%0a%3c %0a%3c The @@plotInds@@ function is a Python function that calls R to plot locations of individuals, which is defined as%0a%3c %0a%3c =python [=%0a%3c def plotInds(pop):%0a%3c     '''plot the location of individuals. This requires R and rpy. '''%0a%3c     if not has_rpy:%0a%3c         return True%0a%3c     r.postscript('loc_%25d.eps' %25 pop.dvars().gen)%0a%3c     r.plot(0, 0, xlim=[-5, 5], ylim=[-5, 5], type='n',%0a%3c         xlab='x', ylab='y',%0a%3c         main='Locations of individuals at generation %25d' %25 pop.dvars().gen)%0a%3c     for ind in pop.individuals():%0a%3c         r.points(ind.info(0), ind.info(1))%0a%3c     r.dev_off()%0a%3c     return True%0a%3c =]%0a%3c %0a%3c The locations of offspring are calculated using a during-mating Python operator%0a%3c %0a%3c =python [=%0a%3c %0a%3c def locOfOffspring(loc):%0a%3c     '''set offspring loc from parental locs'''%0a%3c     # loc = (dad_x, dad_y, mom_x, mom_y)%0a%3c     #%0a%3c     # move to (dad_x + mom_x)/2 + N(0, 1), (dad_y + mom_y)/2 + N(0,1)%0a%3c     new_x = (loc[0]+loc[2])/2. + normalvariate(0, 1)%0a%3c     new_y = (loc[1]+loc[3])/2. + normalvariate(0, 1)%0a%3c     # limit to region [-5, 5] x [-5, 5]%0a%3c     new_x = min(new_x, 5)%0a%3c     new_x = max(new_x, -5)%0a%3c     new_y = min(new_y, 5)%0a%3c     new_y = max(new_y, -5)%0a%3c     return (new_x, new_y)%0a%3c %0a%3c %0a%3c =]%0a
host:1232493521=127.0.0.1
author:1232492968=
diff:1232492968:1232492103:=
host:1232492968=127.0.0.1
author:1232492103=
diff:1232492103:1232492103:=1,4d0%0a%3c (:title A Python parent chooser implemented at the C++ level:)%0a%3c %0a%3c %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:cppParentChooser.zip | http://simupop.sourceforge.net/images/download.jpg]]|cppParentChooser.zip%0a%3c %0a
host:1232492103=127.0.0.1
