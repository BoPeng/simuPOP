version=pmwiki-2.2.0 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 GTB5 (.NET CLR 3.5.30729)
author=
charset=ISO-8859-1
csum=
ctime=1232509123
host=127.0.0.1
name=Cookbook.FollowFreqTrajectory
rev=4
targets=
text=(:title Following a pre-simulated allele frequency trajectory:)%0a%0a%25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:followFreqTraj.py | http://simupop.sourceforge.net/images/download.jpg]]|followFreqTraj.py%0a%0aThis recipe shows the use of a controlled random mating scheme to force evolve a population conditioning on a pre-simulated allele frequency trajectory.%0a%0aIn this example, a small simulation (with one locus) is performed and the allele frequency of an allele is recorded. This is implemented in function @@recordTrajectory@@.%0a%0a=python [=%0adef recordTrajectory(N, initFreq, gen):%0a    '''%0a    Evolve a population gen generations and record its allele%0a    frequency trajectory.%0a    '''%0a    simu = simulator(population(N, loci=[1]), randomMating())%0a    simu.evolve(%0a        initOps = [%0a            initSex(),%0a            initByFreq([1 - initFreq, initFreq]),%0a            # initialize an array in the population's local namespace%0a            pyExec('traj=[]')%0a        ],%0a        postOps = [%0a            stat(alleleFreq=[0]),%0a            pyExec('traj.append(alleleFreq[0][1])'),%0a        ],%0a        gen = gen%0a    )%0a    return simu.dvars(0).traj%0a=]%0a%0aThe interesting part of this function is the use of a @@pyExec@@ operator. Unlike a @@pyEval@@ operator that evaluate an expression and return its value, this operator execute a statement with no return value. In this case, a variable @@traj@@ is created and used to record allele frequency at each generation.%0a%0aIn the next function @@simuFollowTrajectory@@, a special @@controlledRandomMating@@ mating scheme is used to force the all populations to follow this allele frequency trajectory at locus 50.%0a%0a=python [=%0adef simuFollowTrajectory(N, locus, initFreq, traj):%0a    '''%0a    Evolve a population, initialize a specified locus with given%0a    allele frequency and force it to follow a particular allele%0a    frequency trajectory.%0a    '''%0a    # define a trajectory function%0a    def func(gen):%0a        return traj[gen]%0a    #%0a    simu = simulator(%0a        population(size=N, loci=[100]), # a larger simulation%0a        controlledRandomMating(loci=locus, alleles=1, freqFunc=func),%0a        rep = 5%0a    )%0a    simu.evolve(%0a        initOps = [%0a            initSex(),%0a            initByFreq([1 - initFreq, initFreq])%0a        ],%0a        postOps = [stat(alleleFreq=[locus], at=-1)],%0a        gen = len(traj)%0a    )%0a    print [simu.dvars(rep).alleleFreq[locus][1] for rep in range(5)]%0a=]%0a%0aAlthough all populations are evolved randomly, their allele frequency at locus 50 will be the same. This technique is very useful in the simulation of genetic diseases where disease allele frequency are controlled so that the simulated populations will have similar disease prevalence.%0a%0aNote that the allele frequency trajectory can be simulated in a number of ways. For more detailed information, please refer to%0a%0aBo Peng, Christopher I Amos, Marek Kimmel, '''Forward-Time Simulations of Human Populations with Complex Diseases''', PLoS Genetics, 3(3) e47.
time=1261119550
title=Following a pre-simulated allele frequency trajectory
author:1261119550=
diff:1261119550:1232509204:=17,18c17%0a%3c         initOps = [%0a%3c             initSex(),%0a---%0a>         preOps = [%0a23c22%0a%3c         postOps = [%0a---%0a>         ops = [%0a53,57c52,53%0a%3c         initOps = [%0a%3c             initSex(),%0a%3c             initByFreq([1 - initFreq, initFreq])%0a%3c         ],%0a%3c         postOps = [stat(alleleFreq=[locus], at=-1)],%0a---%0a>         preOps = [initByFreq([1 - initFreq, initFreq])],%0a>         ops = [stat(alleleFreq=[locus], at=-1)],%0a
host:1261119550=127.0.0.1
author:1232509204=
diff:1232509204:1232509156:=3c3%0a%3c %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:followFreqTraj.py | http://simupop.sourceforge.net/images/download.jpg]]|followFreqTraj.py%0a---%0a> %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:controlledRandomMating.py | http://simupop.sourceforge.net/images/download.jpg]]|controlledRandomMating.py%0a
host:1232509204=127.0.0.1
author:1232509123=
diff:1232509123:1232509123:=1,63d0%0a%3c (:title Following a pre-simulated allele frequency trajectory:)%0a%3c %0a%3c %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:controlledRandomMating.py | http://simupop.sourceforge.net/images/download.jpg]]|controlledRandomMating.py%0a%3c %0a%3c This recipe shows the use of a controlled random mating scheme to force evolve a population conditioning on a pre-simulated allele frequency trajectory.%0a%3c %0a%3c In this example, a small simulation (with one locus) is performed and the allele frequency of an allele is recorded. This is implemented in function @@recordTrajectory@@.%0a%3c %0a%3c =python [=%0a%3c def recordTrajectory(N, initFreq, gen):%0a%3c     '''%0a%3c     Evolve a population gen generations and record its allele%0a%3c     frequency trajectory.%0a%3c     '''%0a%3c     simu = simulator(population(N, loci=[1]), randomMating())%0a%3c     simu.evolve(%0a%3c         preOps = [%0a%3c             initByFreq([1 - initFreq, initFreq]),%0a%3c             # initialize an array in the population's local namespace%0a%3c             pyExec('traj=[]')%0a%3c         ],%0a%3c         ops = [%0a%3c             stat(alleleFreq=[0]),%0a%3c             pyExec('traj.append(alleleFreq[0][1])'),%0a%3c         ],%0a%3c         gen = gen%0a%3c     )%0a%3c     return simu.dvars(0).traj%0a%3c =]%0a%3c %0a%3c The interesting part of this function is the use of a @@pyExec@@ operator. Unlike a @@pyEval@@ operator that evaluate an expression and return its value, this operator execute a statement with no return value. In this case, a variable @@traj@@ is created and used to record allele frequency at each generation.%0a%3c %0a%3c In the next function @@simuFollowTrajectory@@, a special @@controlledRandomMating@@ mating scheme is used to force the all populations to follow this allele frequency trajectory at locus 50.%0a%3c %0a%3c =python [=%0a%3c def simuFollowTrajectory(N, locus, initFreq, traj):%0a%3c     '''%0a%3c     Evolve a population, initialize a specified locus with given%0a%3c     allele frequency and force it to follow a particular allele%0a%3c     frequency trajectory.%0a%3c     '''%0a%3c     # define a trajectory function%0a%3c     def func(gen):%0a%3c         return traj[gen]%0a%3c     #%0a%3c     simu = simulator(%0a%3c         population(size=N, loci=[100]), # a larger simulation%0a%3c         controlledRandomMating(loci=locus, alleles=1, freqFunc=func),%0a%3c         rep = 5%0a%3c     )%0a%3c     simu.evolve(%0a%3c         preOps = [initByFreq([1 - initFreq, initFreq])],%0a%3c         ops = [stat(alleleFreq=[locus], at=-1)],%0a%3c         gen = len(traj)%0a%3c     )%0a%3c     print [simu.dvars(rep).alleleFreq[locus][1] for rep in range(5)]%0a%3c =]%0a%3c %0a%3c Although all populations are evolved randomly, their allele frequency at locus 50 will be the same. This technique is very useful in the simulation of genetic diseases where disease allele frequency are controlled so that the simulated populations will have similar disease prevalence.%0a%3c %0a%3c Note that the allele frequency trajectory can be simulated in a number of ways. For more detailed information, please refer to%0a%3c %0a%3c Bo Peng, Christopher I Amos, Marek Kimmel, '''Forward-Time Simulations of Human Populations with Complex Diseases''', PLoS Genetics, 3(3) e47.%0a\ No newline at end of file%0a
host:1232509123=127.0.0.1
