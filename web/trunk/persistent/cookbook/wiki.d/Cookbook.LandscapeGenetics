version=pmwiki-2.2.0 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6 (.NET CLR 3.5.30729)
author=
charset=ISO-8859-1
csum=
ctime=1239632569
host=127.0.0.1
name=Cookbook.LandscapeGenetics
rev=12
targets=
text=(:title Landscape genetics example:)%0a%25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:land.py | http://simupop.sourceforge.net/images/download.jpg]]|land.py%0a%0aThe example attached provides a landscape genetics simulation, the main points are:%0a%0a#2D map varying from coordinates 0 to 100 on each dimension%0a%0a#Map imposes selection conditions (left is "cold", right is "hot". Bottom is "low", top is "high")%0a%0a#Individuals have a set of loci that are adaptative to temperature and height.%0a%0a#The population has a constant size of 1000%0a%0a#Individuals are able to (random) mate in a certain radius%0a%0a#Offspring are able to walk from the origin point (equidistant between father and mother). There is probability space of where to walk, making the individual more prone to walk in the direction to which it is adapted%0a%0a#The initial population is adapted to cold, low (i.e., bottom-left corner). Random mutation introduces adaptation to new environments.%0a%0a#For each variable (temperature, height) there are a set of loci connected. The more mutations on the set, the more able is the individual to move to hotter and higher zones)%0a%0a#Mutations might be wild-recessive (ie, having a single mutant allele makes it prone to move away for the original corner), wild-dominant (needs both alleles to make an effect) or random (an allele is choosen at random to define the phenotype).%0a%0a#Selection doesn't use simuPOP operators, instead there is joint probability of an individual being killed before mating (joint of the adaptation of being suited to the point in space where it is)%0a%0a#Some simuPOP programming techniques might not be the best%0a%0a!!Video%0a%0aFrom the output of the script above you can generate a set of images with [[Attach:plot.py |this script]].%0a%0aHere is a video example:%0a%0a(:youtube Al_0BlSxcHI:)%0a%0aThe reason the individuals go from one corner to the opposite is two-fold:%0a%0a%0a#All loci are wild-recessive (as soon as you have a mutation you will move). This is probably realistic%0a#There is no notion of "crowding". All individuals can occupy the same point in space. This is less realistic, of course...%0a%0aThe color of individuals is revealing of the genotype: black is wild-type. More green means more "hot" (i.e., tends to go to the right). More blue means more "high" (i.e., tends to go up)%0a%0a%0a%0a!!Comments on the code supplied%0a%0a=python [=%0apop = population(POPSIZE, 2,%0a    loci=[1]*LOCIPERDIM*2,%0a    infoFields = ['x', 'y']%0a)%0a=]%0a%0aNote the infoFields x and y.%0a%0a%0a=python [=%0adef geoChooser(pop, sp):%0a    while (True):%0a        gender = 2%0a        while gender != 1:%0a            g1Idx = randint(0, pop.popSize()-1)%0a            gender = pop.individual(g1Idx).sex()%0a        g1 = pop.individual(g1Idx)%0a        g1x = g1.info('x')%0a        g1y = g1.info('y')%0a        g2Cases = []%0a        for idx in range(0, pop.popSize()-1):%0a            tempG2 = pop.individual(idx)%0a            if tempG2.sex()==2:%0a                tg2x = tempG2.info('x')%0a                tg2y = tempG2.info('y')%0a                dist =  sqrt((g1x-tg2x)**2 + (g1y-tg2y)**2)%0a                if dist%3c=MATERADIUS: g2Cases.append(idx)%0a        if len(g2Cases)==0: continue%0a        yield g1Idx, g2Cases[randint(0,len(g2Cases)-1)]%0a=]%0a%0aThis is the random mating (but only within a certain radius).%0a%0a=python [=%0adef placeIndividual(pop, off, dad, mom):%0a    cX = (dad.info('x') + mom.info('x'))/2%0a    cY = (dad.info('y') + mom.info('y'))/2%0a    #This is really a SQUARE%0a    x=-1%0a    y=-1%0a    xMut, yMut = countMutants(off)%0a    optX = getOptimalCoord(maxX, xMut)%0a    optY = getOptimalCoord(maxY, yMut)%0a    while x%3c0 or x>maxX: # or x%3ccX-WALKRADIUS or x>cX+WALKRADIUS:%0a        #We will assure that the most distant extreme is within 68?%25%0a        d1X = abs((cX-WALKRADIUS)-optX) %0a        d2X = abs((cX+WALKRADIUS)-optX)%0a        if d1X>d2X:%0a            bigger=cX-WALKRADIUS%0a            smaller=cX+WALKRADIUS%0a        else:%0a            bigger=cX+WALKRADIUS%0a            smaller=cX-WALKRADIUS%0a        if smaller%3c0: smaller=0%0a        if bigger%3c0: bigger=maxX%0a        x = normalvariate(smaller, WALKRADIUS)%0a    while y%3c0 or y>maxY: # or y%3ccY-WALKRADIUS or y>cY+WALKRADIUS:%0a        #We will assure that the most distant extreme is within 68?%25%0a        d1Y = abs((cY-WALKRADIUS)-optY) %0a        d2Y = abs((cY+WALKRADIUS)-optY)%0a        if d1Y>d2Y:%0a            bigger=cY-WALKRADIUS%0a            smaller=cY+WALKRADIUS%0a        else:%0a            bigger=cY+WALKRADIUS%0a            smaller=cY-WALKRADIUS%0a        if smaller%3c0: smaller=0%0a        if bigger%3c0: bigger=maxY%0a        y = normalvariate(smaller, WALKRADIUS)%0a%0a    off.setInfo(x, pop.infoIdx('x'))%0a    off.setInfo(y, pop.infoIdx('y'))%0a    return True%0a%0a=]%0a%0aThis places the new individual as a function of parent position and approximation to the point in space to which it is most adapted.%0a%0a=python [=%0a%0adef countMutants(ind):%0a    xMut = 0%0a    yMut = 0%0a    for i in range(LOCIPERDIM):%0a        if epiState==0: #wild-recissive%0a            if (ind.allele(i) == 1 or ind.allele(i+LOCIPERDIM*2) == 1): xMut+=1%0a            if (ind.allele(i+LOCIPERDIM) == 1 or ind.allele(i+LOCIPERDIM+LOCIPERDIM*2) == 1):%0a                yMut+=1%0a        elif epiState==1: #wild-dominant%0a            if (ind.allele(i) == 1 and ind.allele(i+LOCIPERDIM*2) == 1): xMut+=1%0a            if (ind.allele(i+LOCIPERDIM) == 1 and ind.allele(i+LOCIPERDIM+LOCIPERDIM*2) == 1):%0a                yMut+=1%0a        elif epiState ==2: #random%0a            xMut += ind.allele(i+randint(0,1)*2*LOCIPERDIM)%0a            yMut += ind.allele(i+LOCIPERDIM+randint(0,1)*2*LOCIPERDIM)%0a    return xMut, yMut%0a%0a%0adef getPenalty(maxPos, pos, numMuts):%0a    return 1.0 - abs(pos - getOptimalCoord(maxPos, numMuts))/maxPos%0a%0adef killUnfit(pop):%0a    indivs = []%0a    for indPos in range(pop.popSize()):%0a        ind     = pop.individual(indPos)%0a        x       = ind.info('x')%0a        y       = ind.info('y')%0a        xMut, yMut = countMutants(ind)%0a        xFactor = getPenalty(maxX, x, xMut) %0a        yFactor = getPenalty(maxY, y, yMut) %0a        luck    = uniform(0,1)%0a        if luck>xFactor*yFactor:%0a            indivs.append(indPos)%0a    pop.removeIndividuals(indivs)%0a    return True%0a=]%0a%0aThis kills an unfit individual. Each coordinate penalty is calculated as a distance from the optimal point (which is dependent on the number of mutations). Penalties are multiplied (one for each coordinate) and compared to a random number.%0a%0a=python [=%0apop.evolve(%0a    initOps = [%0a        InitGenotype(freq=[1,0])%0a    ],%0a    preOps = [%0a        PyOperator(killUnfit),%0a        KamMutator(k=2, rates=[0.01]*LOCIPERDIM*2, loci=range(LOCIPERDIM*2)),%0a    ],%0a    matingScheme = HomoMating(%0a        PyParentsChooser(geoChooser),%0a        OffspringGenerator(ops=[%0a            MendelianGenoTransmitter(),#numOffspring=(UniformDistribution, 2, 4)),%0a            PyOperator(placeIndividual)]),%0a        subPopSize=[POPSIZE]%0a    ),%0a    postOps = PyOperator(dmp),%0a    gen = 1000%0a)%0a=]%0a%0aThe main loop, note the fixed initial frequencies, the mutation, placing the new individuals and the killings.%0a%0a%0a!!Copyright%0a%0aThe author of this script is [[http://tiago.org | Tiago Antao]]. You are free to use this script, but I would appreciate if you inform me in case you use it. In case of doubts, ideas, suggestions or whatever, feel free to contact me.
time=1262666755
title=Landscape genetics example
author:1262666755=
diff:1262666755:1239656690:=169,172c169%0a%3c pop.evolve(%0a%3c     initOps = [%0a%3c         InitGenotype(freq=[1,0])%0a%3c     ],%0a---%0a> sim.evolve(%0a174,175c171%0a%3c         PyOperator(killUnfit),%0a%3c         KamMutator(k=2, rates=[0.01]*LOCIPERDIM*2, loci=range(LOCIPERDIM*2)),%0a---%0a>         initByFreq(alleleFreq=[1,0])%0a177,184c173,178%0a%3c     matingScheme = HomoMating(%0a%3c         PyParentsChooser(geoChooser),%0a%3c         OffspringGenerator(ops=[%0a%3c             MendelianGenoTransmitter(),#numOffspring=(UniformDistribution, 2, 4)),%0a%3c             PyOperator(placeIndividual)]),%0a%3c         subPopSize=[POPSIZE]%0a%3c     ),%0a%3c     postOps = PyOperator(dmp),%0a---%0a>     ops = [%0a>         kamMutator(rate=[0.01]*LOCIPERDIM*2, loci=range(LOCIPERDIM*2), maxAllele=1),%0a>         pyOperator(dmp, stage=PreMating),%0a>         pyOperator(placeIndividual, stage=DuringMating),%0a>         pyOperator(killUnfit, stage=PreMating)%0a>     ],%0a
host:1262666755=127.0.0.1
author:1239656690=
diff:1239656690:1239656672:=33d32%0a%3c %0a
host:1239656690=127.0.0.1
author:1239656672=
diff:1239656672:1239656606:=32c32,33%0a%3c Here is a video example:%0a---%0a> Here is an [[http://www.youtube.com/watch?v=Al_0BlSxcHI | video example]]. The reason the individuals go from one corner to the opposite is two-fold:%0a> %0a34,36d34%0a%3c %0a%3c The reason the individuals go from one corner to the opposite is two-fold:%0a%3c %0a
host:1239656672=127.0.0.1
author:1239656606=
diff:1239656606:1239640507:=33,34d32%0a%3c %0a%3c (:youtube Al_0BlSxcHI:)%0a
host:1239656606=127.0.0.1
author:1239640507=
diff:1239640507:1239640232:minor=35c35%0a%3c #There is no notion of "crowding". All individuals can occupy the same point in space. This is less realistic, of course...%0a---%0a> #There is no notion of "crowing". All individuals can occupy the same point in space. This is less realistic, of course...%0a
host:1239640507=127.0.0.1
author:1239640232=
diff:1239640232:1239636685:=26,27c26%0a%3c #Some simuPOP programming techniques might not be the best%0a%3c %0a---%0a> %0a32,33c31,32%0a%3c Here is an [[http://www.youtube.com/watch?v=Al_0BlSxcHI | video example]]. The reason the individuals go from one corner to the opposite is two-fold:%0a%3c %0a---%0a> Here is an example (link to youtube). The reason the individuals go from one corner to the opposite is two-fold:%0a> %0a36,37d34%0a%3c %0a%3c The color of individuals is revealing of the genotype: black is wild-type. More green means more "hot" (i.e., tends to go to the right). More blue means more "high" (i.e., tends to go up)%0a
host:1239640232=127.0.0.1
author:1239636685=
diff:1239636685:1239634511:=30,35d29%0a%3c %0a%3c Here is an example (link to youtube). The reason the individuals go from one corner to the opposite is two-fold:%0a%3c %0a%3c #All loci are wild-recessive (as soon as you have a mutation you will move). This is probably realistic%0a%3c #There is no notion of "crowing". All individuals can occupy the same point in space. This is less realistic, of course...%0a%3c %0a
host:1239636685=127.0.0.1
author:1239634511=
diff:1239634511:1239634148:=26,31d25%0a%3c %0a%3c !!Video%0a%3c %0a%3c From the output of the script above you can generate a set of images with [[Attach:plot.py |this script]].%0a%3c %0a%3c %0a171d164%0a%3c %0a174c167%0a%3c The author of this script is [[http://tiago.org | Tiago Antao]]. You are free to use this script, but I would appreciate if you inform me in case you use it. In case of doubts, ideas, suggestions or whatever, feel free to contact me.%0a\ No newline at end of file%0a---%0a> The author of this script is [[http://tiago.org | Tiago Antao]]. You are free to use this script, but I would appreciate if you inform me in case you use it.%0a\ No newline at end of file%0a
host:1239634511=127.0.0.1
author:1239634148=
diff:1239634148:1239633396:=35,167c35%0a%3c Note the infoFields x and y.%0a%3c %0a%3c %0a%3c =python [=%0a%3c def geoChooser(pop, sp):%0a%3c     while (True):%0a%3c         gender = 2%0a%3c         while gender != 1:%0a%3c             g1Idx = randint(0, pop.popSize()-1)%0a%3c             gender = pop.individual(g1Idx).sex()%0a%3c         g1 = pop.individual(g1Idx)%0a%3c         g1x = g1.info('x')%0a%3c         g1y = g1.info('y')%0a%3c         g2Cases = []%0a%3c         for idx in range(0, pop.popSize()-1):%0a%3c             tempG2 = pop.individual(idx)%0a%3c             if tempG2.sex()==2:%0a%3c                 tg2x = tempG2.info('x')%0a%3c                 tg2y = tempG2.info('y')%0a%3c                 dist =  sqrt((g1x-tg2x)**2 + (g1y-tg2y)**2)%0a%3c                 if dist%3c=MATERADIUS: g2Cases.append(idx)%0a%3c         if len(g2Cases)==0: continue%0a%3c         yield g1Idx, g2Cases[randint(0,len(g2Cases)-1)]%0a%3c =]%0a%3c %0a%3c This is the random mating (but only within a certain radius).%0a%3c %0a%3c =python [=%0a%3c def placeIndividual(pop, off, dad, mom):%0a%3c     cX = (dad.info('x') + mom.info('x'))/2%0a%3c     cY = (dad.info('y') + mom.info('y'))/2%0a%3c     #This is really a SQUARE%0a%3c     x=-1%0a%3c     y=-1%0a%3c     xMut, yMut = countMutants(off)%0a%3c     optX = getOptimalCoord(maxX, xMut)%0a%3c     optY = getOptimalCoord(maxY, yMut)%0a%3c     while x%3c0 or x>maxX: # or x%3ccX-WALKRADIUS or x>cX+WALKRADIUS:%0a%3c         #We will assure that the most distant extreme is within 68?%25%0a%3c         d1X = abs((cX-WALKRADIUS)-optX) %0a%3c         d2X = abs((cX+WALKRADIUS)-optX)%0a%3c         if d1X>d2X:%0a%3c             bigger=cX-WALKRADIUS%0a%3c             smaller=cX+WALKRADIUS%0a%3c         else:%0a%3c             bigger=cX+WALKRADIUS%0a%3c             smaller=cX-WALKRADIUS%0a%3c         if smaller%3c0: smaller=0%0a%3c         if bigger%3c0: bigger=maxX%0a%3c         x = normalvariate(smaller, WALKRADIUS)%0a%3c     while y%3c0 or y>maxY: # or y%3ccY-WALKRADIUS or y>cY+WALKRADIUS:%0a%3c         #We will assure that the most distant extreme is within 68?%25%0a%3c         d1Y = abs((cY-WALKRADIUS)-optY) %0a%3c         d2Y = abs((cY+WALKRADIUS)-optY)%0a%3c         if d1Y>d2Y:%0a%3c             bigger=cY-WALKRADIUS%0a%3c             smaller=cY+WALKRADIUS%0a%3c         else:%0a%3c             bigger=cY+WALKRADIUS%0a%3c             smaller=cY-WALKRADIUS%0a%3c         if smaller%3c0: smaller=0%0a%3c         if bigger%3c0: bigger=maxY%0a%3c         y = normalvariate(smaller, WALKRADIUS)%0a%3c %0a%3c     off.setInfo(x, pop.infoIdx('x'))%0a%3c     off.setInfo(y, pop.infoIdx('y'))%0a%3c     return True%0a%3c %0a%3c =]%0a%3c %0a%3c This places the new individual as a function of parent position and approximation to the point in space to which it is most adapted.%0a%3c %0a%3c =python [=%0a%3c %0a%3c def countMutants(ind):%0a%3c     xMut = 0%0a%3c     yMut = 0%0a%3c     for i in range(LOCIPERDIM):%0a%3c         if epiState==0: #wild-recissive%0a%3c             if (ind.allele(i) == 1 or ind.allele(i+LOCIPERDIM*2) == 1): xMut+=1%0a%3c             if (ind.allele(i+LOCIPERDIM) == 1 or ind.allele(i+LOCIPERDIM+LOCIPERDIM*2) == 1):%0a%3c                 yMut+=1%0a%3c         elif epiState==1: #wild-dominant%0a%3c             if (ind.allele(i) == 1 and ind.allele(i+LOCIPERDIM*2) == 1): xMut+=1%0a%3c             if (ind.allele(i+LOCIPERDIM) == 1 and ind.allele(i+LOCIPERDIM+LOCIPERDIM*2) == 1):%0a%3c                 yMut+=1%0a%3c         elif epiState ==2: #random%0a%3c             xMut += ind.allele(i+randint(0,1)*2*LOCIPERDIM)%0a%3c             yMut += ind.allele(i+LOCIPERDIM+randint(0,1)*2*LOCIPERDIM)%0a%3c     return xMut, yMut%0a%3c %0a%3c %0a%3c def getPenalty(maxPos, pos, numMuts):%0a%3c     return 1.0 - abs(pos - getOptimalCoord(maxPos, numMuts))/maxPos%0a%3c %0a%3c def killUnfit(pop):%0a%3c     indivs = []%0a%3c     for indPos in range(pop.popSize()):%0a%3c         ind     = pop.individual(indPos)%0a%3c         x       = ind.info('x')%0a%3c         y       = ind.info('y')%0a%3c         xMut, yMut = countMutants(ind)%0a%3c         xFactor = getPenalty(maxX, x, xMut) %0a%3c         yFactor = getPenalty(maxY, y, yMut) %0a%3c         luck    = uniform(0,1)%0a%3c         if luck>xFactor*yFactor:%0a%3c             indivs.append(indPos)%0a%3c     pop.removeIndividuals(indivs)%0a%3c     return True%0a%3c =]%0a%3c %0a%3c This kills an unfit individual. Each coordinate penalty is calculated as a distance from the optimal point (which is dependent on the number of mutations). Penalties are multiplied (one for each coordinate) and compared to a random number.%0a%3c %0a%3c =python [=%0a%3c sim.evolve(%0a%3c     preOps = [%0a%3c         initByFreq(alleleFreq=[1,0])%0a%3c     ],%0a%3c     ops = [%0a%3c         kamMutator(rate=[0.01]*LOCIPERDIM*2, loci=range(LOCIPERDIM*2), maxAllele=1),%0a%3c         pyOperator(dmp, stage=PreMating),%0a%3c         pyOperator(placeIndividual, stage=DuringMating),%0a%3c         pyOperator(killUnfit, stage=PreMating)%0a%3c     ],%0a%3c     gen = 1000%0a%3c )%0a%3c =]%0a%3c %0a%3c The main loop, note the fixed initial frequencies, the mutation, placing the new individuals and the killings.%0a%3c %0a%3c !!Copyright%0a%3c %0a%3c The author of this script is [[http://tiago.org | Tiago Antao]]. You are free to use this script, but I would appreciate if you inform me in case you use it.%0a\ No newline at end of file%0a---%0a> Note the infoFields x and y.%0a\ No newline at end of file%0a
host:1239634148=127.0.0.1
author:1239633396=
diff:1239633396:1239633251:=24,35c24%0a%3c #Selection doesn't use simuPOP operators, instead there is joint probability of an individual being killed before mating (joint of the adaptation of being suited to the point in space where it is)%0a%3c %0a%3c !!Comments on the code supplied%0a%3c %0a%3c =python [=%0a%3c pop = population(POPSIZE, 2,%0a%3c     loci=[1]*LOCIPERDIM*2,%0a%3c     infoFields = ['x', 'y']%0a%3c )%0a%3c =]%0a%3c %0a%3c Note the infoFields x and y.%0a\ No newline at end of file%0a---%0a> #Selection doesn't use simuPOP operators, instead there is joint probability of an individual being killed before mating (joint of the adaptation of being suited to the point in space where it is)%0a\ No newline at end of file%0a
host:1239633396=127.0.0.1
author:1239633251=
diff:1239633251:1239632569:=1c1%0a%3c (:title Landscape genetics example:)%0a---%0a> (:title Landscape genetics example ts:)%0a3,24d2%0a%3c %0a%3c The example attached provides a landscape genetics simulation, the main points are:%0a%3c %0a%3c #2D map varying from coordinates 0 to 100 on each dimension%0a%3c %0a%3c #Map imposes selection conditions (left is "cold", right is "hot". Bottom is "low", top is "high")%0a%3c %0a%3c #Individuals have a set of loci that are adaptative to temperature and height.%0a%3c %0a%3c #The population has a constant size of 1000%0a%3c %0a%3c #Individuals are able to (random) mate in a certain radius%0a%3c %0a%3c #Offspring are able to walk from the origin point (equidistant between father and mother). There is probability space of where to walk, making the individual more prone to walk in the direction to which it is adapted%0a%3c %0a%3c #The initial population is adapted to cold, low (i.e., bottom-left corner). Random mutation introduces adaptation to new environments.%0a%3c %0a%3c #For each variable (temperature, height) there are a set of loci connected. The more mutations on the set, the more able is the individual to move to hotter and higher zones)%0a%3c %0a%3c #Mutations might be wild-recessive (ie, having a single mutant allele makes it prone to move away for the original corner), wild-dominant (needs both alleles to make an effect) or random (an allele is choosen at random to define the phenotype).%0a%3c %0a%3c #Selection doesn't use simuPOP operators, instead there is joint probability of an individual being killed before mating (joint of the adaptation of being suited to the point in space where it is)%0a\ No newline at end of file%0a
host:1239633251=127.0.0.1
author:1239632569=
diff:1239632569:1239632569:=1,2d0%0a%3c (:title Landscape genetics example ts:)%0a%3c %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:land.py | http://simupop.sourceforge.net/images/download.jpg]]|land.py%0a
host:1239632569=127.0.0.1
