version=pmwiki-2.2.0 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 GTB5 (.NET CLR 3.5.30729)
author=
charset=ISO-8859-1
csum=
ctime=1252939049
host=127.0.0.1
name=Cookbook.SelectiveSweep
rev=4
targets=
text=(:title Selective Sweep :)%0a%0a%25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:SelectiveSweep.py | http://simupop.sourceforge.net/images/download.jpg]]|SelectiveSweep.py%0a%0aSelective sweep is defined as the reduction or amplification of variation in nucleotides in neighboring DNA because of natural selection. This program specifically aims to simulate amplification. For example, a strong selective sweep would result in the positively selected haplotype as the only allele that exists in the population. Essentially, the mutated allele and its neighbors are positively selected for. This results in a large reduction in genetic variation.%0a%0aA mutation must first occur that seeks to increase the fitness of the carrier. Then, natural selection favors that mutation that increases fitness. Thus, the mutant allele will become more prevalent among the population. Neighboring alleles linked to the mutated allele will also become more prevalent. Think of it almost as a type of genetic hitchhiking.%0a%0aAn earlier version of this simulation was first written with 101 loci of interest. A positively selected mutant allele was then introduced into the 51st allele which was usually lost to genetic drift. The initial simulation thus reintroduced the mutation if the allele was lost.%0a%0aThis written simulation is based off of Yuseob Kim and Wolfgang Stephan's own study published in "Selective Sweeps in the Presence of Interference Among Partially Linked Loci". The paper can be found at: %0ahttp://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=12750349  %0a%0aMost of Kim and Stephan's study was based on two or more selected alleles. They then proceeded to study the interference between the linked beneficial alleles. However, this simulation only aims to present a single selective sweep.%0a%0aThis simulation works first by simulating the process of entire populations generation by generation forward in time where a mutant allele is introduced at a neutral locus and the frequency of change is monitored. The number of generation before fixation of the allele is obtained, thus ending the simulation.%0a%0aThirty thousand diploid individuals with two loci of interest are looked at here. A mutation thus occurs at one loci which are linked. Only ten copies of the beneficial allele are introduced into the population. Recombination and fitness variables were used as controls to examine the generations until fixation occurs as well as the genetic variation variable, known as the I2k value.%0a%0aResults from Table 1 were re-simulated to verify Kim and Stephan's work. The results found using simuPOP were very similar to Kim and Stephan's data found. There were several slight discrepancies, but they may be to the fact that only 10 simulations of each variable was run using simuPOP while 500 simulations were run for each variable in Kim and Stephan's data.%0a%0a%0a%0a=python [=%0adef simulate(r, eta, size=30000, numLoci=2, gen=500):%0a    pop = population(size=size, loci=[numLoci], infoFields='fitness')%0a%0a    for i,ind in enumerate(pop.individuals()):%0a        if i %3c 5:%0a            ind.setAllele(0, 0, ploidy=0)%0a            ind.setAllele(0, 0, ploidy=1)%0a            ind.setAllele(1, 1, ploidy=0)%0a            ind.setAllele(1, 1, ploidy=1)%0a        else:%0a            ind.setAllele(2*i, 0, ploidy=0)%0a            ind.setAllele(2*i+1, 0, ploidy=1)%0a            ind.setAllele(0, 1, ploidy=0)%0a            ind.setAllele(0, 1, ploidy=1)%0a%0a    simu = simulator(pop, randomMating(ops=recombinator(rates=r)))%0a%0a    selLocus = 1%0a%0a    if useRPy:%0a        plotter = varPlotter('alleleFreq[%25d][1]' %25 selLocus,%0a            ylim=[0, 1], update=10, legend=['Allele freq'],%0a	    xlab="genenerations", ylab="alleleFrequency", saveAs='selectionsweep.png')%0a    else:%0a        plotter = noneOp()%0a        %0a    a=[]%0a%0a    g = simu.evolve(%0a        initOps = initSex(),%0a        preOps = [%0a            stat (alleleFreq=[selLocus]),%0a            ifElse('alleleFreq[%25d][1] == 0' %25 selLocus, %0a                ifOps=[%0a                    pyEval (r'"introduce at gen %25d\n"%25 gen'),%0a                    pointMutator(inds=0, loci=selLocus, allele=1, ploidy=0, at=0),%0a                ]),%0a            maSelector (loci = selLocus, fitness = [1, 1.+2*eta*0.05, 1+2*0.05]),%0a            stat (alleleFreq=[selLocus]),%0a        ],%0a        postOps = [%0a            #dumper(),%0a            stat(alleleFreq=[0,1]),%0a            pyOperator(func = I2k, param=[0]),%0a            #pyEval(r"'Gen %25d: allele frequency: %25.3e I2k: %25.2e\n' %25 (gen, alleleFreq[1][1], I2k[0])"),%0a            terminateIf('len(alleleFreq[1]) == 1'),%0a            #plotter,%0a            #pause(at=gen-1)%0a        ],%0a%0a    #dryrun=True,%0a    gen = gen%0a    )%0a=]
time=1261111730
title=Selective Sweep 
author:1261111730=
diff:1261111730:1252939570:=25c25,56%0a%3c def simulate(r, eta, size=30000, numLoci=2, gen=500):%0a---%0a> %0a> #%0a> # Selection Sweep Model%0a> #%0a> %0a> """%0a> This program attempts to model selective sweep.%0a> """%0a> from simuOpt import setOptions%0a> setOptions(alleleType='long')%0a> %0a> from simuPOP import *%0a> %0a> try:%0a>     from simuRPy import *%0a> except:%0a>     print "simuRPy import failed. Please check your rpy installation."%0a>     useRPy = False%0a> else:%0a>     useRPy = True%0a>         %0a> def I2k(pop, loci):%0a>     #Stat(pop, alleleFreq=loci)%0a>     I2k ={}%0a>     for loc in loci:%0a>         #print pop.dvars().alleleFreq[loc].values()[0]%0a>         I2k[loc] = sum([x*x for x in pop.dvars().alleleFreq[loc].values()])%0a>         #print I2k%0a>     pop.dvars().I2k = I2k%0a>     return True            %0a> %0a> def simulate(size=30000, numLoci=2, gen=500):%0a40,41c71,72%0a%3c     simu = simulator(pop, randomMating(ops=recombinator(rates=r)))%0a%3c %0a---%0a>     simu = simulator(pop, randomMating())%0a> %0a54,63c85,86%0a%3c         initOps = initSex(),%0a%3c         preOps = [%0a%3c             stat (alleleFreq=[selLocus]),%0a%3c             ifElse('alleleFreq[%25d][1] == 0' %25 selLocus, %0a%3c                 ifOps=[%0a%3c                     pyEval (r'"introduce at gen %25d\n"%25 gen'),%0a%3c                     pointMutator(inds=0, loci=selLocus, allele=1, ploidy=0, at=0),%0a%3c                 ]),%0a%3c             maSelector (loci = selLocus, fitness = [1, 1.+2*eta*0.05, 1+2*0.05]),%0a%3c             stat (alleleFreq=[selLocus]),%0a---%0a>     preOps = [%0a>         initSex()%0a65,72c88,107%0a%3c         postOps = [%0a%3c             #dumper(),%0a%3c             stat(alleleFreq=[0,1]),%0a%3c             pyOperator(func = I2k, param=[0]),%0a%3c             #pyEval(r"'Gen %25d: allele frequency: %25.3e I2k: %25.2e\n' %25 (gen, alleleFreq[1][1], I2k[0])"),%0a%3c             terminateIf('len(alleleFreq[1]) == 1'),%0a%3c             #plotter,%0a%3c             #pause(at=gen-1)%0a---%0a>     ops = [%0a>         stat (alleleFreq=[selLocus], stage=PreMating),%0a>         ifElse('alleleFreq[%25d][1] == 0' %25 selLocus, stage=PreMating,%0a>             ifOps=[%0a>             pyEval (r'"introduce at gen %25d\n"%25 gen'),%0a>             pointMutator(inds=0, loci=selLocus, allele=1, ploidy=0, at=0, stage=PreMating),%0a>             ]),%0a>         %0a>         recombinator(rates=r),%0a> %0a>         #dumper(stage=PreMating),%0a>         stat (alleleFreq=[selLocus], stage=PreMating),%0a>         maSelector (loci = selLocus, fitness = [1, 1.+2*eta*0.05, 1+2*0.05]),%0a>         #dumper(),%0a>         stat(alleleFreq=[0,1]),%0a>         pyOperator(func = I2k, param=[0]),%0a>         #pyEval(r"'Gen %25d: allele frequency: %25.3e I2k: %25.2e\n' %25 (gen, alleleFreq[1][1], I2k[0])"),%0a>         terminateIf('len(alleleFreq[1]) == 1'),%0a>         #plotter,%0a>         #pause(at=gen-1)%0a77a113,125%0a>     %0a>     %0a>     return simu.dvars(0).I2k[0], simu.dvars(0).alleleFreq[1][1], g[0]%0a> %0a> resFile = open('result.txt', 'w')%0a> %0a> for r, eta in zip((0.5, 0.01, 0.0033, 0.001, 0.001, 0.001, 0.001),%0a>                  (0.5, 0.5, 0.5, 0.02, 0.1, 0.5, 0.9)):%0a>   for rep in range(10):%0a>       res = simulate(size=10000, numLoci=2, gen=2000)%0a>       print >> resFile, r, eta, res, rep%0a> %0a> %0a
host:1261111730=127.0.0.1
author:1252939570=
diff:1252939570:1252939239:=126c126,188%0a%3c =]%0a\ No newline at end of file%0a---%0a> =]%0a> %0a> The following is one of the possible outputs of the above script:%0a> %0a> %25define=box block bgcolor=#ddddff border="1px blue"%25%0a> %25box%25 [@%0a> Gen:   0 Gst: 0.000050 (all), 0.000545 (sample) Fst: 0.000025 (all) -0.000189 (sample)%0a> Gen:  20 Gst: 0.000233 (all), 0.001049 (sample) Fst: 0.000300 (all) 0.000586 (sample)%0a> Gen:  40 Gst: 0.001564 (all), 0.001374 (sample) Fst: 0.002294 (all) 0.001064 (sample)%0a> Gen:  60 Gst: 0.002097 (all), 0.002351 (sample) Fst: 0.003092 (all) 0.002522 (sample)%0a> Gen:  80 Gst: 0.002803 (all), 0.002345 (sample) Fst: 0.004149 (all) 0.002512 (sample)%0a> Gen: 100 Gst: 0.003123 (all), 0.003653 (sample) Fst: 0.004627 (all) 0.004473 (sample)%0a> Gen: 120 Gst: 0.004032 (all), 0.003035 (sample) Fst: 0.005986 (all) 0.003551 (sample)%0a> Gen: 140 Gst: 0.004738 (all), 0.006816 (sample) Fst: 0.007041 (all) 0.009195 (sample)%0a> Gen: 160 Gst: 0.004622 (all), 0.007112 (sample) Fst: 0.006867 (all) 0.009641 (sample)%0a> Gen: 180 Gst: 0.005747 (all), 0.006117 (sample) Fst: 0.008547 (all) 0.008170 (sample)%0a> Gen: 200 Gst: 0.006219 (all), 0.006300 (sample) Fst: 0.009250 (all) 0.008449 (sample)%0a> Gen: 220 Gst: 0.007188 (all), 0.007680 (sample) Fst: 0.010693 (all) 0.010477 (sample)%0a> Gen: 240 Gst: 0.008256 (all), 0.006324 (sample) Fst: 0.012284 (all) 0.008466 (sample)%0a> Gen: 260 Gst: 0.008396 (all), 0.008324 (sample) Fst: 0.012492 (all) 0.011446 (sample)%0a> Gen: 280 Gst: 0.009328 (all), 0.008011 (sample) Fst: 0.013878 (all) 0.010963 (sample)%0a> Gen: 300 Gst: 0.008824 (all), 0.008966 (sample) Fst: 0.013129 (all) 0.012396 (sample)%0a> Gen: 320 Gst: 0.010391 (all), 0.009601 (sample) Fst: 0.015457 (all) 0.013354 (sample)%0a> Gen: 340 Gst: 0.010343 (all), 0.010922 (sample) Fst: 0.015385 (all) 0.015310 (sample)%0a> Gen: 360 Gst: 0.010145 (all), 0.009684 (sample) Fst: 0.015091 (all) 0.013466 (sample)%0a> Gen: 380 Gst: 0.012994 (all), 0.014168 (sample) Fst: 0.019316 (all) 0.020123 (sample)%0a> Gen: 400 Gst: 0.012513 (all), 0.012029 (sample) Fst: 0.018604 (all) 0.016972 (sample)%0a> Gen: 420 Gst: 0.014496 (all), 0.016989 (sample) Fst: 0.021538 (all) 0.024289 (sample)%0a> Gen: 440 Gst: 0.012049 (all), 0.011997 (sample) Fst: 0.017916 (all) 0.016896 (sample)%0a> Gen: 460 Gst: 0.010773 (all), 0.014430 (sample) Fst: 0.016024 (all) 0.020513 (sample)%0a> Gen: 480 Gst: 0.009734 (all), 0.010997 (sample) Fst: 0.014481 (all) 0.015440 (sample)%0a> %0a> @]%0a> %0a> If we increase the number of subpopulations, the difference between {$G_{st}$} and {$F_{st}$} becomes smaller. The following is a possible output when we use 10 subpopulations instead of 3 (each of size 10000):%0a> %0a> %25box%25 [@%0a> Gen:   0 Gst: 0.000104 (all), 0.001035 (sample) Fst: 0.000066 (all) 0.000152 (sample)%0a> Gen:  20 Gst: 0.000910 (all), 0.001926 (sample) Fst: 0.000961 (all) 0.001134 (sample)%0a> Gen:  40 Gst: 0.001595 (all), 0.002844 (sample) Fst: 0.001722 (all) 0.002156 (sample)%0a> Gen:  60 Gst: 0.002499 (all), 0.002543 (sample) Fst: 0.002726 (all) 0.001830 (sample)%0a> Gen:  80 Gst: 0.003286 (all), 0.004476 (sample) Fst: 0.003600 (all) 0.003974 (sample)%0a> Gen: 100 Gst: 0.004412 (all), 0.004964 (sample) Fst: 0.004850 (all) 0.004521 (sample)%0a> Gen: 120 Gst: 0.005066 (all), 0.006313 (sample) Fst: 0.005575 (all) 0.006010 (sample)%0a> Gen: 140 Gst: 0.006552 (all), 0.007172 (sample) Fst: 0.007225 (all) 0.006972 (sample)%0a> Gen: 160 Gst: 0.007599 (all), 0.008516 (sample) Fst: 0.008386 (all) 0.008455 (sample)%0a> Gen: 180 Gst: 0.009159 (all), 0.010090 (sample) Fst: 0.010117 (all) 0.010206 (sample)%0a> Gen: 200 Gst: 0.009225 (all), 0.010739 (sample) Fst: 0.010190 (all) 0.010924 (sample)%0a> Gen: 220 Gst: 0.011350 (all), 0.011179 (sample) Fst: 0.012546 (all) 0.011421 (sample)%0a> Gen: 240 Gst: 0.011750 (all), 0.013076 (sample) Fst: 0.012989 (all) 0.013533 (sample)%0a> Gen: 260 Gst: 0.012848 (all), 0.014396 (sample) Fst: 0.014206 (all) 0.014974 (sample)%0a> Gen: 280 Gst: 0.014376 (all), 0.015611 (sample) Fst: 0.015899 (all) 0.016332 (sample)%0a> Gen: 300 Gst: 0.014542 (all), 0.015677 (sample) Fst: 0.016083 (all) 0.016394 (sample)%0a> Gen: 320 Gst: 0.017318 (all), 0.018611 (sample) Fst: 0.019156 (all) 0.019651 (sample)%0a> Gen: 340 Gst: 0.019126 (all), 0.019498 (sample) Fst: 0.021157 (all) 0.020635 (sample)%0a> Gen: 360 Gst: 0.020142 (all), 0.022216 (sample) Fst: 0.022281 (all) 0.023654 (sample)%0a> Gen: 380 Gst: 0.021645 (all), 0.022353 (sample) Fst: 0.023944 (all) 0.023788 (sample)%0a> Gen: 400 Gst: 0.022627 (all), 0.023709 (sample) Fst: 0.025030 (all) 0.025303 (sample)%0a> Gen: 420 Gst: 0.022979 (all), 0.022245 (sample) Fst: 0.025419 (all) 0.023679 (sample)%0a> Gen: 440 Gst: 0.023283 (all), 0.024036 (sample) Fst: 0.025755 (all) 0.025663 (sample)%0a> Gen: 460 Gst: 0.023463 (all), 0.024456 (sample) Fst: 0.025954 (all) 0.026116 (sample)%0a> Gen: 480 Gst: 0.024137 (all), 0.025089 (sample) Fst: 0.026699 (all) 0.026822 (sample)%0a> @]%0a
host:1252939570=127.0.0.1
author:1252939239=
diff:1252939239:1252939049:=11,13c11,12%0a%3c This written simulation is based off of Yuseob Kim and Wolfgang Stephan's own study published in "Selective Sweeps in the Presence of Interference Among Partially Linked Loci". The paper can be found at: %0a%3c http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=12750349  %0a%3c %0a---%0a> This written simulation is based off of Yuseob Kim and Wolfgang Stephan's own study published in "Selective Sweeps in the Presence of Interference Among Partially Linked Loci". The paper can be found at http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=12750349 . %0a> %0a25,35c24%0a%3c %0a%3c #%0a%3c # Selection Sweep Model%0a%3c #%0a%3c %0a%3c """%0a%3c This program attempts to model selective sweep.%0a%3c """%0a%3c from simuOpt import setOptions%0a%3c setOptions(alleleType='long')%0a%3c %0a---%0a> #!/usr/bin/env python%0a37,84c26,42%0a%3c %0a%3c try:%0a%3c     from simuRPy import *%0a%3c except:%0a%3c     print "simuRPy import failed. Please check your rpy installation."%0a%3c     useRPy = False%0a%3c else:%0a%3c     useRPy = True%0a%3c         %0a%3c def I2k(pop, loci):%0a%3c     #Stat(pop, alleleFreq=loci)%0a%3c     I2k ={}%0a%3c     for loc in loci:%0a%3c         #print pop.dvars().alleleFreq[loc].values()[0]%0a%3c         I2k[loc] = sum([x*x for x in pop.dvars().alleleFreq[loc].values()])%0a%3c         #print I2k%0a%3c     pop.dvars().I2k = I2k%0a%3c     return True            %0a%3c %0a%3c def simulate(size=30000, numLoci=2, gen=500):%0a%3c     pop = population(size=size, loci=[numLoci], infoFields='fitness')%0a%3c %0a%3c     for i,ind in enumerate(pop.individuals()):%0a%3c         if i %3c 5:%0a%3c             ind.setAllele(0, 0, ploidy=0)%0a%3c             ind.setAllele(0, 0, ploidy=1)%0a%3c             ind.setAllele(1, 1, ploidy=0)%0a%3c             ind.setAllele(1, 1, ploidy=1)%0a%3c         else:%0a%3c             ind.setAllele(2*i, 0, ploidy=0)%0a%3c             ind.setAllele(2*i+1, 0, ploidy=1)%0a%3c             ind.setAllele(0, 1, ploidy=0)%0a%3c             ind.setAllele(0, 1, ploidy=1)%0a%3c %0a%3c     simu = simulator(pop, randomMating())%0a%3c %0a%3c     selLocus = 1%0a%3c %0a%3c     if useRPy:%0a%3c         plotter = varPlotter('alleleFreq[%25d][1]' %25 selLocus,%0a%3c             ylim=[0, 1], update=10, legend=['Allele freq'],%0a%3c 	    xlab="genenerations", ylab="alleleFrequency", saveAs='selectionsweep.png')%0a%3c     else:%0a%3c         plotter = noneOp()%0a%3c         %0a%3c     a=[]%0a%3c %0a%3c     g = simu.evolve(%0a---%0a> from simuUtil import MigrIslandRates%0a> %0a> %0a> def calcFst(pop):%0a>     'Calculate Fst and Gst for the whole population and a random sample'%0a>     Stat(pop, structure=range(5), vars=['F_st', 'G_st'])%0a>     sample = RandomSample(pop, size=[500]*pop.numSubPop())[0]%0a>     Stat(sample, structure=range(5), vars=['F_st', 'G_st'])%0a>     print 'Gen: %253d Gst: %25.6f (all), %25.6f (sample) Fst: %25.6f (all) %25.6f (sample)' \%0a>         %25 (pop.dvars().gen,%0a>            pop.dvars().G_st, sample.dvars().G_st,%0a>            pop.dvars().F_st, sample.dvars().F_st)%0a>     return True%0a> %0a> simu = simulator(population([10000]*3, loci=[1]*5, infoFields='migrate_to'),%0a>     randomMating())%0a> simu.evolve(%0a86,87c44,46%0a%3c         initSex()%0a%3c         ],%0a---%0a>         initByFreq([0.5, 0.5], loci=[0, 2]),%0a>         initByFreq([0.2, 0.4, 0.4], loci=[1, 3, 4]),%0a>     ],%0a89,125c48,52%0a%3c         stat (alleleFreq=[selLocus], stage=PreMating),%0a%3c         ifElse('alleleFreq[%25d][1] == 0' %25 selLocus, stage=PreMating,%0a%3c             ifOps=[%0a%3c             pyEval (r'"introduce at gen %25d\n"%25 gen'),%0a%3c             pointMutator(inds=0, loci=selLocus, allele=1, ploidy=0, at=0, stage=PreMating),%0a%3c             ]),%0a%3c         %0a%3c         recombinator(rates=r),%0a%3c %0a%3c         #dumper(stage=PreMating),%0a%3c         stat (alleleFreq=[selLocus], stage=PreMating),%0a%3c         maSelector (loci = selLocus, fitness = [1, 1.+2*eta*0.05, 1+2*0.05]),%0a%3c         #dumper(),%0a%3c         stat(alleleFreq=[0,1]),%0a%3c         pyOperator(func = I2k, param=[0]),%0a%3c         #pyEval(r"'Gen %25d: allele frequency: %25.3e I2k: %25.2e\n' %25 (gen, alleleFreq[1][1], I2k[0])"),%0a%3c         terminateIf('len(alleleFreq[1]) == 1'),%0a%3c         #plotter,%0a%3c         #pause(at=gen-1)%0a%3c         ],%0a%3c %0a%3c     #dryrun=True,%0a%3c     gen = gen%0a%3c     )%0a%3c     %0a%3c     %0a%3c     return simu.dvars(0).I2k[0], simu.dvars(0).alleleFreq[1][1], g[0]%0a%3c %0a%3c resFile = open('result.txt', 'w')%0a%3c %0a%3c for r, eta in zip((0.5, 0.01, 0.0033, 0.001, 0.001, 0.001, 0.001),%0a%3c                  (0.5, 0.5, 0.5, 0.02, 0.1, 0.5, 0.9)):%0a%3c   for rep in range(10):%0a%3c       res = simulate(size=10000, numLoci=2, gen=2000)%0a%3c       print >> resFile, r, eta, res, rep%0a%3c %0a%3c %0a---%0a>         # migrator(rate=MigrIslandRates(0.01, 3)),%0a>         pyOperator(func=calcFst, step=20),%0a>     ],%0a>     gen = 500%0a> )%0a
host:1252939239=127.0.0.1
author:1252939049=
diff:1252939049:1252939049:=1,115d0%0a%3c (:title Selective Sweep :)%0a%3c %0a%3c %25rfloat text-align=center margin-top=5px margin-right=25px margin-bottom=15px margin-left=25px %25 [[Attach:SelectiveSweep.py | http://simupop.sourceforge.net/images/download.jpg]]|SelectiveSweep.py%0a%3c %0a%3c Selective sweep is defined as the reduction or amplification of variation in nucleotides in neighboring DNA because of natural selection. This program specifically aims to simulate amplification. For example, a strong selective sweep would result in the positively selected haplotype as the only allele that exists in the population. Essentially, the mutated allele and its neighbors are positively selected for. This results in a large reduction in genetic variation.%0a%3c %0a%3c A mutation must first occur that seeks to increase the fitness of the carrier. Then, natural selection favors that mutation that increases fitness. Thus, the mutant allele will become more prevalent among the population. Neighboring alleles linked to the mutated allele will also become more prevalent. Think of it almost as a type of genetic hitchhiking.%0a%3c %0a%3c An earlier version of this simulation was first written with 101 loci of interest. A positively selected mutant allele was then introduced into the 51st allele which was usually lost to genetic drift. The initial simulation thus reintroduced the mutation if the allele was lost.%0a%3c %0a%3c This written simulation is based off of Yuseob Kim and Wolfgang Stephan's own study published in "Selective Sweeps in the Presence of Interference Among Partially Linked Loci". The paper can be found at http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=12750349 . %0a%3c %0a%3c Most of Kim and Stephan's study was based on two or more selected alleles. They then proceeded to study the interference between the linked beneficial alleles. However, this simulation only aims to present a single selective sweep.%0a%3c %0a%3c This simulation works first by simulating the process of entire populations generation by generation forward in time where a mutant allele is introduced at a neutral locus and the frequency of change is monitored. The number of generation before fixation of the allele is obtained, thus ending the simulation.%0a%3c %0a%3c Thirty thousand diploid individuals with two loci of interest are looked at here. A mutation thus occurs at one loci which are linked. Only ten copies of the beneficial allele are introduced into the population. Recombination and fitness variables were used as controls to examine the generations until fixation occurs as well as the genetic variation variable, known as the I2k value.%0a%3c %0a%3c Results from Table 1 were re-simulated to verify Kim and Stephan's work. The results found using simuPOP were very similar to Kim and Stephan's data found. There were several slight discrepancies, but they may be to the fact that only 10 simulations of each variable was run using simuPOP while 500 simulations were run for each variable in Kim and Stephan's data.%0a%3c %0a%3c %0a%3c %0a%3c =python [=%0a%3c #!/usr/bin/env python%0a%3c from simuPOP import *%0a%3c from simuUtil import MigrIslandRates%0a%3c %0a%3c %0a%3c def calcFst(pop):%0a%3c     'Calculate Fst and Gst for the whole population and a random sample'%0a%3c     Stat(pop, structure=range(5), vars=['F_st', 'G_st'])%0a%3c     sample = RandomSample(pop, size=[500]*pop.numSubPop())[0]%0a%3c     Stat(sample, structure=range(5), vars=['F_st', 'G_st'])%0a%3c     print 'Gen: %253d Gst: %25.6f (all), %25.6f (sample) Fst: %25.6f (all) %25.6f (sample)' \%0a%3c         %25 (pop.dvars().gen,%0a%3c            pop.dvars().G_st, sample.dvars().G_st,%0a%3c            pop.dvars().F_st, sample.dvars().F_st)%0a%3c     return True%0a%3c %0a%3c simu = simulator(population([10000]*3, loci=[1]*5, infoFields='migrate_to'),%0a%3c     randomMating())%0a%3c simu.evolve(%0a%3c     preOps = [%0a%3c         initByFreq([0.5, 0.5], loci=[0, 2]),%0a%3c         initByFreq([0.2, 0.4, 0.4], loci=[1, 3, 4]),%0a%3c     ],%0a%3c     ops = [%0a%3c         # migrator(rate=MigrIslandRates(0.01, 3)),%0a%3c         pyOperator(func=calcFst, step=20),%0a%3c     ],%0a%3c     gen = 500%0a%3c )%0a%3c =]%0a%3c %0a%3c The following is one of the possible outputs of the above script:%0a%3c %0a%3c %25define=box block bgcolor=#ddddff border="1px blue"%25%0a%3c %25box%25 [@%0a%3c Gen:   0 Gst: 0.000050 (all), 0.000545 (sample) Fst: 0.000025 (all) -0.000189 (sample)%0a%3c Gen:  20 Gst: 0.000233 (all), 0.001049 (sample) Fst: 0.000300 (all) 0.000586 (sample)%0a%3c Gen:  40 Gst: 0.001564 (all), 0.001374 (sample) Fst: 0.002294 (all) 0.001064 (sample)%0a%3c Gen:  60 Gst: 0.002097 (all), 0.002351 (sample) Fst: 0.003092 (all) 0.002522 (sample)%0a%3c Gen:  80 Gst: 0.002803 (all), 0.002345 (sample) Fst: 0.004149 (all) 0.002512 (sample)%0a%3c Gen: 100 Gst: 0.003123 (all), 0.003653 (sample) Fst: 0.004627 (all) 0.004473 (sample)%0a%3c Gen: 120 Gst: 0.004032 (all), 0.003035 (sample) Fst: 0.005986 (all) 0.003551 (sample)%0a%3c Gen: 140 Gst: 0.004738 (all), 0.006816 (sample) Fst: 0.007041 (all) 0.009195 (sample)%0a%3c Gen: 160 Gst: 0.004622 (all), 0.007112 (sample) Fst: 0.006867 (all) 0.009641 (sample)%0a%3c Gen: 180 Gst: 0.005747 (all), 0.006117 (sample) Fst: 0.008547 (all) 0.008170 (sample)%0a%3c Gen: 200 Gst: 0.006219 (all), 0.006300 (sample) Fst: 0.009250 (all) 0.008449 (sample)%0a%3c Gen: 220 Gst: 0.007188 (all), 0.007680 (sample) Fst: 0.010693 (all) 0.010477 (sample)%0a%3c Gen: 240 Gst: 0.008256 (all), 0.006324 (sample) Fst: 0.012284 (all) 0.008466 (sample)%0a%3c Gen: 260 Gst: 0.008396 (all), 0.008324 (sample) Fst: 0.012492 (all) 0.011446 (sample)%0a%3c Gen: 280 Gst: 0.009328 (all), 0.008011 (sample) Fst: 0.013878 (all) 0.010963 (sample)%0a%3c Gen: 300 Gst: 0.008824 (all), 0.008966 (sample) Fst: 0.013129 (all) 0.012396 (sample)%0a%3c Gen: 320 Gst: 0.010391 (all), 0.009601 (sample) Fst: 0.015457 (all) 0.013354 (sample)%0a%3c Gen: 340 Gst: 0.010343 (all), 0.010922 (sample) Fst: 0.015385 (all) 0.015310 (sample)%0a%3c Gen: 360 Gst: 0.010145 (all), 0.009684 (sample) Fst: 0.015091 (all) 0.013466 (sample)%0a%3c Gen: 380 Gst: 0.012994 (all), 0.014168 (sample) Fst: 0.019316 (all) 0.020123 (sample)%0a%3c Gen: 400 Gst: 0.012513 (all), 0.012029 (sample) Fst: 0.018604 (all) 0.016972 (sample)%0a%3c Gen: 420 Gst: 0.014496 (all), 0.016989 (sample) Fst: 0.021538 (all) 0.024289 (sample)%0a%3c Gen: 440 Gst: 0.012049 (all), 0.011997 (sample) Fst: 0.017916 (all) 0.016896 (sample)%0a%3c Gen: 460 Gst: 0.010773 (all), 0.014430 (sample) Fst: 0.016024 (all) 0.020513 (sample)%0a%3c Gen: 480 Gst: 0.009734 (all), 0.010997 (sample) Fst: 0.014481 (all) 0.015440 (sample)%0a%3c %0a%3c @]%0a%3c %0a%3c If we increase the number of subpopulations, the difference between {$G_{st}$} and {$F_{st}$} becomes smaller. The following is a possible output when we use 10 subpopulations instead of 3 (each of size 10000):%0a%3c %0a%3c %25box%25 [@%0a%3c Gen:   0 Gst: 0.000104 (all), 0.001035 (sample) Fst: 0.000066 (all) 0.000152 (sample)%0a%3c Gen:  20 Gst: 0.000910 (all), 0.001926 (sample) Fst: 0.000961 (all) 0.001134 (sample)%0a%3c Gen:  40 Gst: 0.001595 (all), 0.002844 (sample) Fst: 0.001722 (all) 0.002156 (sample)%0a%3c Gen:  60 Gst: 0.002499 (all), 0.002543 (sample) Fst: 0.002726 (all) 0.001830 (sample)%0a%3c Gen:  80 Gst: 0.003286 (all), 0.004476 (sample) Fst: 0.003600 (all) 0.003974 (sample)%0a%3c Gen: 100 Gst: 0.004412 (all), 0.004964 (sample) Fst: 0.004850 (all) 0.004521 (sample)%0a%3c Gen: 120 Gst: 0.005066 (all), 0.006313 (sample) Fst: 0.005575 (all) 0.006010 (sample)%0a%3c Gen: 140 Gst: 0.006552 (all), 0.007172 (sample) Fst: 0.007225 (all) 0.006972 (sample)%0a%3c Gen: 160 Gst: 0.007599 (all), 0.008516 (sample) Fst: 0.008386 (all) 0.008455 (sample)%0a%3c Gen: 180 Gst: 0.009159 (all), 0.010090 (sample) Fst: 0.010117 (all) 0.010206 (sample)%0a%3c Gen: 200 Gst: 0.009225 (all), 0.010739 (sample) Fst: 0.010190 (all) 0.010924 (sample)%0a%3c Gen: 220 Gst: 0.011350 (all), 0.011179 (sample) Fst: 0.012546 (all) 0.011421 (sample)%0a%3c Gen: 240 Gst: 0.011750 (all), 0.013076 (sample) Fst: 0.012989 (all) 0.013533 (sample)%0a%3c Gen: 260 Gst: 0.012848 (all), 0.014396 (sample) Fst: 0.014206 (all) 0.014974 (sample)%0a%3c Gen: 280 Gst: 0.014376 (all), 0.015611 (sample) Fst: 0.015899 (all) 0.016332 (sample)%0a%3c Gen: 300 Gst: 0.014542 (all), 0.015677 (sample) Fst: 0.016083 (all) 0.016394 (sample)%0a%3c Gen: 320 Gst: 0.017318 (all), 0.018611 (sample) Fst: 0.019156 (all) 0.019651 (sample)%0a%3c Gen: 340 Gst: 0.019126 (all), 0.019498 (sample) Fst: 0.021157 (all) 0.020635 (sample)%0a%3c Gen: 360 Gst: 0.020142 (all), 0.022216 (sample) Fst: 0.022281 (all) 0.023654 (sample)%0a%3c Gen: 380 Gst: 0.021645 (all), 0.022353 (sample) Fst: 0.023944 (all) 0.023788 (sample)%0a%3c Gen: 400 Gst: 0.022627 (all), 0.023709 (sample) Fst: 0.025030 (all) 0.025303 (sample)%0a%3c Gen: 420 Gst: 0.022979 (all), 0.022245 (sample) Fst: 0.025419 (all) 0.023679 (sample)%0a%3c Gen: 440 Gst: 0.023283 (all), 0.024036 (sample) Fst: 0.025755 (all) 0.025663 (sample)%0a%3c Gen: 460 Gst: 0.023463 (all), 0.024456 (sample) Fst: 0.025954 (all) 0.026116 (sample)%0a%3c Gen: 480 Gst: 0.024137 (all), 0.025089 (sample) Fst: 0.026699 (all) 0.026822 (sample)%0a%3c @]%0a
host:1252939049=127.0.0.1
