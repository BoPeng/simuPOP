version=pmwiki-2.1.27 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.7) Gecko/2009021910 Firefox/3.0.7
author=
csum=
ctime=1235234709
host=127.0.0.1
name=Main.DevelopmentStories
rev=40
targets=
text=(:title Stories about the development of simuPOP:)%0a(:toc:)%0a%0a!!! Why the development of a MPI version of simuPOP was discontinued? (Mar. 10, 2009)%0a%0aA prototype of a MPI version of simuPOP was added to simuPOP 0.7.5 in Dec. 2006. The general idea worked and I was even able to run small scripts using it. However, because a MPI version could not achieve its initial design goals, and because a full implementation required major revision to the simuPOP core, the MPI code was removed in simuPOP 0.8.3.%0a%0aWhen the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seemed to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%0aHowever, compare to other single-executable programs, a MPI implementation of simuPOP was extremely difficult to design. Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI design would be a master-slave model where a master node interprets a script, and sends very detailed instructions to the slave nodes. However, this model requires a large amount of communication between nodes, especially with population changes. Consequently, the MPI modules may not provide any performance advantage over a regular module. This was more or less confirmed using my experimental implementation.%0a%0aAnd you know what happened next. RAM became cheaper and cheaper and even home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%0aAnother reason for the removal of the MPI version is because I am looking into an [[http://www.openmp.org | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%0aIf everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x releases will have openMP support.%0a%0a%0a!!! Icc vs. Gcc: which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%0asimuPOP uses Visual C++ 2003 (win32, Python 2.4 and 2.5), Visual C++ Express 2008 (win32, Python 2.6), and GCC/G++ for all other platforms (MacOS, Linux, Solaris). These compilers are chosen because they are the compilers used for the official Python distributions.%0a%0aIntel icc is usually considered to generate (much) faster code than gcc. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%0aHere are the steps:%0a%0a* Download icc from Intel ICC website. The linux non-commercial version is free, and is the version I use.%0a%0a* Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment. I use csh and set a @@~/.cshrc@@ file as follows:%0a%0a-> [@%0asource /my/home/intel/Compiler/11.0/081/bin/iccvars.csh intel64%0asetenv PATH /my/home/Python26/bin:${PATH}%0a@]%0a%0a* Download Python 2.6 source code, and compile as follows%0a%0a-> [@%0a> tar zxf Python-2.6.tgz%0a> cd Python-2.6%0a> setenv CC icc%0a> setenv CXX icc%0a> ./configure --prefix=/my/home/Python26%0a> make%0a> make install%0a@]%0a-> Note that some modules could not be compiled by icc.%0a%0a* (Optinal) download and install scons.%0a%0a* Then, I check up a clean copy of simuPOP, and compile simuPOP as usual:%0a--> [@%0a> python setup.py install%0a@]%0a-> or%0a--> [@%0a> scons install%0a@]%0a-> if scons is installed.%0a%0aThere are a lot more remarks (warnings) than gcc and many of them do not make much sense to me. Anyway, simuPOP is compiled successfully. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%0aDoes icc really help the performance of simuPOP? I do not have time for a thorough test so I run a typical random mating test in @@test_21_performance@@.%0a%0a-> [@%0a> cd simuPOP/test%0a> python test_21_performance.py TestPerformance.TestRandomMating%0a@]%0a%0afor both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result (execution time in seconds, the shorter the better):%0a%0a(:table border=1 cellpadding=5 cellspacing=0:)%0a(:cell colspan=2:) &nbsp;%0a(:cell align=center colspan=3:) N=10k%0a(:cell align=center colspan=3:) N=100k%0a(:cell align=center colspan=3:) N=1000k%0a(:cellnr:) &nbsp;%0a(:cell:) &nbsp;%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cellnr rowspan=3:) Gcc 4.1.2%0a(:cell:) binary%0a(:cell:) 0.30%0a(:cell:) 0.35%0a(:cell:) 0.53%0a(:cell:) 4.41%0a(:cell:) 7.43%0a(:cell:) 9.02%0a(:cell:) 85.33%0a(:cell:) 101.88%0a(:cell:) 141.08%0a(:cellnr:) short%0a(:cell:) 0.28%0a(:cell:) 0.32%0a(:cell:) 0.48%0a(:cell:) 3.89%0a(:cell:) 7.04%0a(:cell:) 8.49%0a(:cell:) 94.58%0a(:cell:) 115.20%0a(:cell:) 150.69%0a(:cellnr:) long%0a(:cell:) 0.29%0a(:cell:) 0.33%0a(:cell:) 0.50%0a(:cell:) 4.17%0a(:cell:) 7.73%0a(:cell:) 8.52%0a(:cell:) 101.29%0a(:cell:) 118.75%0a(:cell:) 156.76%0a(:cellnr rowspan=3:) Icc 11.0%0a(:cell:) binary%0a(:cell:) 0.34%0a(:cell:) 0.41%0a(:cell:) 0.62%0a(:cell:) 4.83%0a(:cell:) 8.17%0a(:cell:) 10.02%0a(:cell:) 89.03%0a(:cell:) 107.23%0a(:cell:) 151.62%0a(:cellnr:) short%0a(:cell:) 0.32%0a(:cell:) 0.38%0a(:cell:) 0.57%0a(:cell:) 4.21%0a(:cell:) 7.83%0a(:cell:) 9.07%0a(:cell:) 97.84%0a(:cell:) 121.65%0a(:cell:) 160.67%0a(:cellnr:) long%0a(:cell:) 0.29%0a(:cell:) 0.35%0a(:cell:) 0.55%0a(:cell:) 4.40%0a(:cell:) 8.18%0a(:cell:) 8.97%0a(:cell:) 104.4%0a(:cell:) 121.97%0a(:cell:) 165.00%0a(:tableend:)%0a%0aIt is still quite obvious that gcc is better in all cases, which comes as a surprise to me. Anyway, these numbers are from single runs and icc may not get the right optimization flags. If you have any suggestion, please feel free to let me know.%0a%0aThe comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) and 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a PC with a Quad-core CPU (Q6600) and 3G RAM, running 32bit of windows Vista. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%0a(:table border=1 cellpadding=5 cellspacing=0:)%0a(:cell colspan=2:) &nbsp;%0a(:cell align=center colspan=3:) N=10k%0a(:cell align=center colspan=3:) N=100k%0a(:cell align=center colspan=3:) N=1000k%0a(:cellnr:) &nbsp;%0a(:cell:) &nbsp;%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cellnr rowspan=3:) MacOS Gcc 4.1.2%0a(:cell:) binary%0a(:cell:) 0.23%0a(:cell:) 0.34%0a(:cell:) 0.52%0a(:cell:) 2.31%0a(:cell:) 3.37%0a(:cell:) 5.54%0a(:cell:) 40.12%0a(:cell:) 75.70%0a(:cell:) 100.56%0a(:cellnr:) short%0a(:cell:) 0.24%0a(:cell:) 0.34%0a(:cell:) 0.49%0a(:cell:) 2.51%0a(:cell:) 3.60%0a(:cell:) 5.53%0a(:cell:) 40.06%0a(:cell:) 75.19%0a(:cell:) 100.26%0a(:cellnr:) long%0a(:cell:) 0.24%0a(:cell:) 0.33%0a(:cell:) 0.48%0a(:cell:) 2.25%0a(:cell:) 3.38%0a(:cell:) 5.49%0a(:cell:) 40.51%0a(:cell:) 75.08%0a(:cell:) 101.39%0a(:cellnr rowspan=3:) Windows Vista Visual C++%0a(:cell:) binary%0a(:cell:) 0.53%0a(:cell:) 0.72%0a(:cell:) 0.93%0a(:cell:) 5.53%0a(:cell:) 8.57%0a(:cell:) 10.02%0a(:cell:) 85.38%0a(:cell:) 123.79%0a(:cell:) 141.51%0a(:cellnr:) short%0a(:cell:) 0.43%0a(:cell:) 0.60%0a(:cell:) 0.81%0a(:cell:) 4.55%0a(:cell:) 7.04%0a(:cell:) 8.66%0a(:cell:) 81.89%0a(:cell:) 118.15%0a(:cell:) 134.67%0a(:cellnr:) long%0a(:cell:) 0.43%0a(:cell:) 0.61%0a(:cell:) 0.82%0a(:cell:) 4.78%0a(:cell:) 7.59%0a(:cell:) 8.90%0a(:cell:) 88.21%0a(:cell:) 121.93%0a(:cell:) 138.19%0a(:tableend:)
time=1238171333
title=Stories about the development of simuPOP
author:1238171333=
diff:1238171333:1238171288:=70,71c70,71%0a%3c for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result (execution time in seconds, the shorter the better):%0a%3c %0a---%0a> for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result:%0a> %0a
host:1238171333=127.0.0.1
author:1238171288=
diff:1238171288:1236717530:=154,155c154,155%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) and 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a PC with a Quad-core CPU (Q6600) and 3G RAM, running 32bit of windows Vista. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1238171288=127.0.0.1
author:1236717530=
diff:1236717530:1236716577:=4,5c4,5%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued? (Mar. 10, 2009)%0a%3c %0a---%0a> !!! Why the development of a MPI version of simuPOP was discontinued? (Mar 10, 2009)%0a> %0a
host:1236717530=127.0.0.1
author:1236716577=
diff:1236716577:1236716527:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an [[http://www.openmp.org | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an [[www.openmp.org/ | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716577=127.0.0.1
author:1236716527=
diff:1236716527:1236716440:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an [[www.openmp.org/ | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716527=127.0.0.1
author:1236716440=
diff:1236716440:1236716140:=4,5c4,5%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued? (Mar 10, 2009)%0a%3c %0a---%0a> !!! Why the development of a MPI version of simuPOP was discontinued?%0a> %0a
host:1236716440=127.0.0.1
author:1236716140=
diff:1236716140:1236716078:=16,18c16,18%0a%3c If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x releases will have openMP support.%0a%3c %0a%3c %0a---%0a> If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x will have openMP support.%0a> %0a> %0a
host:1236716140=127.0.0.1
author:1236716078=
diff:1236716078:1236716012:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates simultaneously, or produce multiple offspring using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716078=127.0.0.1
author:1236716012=
diff:1236716012:1236716000:=12,13c12,13%0a%3c And you know what happened next. RAM became cheaper and cheaper and even home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a---%0a> And you know what happened next. RAM became cheaper and cheaper and even a home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a> %0a
host:1236716012=127.0.0.1
author:1236716000=
diff:1236716000:1236715895:=12,13c12,13%0a%3c And you know what happened next. RAM became cheaper and cheaper and even a home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a---%0a> And you know what happened next. RAM became cheaper and cheaper and everyone was getting 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a> %0a
host:1236716000=127.0.0.1
author:1236715895=
diff:1236715895:1236715366:=8,9c8,9%0a%3c When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seemed to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%3c %0a---%0a> When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seems to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a> %0a
host:1236715895=127.0.0.1
author:1236715366=
diff:1236715366:1236713884:=8,18c8,12%0a%3c When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seems to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%3c %0a%3c However, compare to other single-executable programs, a MPI implementation of simuPOP was extremely difficult to design. Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI design would be a master-slave model where a master node interprets a script, and sends very detailed instructions to the slave nodes. However, this model requires a large amount of communication between nodes, especially with population changes. Consequently, the MPI modules may not provide any performance advantage over a regular module. This was more or less confirmed using my experimental implementation.%0a%3c %0a%3c And you know what happened next. RAM became cheaper and cheaper and everyone was getting 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a%3c Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates simultaneously, or produce multiple offspring using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a%3c If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x will have openMP support.%0a%3c %0a%3c %0a---%0a> Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI implementation would be a master-slave design where a master node interprets a script, and sends very detailed instructions to the slave nodes. This is doable but requires the rewrite of almost all simuPOP functions.%0a> %0a> When the MPI version of simuPOP was first , 2G of RAM sounded huge and 64 bit operating systems were rare. When I re-considered the motivations for a MPI version, namely simulations of very large populations more efficiently, I realized that a MPI version could perhaps achieve the first (large population), but not the latter (efficiency). %0a> %0a> %0a
host:1236715366=127.0.0.1
author:1236713884=
diff:1236713884:1235966954:=4,12d3%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued?%0a%3c %0a%3c A prototype of a MPI version of simuPOP was added to simuPOP 0.7.5 in Dec. 2006. The general idea worked and I was even able to run small scripts using it. However, because a MPI version could not achieve its initial design goals, and because a full implementation required major revision to the simuPOP core, the MPI code was removed in simuPOP 0.8.3.%0a%3c %0a%3c Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI implementation would be a master-slave design where a master node interprets a script, and sends very detailed instructions to the slave nodes. This is doable but requires the rewrite of almost all simuPOP functions.%0a%3c %0a%3c When the MPI version of simuPOP was first , 2G of RAM sounded huge and 64 bit operating systems were rare. When I re-considered the motivations for a MPI version, namely simulations of very large populations more efficiently, I realized that a MPI version could perhaps achieve the first (large population), but not the latter (efficiency). %0a%3c %0a%3c %0a
host:1236713884=127.0.0.1
author:1235966954=
diff:1235966954:1235966868:=139,140c139,140%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It may be a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235966954=127.0.0.1
author:1235966868=
diff:1235966868:1235966841:=36a37%0a> %0a
host:1235966868=127.0.0.1
author:1235966841=
diff:1235966841:1235338510:=38c38%0a%3c --> [@%0a---%0a> -> [@%0a42c42%0a%3c --> [@%0a---%0a> -> [@%0a
host:1235966841=127.0.0.1
author:1235338510=
diff:1235338510:1235249333:=140,141c140,141%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235338510=127.0.0.1
author:1235249333=
diff:1235249333:1235243575:=47,48c47,48%0a%3c There are a lot more remarks (warnings) than gcc and many of them do not make much sense to me. Anyway, simuPOP is compiled successfully. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%3c %0a---%0a> There are a lot more remarks than gcc and I cannot really fix them all. Anyway, simuPOP is compiled OK. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a> %0a
host:1235249333=127.0.0.1
author:1235243575=
diff:1235243575:1235243506:=140,141c140,141%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 2-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same test on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235243575=127.0.0.1
author:1235243506=
diff:1235243506:1235242763:=197,199c197,199%0a%3c (:cell:) 85.38%0a%3c (:cell:) 123.79%0a%3c (:cell:) 141.51%0a---%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a211,219c211,219%0a%3c (:cell:) 0.43%0a%3c (:cell:) 0.61%0a%3c (:cell:) 0.82%0a%3c (:cell:) 4.78%0a%3c (:cell:) 7.59%0a%3c (:cell:) 8.90%0a%3c (:cell:) 88.21%0a%3c (:cell:) 121.93%0a%3c (:cell:) 138.19%0a---%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a
host:1235243506=127.0.0.1
author:1235242763=
diff:1235242763:1235242582:=191,196d190%0a%3c (:cell:) 0.53%0a%3c (:cell:) 0.72%0a%3c (:cell:) 0.93%0a%3c (:cell:) 5.53%0a%3c (:cell:) 8.57%0a%3c (:cell:) 10.02%0a199a194,199%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a209,210d208%0a%3c (:cell:) 134.67%0a%3c (:cellnr:) long%0a211a210%0a> (:cellnr:) long%0a219a219%0a> (:cell:) %0a
host:1235242763=127.0.0.1
author:1235242582=
diff:1235242582:1235241576:=140,220c140,142%0a%3c The comparison is done on a 2-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same test on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a%3c (:table border=1 cellpadding=5 cellspacing=0:)%0a%3c (:cell colspan=2:) &nbsp;%0a%3c (:cell align=center colspan=3:) N=10k%0a%3c (:cell align=center colspan=3:) N=100k%0a%3c (:cell align=center colspan=3:) N=1000k%0a%3c (:cellnr:) &nbsp;%0a%3c (:cell:) &nbsp;%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cellnr rowspan=3:) MacOS Gcc 4.1.2%0a%3c (:cell:) binary%0a%3c (:cell:) 0.23%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.52%0a%3c (:cell:) 2.31%0a%3c (:cell:) 3.37%0a%3c (:cell:) 5.54%0a%3c (:cell:) 40.12%0a%3c (:cell:) 75.70%0a%3c (:cell:) 100.56%0a%3c (:cellnr:) short%0a%3c (:cell:) 0.24%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.49%0a%3c (:cell:) 2.51%0a%3c (:cell:) 3.60%0a%3c (:cell:) 5.53%0a%3c (:cell:) 40.06%0a%3c (:cell:) 75.19%0a%3c (:cell:) 100.26%0a%3c (:cellnr:) long%0a%3c (:cell:) 0.24%0a%3c (:cell:) 0.33%0a%3c (:cell:) 0.48%0a%3c (:cell:) 2.25%0a%3c (:cell:) 3.38%0a%3c (:cell:) 5.49%0a%3c (:cell:) 40.51%0a%3c (:cell:) 75.08%0a%3c (:cell:) 101.39%0a%3c (:cellnr rowspan=3:) Windows Vista Visual C++%0a%3c (:cell:) binary%0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cellnr:) short%0a%3c (:cell:) 0.43%0a%3c (:cell:) 0.60%0a%3c (:cell:) 0.81%0a%3c (:cell:) 4.55%0a%3c (:cell:) 7.04%0a%3c (:cell:) 8.66%0a%3c (:cell:) 81.89%0a%3c (:cell:) 118.15%0a%3c (:cell:) %0a%3c (:cellnr:) long%0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:tableend:)%0a\ No newline at end of file%0a---%0a> %0a> %0a> %0a
host:1235242582=127.0.0.1
author:1235241576=
diff:1235241576:1235241295:=8,9c8,9%0a%3c Intel icc is usually considered to generate (much) faster code than gcc. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%3c %0a---%0a> Intel icc is usually quoted to generate code that runs 20%25 to 30%25 faster than gcc compiled programs. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a> %0a
host:1235241576=127.0.0.1
author:1235241295=
diff:1235241295:1235241270:=4,5c4,5%0a%3c !!! Icc vs. Gcc: which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%3c %0a---%0a> !!! Intel ICC vs. Gcc, which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a> %0a
host:1235241295=127.0.0.1
author:1235241270=
diff:1235241270:1235241234:=4,5c4,5%0a%3c !!! Intel ICC vs. Gcc, which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%3c %0a---%0a> !!! How to compile simuPOP with intel icc. (Feb, 21, 2009)%0a> %0a
host:1235241270=127.0.0.1
author:1235241234=
diff:1235241234:1235241166:=1c1%0a%3c (:title Stories about the development of simuPOP:)%0a---%0a> (:title Unofficial stories about the development of simuPOP:)%0a
host:1235241234=127.0.0.1
author:1235241166=
diff:1235241166:1235240771:=102,104c102,104%0a%3c (:cell:) 101.29%0a%3c (:cell:) 118.75%0a%3c (:cell:) 156.76%0a---%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a138,142c138,140%0a%3c It is still quite obvious that gcc is better in all cases, which comes as a surprise to me. Anyway, these numbers are from single runs and icc may not get the right optimization flags. If you have any suggestion, please feel free to let me know.%0a%3c %0a%3c %0a%3c %0a%3c %0a---%0a> These numbers are from single runs so 10%25 or more variations are expected. However, it is still quite obvious that gcc is better in all cases. What a surprise.%0a> %0a> %0a
host:1235241166=127.0.0.1
author:1235240771=
diff:1235240771:1235239985:=74c74%0a%3c (:cellnr rowspan=3:) Gcc 4.1.2%0a---%0a> (:cellnr:) Gcc%0a76,85c76,86%0a%3c (:cell:) 0.30%0a%3c (:cell:) 0.35%0a%3c (:cell:) 0.53%0a%3c (:cell:) 4.41%0a%3c (:cell:) 7.43%0a%3c (:cell:) 9.02%0a%3c (:cell:) 85.33%0a%3c (:cell:) 101.88%0a%3c (:cell:) 141.08%0a%3c (:cellnr:) short%0a---%0a> (:cell:) b2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cellnr:) Gcc%0a> (:cell:) short%0a92,101d92%0a%3c (:cell:) 94.58%0a%3c (:cell:) 115.20%0a%3c (:cell:) 150.69%0a%3c (:cellnr:) long%0a%3c (:cell:) 0.29%0a%3c (:cell:) 0.33%0a%3c (:cell:) 0.50%0a%3c (:cell:) 4.17%0a%3c (:cell:) 7.73%0a%3c (:cell:) 8.52%0a105c96,107%0a%3c (:cellnr rowspan=3:) Icc 11.0%0a---%0a> (:cellnr:) Gcc%0a> (:cell:) long%0a> (:cell:) b2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cellnr:) Icc%0a116c118,119%0a%3c (:cellnr:) short%0a---%0a> (:cellnr:) Icc%0a> (:cell:) short%0a126c129,130%0a%3c (:cellnr:) long%0a---%0a> (:cellnr:) Icc%0a> (:cell:) long%0a138,140c142,144%0a%3c These numbers are from single runs so 10%25 or more variations are expected. However, it is still quite obvious that gcc is better in all cases. What a surprise.%0a%3c %0a%3c %0a---%0a> Note that these numbers are single runs so 10%25 or more variations are expected.%0a> %0a> %0a
host:1235240771=127.0.0.1
author:1235239985=
diff:1235239985:1235239466:=87,93d86%0a%3c (:cell:) 0.28%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.48%0a%3c (:cell:) 3.89%0a%3c (:cell:) 7.04%0a%3c (:cell:) 8.49%0a%3c (:cell:) a2%0a94a88%0a> (:cell:) b2%0a96,97c90%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) long%0a---%0a> (:cell:) a2%0a99d91%0a%3c (:cell:) b2%0a104c96,97%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) Gcc%0a> (:cell:) long%0a105a99%0a> (:cell:) b2%0a106a101,106%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a131,139c131,139%0a%3c (:cell:) 0.29%0a%3c (:cell:) 0.35%0a%3c (:cell:) 0.55%0a%3c (:cell:) 4.40%0a%3c (:cell:) 8.18%0a%3c (:cell:) 8.97%0a%3c (:cell:) 104.4%0a%3c (:cell:) 121.97%0a%3c (:cell:) 165.00%0a---%0a> (:cell:) 0.32%0a> (:cell:) 0.38%0a> (:cell:) 0.57%0a> (:cell:) 4.21%0a> (:cell:) 7.83%0a> (:cell:) 9.07%0a> (:cell:) 97.84%0a> (:cell:) 121.65%0a> (:cell:) 160.67%0a142,144c142,143%0a%3c Note that these numbers are single runs so 10%25 or more variations are expected.%0a%3c %0a%3c %0a---%0a> %0a> %0a
host:1235239985=127.0.0.1
author:1235239466=
diff:1235239466:1235238758:=49,50c49,50%0a%3c Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run a typical random mating test in @@test_21_performance@@.%0a%3c %0a---%0a> Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run%0a> %0a111,117c111,117%0a%3c (:cell:) 0.62%0a%3c (:cell:) 4.83%0a%3c (:cell:) 8.17%0a%3c (:cell:) 10.02%0a%3c (:cell:) 89.03%0a%3c (:cell:) 107.23%0a%3c (:cell:) 151.62%0a---%0a> (:cell:) 0.63%0a> (:cell:) 4.78%0a> (:cell:) 7.83%0a> (:cell:) 9.07%0a> (:cell:) 97.84%0a> (:cell:) 121.65%0a> (:cell:) 160.67%0a
host:1235239466=127.0.0.1
author:1235238758=
diff:1235238758:1235238728:=2,3d1%0a%3c (:toc:)%0a%3c %0a
host:1235238758=127.0.0.1
author:1235238481=
diff:1235238481:1235238427:=73c73%0a%3c (:cell:) binary%0a---%0a> (:cell:) short%0a83d82%0a%3c (:cellnr:) Gcc%0a94,95c93%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) long%0a---%0a> (:cell:) short%0a104a103%0a> %0a
host:1235238481=127.0.0.1
author:1235238427=
diff:1235238427:1235237337:=1d0%0a%3c (:title Unofficial stories about the development of simuPOP:)%0a57,63c56,60%0a%3c (:cell colspan=2:) &nbsp;%0a%3c (:cell align=center colspan=3:) N=10k%0a%3c (:cell align=center colspan=3:) N=100k%0a%3c (:cell align=center colspan=3:) N=1000k%0a%3c (:cellnr:) &nbsp;%0a%3c (:cell:) &nbsp;%0a%3c (:cell:) plain%0a---%0a> (:cell:) &nbsp%0a> (:cell colspan=3:) N=10000%0a> (:cell colspan=3:) N=100000%0a> (:cell colspan=3:) N=100000%0a> (:cellnr:) plain%0a72,73c69%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) short%0a---%0a> (:cellnr:) a2%0a75d70%0a%3c (:cell:) b2%0a77c72%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) a2%0a80c75%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) a2%0a83,136d77%0a%3c (:cell:) short%0a%3c (:cell:) b2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) short%0a%3c (:cell:) b2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c %0a%3c (:cellnr:) Icc%0a%3c (:cell:) binary%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.41%0a%3c (:cell:) 0.63%0a%3c (:cell:) 4.78%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a%3c (:cellnr:) Icc%0a%3c (:cell:) short%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.38%0a%3c (:cell:) 0.57%0a%3c (:cell:) 4.21%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a%3c (:cellnr:) Icc%0a%3c (:cell:) long%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.38%0a%3c (:cell:) 0.57%0a%3c (:cell:) 4.21%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a140d80%0a%3c %0a
host:1235238427=127.0.0.1
author:1235237337=
diff:1235237337:1235237095:=55,80c55,56%0a%3c (:table border=1 cellpadding=5 cellspacing=0:)%0a%3c (:cell:) &nbsp%0a%3c (:cell colspan=3:) N=10000%0a%3c (:cell colspan=3:) N=100000%0a%3c (:cell colspan=3:) N=100000%0a%3c (:cellnr:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:tableend:)%0a%3c %0a%3c %0a---%0a> %0a> %0a
host:1235237337=127.0.0.1
author:1235237095=
diff:1235237095:1235236711:=29,30c29%0a%3c -> Note that some modules could not be compiled by icc.%0a%3c %0a---%0a> %0a42,56c41%0a%3c -> if scons is installed.%0a%3c %0a%3c There are a lot more remarks than gcc and I cannot really fix them all. Anyway, simuPOP is compiled OK. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%3c %0a%3c Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run%0a%3c %0a%3c -> [@%0a%3c > cd simuPOP/test%0a%3c > python test_21_performance.py TestPerformance.TestRandomMating%0a%3c @]%0a%3c %0a%3c for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result:%0a%3c %0a%3c %0a%3c %0a---%0a> -> if scons is installed.%0a\ No newline at end of file%0a
host:1235237095=127.0.0.1
author:1235236711=
diff:1235236711:1235236356:=11,41c11,17%0a%3c * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment. I use csh and set a @@~/.cshrc@@ file as follows:%0a%3c %0a%3c -> [@%0a%3c source /my/home/intel/Compiler/11.0/081/bin/iccvars.csh intel64%0a%3c setenv PATH /my/home/Python26/bin:${PATH}%0a%3c @]%0a%3c %0a%3c * Download Python 2.6 source code, and compile as follows%0a%3c %0a%3c -> [@%0a%3c > tar zxf Python-2.6.tgz%0a%3c > cd Python-2.6%0a%3c > setenv CC icc%0a%3c > setenv CXX icc%0a%3c > ./configure --prefix=/my/home/Python26%0a%3c > make%0a%3c > make install%0a%3c @]%0a%3c %0a%3c * (Optinal) download and install scons.%0a%3c %0a%3c * Then, I check up a clean copy of simuPOP, and compile simuPOP as usual:%0a%3c %0a%3c -> [@%0a%3c > python setup.py install%0a%3c @]%0a%3c -> or%0a%3c -> [@%0a%3c > scons install%0a%3c @]%0a%3c -> if scons is installed.%0a\ No newline at end of file%0a---%0a> * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment.%0a> %0a> * Download Python 2.6 source code.%0a> %0a> [=%0a> > blah%0a> =]%0a
host:1235236711=127.0.0.1
author:1235236356=
diff:1235236356:1235236350:=
host:1235236356=127.0.0.1
author:1235236350=
diff:1235236350:1235234709:=1,17c1,2%0a%3c !!! How to compile simuPOP with intel icc. (Feb, 21, 2009)%0a%3c %0a%3c simuPOP uses Visual C++ 2003 (win32, Python 2.4 and 2.5), Visual C++ Express 2008 (win32, Python 2.6), and GCC/G++ for all other platforms (MacOS, Linux, Solaris). These compilers are chosen because they are the compilers used for the official Python distributions.%0a%3c %0a%3c Intel icc is usually quoted to generate code that runs 20%25 to 30%25 faster than gcc compiled programs. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%3c %0a%3c Here are the steps:%0a%3c %0a%3c * Download icc from Intel ICC website. The linux non-commercial version is free, and is the version I use.%0a%3c %0a%3c * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment.%0a%3c %0a%3c * Download Python 2.6 source code.%0a%3c %0a%3c [=%0a%3c > blah%0a%3c =]%0a---%0a> !!! How to compile simuPOP with intel icc.%0a> %0a
host:1235236350=127.0.0.1
author:1235234709=
diff:1235234709:1235234709:=1,2d0%0a%3c !!! How to compile simuPOP with intel icc.%0a%3c %0a
host:1235234709=127.0.0.1
