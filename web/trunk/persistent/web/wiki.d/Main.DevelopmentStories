version=pmwiki-2.1.27 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 ( .NET CLR 3.5.30729)
author=
csum=
ctime=1235234709
host=127.0.0.1
name=Main.DevelopmentStories
rev=54
targets=
text=(:title Stories about the development of simuPOP:)%0a(:toc:)%0a%0a!!! Porting simuPOP to Python 3. (Aug, 30, 2010)%0a%0aBecause Python 3 is not compatible with Python 2.x, porting simuPOP to Python 3 is non-trivial. Because of the amount of work that is required to port a module, many popular Python modules, such as rpy and wxPython used by simuPOP, have not been ported. This has in turn slowed down the adoption of Python 3. This chicken-egg problem can only be solved by time.%0a%0aIt is certainly not easy to port simuPOP to Python 3 because the simuPOP core is deeply entangled with Python. Other than routine 2to3 API changes, I had a great deal of trouble for secure usages of STL (@@_SECURE_SCL@@), redefining %25%25carray%25%25 and %25%25defdict%25%25 types in Python 3, debugging a SWIG bug (interaction between the wrapper and my own @@__setattr__@@ and @@__getattr__@@ functions), and a namespace issue with python list comprehension. Anyway, after a week's intense work, all tests run successfully for Python 3. I am listing the major steps here in case that they can help other Python module maintainers port their modules to Python 3.%0a%0a* Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@ or batch file is recommended to automate the process.%0a%0a* Use @@sys.version_info.major == 3@@ to test the version of Python and add Python3-specific code to Python modules. For example, you can add option @@'-py3'@@ to the @@swig@@ command to generate python3-specific wrapper code.%0a%0a* Use @@python setup.py build@@ to compile the module and try to correct for errors. Add python3 specific code using something like%0a%0a=python [=%0a#if PY_VERSION_HEX >= 0x03000000%0a%0a#  define PyString_Check PyUnicode_Check%0a#  define PyString_FromStringAndSize PyUnicode_FromStringAndSize%0a#  define PyString_FromString PyUnicode_FromString%0a#  define PyString_Concat PyUnicode_Concat%0a#  define PyString_ConcatAndDel PyUnicode_ConcatAndDel%0a%0a#  define PyInt_Check PyLong_Check%0a#  define PyInt_AsLong PyLong_AsLong%0a#  define PyInt_FromLong PyLong_FromLong%0a#  define PyNumber_Int PyNumber_Long%0a#  define PyInt_FromString PyLong_FromString%0a#  define PyInt_Type PyLong_Type%0a#  define PyString_Type PyUnicode_Type%0a%0a#endif%0a=]%0a%0a->Some functions are more involved, such as the conversion between char* and unicode. Fortunately, the swig wrapper code provides some functions that you can borrow. :-)%0a%0a* Python 3.1 (and 2.7) has @@_SECURE_SCL@@ defined by default. Under windows, any insecure use of iterators will cause the module to crash (without even a warning or error message). Such errors are triggered by insecure usages of iterators such as @@*ptr + 1 == myvector.end() + 1@@ and I was able to locate them relatively easily later on.%0a%0a* The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. However, my wrapper does not work well under Python3 and I had to trace into the wrapper code. I noticed that swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly) for Python 2.x, but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. The problem was then clear because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details). After handling this special case, the wrapper code works fine for Python 3.%0a%0a* I then encountered a problem where expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working. It turned out that I was evaluating such expressions using population dictionary as locals, and module dictionary as globals, and such expression requires @@alleleFreq@@ to be available in globals. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details).%0a%0a* After some testing and things appear to be working. I revised @@setup.py@@ so that it works with both Python 2.x and Python 3.x. This is mostly easy to do because I only need to change a bunch of print statements, and their function form works well in Python 2.x because @@print(a)@@ will be interpreted as printing a tuple with one element in Python 2.x. I then added%0a%0a=python [=%0atry:%0a   from distutils.command.build_py import build_py_2to3 as build_py%0aexcept ImportError:%0a   from distutils.command.build_py import build_py%0a%0a=]%0a->to my setup.py and%0a%0a=python [=%0a        cmdclass = {'build_py': build_py}%0a=]%0a->to its @@setup()@@ function. In this way, setup.py will automatically convert my .py files when setup.py is executed in python 3.%0a%0a* Keeping python2 compatible changes from @@2to3@@ and using @@sys.version_info@@ for the rest of them, I modified test cases and examples so that they are compatible with both Python 2.x and 3.x. This is very helpful because I can provide a single version of documentation for both python versions.%0a%0aIn the end, simuPOP is now fully compatible and I only need to provide one set of source code, test, and documentation because they all work for both Python 2.x and Python 3.x. This is a huge relief because it would be troublesome to provide two sets of code for python 2.x and python 3.x.%0a%0aA pending issue with simuPOP/Python3 is graphics support. Although rpy%0ahas not been updated for a while, it can be compiled for python 2.x%0aand all R versions. This is not the case for Python 3. Because rpy2%0arecently added support to python 3, I may have to switch to rpy2%0aalthough I like rpy much better than rpy2. I do not have time for this%0anow so perhaps I will leave this to 1.0.5 or later. Considering all%0athe trouble in maintaining rpy, it might have been a mistake to use%0arpy in simuPOP.%0a%0aAnyway, I am glad that simuPOP now supports Python 2.7 and 3.1 and I%0adid fix a few bugs and cleaned the code along the way. Because 2.7%0awill be the last Python 2.x release, compatibility with Python will%0ahopefully not an issue for quite some time.%0a%0aFinally, I would like to thank Georg Brandl and Benjamin Peterson for their prompt and helpful answers to my questions in the python-porting mailinglist. If you have any question in porting your module to Python 3, that mailinglist would be a great resource to use.%0a%0a!!! Why the development of a MPI version of simuPOP was discontinued? (Mar. 10, 2009)%0a%0aA prototype of a MPI version of simuPOP was added to simuPOP 0.7.5 in Dec. 2006. The general idea worked and I was even able to run small scripts using it. However, because a MPI version could not achieve its initial design goals, and because a full implementation required major revision to the simuPOP core, the MPI code was removed in simuPOP 0.8.3.%0a%0aWhen the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seemed to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%0aHowever, compare to other single-executable programs, a MPI implementation of simuPOP was extremely difficult to design. Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI design would be a master-slave model where a master node interprets a script, and sends very detailed instructions to the slave nodes. However, this model requires a large amount of communication between nodes, especially with population changes. Consequently, the MPI modules may not provide any performance advantage over a regular module. This was more or less confirmed using my experimental implementation.%0a%0aAnd you know what happened next. RAM became cheaper and cheaper and even home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%0aAnother reason for the removal of the MPI version is because I am looking into an [[http://www.openmp.org | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%0aIf everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x releases will have openMP support.%0a%0a%0a!!! Icc vs. Gcc: which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%0asimuPOP uses Visual C++ 2003 (win32, Python 2.4 and 2.5), Visual C++ Express 2008 (win32, Python 2.6), and GCC/G++ for all other platforms (MacOS, Linux, Solaris). These compilers are chosen because they are the compilers used for the official Python distributions.%0a%0aIntel icc is usually considered to generate (much) faster code than gcc. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%0aHere are the steps:%0a%0a* Download icc from Intel ICC website. The linux non-commercial version is free, and is the version I use.%0a%0a* Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment. I use csh and set a @@~/.cshrc@@ file as follows:%0a%0a-> [@%0asource /my/home/intel/Compiler/11.0/081/bin/iccvars.csh intel64%0asetenv PATH /my/home/Python26/bin:${PATH}%0a@]%0a%0a* Download Python 2.6 source code, and compile as follows%0a%0a-> [@%0a> tar zxf Python-2.6.tgz%0a> cd Python-2.6%0a> setenv CC icc%0a> setenv CXX icc%0a> ./configure --prefix=/my/home/Python26%0a> make%0a> make install%0a@]%0a-> Note that some modules could not be compiled by icc.%0a%0a* (Optinal) download and install scons.%0a%0a* Then, I check up a clean copy of simuPOP, and compile simuPOP as usual:%0a--> [@%0a> python setup.py install%0a@]%0a-> or%0a--> [@%0a> scons install%0a@]%0a-> if scons is installed.%0a%0aThere are a lot more remarks (warnings) than gcc and many of them do not make much sense to me. Anyway, simuPOP is compiled successfully. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%0aDoes icc really help the performance of simuPOP? I do not have time for a thorough test so I run a typical random mating test in @@test_21_performance@@.%0a%0a-> [@%0a> cd simuPOP/test%0a> python test_21_performance.py TestPerformance.TestRandomMating%0a@]%0a%0afor both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result (execution time in seconds, the shorter the better):%0a%0a(:table border=1 cellpadding=5 cellspacing=0:)%0a(:cell colspan=2:) &nbsp;%0a(:cell align=center colspan=3:) N=10k%0a(:cell align=center colspan=3:) N=100k%0a(:cell align=center colspan=3:) N=1000k%0a(:cellnr:) &nbsp;%0a(:cell:) &nbsp;%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cellnr rowspan=3:) Gcc 4.1.2%0a(:cell:) binary%0a(:cell:) 0.30%0a(:cell:) 0.35%0a(:cell:) 0.53%0a(:cell:) 4.41%0a(:cell:) 7.43%0a(:cell:) 9.02%0a(:cell:) 85.33%0a(:cell:) 101.88%0a(:cell:) 141.08%0a(:cellnr:) short%0a(:cell:) 0.28%0a(:cell:) 0.32%0a(:cell:) 0.48%0a(:cell:) 3.89%0a(:cell:) 7.04%0a(:cell:) 8.49%0a(:cell:) 94.58%0a(:cell:) 115.20%0a(:cell:) 150.69%0a(:cellnr:) long%0a(:cell:) 0.29%0a(:cell:) 0.33%0a(:cell:) 0.50%0a(:cell:) 4.17%0a(:cell:) 7.73%0a(:cell:) 8.52%0a(:cell:) 101.29%0a(:cell:) 118.75%0a(:cell:) 156.76%0a(:cellnr rowspan=3:) Icc 11.0%0a(:cell:) binary%0a(:cell:) 0.34%0a(:cell:) 0.41%0a(:cell:) 0.62%0a(:cell:) 4.83%0a(:cell:) 8.17%0a(:cell:) 10.02%0a(:cell:) 89.03%0a(:cell:) 107.23%0a(:cell:) 151.62%0a(:cellnr:) short%0a(:cell:) 0.32%0a(:cell:) 0.38%0a(:cell:) 0.57%0a(:cell:) 4.21%0a(:cell:) 7.83%0a(:cell:) 9.07%0a(:cell:) 97.84%0a(:cell:) 121.65%0a(:cell:) 160.67%0a(:cellnr:) long%0a(:cell:) 0.29%0a(:cell:) 0.35%0a(:cell:) 0.55%0a(:cell:) 4.40%0a(:cell:) 8.18%0a(:cell:) 8.97%0a(:cell:) 104.4%0a(:cell:) 121.97%0a(:cell:) 165.00%0a(:tableend:)%0a%0aIt is still quite obvious that gcc is better in all cases, which comes as a surprise to me. Anyway, these numbers are from single runs and icc may not get the right optimization flags. If you have any suggestion, please feel free to let me know.%0a%0aThe comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) and 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a PC with a Quad-core CPU (Q6600) and 3G RAM, running 32bit of windows Vista. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%0a(:table border=1 cellpadding=5 cellspacing=0:)%0a(:cell colspan=2:) &nbsp;%0a(:cell align=center colspan=3:) N=10k%0a(:cell align=center colspan=3:) N=100k%0a(:cell align=center colspan=3:) N=1000k%0a(:cellnr:) &nbsp;%0a(:cell:) &nbsp;%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cell:) plain%0a(:cell:) with selection%0a(:cell:) with migration%0a(:cellnr rowspan=3:) MacOS Gcc 4.1.2%0a(:cell:) binary%0a(:cell:) 0.23%0a(:cell:) 0.34%0a(:cell:) 0.52%0a(:cell:) 2.31%0a(:cell:) 3.37%0a(:cell:) 5.54%0a(:cell:) 40.12%0a(:cell:) 75.70%0a(:cell:) 100.56%0a(:cellnr:) short%0a(:cell:) 0.24%0a(:cell:) 0.34%0a(:cell:) 0.49%0a(:cell:) 2.51%0a(:cell:) 3.60%0a(:cell:) 5.53%0a(:cell:) 40.06%0a(:cell:) 75.19%0a(:cell:) 100.26%0a(:cellnr:) long%0a(:cell:) 0.24%0a(:cell:) 0.33%0a(:cell:) 0.48%0a(:cell:) 2.25%0a(:cell:) 3.38%0a(:cell:) 5.49%0a(:cell:) 40.51%0a(:cell:) 75.08%0a(:cell:) 101.39%0a(:cellnr rowspan=3:) Windows Vista Visual C++%0a(:cell:) binary%0a(:cell:) 0.53%0a(:cell:) 0.72%0a(:cell:) 0.93%0a(:cell:) 5.53%0a(:cell:) 8.57%0a(:cell:) 10.02%0a(:cell:) 85.38%0a(:cell:) 123.79%0a(:cell:) 141.51%0a(:cellnr:) short%0a(:cell:) 0.43%0a(:cell:) 0.60%0a(:cell:) 0.81%0a(:cell:) 4.55%0a(:cell:) 7.04%0a(:cell:) 8.66%0a(:cell:) 81.89%0a(:cell:) 118.15%0a(:cell:) 134.67%0a(:cellnr:) long%0a(:cell:) 0.43%0a(:cell:) 0.61%0a(:cell:) 0.82%0a(:cell:) 4.78%0a(:cell:) 7.59%0a(:cell:) 8.90%0a(:cell:) 88.21%0a(:cell:) 121.93%0a(:cell:) 138.19%0a(:tableend:)
time=1283220565
title=Stories about the development of simuPOP
author:1283220565=
diff:1283220565:1283219784:=8,9c8,9%0a%3c It is certainly not easy to port simuPOP to Python 3 because the simuPOP core is deeply entangled with Python. Other than routine 2to3 API changes, I had a great deal of trouble for secure usages of STL (@@_SECURE_SCL@@), redefining %25%25carray%25%25 and %25%25defdict%25%25 types in Python 3, debugging a SWIG bug (interaction between the wrapper and my own @@__setattr__@@ and @@__getattr__@@ functions), and a namespace issue with python list comprehension. Anyway, after a week's intense work, all tests run successfully for Python 3. I am listing the major steps here in case that they can help other Python module maintainers port their modules to Python 3.%0a%3c %0a---%0a> It is certainly not easy to port simuPOP to Python 3 because the simuPOP core has become more and more entangled with Python. Other than routine 2to3 API changes, I had a great deal of trouble for secure usages of STL (@@_SECURE_SCL@@), redefining %25%25carray%25%25 and %25%25defdict%25%25 types in Python 3, debugging a SWIG bug (interaction between the wrapper and my own @@__setattr__@@ and @@__getattr__@@ functions), and this namespace problem. Anyway, after a week's intense work, all tests run successfully for Python 3. I am listing the major steps here in case that they can help other Python module maintainers port their modules to Python 3.%0a> %0a38,45c38,45%0a%3c * Python 3.1 (and 2.7) has @@_SECURE_SCL@@ defined by default. Under windows, any insecure use of iterators will cause the module to crash (without even a warning or error message). Such errors are triggered by insecure usages of iterators such as @@*ptr + 1 == myvector.end() + 1@@ and I was able to locate them relatively easily later on.%0a%3c %0a%3c * The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. However, my wrapper does not work well under Python3 and I had to trace into the wrapper code. I noticed that swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly) for Python 2.x, but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. The problem was then clear because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details). After handling this special case, the wrapper code works fine for Python 3.%0a%3c %0a%3c * I then encountered a problem where expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working. It turned out that I was evaluating such expressions using population dictionary as locals, and module dictionary as globals, and such expression requires @@alleleFreq@@ to be available in globals. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details).%0a%3c %0a%3c * After some testing and things appear to be working. I revised @@setup.py@@ so that it works with both Python 2.x and Python 3.x. This is mostly easy to do because I only need to change a bunch of print statements, and their function form works well in Python 2.x because @@print(a)@@ will be interpreted as printing a tuple with one element in Python 2.x. I then added%0a%3c %0a---%0a> * Python 3.1 (and 2.7) has @@_SECURE_SCL@@ defined by default. Under windows, any insecure use of iterators will cause the module to crash (without even a warning or error message). Such errors are difficult to identify, but you can generally look for places with insecure usages of iterators such as @@*ptr + 1 == myvector.end() + 1@@.%0a> %0a> * The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. If your wrapper does not work well under Python3, you should look into the wrapper code for signs of Python3-specific implementation. For example, swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly), but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. This has caused some problem because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details).%0a> %0a> * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details).%0a> %0a> * After some testing and things appear to be working. You can look at your converted @@setup.py@@ and see if it is possible to make it work with both Python 2.x and Python 3.x. If most of the changes are a bunch of @@print@@ statement, the converted code will work in Python 2.x as well because @@print(a)@@ will be interpreted as printing a tuple with one element in Python 2.x. If your setup.py can work in both python 2.x and python 3.x, add%0a> %0a53,54c53,54%0a%3c ->to my setup.py and%0a%3c %0a---%0a> ->to your setup.py and%0a> %0a58,59c58,59%0a%3c ->to its @@setup()@@ function. In this way, setup.py will automatically convert my .py files when setup.py is executed in python 3.%0a%3c %0a---%0a> ->to your @@setup()@@ function. In this way, setup.py will automatically convert your .py files when setup.py is executed in python 3.%0a> %0a62,63d61%0a%3c In the end, simuPOP is now fully compatible and I only need to provide one set of source code, test, and documentation because they all work for both Python 2.x and Python 3.x. This is a huge relief because it would be troublesome to provide two sets of code for python 2.x and python 3.x.%0a%3c %0a
host:1283220565=127.0.0.1
author:1283219784=
diff:1283219784:1283219758:=53,54c53,54%0a%3c ->to your setup.py and%0a%3c %0a---%0a> to your setup.py and%0a> %0a58,59c58,59%0a%3c ->to your @@setup()@@ function. In this way, setup.py will automatically convert your .py files when setup.py is executed in python 3.%0a%3c %0a---%0a> to your @@setup()@@ function. In this way, setup.py will automatically convert your .py files when setup.py is executed in python 3.%0a> %0a
host:1283219784=127.0.0.1
author:1283219758=
diff:1283219758:1283219730:=42,43c42,43%0a%3c * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details).%0a%3c %0a---%0a> * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details. %0a> %0a
host:1283219758=127.0.0.1
author:1283219730=
diff:1283219730:1283185858:=44,61d43%0a%3c * After some testing and things appear to be working. You can look at your converted @@setup.py@@ and see if it is possible to make it work with both Python 2.x and Python 3.x. If most of the changes are a bunch of @@print@@ statement, the converted code will work in Python 2.x as well because @@print(a)@@ will be interpreted as printing a tuple with one element in Python 2.x. If your setup.py can work in both python 2.x and python 3.x, add%0a%3c %0a%3c =python [=%0a%3c try:%0a%3c    from distutils.command.build_py import build_py_2to3 as build_py%0a%3c except ImportError:%0a%3c    from distutils.command.build_py import build_py%0a%3c %0a%3c =]%0a%3c to your setup.py and%0a%3c %0a%3c =python [=%0a%3c         cmdclass = {'build_py': build_py}%0a%3c =]%0a%3c to your @@setup()@@ function. In this way, setup.py will automatically convert your .py files when setup.py is executed in python 3.%0a%3c %0a%3c * Keeping python2 compatible changes from @@2to3@@ and using @@sys.version_info@@ for the rest of them, I modified test cases and examples so that they are compatible with both Python 2.x and 3.x. This is very helpful because I can provide a single version of documentation for both python versions.%0a%3c %0a
host:1283219730=127.0.0.1
author:1283185858=
diff:1283185858:1283185832:=40,41c40,41%0a%3c * The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. If your wrapper does not work well under Python3, you should look into the wrapper code for signs of Python3-specific implementation. For example, swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly), but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. This has caused some problem because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details).%0a%3c %0a---%0a> * The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. If your wrapper does not work well under Python3, you should look into the wrapper code for signs of Python3-specific implementation. For example, swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly), but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. This has caused some problem because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details.%0a> %0a
host:1283185858=127.0.0.1
author:1283185832=
diff:1283185832:1283185614:=58,59d57%0a%3c Finally, I would like to thank Georg Brandl and Benjamin Peterson for their prompt and helpful answers to my questions in the python-porting mailinglist. If you have any question in porting your module to Python 3, that mailinglist would be a great resource to use.%0a%3c %0a
host:1283185832=127.0.0.1
author:1283185614=
diff:1283185614:1283185591:=42,43c42,45%0a%3c * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details. %0a%3c %0a---%0a> * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the%0a> module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and%0a> pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details. %0a> %0a
host:1283185614=127.0.0.1
author:1283185591=
diff:1283185591:1283185578:=16c16%0a%3c =python [=%0a---%0a> ->=python [=%0a
host:1283185591=127.0.0.1
author:1283185578=
diff:1283185578:1283185557:=16c16%0a%3c ->=python [=%0a---%0a> =python [=%0a36,37c36,37%0a%3c ->Some functions are more involved, such as the conversion between char* and unicode. Fortunately, the swig wrapper code provides some functions that you can borrow. :-)%0a%3c %0a---%0a> Some functions are more involved, such as the conversion between char* and unicode. Fortunately, the swig wrapper code provides some functions that you can borrow. :-)%0a> %0a
host:1283185578=127.0.0.1
author:1283185557=
diff:1283185557:1283185476:=42,45c42,55%0a%3c * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. The only complete solution to this problem is to merge local dictionaries to the%0a%3c module. However, it is possible that the same variable exists in module_dict and pop_dict so copying variables from pop_dict to module_dict is dangerous. An alternative is to create a combined dictionary from deep copies of module_dict and%0a%3c pop_dict so expression evaluations will not affect module_dict. I really did not want to do this because of performance considerations. In the end, I added @@__builtins__@@ to pop_dict and used it as both locals and globals. This effectively limits expressions to @@__builtins__@@ and population variables, but should be sufficient in almost all applications. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details. %0a%3c %0a---%0a> * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details.%0a> %0a> Regarding this namespace issue, merging local dictionaries to the%0a> module one is the only complete solution. However, it is possible that%0a> the same variable exists in module_dict and pop_dict so copying%0a> variables from pop_dict to module_dict is dangerous. An alternative is%0a> to create a combined dictionary from deep copies of module_dict and%0a> pop_dict so expression evaluations will not affect module_dict. I%0a> really did not want to do this because of performance considerations.%0a> In the end, I added @@__builtins__@@ to pop_dict and used it as both%0a> locals and globals. This effectively limits expressions to%0a> @@__builtins__@@ and population variables, but should be sufficient in%0a> almost all applications.%0a> %0a
host:1283185557=127.0.0.1
author:1283185476=
diff:1283185476:1283185250:=42,43c42,43%0a%3c * There are some language issues with Python 3. For example, list comprehension in Python 3 does not work the same way as Python 2. This has caused some problem with simuPOP. More specifically, expression @@[alleleFreq[x][0] for x in range(3)]@@ stops working because @@alleleFreq@@ used in this way has to be available from a global namespace, which in simuPOP's case is the module namespace. (Please see [[http://mail.python.org/pipermail/python-porting/2010-August/000146.html | this email]] for details.%0a%3c %0a---%0a> * There are some language issues %0a> %0a51c51%0a%3c In the end, I added @@__builtins__@@ to pop_dict and used it as both%0a---%0a> In the end, I added __builtins__ to pop_dict and used it as both%0a53c53%0a%3c @@__builtins__@@ and population variables, but should be sufficient in%0a---%0a> __builtins__ and population variables, but should be sufficient in%0a
host:1283185476=127.0.0.1
author:1283185250=
diff:1283185250:1283184403:=10,43c10,15%0a%3c * Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@ or batch file is recommended to automate the process.%0a%3c %0a%3c * Use @@sys.version_info.major == 3@@ to test the version of Python and add Python3-specific code to Python modules. For example, you can add option @@'-py3'@@ to the @@swig@@ command to generate python3-specific wrapper code.%0a%3c %0a%3c * Use @@python setup.py build@@ to compile the module and try to correct for errors. Add python3 specific code using something like%0a%3c %0a%3c =python [=%0a%3c #if PY_VERSION_HEX >= 0x03000000%0a%3c %0a%3c #  define PyString_Check PyUnicode_Check%0a%3c #  define PyString_FromStringAndSize PyUnicode_FromStringAndSize%0a%3c #  define PyString_FromString PyUnicode_FromString%0a%3c #  define PyString_Concat PyUnicode_Concat%0a%3c #  define PyString_ConcatAndDel PyUnicode_ConcatAndDel%0a%3c %0a%3c #  define PyInt_Check PyLong_Check%0a%3c #  define PyInt_AsLong PyLong_AsLong%0a%3c #  define PyInt_FromLong PyLong_FromLong%0a%3c #  define PyNumber_Int PyNumber_Long%0a%3c #  define PyInt_FromString PyLong_FromString%0a%3c #  define PyInt_Type PyLong_Type%0a%3c #  define PyString_Type PyUnicode_Type%0a%3c %0a%3c #endif%0a%3c =]%0a%3c %0a%3c Some functions are more involved, such as the conversion between char* and unicode. Fortunately, the swig wrapper code provides some functions that you can borrow. :-)%0a%3c %0a%3c * Python 3.1 (and 2.7) has @@_SECURE_SCL@@ defined by default. Under windows, any insecure use of iterators will cause the module to crash (without even a warning or error message). Such errors are difficult to identify, but you can generally look for places with insecure usages of iterators such as @@*ptr + 1 == myvector.end() + 1@@.%0a%3c %0a%3c * The SWIG wrapper code works for both Python2 and Python3 but different implementations are used in some cases. If your wrapper does not work well under Python3, you should look into the wrapper code for signs of Python3-specific implementation. For example, swig uses fast-get-set to get/set a "this" pointer (access object dictionary directly), but calls the regular @@__setattr__@@ and @@__getattr__@@ functions for Python 3. This has caused some problem because my code redefines @@__setattr__@@ and @@__getattr__@@ for a class. (See [[http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTimTSpU%252ByETu6od9m%253DjtaC3QhHZm48siMXbPW9Hf%2540mail.gmail.com&forum_name=swig-user | this email]] for details.%0a%3c %0a%3c * There are some language issues %0a%3c %0a---%0a> # Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@ or batch file is recommended to automate the process.%0a> %0a> # Use @@sys.version_info.major == 3@@ to test the version of Python and add Python3-specific code to Python modules. For example, you can add option @@'-py3'@@ to the @@swig@@ command to generate python3-specific wrapper code.%0a> %0a> # Use @@python setup.py build@@ to compile the module and try to correct for errors.%0a> %0a
host:1283185250=127.0.0.1
author:1283184403=
diff:1283184403:1283184235:=10,15c10,11%0a%3c # Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@ or batch file is recommended to automate the process.%0a%3c %0a%3c # Use @@sys.version_info.major == 3@@ to test the version of Python and add Python3-specific code to Python modules. For example, you can add option @@'-py3'@@ to the @@swig@@ command to generate python3-specific wrapper code.%0a%3c %0a%3c # Use @@python setup.py build@@ to compile the module and try to correct for errors.%0a%3c %0a---%0a> # Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@%0a> %0a
host:1283184403=127.0.0.1
author:1283184235=
diff:1283184235:1238171333:=4,37d3%0a%3c !!! Porting simuPOP to Python 3. (Aug, 30, 2010)%0a%3c %0a%3c Because Python 3 is not compatible with Python 2.x, porting simuPOP to Python 3 is non-trivial. Because of the amount of work that is required to port a module, many popular Python modules, such as rpy and wxPython used by simuPOP, have not been ported. This has in turn slowed down the adoption of Python 3. This chicken-egg problem can only be solved by time.%0a%3c %0a%3c It is certainly not easy to port simuPOP to Python 3 because the simuPOP core has become more and more entangled with Python. Other than routine 2to3 API changes, I had a great deal of trouble for secure usages of STL (@@_SECURE_SCL@@), redefining %25%25carray%25%25 and %25%25defdict%25%25 types in Python 3, debugging a SWIG bug (interaction between the wrapper and my own @@__setattr__@@ and @@__getattr__@@ functions), and this namespace problem. Anyway, after a week's intense work, all tests run successfully for Python 3. I am listing the major steps here in case that they can help other Python module maintainers port their modules to Python 3.%0a%3c %0a%3c # Use 2to3 to translate Python code from Python 2 to 3. A @@Makefile@@%0a%3c %0a%3c Regarding this namespace issue, merging local dictionaries to the%0a%3c module one is the only complete solution. However, it is possible that%0a%3c the same variable exists in module_dict and pop_dict so copying%0a%3c variables from pop_dict to module_dict is dangerous. An alternative is%0a%3c to create a combined dictionary from deep copies of module_dict and%0a%3c pop_dict so expression evaluations will not affect module_dict. I%0a%3c really did not want to do this because of performance considerations.%0a%3c In the end, I added __builtins__ to pop_dict and used it as both%0a%3c locals and globals. This effectively limits expressions to%0a%3c __builtins__ and population variables, but should be sufficient in%0a%3c almost all applications.%0a%3c %0a%3c A pending issue with simuPOP/Python3 is graphics support. Although rpy%0a%3c has not been updated for a while, it can be compiled for python 2.x%0a%3c and all R versions. This is not the case for Python 3. Because rpy2%0a%3c recently added support to python 3, I may have to switch to rpy2%0a%3c although I like rpy much better than rpy2. I do not have time for this%0a%3c now so perhaps I will leave this to 1.0.5 or later. Considering all%0a%3c the trouble in maintaining rpy, it might have been a mistake to use%0a%3c rpy in simuPOP.%0a%3c %0a%3c Anyway, I am glad that simuPOP now supports Python 2.7 and 3.1 and I%0a%3c did fix a few bugs and cleaned the code along the way. Because 2.7%0a%3c will be the last Python 2.x release, compatibility with Python will%0a%3c hopefully not an issue for quite some time.%0a%3c %0a
host:1283184235=127.0.0.1
author:1238171333=
diff:1238171333:1238171288:=70,71c70,71%0a%3c for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result (execution time in seconds, the shorter the better):%0a%3c %0a---%0a> for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result:%0a> %0a
host:1238171333=127.0.0.1
author:1238171288=
diff:1238171288:1236717530:=154,155c154,155%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) and 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a PC with a Quad-core CPU (Q6600) and 3G RAM, running 32bit of windows Vista. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1238171288=127.0.0.1
author:1236717530=
diff:1236717530:1236716577:=4,5c4,5%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued? (Mar. 10, 2009)%0a%3c %0a---%0a> !!! Why the development of a MPI version of simuPOP was discontinued? (Mar 10, 2009)%0a> %0a
host:1236717530=127.0.0.1
author:1236716577=
diff:1236716577:1236716527:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an [[http://www.openmp.org | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an [[www.openmp.org/ | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716577=127.0.0.1
author:1236716527=
diff:1236716527:1236716440:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an [[www.openmp.org/ | openMP]] implementation. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716527=127.0.0.1
author:1236716440=
diff:1236716440:1236716140:=4,5c4,5%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued? (Mar 10, 2009)%0a%3c %0a---%0a> !!! Why the development of a MPI version of simuPOP was discontinued?%0a> %0a
host:1236716440=127.0.0.1
author:1236716140=
diff:1236716140:1236716078:=16,18c16,18%0a%3c If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x releases will have openMP support.%0a%3c %0a%3c %0a---%0a> If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x will have openMP support.%0a> %0a> %0a
host:1236716140=127.0.0.1
author:1236716078=
diff:1236716078:1236716012:=14,15c14,15%0a%3c Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates, or produce multiple offspring simultaneously using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a---%0a> Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates simultaneously, or produce multiple offspring using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a> %0a
host:1236716078=127.0.0.1
author:1236716012=
diff:1236716012:1236716000:=12,13c12,13%0a%3c And you know what happened next. RAM became cheaper and cheaper and even home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a---%0a> And you know what happened next. RAM became cheaper and cheaper and even a home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a> %0a
host:1236716012=127.0.0.1
author:1236716000=
diff:1236716000:1236715895:=12,13c12,13%0a%3c And you know what happened next. RAM became cheaper and cheaper and even a home computers got 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a---%0a> And you know what happened next. RAM became cheaper and cheaper and everyone was getting 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a> %0a
host:1236716000=127.0.0.1
author:1236715895=
diff:1236715895:1236715366:=8,9c8,9%0a%3c When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seemed to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%3c %0a---%0a> When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seems to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a> %0a
host:1236715895=127.0.0.1
author:1236715366=
diff:1236715366:1236713884:=8,18c8,12%0a%3c When the MPI version of simuPOP was first designed, 2G of RAM sounded huge and 64 bit operating systems were rare. A MPI version seems to be the only way to break the 4G RAM barrier of 32 bit operating systems. I also hoped that a MPI version could significantly improve the performance of large simulations.%0a%3c %0a%3c However, compare to other single-executable programs, a MPI implementation of simuPOP was extremely difficult to design. Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI design would be a master-slave model where a master node interprets a script, and sends very detailed instructions to the slave nodes. However, this model requires a large amount of communication between nodes, especially with population changes. Consequently, the MPI modules may not provide any performance advantage over a regular module. This was more or less confirmed using my experimental implementation.%0a%3c %0a%3c And you know what happened next. RAM became cheaper and cheaper and everyone was getting 4G or more RAM. Dual-core or quad-core machines became commonplace and 64 bit operating systems became mainstream. Because it became easy to simulate large populations on a regular workstation, there was less and less a need for the MPI version of simuPOP.%0a%3c %0a%3c Another reason for the removal of the MPI version is because I am looking into an openMP version. Using a shared-memory architecture, I might be able to simulate several replicates simultaneously, or produce multiple offspring using different threads. The performance boost could be dramatic. In addition, this implementation requires little modification to the simuPOP codebase and it is possible that I can distribute simuPOP modules that can run on both single and multi-core machines...%0a%3c %0a%3c If everything moves as planned, simuPOP 1.0.x will be bug fix releases of simuPOP 1.0, and the 1.1.x will have openMP support.%0a%3c %0a%3c %0a---%0a> Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI implementation would be a master-slave design where a master node interprets a script, and sends very detailed instructions to the slave nodes. This is doable but requires the rewrite of almost all simuPOP functions.%0a> %0a> When the MPI version of simuPOP was first , 2G of RAM sounded huge and 64 bit operating systems were rare. When I re-considered the motivations for a MPI version, namely simulations of very large populations more efficiently, I realized that a MPI version could perhaps achieve the first (large population), but not the latter (efficiency). %0a> %0a> %0a
host:1236715366=127.0.0.1
author:1236713884=
diff:1236713884:1235966954:=4,12d3%0a%3c !!! Why the development of a MPI version of simuPOP was discontinued?%0a%3c %0a%3c A prototype of a MPI version of simuPOP was added to simuPOP 0.7.5 in Dec. 2006. The general idea worked and I was even able to run small scripts using it. However, because a MPI version could not achieve its initial design goals, and because a full implementation required major revision to the simuPOP core, the MPI code was removed in simuPOP 0.8.3.%0a%3c %0a%3c Because simuPOP is a programming environment, arbitrary user logic could be used. For example, a user could change genotype of a random individual using the Python random module. Different individuals could be chosen if the script is executed separately on different nodes, and lead to erroneous results. The only feasible MPI implementation would be a master-slave design where a master node interprets a script, and sends very detailed instructions to the slave nodes. This is doable but requires the rewrite of almost all simuPOP functions.%0a%3c %0a%3c When the MPI version of simuPOP was first , 2G of RAM sounded huge and 64 bit operating systems were rare. When I re-considered the motivations for a MPI version, namely simulations of very large populations more efficiently, I realized that a MPI version could perhaps achieve the first (large population), but not the latter (efficiency). %0a%3c %0a%3c %0a
host:1236713884=127.0.0.1
author:1235966954=
diff:1235966954:1235966868:=139,140c139,140%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. The benchmark from the Mac machine is impressive. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It may be a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235966954=127.0.0.1
author:1235966868=
diff:1235966868:1235966841:=36a37%0a> %0a
host:1235966868=127.0.0.1
author:1235966841=
diff:1235966841:1235338510:=38c38%0a%3c --> [@%0a---%0a> -> [@%0a42c42%0a%3c --> [@%0a---%0a> -> [@%0a
host:1235966841=127.0.0.1
author:1235338510=
diff:1235338510:1235249333:=140,141c140,141%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It may be a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235338510=127.0.0.1
author:1235249333=
diff:1235249333:1235243575:=47,48c47,48%0a%3c There are a lot more remarks (warnings) than gcc and many of them do not make much sense to me. Anyway, simuPOP is compiled successfully. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%3c %0a---%0a> There are a lot more remarks than gcc and I cannot really fix them all. Anyway, simuPOP is compiled OK. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a> %0a
host:1235249333=127.0.0.1
author:1235243575=
diff:1235243575:1235243506:=140,141c140,141%0a%3c The comparison is done on a 3-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same tests on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a---%0a> The comparison is done on a 2-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same test on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a> %0a
host:1235243575=127.0.0.1
author:1235243506=
diff:1235243506:1235242763:=197,199c197,199%0a%3c (:cell:) 85.38%0a%3c (:cell:) 123.79%0a%3c (:cell:) 141.51%0a---%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a211,219c211,219%0a%3c (:cell:) 0.43%0a%3c (:cell:) 0.61%0a%3c (:cell:) 0.82%0a%3c (:cell:) 4.78%0a%3c (:cell:) 7.59%0a%3c (:cell:) 8.90%0a%3c (:cell:) 88.21%0a%3c (:cell:) 121.93%0a%3c (:cell:) 138.19%0a---%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a
host:1235243506=127.0.0.1
author:1235242763=
diff:1235242763:1235242582:=191,196d190%0a%3c (:cell:) 0.53%0a%3c (:cell:) 0.72%0a%3c (:cell:) 0.93%0a%3c (:cell:) 5.53%0a%3c (:cell:) 8.57%0a%3c (:cell:) 10.02%0a199a194,199%0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a> (:cell:) %0a209,210d208%0a%3c (:cell:) 134.67%0a%3c (:cellnr:) long%0a211a210%0a> (:cellnr:) long%0a219a219%0a> (:cell:) %0a
host:1235242763=127.0.0.1
author:1235242582=
diff:1235242582:1235241576:=140,220c140,142%0a%3c The comparison is done on a 2-year old DELL Precision 650 workstation with Dual Xeon CPU (3.73GHz) with 4G RAM, running RHEL5 x86-64. Just out of curiosity, I also run the same test on a new PowerMac with a Quad-Core CPU (2.6G) and 8G of RAM, and a windows machine with a Quad-core CPU (Q6600) and 3G RAM. It is maybe a good time to replace my linux workstation with a Mac. :-)%0a%3c %0a%3c (:table border=1 cellpadding=5 cellspacing=0:)%0a%3c (:cell colspan=2:) &nbsp;%0a%3c (:cell align=center colspan=3:) N=10k%0a%3c (:cell align=center colspan=3:) N=100k%0a%3c (:cell align=center colspan=3:) N=1000k%0a%3c (:cellnr:) &nbsp;%0a%3c (:cell:) &nbsp;%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cellnr rowspan=3:) MacOS Gcc 4.1.2%0a%3c (:cell:) binary%0a%3c (:cell:) 0.23%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.52%0a%3c (:cell:) 2.31%0a%3c (:cell:) 3.37%0a%3c (:cell:) 5.54%0a%3c (:cell:) 40.12%0a%3c (:cell:) 75.70%0a%3c (:cell:) 100.56%0a%3c (:cellnr:) short%0a%3c (:cell:) 0.24%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.49%0a%3c (:cell:) 2.51%0a%3c (:cell:) 3.60%0a%3c (:cell:) 5.53%0a%3c (:cell:) 40.06%0a%3c (:cell:) 75.19%0a%3c (:cell:) 100.26%0a%3c (:cellnr:) long%0a%3c (:cell:) 0.24%0a%3c (:cell:) 0.33%0a%3c (:cell:) 0.48%0a%3c (:cell:) 2.25%0a%3c (:cell:) 3.38%0a%3c (:cell:) 5.49%0a%3c (:cell:) 40.51%0a%3c (:cell:) 75.08%0a%3c (:cell:) 101.39%0a%3c (:cellnr rowspan=3:) Windows Vista Visual C++%0a%3c (:cell:) binary%0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cellnr:) short%0a%3c (:cell:) 0.43%0a%3c (:cell:) 0.60%0a%3c (:cell:) 0.81%0a%3c (:cell:) 4.55%0a%3c (:cell:) 7.04%0a%3c (:cell:) 8.66%0a%3c (:cell:) 81.89%0a%3c (:cell:) 118.15%0a%3c (:cell:) %0a%3c (:cellnr:) long%0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:cell:) %0a%3c (:tableend:)%0a\ No newline at end of file%0a---%0a> %0a> %0a> %0a
host:1235242582=127.0.0.1
author:1235241576=
diff:1235241576:1235241295:=8,9c8,9%0a%3c Intel icc is usually considered to generate (much) faster code than gcc. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%3c %0a---%0a> Intel icc is usually quoted to generate code that runs 20%25 to 30%25 faster than gcc compiled programs. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a> %0a
host:1235241576=127.0.0.1
author:1235241295=
diff:1235241295:1235241270:=4,5c4,5%0a%3c !!! Icc vs. Gcc: which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%3c %0a---%0a> !!! Intel ICC vs. Gcc, which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a> %0a
host:1235241295=127.0.0.1
author:1235241270=
diff:1235241270:1235241234:=4,5c4,5%0a%3c !!! Intel ICC vs. Gcc, which one is faster for simuPOP simulations? (Feb, 21, 2009)%0a%3c %0a---%0a> !!! How to compile simuPOP with intel icc. (Feb, 21, 2009)%0a> %0a
host:1235241270=127.0.0.1
author:1235241234=
diff:1235241234:1235241166:=1c1%0a%3c (:title Stories about the development of simuPOP:)%0a---%0a> (:title Unofficial stories about the development of simuPOP:)%0a
host:1235241234=127.0.0.1
author:1235241166=
diff:1235241166:1235240771:=102,104c102,104%0a%3c (:cell:) 101.29%0a%3c (:cell:) 118.75%0a%3c (:cell:) 156.76%0a---%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a138,142c138,140%0a%3c It is still quite obvious that gcc is better in all cases, which comes as a surprise to me. Anyway, these numbers are from single runs and icc may not get the right optimization flags. If you have any suggestion, please feel free to let me know.%0a%3c %0a%3c %0a%3c %0a%3c %0a---%0a> These numbers are from single runs so 10%25 or more variations are expected. However, it is still quite obvious that gcc is better in all cases. What a surprise.%0a> %0a> %0a
host:1235241166=127.0.0.1
author:1235240771=
diff:1235240771:1235239985:=74c74%0a%3c (:cellnr rowspan=3:) Gcc 4.1.2%0a---%0a> (:cellnr:) Gcc%0a76,85c76,86%0a%3c (:cell:) 0.30%0a%3c (:cell:) 0.35%0a%3c (:cell:) 0.53%0a%3c (:cell:) 4.41%0a%3c (:cell:) 7.43%0a%3c (:cell:) 9.02%0a%3c (:cell:) 85.33%0a%3c (:cell:) 101.88%0a%3c (:cell:) 141.08%0a%3c (:cellnr:) short%0a---%0a> (:cell:) b2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cellnr:) Gcc%0a> (:cell:) short%0a92,101d92%0a%3c (:cell:) 94.58%0a%3c (:cell:) 115.20%0a%3c (:cell:) 150.69%0a%3c (:cellnr:) long%0a%3c (:cell:) 0.29%0a%3c (:cell:) 0.33%0a%3c (:cell:) 0.50%0a%3c (:cell:) 4.17%0a%3c (:cell:) 7.73%0a%3c (:cell:) 8.52%0a105c96,107%0a%3c (:cellnr rowspan=3:) Icc 11.0%0a---%0a> (:cellnr:) Gcc%0a> (:cell:) long%0a> (:cell:) b2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cellnr:) Icc%0a116c118,119%0a%3c (:cellnr:) short%0a---%0a> (:cellnr:) Icc%0a> (:cell:) short%0a126c129,130%0a%3c (:cellnr:) long%0a---%0a> (:cellnr:) Icc%0a> (:cell:) long%0a138,140c142,144%0a%3c These numbers are from single runs so 10%25 or more variations are expected. However, it is still quite obvious that gcc is better in all cases. What a surprise.%0a%3c %0a%3c %0a---%0a> Note that these numbers are single runs so 10%25 or more variations are expected.%0a> %0a> %0a
host:1235240771=127.0.0.1
author:1235239985=
diff:1235239985:1235239466:=87,93d86%0a%3c (:cell:) 0.28%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.48%0a%3c (:cell:) 3.89%0a%3c (:cell:) 7.04%0a%3c (:cell:) 8.49%0a%3c (:cell:) a2%0a94a88%0a> (:cell:) b2%0a96,97c90%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) long%0a---%0a> (:cell:) a2%0a99d91%0a%3c (:cell:) b2%0a104c96,97%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) Gcc%0a> (:cell:) long%0a105a99%0a> (:cell:) b2%0a106a101,106%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a> (:cell:) a2%0a> (:cell:) b2%0a> (:cell:) c2%0a131,139c131,139%0a%3c (:cell:) 0.29%0a%3c (:cell:) 0.35%0a%3c (:cell:) 0.55%0a%3c (:cell:) 4.40%0a%3c (:cell:) 8.18%0a%3c (:cell:) 8.97%0a%3c (:cell:) 104.4%0a%3c (:cell:) 121.97%0a%3c (:cell:) 165.00%0a---%0a> (:cell:) 0.32%0a> (:cell:) 0.38%0a> (:cell:) 0.57%0a> (:cell:) 4.21%0a> (:cell:) 7.83%0a> (:cell:) 9.07%0a> (:cell:) 97.84%0a> (:cell:) 121.65%0a> (:cell:) 160.67%0a142,144c142,143%0a%3c Note that these numbers are single runs so 10%25 or more variations are expected.%0a%3c %0a%3c %0a---%0a> %0a> %0a
host:1235239985=127.0.0.1
author:1235239466=
diff:1235239466:1235238758:=49,50c49,50%0a%3c Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run a typical random mating test in @@test_21_performance@@.%0a%3c %0a---%0a> Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run%0a> %0a111,117c111,117%0a%3c (:cell:) 0.62%0a%3c (:cell:) 4.83%0a%3c (:cell:) 8.17%0a%3c (:cell:) 10.02%0a%3c (:cell:) 89.03%0a%3c (:cell:) 107.23%0a%3c (:cell:) 151.62%0a---%0a> (:cell:) 0.63%0a> (:cell:) 4.78%0a> (:cell:) 7.83%0a> (:cell:) 9.07%0a> (:cell:) 97.84%0a> (:cell:) 121.65%0a> (:cell:) 160.67%0a
host:1235239466=127.0.0.1
author:1235238758=
diff:1235238758:1235238728:=2,3d1%0a%3c (:toc:)%0a%3c %0a
host:1235238758=127.0.0.1
author:1235238481=
diff:1235238481:1235238427:=73c73%0a%3c (:cell:) binary%0a---%0a> (:cell:) short%0a83d82%0a%3c (:cellnr:) Gcc%0a94,95c93%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) long%0a---%0a> (:cell:) short%0a104a103%0a> %0a
host:1235238481=127.0.0.1
author:1235238427=
diff:1235238427:1235237337:=1d0%0a%3c (:title Unofficial stories about the development of simuPOP:)%0a57,63c56,60%0a%3c (:cell colspan=2:) &nbsp;%0a%3c (:cell align=center colspan=3:) N=10k%0a%3c (:cell align=center colspan=3:) N=100k%0a%3c (:cell align=center colspan=3:) N=1000k%0a%3c (:cellnr:) &nbsp;%0a%3c (:cell:) &nbsp;%0a%3c (:cell:) plain%0a---%0a> (:cell:) &nbsp%0a> (:cell colspan=3:) N=10000%0a> (:cell colspan=3:) N=100000%0a> (:cell colspan=3:) N=100000%0a> (:cellnr:) plain%0a72,73c69%0a%3c (:cellnr:) Gcc%0a%3c (:cell:) short%0a---%0a> (:cellnr:) a2%0a75d70%0a%3c (:cell:) b2%0a77c72%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) a2%0a80c75%0a%3c (:cell:) a2%0a---%0a> (:cellnr:) a2%0a83,136d77%0a%3c (:cell:) short%0a%3c (:cell:) b2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) short%0a%3c (:cell:) b2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cell:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c %0a%3c (:cellnr:) Icc%0a%3c (:cell:) binary%0a%3c (:cell:) 0.34%0a%3c (:cell:) 0.41%0a%3c (:cell:) 0.63%0a%3c (:cell:) 4.78%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a%3c (:cellnr:) Icc%0a%3c (:cell:) short%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.38%0a%3c (:cell:) 0.57%0a%3c (:cell:) 4.21%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a%3c (:cellnr:) Icc%0a%3c (:cell:) long%0a%3c (:cell:) 0.32%0a%3c (:cell:) 0.38%0a%3c (:cell:) 0.57%0a%3c (:cell:) 4.21%0a%3c (:cell:) 7.83%0a%3c (:cell:) 9.07%0a%3c (:cell:) 97.84%0a%3c (:cell:) 121.65%0a%3c (:cell:) 160.67%0a140d80%0a%3c %0a
host:1235238427=127.0.0.1
author:1235237337=
diff:1235237337:1235237095:=55,80c55,56%0a%3c (:table border=1 cellpadding=5 cellspacing=0:)%0a%3c (:cell:) &nbsp%0a%3c (:cell colspan=3:) N=10000%0a%3c (:cell colspan=3:) N=100000%0a%3c (:cell colspan=3:) N=100000%0a%3c (:cellnr:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cell:) plain%0a%3c (:cell:) with selection%0a%3c (:cell:) with migration%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:cellnr:) a2%0a%3c (:cell:) b2%0a%3c (:cell:) c2%0a%3c (:tableend:)%0a%3c %0a%3c %0a---%0a> %0a> %0a
host:1235237337=127.0.0.1
author:1235237095=
diff:1235237095:1235236711:=29,30c29%0a%3c -> Note that some modules could not be compiled by icc.%0a%3c %0a---%0a> %0a42,56c41%0a%3c -> if scons is installed.%0a%3c %0a%3c There are a lot more remarks than gcc and I cannot really fix them all. Anyway, simuPOP is compiled OK. All simuPOP tests and examples in the [[http://simupop.svn.sourceforge.net/viewvc/simupop/trunk/doc/userGuide.pdf | simuPOP user's guide]] run smoothly.%0a%3c %0a%3c Does icc really help the performance of simuPOP? I do not have time for a thorough test so I run%0a%3c %0a%3c -> [@%0a%3c > cd simuPOP/test%0a%3c > python test_21_performance.py TestPerformance.TestRandomMating%0a%3c @]%0a%3c %0a%3c for both icc compiled and gcc compiled simuPOP (both for Python 2.6). Here is the result:%0a%3c %0a%3c %0a%3c %0a---%0a> -> if scons is installed.%0a\ No newline at end of file%0a
host:1235237095=127.0.0.1
author:1235236711=
diff:1235236711:1235236356:=11,41c11,17%0a%3c * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment. I use csh and set a @@~/.cshrc@@ file as follows:%0a%3c %0a%3c -> [@%0a%3c source /my/home/intel/Compiler/11.0/081/bin/iccvars.csh intel64%0a%3c setenv PATH /my/home/Python26/bin:${PATH}%0a%3c @]%0a%3c %0a%3c * Download Python 2.6 source code, and compile as follows%0a%3c %0a%3c -> [@%0a%3c > tar zxf Python-2.6.tgz%0a%3c > cd Python-2.6%0a%3c > setenv CC icc%0a%3c > setenv CXX icc%0a%3c > ./configure --prefix=/my/home/Python26%0a%3c > make%0a%3c > make install%0a%3c @]%0a%3c %0a%3c * (Optinal) download and install scons.%0a%3c %0a%3c * Then, I check up a clean copy of simuPOP, and compile simuPOP as usual:%0a%3c %0a%3c -> [@%0a%3c > python setup.py install%0a%3c @]%0a%3c -> or%0a%3c -> [@%0a%3c > scons install%0a%3c @]%0a%3c -> if scons is installed.%0a\ No newline at end of file%0a---%0a> * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment.%0a> %0a> * Download Python 2.6 source code.%0a> %0a> [=%0a> > blah%0a> =]%0a
host:1235236711=127.0.0.1
author:1235236356=
diff:1235236356:1235236350:=
host:1235236356=127.0.0.1
author:1235236350=
diff:1235236350:1235234709:=1,17c1,2%0a%3c !!! How to compile simuPOP with intel icc. (Feb, 21, 2009)%0a%3c %0a%3c simuPOP uses Visual C++ 2003 (win32, Python 2.4 and 2.5), Visual C++ Express 2008 (win32, Python 2.6), and GCC/G++ for all other platforms (MacOS, Linux, Solaris). These compilers are chosen because they are the compilers used for the official Python distributions.%0a%3c %0a%3c Intel icc is usually quoted to generate code that runs 20%25 to 30%25 faster than gcc compiled programs. I tried icc before, using a simuPOP version around 0.6.0 so I am interested to see whether or not simuPOP 0.9.2 can be compiled with icc.%0a%3c %0a%3c Here are the steps:%0a%3c %0a%3c * Download icc from Intel ICC website. The linux non-commercial version is free, and is the version I use.%0a%3c %0a%3c * Install icc. I uses a separate user account and install icc locally to that user so that it will not mess up with my current development environment.%0a%3c %0a%3c * Download Python 2.6 source code.%0a%3c %0a%3c [=%0a%3c > blah%0a%3c =]%0a---%0a> !!! How to compile simuPOP with intel icc.%0a> %0a
host:1235236350=127.0.0.1
author:1235234709=
diff:1235234709:1235234709:=1,2d0%0a%3c !!! How to compile simuPOP with intel icc.%0a%3c %0a
host:1235234709=127.0.0.1
