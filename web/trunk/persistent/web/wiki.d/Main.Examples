version=pmwiki-2.1.27 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.0.5) Gecko/2008120908 Red Hat/3.0.5-1.el5_2 Firefox/3.0.5
author=
csum=
ctime=1232339530
host=127.0.0.1
name=Main.Examples
rev=9
targets=
text=(:title Selected Examples:)%0a%25rfloat newwin right text-align=right margin-top=0px margin-right=25px margin-bottom=0px margin-left=25px%25 http://simupop.sourceforge.net/images/examples.jpg%0a%0aThe following examples are excerpted from the simuPOP User's Guide for simuPOP version 0.9.2. Please refer to the most recent version of the [[http://simupop.sourceforge.net/manual/build/userGuide.html | simuPOP User's Guide]] for complete explanations of the concepts and functions involved.%0a%0a(:toc:)%0a%0a!!! Genotypic structure%0a%0a'''Genotypic structure''' refers to structural information shared by all individuals in a population, including number of homologous copies of chromosomes (c.f. @@ploidy()@@, @@ploidyName()@@), chromosome types and names (c.f. @@numChrom()@@, @@chromType()@@, @@chromName()@@), position and name of each locus (c.f. @@numLoci(ch)@@, @@locusPos(loc)@@, @@locusName(loc)@@), and axillary information attached to each individual (c.f. @@infoField(idx)@@, @@infoFields()@@). In addition to property access functions, a number of utility functions are provided to, for example, look up the index of a locus by its name (c.f. @@locusByName()@@, @@chromBegin()@@, @@chromLocusPair()@@).%0a%0aA genotypic structure can be retrieved from ''individual'' and ''population'' objects. Because a population consists of individuals of the same type, genotypic information can only be changed for all individuals at the population level. Populations in a simulator usually have the same genotypic structure because they are created by as replicates, but their structure may change during evolution.%0a%0a=python [=%0a>>> pop = population(size=[2, 3], ploidy=2, loci=[5, 10],%0a...     lociPos=[range(0, 5), range(0, 20, 2)], chromNames=['Chr1', 'Chr2'],%0a...     alleleNames=['A', 'C', 'T', 'G'])%0a>>> # access genotypic information from the population%0a>>> pop.ploidy()%0a2%0a>>> pop.ploidyName()%0a'diploid'%0a>>> pop.numChrom()%0a2%0a>>> pop.locusPos(2)%0a2.0%0a>>> pop.alleleName(1)%0a'C'%0a>>> # access from an individual%0a>>> ind = pop.individual(2)%0a>>> ind.numLoci(1)%0a10%0a>>> ind.chromName(0)%0a'Chr1'%0a>>> ind.locusName(1)%0a'loc1-2'%0a>>> # utility functions%0a>>> ind.chromBegin(1)%0a5%0a>>> ind.chromByName('Chr2')%0a1%0a>>>%0a=]%0a%0a!!! Chromosome types%0a%0aThe default chromosome type is autosome, which is the normal chromosomes in diploid, and in haploid populations. simuPOP supports three other types of chromosomes, namely ''ChromosomeX'', ''ChromosomeY'' and ''Customized''. Sex chromosomes are only valid in haploid populations where chromosomes X and Y are used to determine the sex of an offspring. Customized chromosomes rely on user defined functions and operators to be passed from parents to offspring.%0a%0aThis example shows how to specify different chromosome types, and how genotypes of these special chromosomes are arranged.%0a%0a=python [=%0a>>> pop = population(size=6, ploidy=2, loci=[3, 3, 6, 4, 4, 4],%0a...     chromTypes=[Autosome]*2 + [ChromosomeX, ChromosomeY] + [Customized]*2)%0a>>> InitByFreq(pop, [0.3, 0.7])%0a>>> Dump(pop, structure=False) # does not display genotypic structure information%0aSubpopulation 0 (unnamed), 6 individuals:%0a   0: FU 000 111 111101 ____ 1001 1011 | 000 010 100110 ____ 1111 1110 %0a   1: MU 011 111 010111 ____ 0010 1010 | 111 110 ______ 1111 1111 0001 %0a   2: FU 111 110 011111 ____ 0100 0111 | 110 111 111111 ____ 1111 1111 %0a   3: FU 111 111 111110 ____ 0001 1111 | 011 111 011101 ____ 0000 1110 %0a   4: MU 111 111 111011 ____ 1101 0111 | 110 110 ______ 0011 0111 0011 %0a   5: FU 001 111 011110 ____ 1100 1011 | 111 111 111110 ____ 1100 1011 %0a>>>%0a%0a=]%0a%0a!!! Information fields%0a%0aDifferent kinds of simulations require different kinds of individuals. Individuals with only genotype information are sufficient to simulate the basic ''Wright-Fisher model''. Sex is needed to simulate such a model in diploid populations with sex. Individual fitness may be needed if selection is induced, and age may be needed if the population is age-structured. In addition, different types of quantitative traits or affection status may be needed to study the impact of genotype on individual phenotype. Because it is infeasible to provide all such information to an individual, simuPOP keeps genotype, sex (Male or Female) and affection status as built-in properties of an individual, and all others as optional information fields (float numbers) attached to each individual.%0a%0aInformation fields can be specified when a population is created, or added later using relevant function. They are essential for the function of many simuPOP operators. For example, all selection operators require information field fitness to store evaluated fitness values for each individual. Operator migrator uses information field migrate_to to store the ID of subpopulation an individual will migrate to. An error will be raised if these operators are applied to a population without needed information fields.%0a%0a=python [=%0a>>> pop = population(10, loci=[20], ancGen=1,%0a...     infoFields=['father_idx', 'mother_idx'])%0a>>> simu = simulator(pop, randomMating())%0a>>> simu.evolve(%0a...     preOps = [initByValue([0]*20+[1]*20)],%0a...     ops = [%0a...         parentsTagger(),%0a...         recombinator(rate=0.01)%0a...     ],%0a...     gen = 1%0a... )%0a(1,)%0a>>> pop = simu.extract(0)%0a>>> pop.indInfo('mother_idx')  # mother of all offspring%0a(7.0, 7.0, 4.0, 4.0, 8.0, 0.0, 2.0, 7.0, 6.0, 6.0)%0a>>> ind = pop.individual(0)%0a>>> mom = pop.ancestor(ind.intInfo('mother_idx'), 1)%0a>>> print ind.genotype(0)%0a[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]%0a>>> print mom.genotype(0)%0a[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]%0a>>> print mom.genotype(1)%0a[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]%0a>>>%0a%0a=]%0a%0a!!! Subpopulations%0aA simuPOP population consists of one or more subpopulations. Subpopulations serve as barriers of individuals in the sense that mating only happens between individuals in the same subpopulation. A number of functions are provided to merge, remove, resize subpopulations, and move individuals between subpopulations (migration). You will rarely get a chance to use them directly because such operations are usually handled by operators.%0a%0a=python [=%0a>>> pop = population(size=[3, 4, 5], ploidy=1, loci=[1], infoFields=['x'])%0a>>> # individual 0, 1, 2, ... will have an allele 0, 1, 2, ...%0a>>> pop.setGenotype(range(pop.popSize()))%0a>>> #%0a>>> pop.subPopSize(1)%0a4%0a>>> # merge subpopulations%0a>>> pop.mergeSubPops([1, 2])%0a>>> # split subpopulations%0a>>> pop.splitSubPop(1, [2, 7])%0a>>> pop.subPopSizes()%0a(3, 2, 7)%0a>>> # set information field to each individual's new subpopulation ID%0a>>> pop.setIndInfo([0, 1, 2, -1, 0, 1, 2, -1, -1, 0, 1, 2], 'x')%0a>>> # this manually triggers an migration, individuals with negative values%0a>>> # at this information field are removed.%0a>>> pop.setSubPopByIndInfo('x')%0a>>> Dump(pop, width=2, structure=False)%0aSubpopulation 0 (unnamed), 3 individuals:%0a   0: MU  0 |  0%0a   1: MU  4 |  0%0a   2: MU  9 |  0%0aSubpopulation 1 (unnamed), 3 individuals:%0a   3: MU  1 |  1%0a   4: MU  5 |  1%0a   5: MU 10 |  1%0aSubpopulation 2 (unnamed), 3 individuals:%0a   6: MU  2 |  2%0a   7: MU  6 |  2%0a   8: MU 11 |  2%0a>>>%0a%0a=]%0a%0a!!! Virtual subpopulations%0a%0asimuPOP subpopulations can be further divided into '''virtual subpopulations''' (VSP), which are groups of individuals who share certain properties. For example, all male individuals, all unaffected individuals, all individuals with information field age > 20, all individuals with genotype 0, 0 at a given locus, can form VSPs. VSPs do not have to add up to the whole subpopulation, nor do they have to be non-overlapping. Unlike subpopulations that have strict boundaries, VSPs change easily with the changes of individual properties.%0a%0aVSPs are defined by '''virtual splitters'''. A splitter defines the same number of VSPs in all subpopulations, although sizes of these VSPs vary across subpopulations due to subpopulation differences. For example, a @@sexSplitter()@@ defines two VSPs, the first with all male individuals and the second with all female individuals, and a @@infoSplitter(field='x', values=[1, 2, 4])@@ defines three VSPs whose members have values 1, 2 and 4 at information field x, respectively. If different types of VSPs are needed, a combined splitter can be used to combine VSPs defined by several splitters.%0a%0aA VSP is represented by a @@[spID, vspID]@@ pair. Its name and size can be obtained using functions @@subPopName()@@ and @@subPopSize()@@. Example @@[virtualSplitter]@@ demonstrates how to apply virtual splitters to a population, and how to check VSP names and sizes.%0a%0a=python [=%0a>>> import random%0a>>> pop = population(size=[200, 400], loci=[30], infoFields=['x'])%0a>>> # assign random information fields%0a>>> pop.setIndInfo([random.randint(0, 3) for x in range(pop.popSize())], 'x')%0a>>> # define a virtual splitter by information field 'x'%0a>>> pop.setVirtualSplitter(infoSplitter(field='x', values=[0, 1, 2, 3]))%0a>>> pop.numVirtualSubPop()    # Number of defined VSPs%0a4%0a>>> pop.subPopName([0, 0])    # Each VSP has a name%0a'unnamed - x = 0'%0a>>> pop.subPopSize([0, 0])    # Size of VSP 0 in subpopulation 0%0a57%0a>>> pop.subPopSize([1, 0])    # Size of VSP 0 in subpopulation 1%0a100%0a>>> # use a combined splitter that defines additional VSPs by sex%0a>>> InitSex(pop)%0a>>> pop.setSubPopName('subPop 1', 0)%0a>>> pop.setVirtualSplitter(combinedSplitter([%0a...     infoSplitter(field='x', values=[0, 1, 2, 3]),%0a...     sexSplitter()])%0a... )%0a>>> pop.numVirtualSubPop()    # Number of defined VSPs%0a6%0a>>> pop.subPopName([0, 4])    # VSP 4 is the first VSP defined by the sex splitter%0a'subPop 1 - Male'%0a>>> pop.subPopSize([0, 4])    # Number of male individuals%0a94%0a>>>%0a%0a=]%0a%0a!!! Ancestral generations%0a%0aA simuPOP population usually holds individuals in one generation. During evolution, an offspring generation will replace the parental generation and become the present generation (population), after it is populated from a parental population. The parental generation is discarded.%0a%0aThis is usually enough when only the present generation is of interest. However, parental generations can provide useful information on how genotype and other information are passed from parental to offspring generations. simuPOP provides a mechanism to store and access arbitrary number of ''ancestral generations'' in a population object. Applications of this feature include pedigree tracking, reconstruction, and pedigree ascertainments.%0a%0aIn this example, a population is created and is initialized with allele frequency 0.5. Its ancestral depth is set to 2 at the beginning of generation 18 so that it can hold parental generations at generation 18 and 19. The allele frequency at each generation is calculated and displayed, both during evolution using a stat operator, and after evolution using the function form this operator. Note that setting the ancestral depth at the end of an evolutionary process is a common practice because we are usually only interested in the last few generations.%0a%0a=python [=%0a>>> simu = simulator(population(500, loci=[1]), randomMating())%0a>>> simu.evolve(%0a...     preOps = [initByFreq([0.5, 0.5])],%0a...     ops = [%0a...         # start recording ancestral generations at generation 18%0a...         setAncestralDepth(2, at=[-2]),%0a...         stat(alleleFreq=[0], begin=-3),%0a...         pyEval(r"'%25.3f\n' %25 alleleFreq[0][0]", begin=-3)%0a...     ],%0a...     gen = 20%0a... )%0a0.436%0a0.455%0a0.450%0a(20,)%0a>>> pop = simu.population(0)%0a>>> # start from current generation%0a>>> for i in range(pop.ancestralGens(), -1, -1):%0a...   pop.useAncestralGen(i)%0a...   Stat(pop, alleleFreq=[0])%0a...   print '%25d   %25.3f' %25 (i, pop.dvars().alleleFreq[0][0])%0a... %0a2   0.436%0a1   0.455%0a0   0.450%0a>>> # restore to the current generation  %0a>>> pop.useAncestralGen(0)  %0a>>>%0a%0a=]%0a%0a!!! Population variables%0a%0aEach simuPOP population has a Python dictionary that can be used to store arbitrary Python variables. These variables are usually used by various operators to share information between them. For example, the stat operator calculates population statistics and stores the results in this Python dictionary. Other operators such as the @@pyEval@@ and @@terminateIf@@ read from this dictionary and act upon its information.%0a%0asimuPOP provides two functions, namely @@population::vars()@@ and @@population::dvars()@@ to access a population dictionary. These functions return the same dictionary object but dvars() returns a wrapper class so that you can access this dictionary as attributes. For example, @@pop.vars()['alleleFreq'][0]@@ is equivalent to @@pop.dvars().alleleFreq[0]@@. Because dictionary subPop[spID] is frequently used by operators to store variables related to a particular (virtual) subpopulation, function pop.vars(subPop) is provided as a shortcut to @@pop.vars()['subPop'][spID]@@. This example demonstrates how to set and access Population variables.%0a%0a=python [=%0a>>> from pprint import pprint%0a>>> pop = population(100, loci=[2])%0a>>> InitByFreq(pop, [0.3, 0.7])%0a>>> print pop.vars()    # No variable now%0a{}%0a>>> pop.dvars().myVar = 21%0a>>> print pop.vars()%0a{'myVar': 21}%0a>>> Stat(pop, popSize=1, alleleFreq=[0])%0a>>> # pprint prints in a less messy format%0a>>> pprint(pop.vars())%0a{'alleleFreq': [[0.32500000000000001, 0.67500000000000004]],%0a 'alleleNum': [[65, 135]],%0a 'myVar': 21,%0a 'numSubPop': 1,%0a 'popSize': 100,%0a 'subPop': [{'alleleFreq': [[0.32500000000000001, 0.67500000000000004]],%0a             'alleleNum': [[65, 135]],%0a             'popSize': 100}],%0a 'subPopSize': [100],%0a 'virtualPopSize': [100]}%0a>>> # print number of allele 1 at locus 0%0a>>> print pop.vars()['alleleNum'][0][1]%0a135%0a>>> # use the dvars() function to access dictionary keys as attributes%0a>>> print pop.dvars().alleleNum[0][1]%0a135%0a>>> print pop.dvars().alleleFreq[0]%0a[0.32500000000000001, 0.67500000000000004]%0a>>>%0a%0a=]%0a%0a!!! Applicable stages and generations of operators%0a%0aA simuPOP life cycle (a generation) can be divided into pre-mating, during-mating and post-mating. In the pre-mating stage, the present generation is the parental generation. In the during-mating stage, an offspring generation is populated from the parental generation. In the post-mating stage, the offspring generation has become the present generation. An operator can be applied at one or more stages at a life cycle. However, each operator has its own default value for the stage parameter and changes to this parameter are not always allowed. For example, a @@recombinator@@ can only be applied @@DuringMating@@ and it will ignore your attemp to apply it at another stage.%0a%0aOperators that are passed to the ops parameter of the @@simulator::evolve@@ function are, by default, applied to all generations during an evolutionary process. This can be changed using the begin, end, step and at parameters. As their names indicate, these parameters control the starting generation (@@begin@@), ending generation (@@end@@), generations between two applicable generations (@@step@@), and an explicit list of applicable generations (@@at@@, a single generation number is also acceptable). Other parameters will be ignored if at is specified. It is worth noting that, if the simulator has an ending generation, negative generations numbers are allowed. They are counted backward from the ending generation.%0a%0a%0a=python [=%0a>>> simu = simulator(population(100, loci=[20]), randomMating())%0a>>> simu.evolve(%0a...     preOps = [initByFreq([0.2, 0.8])],%0a...     ops = [%0a...         stat(alleleFreq=[0], begin=80, step=10),%0a...         pyEval(r"'After gen %25d: allele freq: %25.2f\n' %25 (gen, alleleFreq[0][0])",%0a...             begin=80, step=10),%0a...         pyEval(r"'Around gen %25d: allele Freq: %25.2f\n' %25 (gen, alleleFreq[0][0])",%0a...             at = [-10, -1], stage=PrePostMating)%0a...     ],%0a...     postOps = [savePopulation(output='sample.pop')],%0a...     gen=100%0a... )%0aAfter gen 80: allele freq: 0.28%0aAround gen 90: allele Freq: 0.28%0aAfter gen 90: allele freq: 0.19%0aAround gen 90: allele Freq: 0.19%0aAround gen 99: allele Freq: 0.19%0aAround gen 99: allele Freq: 0.19%0a(100,)%0a>>>%0a%0a=]%0a%0a!!! Operator output%0a%0aAll operators we have seen, except for the @@savePopulation@@ operator in an previous example, write their output to the standard output, namely your terminal window. However, it would be much easier for bookkeeping and further analysis if these output can be redirected to disk files. Parameter @@output@@ is designed for this purpose.%0a%0aParameter output can take the following values:%0a%0a* @@''@@ (an empty string): No output.%0a%0a* @@'>'@@: Write to standard output.%0a%0a* @@'filename'@@ or @@'>filename'@@: Write the output to a file named filename. If multiple operators write to the same file, or if the same operator writes to the file file several times, only the last write operation will succeed.%0a%0a* @@'>>filename'@@: Append the output to a file named filename. The file will be opened at the beginning of evolve function and closed at the end. An existing file will be cleared.%0a%0a* @@'>>>filename'@@: This is similar to the '>>' form but the file will not be cleared at the beginning of the evolve function.%0a%0a* @@'!expr'@@: @@expr@@ is considered as a Python expression that will be evaluated at a population's local namespace whenever an output string is needed. For example, @@'!”%25d.txt” %25 gen'@@ would return 0.txt, 1.txt etc at generation 0, 1, ....%0a%0a=python [=%0a>>> from simuPOP import *%0a>>> simu = simulator(population(size=1000, loci=[2]), randomMating(), rep=3)%0a>>> simu.evolve(%0a...     preOps = [initByValue([1, 2, 2, 1])],  %0a...     ops = [%0a...         recombinator(rate=0.01),%0a...         stat(LD=[0, 1]),%0a...         pyEval(r"'%25.2f\t' %25 LD[0][1]", step=20, output='>>LD.txt'),%0a...         pyOutput('\n', rep=-1, step=20, output='>>LD.txt'),%0a...         pyEval(r"'%25.2f\t' %25 R2[0][1]", output='R2.txt'),%0a...         pyEval(r"'%25.2f\t' %25 LD[0][1]", step=20, output="!'>>LD_%25d.txt' %25 rep"),%0a...     ],%0a...     gen=100%0a... )%0a(100, 100, 100)%0a>>> print open('LD.txt').read()%0a0.25	0.24	0.24	%0a0.20	0.21	0.19	%0a0.15	0.16	0.16	%0a0.15	0.15	0.12	%0a0.11	0.12	0.10	%0a%0a>>> print open('R2.txt').read()    # Only the last write operation succeed.%0a0.07	%0a>>> print open('LD_2.txt').read()  # Each replicate writes to a different file.%0a0.24	0.19	0.16	0.12	0.10	%0a>>>%0a%0a=]%0a%0a!!! Hybrid operators%0a%0aDespite the large number of built-in operators, it is obviously not possible to implement every genetics models available. For example, although simuPOP provides several penetrance models, a user may want to try a customized one. In this case, one can use a hybrid operator.%0a%0aA '''hybrid operator''' is an operator that calls a user-defined function when its applied to a population. The number and meaning of input parameters and return values vary from operator to operator. For example, a hybrid mutator sends a to-be-mutated allele to a user-defined function and use its return value as a mutant allele. A hybrid selector uses the return value of a user defined function as individual fitness. Such an operator handles the routine part of the work (e.g. scan through a chromosome and determine which allele needs to be mutated), and leave the creative part to users. Such a mutator can be used to implement complicated genetic models such as an asymmetric stepwise mutation model for microsatellite markers.%0a%0aThis example defines a three-locus heterogeneity penetrance model  that yields positive penetrance only when at least two disease susceptibility alleles are available. The underlying mechanism of this operator is that for each individual, simuPOP will collect genotype at specified loci (parameter loci) and send them to function @@myPenetrance@@ and evaluate. The return values are used as the penetrance value of the individual, which is then interpreted as the probability that this individual will become affected.%0a%0a=python [=%0a>>> def myPenetrance(geno):%0a...     'A three-locus heterogeneity penetrance model'%0a...     if sum(geno) %3c 2:%0a...         return 0%0a...     else:%0a...         return sum(geno)*0.1%0a... %0a>>> simu = simulator(population(1000, loci=[20]*3), randomMating())%0a>>> simu.evolve(%0a...     preOps = [initByFreq([0.8, 0.2])],%0a...     ops = [%0a...         pyPenetrance(func=myPenetrance, loci=[10, 30, 50]),%0a...         stat(numOfAffected=True),%0a...         pyEval(r"'%25d: %25d\n' %25 (gen, numOfAffected)")%0a...     ],%0a...     gen = 5%0a... )%0a0: 78%0a1: 74%0a2: 76%0a3: 83%0a4: 79%0a(5,)%0a>>>%0a%0a=]%0a%0a!!! Python Operators%0a%0aIf hybrid operators are still not flexible enough, you can always resort to a pure-Python operator @@pyOperator@@. This operator has full access to the evolving population (or parents and offspring when @@stage=DuringMating@@), and can therefore perform arbitrary operations.%0a%0aA pre- or post-mating @@pyOperator@@ expects a function in the form of%0a%0a->@@func(pop [, param])@@%0a%0awhere param is optional, depending on whether or not a parameter is passed to the @@pyOperator()@@ constructor. Function func can perform arbitrary action to pop and must return True or False. The evolution of pop will be stopped if this function returns False.%0a%0aThis example defines such a function. It accepts a cutoff value and two mutation rates as parameters. It then calculate the frequency of allele 1 at each locus and apply a two-allele model at high mutation rate if the frequency is lower than the cutoff and a low mutation rate otherwise. The @@KamMutate@@ function is the function form of a mutator @@kamMutator@@.%0a%0a=python [=%0a#!/usr/bin/env python%0afrom simuPOP import *%0arng().setSeed(12345)%0a%0adef dynaMutator(pop, param):%0a    '''This mutator mutates commom loci with low mutation rate and rare%0a    loci with high mutation rate, as an attempt to raise allele frequency%0a    of rare loci to an higher level.'''%0a    # unpack parameter%0a    (cutoff, mu1, mu2) = param;%0a    Stat(pop, alleleFreq=range(pop.totNumLoci()))%0a    for i in range(pop.totNumLoci()):%0a        # Get the frequency of allele 1 (disease allele)%0a        if pop.dvars().alleleFreq[i][1] %3c cutoff:%0a            KamMutate(pop, maxAllele=1, rate=mu1, loci=[i])%0a        else:%0a            KamMutate(pop, maxAllele=1, rate=mu2, loci=[i])%0a    return True%0a=]%0a%0a%0a!!! Demographic models%0a%0aA mating scheme goes through each subpopulation and populates the subpopulations of an offspring generation sequentially. The number of offspring in each subpopulation is determined by the mating scheme, following the following rules:%0a%0a* A simuPOP mating scheme, by default, produces an offspring generation that has the same subpopulation sizes as the parental generation. This does not guarantee a constant population size because some operators, such as a migrator, can change population or subpopulation sizes.%0a%0a* If fixed subpopulation sizes are given to parameter @@subPopSize@@. A mating scheme will generation an offspring generation with specified sizes even if an operator has changed parental population sizes.%0a%0a* A demographic function can be specified to parameter @@subPopSize@@. This function should take two parameters: the generation number and the current subpopulation sizes, and return an array of new subpopulation sizes. A single number can be returned if there is only one subpopulation.%0a%0aThis example uses a demographic function to control the subpopulation size of the offspring generation. This example implements a linear population expansion model but arbitrarily complex demographic model can be implemented similarly.%0a%0a=python [=%0a>>> def demo(gen, oldSize=[]):%0a...     return [500 + gen*10, 1000 + gen*10]%0a... %0a>>> simu = simulator(%0a...     population(size=[500, 1000], infoFields=['migrate_to']),%0a...     randomMating(subPopSize=demo))%0a>>> simu.evolve(%0a...     preOps = [initSex()],%0a...     ops = [%0a...         migrator(rate=[[0.8, 0.2], [0.4, 0.6]]),%0a...         stat(popSize=True),%0a...         pyEval(r'"%25s\n" %25 subPopSize')%0a...     ],%0a...     gen = 3%0a... )%0a[500, 1000]%0a[510, 1010]%0a[520, 1020]%0a(3,)%0a>>>%0a%0a=]%0a%0a!!! Determine number of offspring during mating%0a%0asimuPOP by default produces only one offspring per mating event. Because more parents are involved in the production of offspring, this setting leads to larger effective population sizes than mating schemes that produce more offspring at each mating event. However, various situations require a larger family size or even varying family sizes. In these cases, parameter @@numOffspring@@ can be used to control the number of offspring that are produced at each mating event. This parameter takes the following types of inputs%0a%0a* If a single number is given, @@numOffspring@@ offspring are produced at each mating event.%0a%0a* If a Python function is given, this function will be called each time when a mating event happens. Generation number will be passed to this function, which allows different numbers of offspring at different generations.%0a%0a* If a tuple (or list) with more than one numbers is given, the first number must be one of @@GeometricDistribution@@, @@PoissonDistribution@@, @@BinomialDistribution@@ and @@UniformDistribution@@, with one or two additional parameters. The number of offspring will then follow a specific statistical distribution. Note that all these distributions are adjusted so that the minimal number of offspring is 1.%0a%0a=python [=%0a>>> def checkNumOffspring(ms):%0a...     '''Check the number of offspring for each family using%0a...        information field father_idx%0a...     '''%0a...     simu = simulator(%0a...         population(size=[30], infoFields=['father_idx', 'mother_idx']),%0a...         matingScheme=ms)%0a...     simu.evolve(%0a...         preOps = [initSex()],%0a...         ops=[parentsTagger()],%0a...         gen=1)%0a...     # get the parents of each offspring%0a...     parents = [(x, y) for x, y in zip(simu.population(0).indInfo('mother_idx'),%0a...         simu.population(0).indInfo('father_idx'))]%0a...     # Individuals with identical parents are considered as siblings.%0a...     famSize = []%0a...     lastParent = (-1, -1)%0a...     for parent in parents:%0a...         if parent == lastParent:%0a...             famSize[-1] += 1%0a...         else:%0a...             lastParent = parent%0a...             famSize.append(1)%0a...     return famSize%0a... %0a>>> # Case 1: produce the given number of offspring%0a>>> checkNumOffspring(randomMating(numOffspring=2))%0a[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]%0a>>> # Case 2: Use a Python function%0a>>> import random%0a>>> def func(gen):%0a...     return random.randint(5, 8)%0a... %0a>>> checkNumOffspring(randomMating(numOffspring=func))%0a[7, 8, 6, 7, 2]%0a>>> # Case 3: A geometric distribution%0a>>> checkNumOffspring(randomMating(numOffspring=(GeometricDistribution, 0.3)))%0a[2, 1, 16, 4, 2, 3, 2]%0a>>> # Case 4: A Possition distribution%0a>>> checkNumOffspring(randomMating(numOffspring=(PoissonDistribution, 3)))%0a[4, 2, 4, 4, 5, 4, 1, 2, 4]%0a>>> # Case 5: A Binomial distribution%0a>>> checkNumOffspring(randomMating(numOffspring=(BinomialDistribution, 0.1, 10)))%0a[4, 1, 2, 2, 1, 3, 2, 3, 2, 1, 4, 3, 2]%0a>>> # Case 6: A uniform distribution%0a>>> checkNumOffspring(randomMating(numOffspring=(UniformDistribution, 2, 6)))%0a[2, 4, 4, 2, 5, 3, 2, 5, 3]%0a>>>%0a%0a=]%0a%0a!!! Control offspring sex%0a%0aBecause sex can influence how genotypes are transmitted (e.g. sex chromosomes, haplodiploid population), simuPOP determines offspring sex before it passes an offspring to a genotype transmitter (during-mating operator) to transmit genotype from parents to offspring. The default sexMode in almost all mating schemes is RandomSex, in which case simuPOP assign Male or Female to offspring with equal probability.%0a%0aOther sex determination methods are also available:%0a%0a• @@sexMode=NoSex@@: Sex is not simulated so everyone is Male. This is the default mode where offspring can be Male or Female with equal probability.%0a%0a* @@sexMode=(ProbOfMale, prob)@@: Produce males with given probability.%0a%0a* @@sexMode=(NumOfMale, n)@@: The first n offspring in each family will be Male. If the number of offspring at a mating event is less than or equal to n, all offspring will be male. %0a%0a* @@sexMode=(NumOfFemale, n)@@: The first n offspring in each family will be Female.%0a%0aThis example demonstrates how to use parameter sexMode. In this example, a function checkSexMode is defined. It takes a mating scheme as its input parameter and use it to evolve a population with 40 individuals. After evolving a population for one generation, sexes of all offspring are returned as a string.%0a%0a=python [=%0a>>> def checkSexMode(ms):%0a...     '''Check the assignment of sex to offspring'''%0a...     simu = simulator(%0a...         population(size=[40]),%0a...         matingScheme=ms)%0a...     simu.evolve(preOps = [initSex()], ops=[], gen=1)%0a...     # return individual sex as a string%0a...     return ''.join([ind.sexChar() for ind in simu.population(0).individuals()])%0a... %0a>>> # Case 1: NoSex (all male, randomMating will not continue)%0a>>> checkSexMode(randomMating(sexMode=NoSex))%0a'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM'%0a>>> # Case 2: RandomSex (Male/Female with probability 0.5)%0a>>> checkSexMode(randomMating(sexMode=RandomSex))%0a'FMFFFMFFFMFFFMFMMFFMFFFMMFMFMMFFMFFMFMMM'%0a>>> # Case 3: ProbOfMale (Specify probability of male)%0a>>> checkSexMode(randomMating(sexMode=(ProbOfMale, 0.8)))%0a'FMMMMMFFMMMMFMMMMMMMMFFMMMMMMMMFMMFMMMMM'%0a>>> # Case 4: NumOfMale (Specify number of male in each family)%0a>>> checkSexMode(randomMating(numOffspring=3, sexMode=(NumOfMale, 1)))%0a'MFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFM'%0a>>> # Case 5: NumOfFamel (Specify number of female in each family)%0a>>> checkSexMode(randomMating(%0a...     numOffspring=(UniformDistribution, 4, 6),%0a...     sexMode=(NumOfFemale, 2))%0a... )%0a'FFMMMFFMMMMFFMMMFFMMMFFMMMFFMMMFFMMMFFMM'%0a>>>%0a%0a=]%0a%0a!!! Monogamous mating%0a%0a''Monogamous mating'' (monogamy) in simuPOP refers to mating schemes in which each parent mates only once. In an asexual setting, this implies parents are chosen without replacement. In sexual mating schemes, this means that parents are chosen without replacement, they have only one spouse during their life time so that all siblings have the same parents (no half-sibling).%0a%0asimuPOP provides a diploid sexual monogamous mating scheme @@monogamousMating@@. However, without careful planning, this mating scheme can easily stop working due to the lack of parents. For example, if a population has 40 males and 55 females, only 40 successful mating events can happen and result in 40 offspring in the offspring generation. monogamousMating will exit if the offspring generation is larger than 40.%0a%0aThis example demonstrates one scenario of using a monogamous mating scheme where sex of parents and offspring are strictly specified so that parents will not be exhausted. The sex initializer initSex assigns exactly 10 males and 10 females to the initial population. Because of the use of @@numOffspring=2@@, @@sexMode=(NumOfMale, 1)@@, each mating event will produce exactly one male and one female. Unlike a random mating scheme that only about 80%25 of parents are involved in the production of an offspring population with the same size, this mating scheme makes use of all parents.%0a%0a%0a=python [=%0a>>> simu = simulator(population(20, infoFields=['father_idx', 'mother_idx']),%0a...     monogamousMating(numOffspring=2, sexMode=(NumOfMale, 1)))%0a>>> simu.evolve(%0a...     preOps = [initSex(sex=(Male, Female))],%0a...     ops = [parentsTagger()],%0a...     gen = 5%0a... )%0a(5,)%0a>>> pop = simu.extract(0)%0a>>> [ind.sex() for ind in pop.individuals()]%0a[1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]%0a>>> [ind.intInfo('father_idx') for ind in pop.individuals()]%0a[18, 18, 6, 6, 0, 0, 10, 10, 8, 8, 4, 4, 2, 2, 16, 16, 14, 14, 12, 12]%0a>>> [ind.intInfo('mother_idx') for ind in pop.individuals()]%0a[17, 17, 19, 19, 5, 5, 1, 1, 7, 7, 3, 3, 13, 13, 11, 11, 9, 9, 15, 15]%0a>>> # count the number of distinct parents%0a>>> len(set(pop.indInfo('father_idx')))%0a10%0a>>> len(set(pop.indInfo('mother_idx')))%0a10%0a>>>%0a%0a=]%0a%0a!!! Mating in haplodiploid populations%0a%0aMale individuals in a haplodiploid population are derived from unfertilized eggs and thus have only one set of chromosomes. Mating in such a population is handled by a special mating scheme called @@haplodiplodMating@@. This mating scheme chooses a pair of parents randomly and produces some offspring. It transmit maternal chromosomes and paternal chromosomes (the only copy) to female offspring, and only maternal chromosomes to male offspring. %0a%0aThis example demonstrates how to use this mating scheme. It uses three initializers because sex has to be initialized before two other intializers can initialize genotype by sex.%0a%0a=python [=%0a>>> pop = population(size=[2,5], ploidy=Haplodiploid, loci=[3, 5])%0a>>> InitByFreq(pop, [0.3, 0.7])%0a>>> Dump(pop)%0aPloidy: 2 (haplodiploid)%0aChromosomes:%0a1: chrom1 (Autosome, 3 loci)%0a  loc1-1 (1), loc1-2 (2), loc1-3 (3)%0a2: chrom2 (Autosome, 5 loci)%0a  loc2-1 (1), loc2-2 (2), loc2-3 (3), loc2-4 (4), loc2-5 (5)%0apopulation size: 7 (2 subpopulations with 2, 5 individuals)%0aNumber of ancestral populations: 0%0a%0aSubpopulation 0 (unnamed), 2 individuals:%0a   0: FU 111 11110 | 100 10101 %0a   1: MU 111 10111 | ___ _____ %0aSubpopulation 1 (unnamed), 5 individuals:%0a   2: FU 110 10110 | 111 00001 %0a   3: FU 110 11110 | 111 01001 %0a   4: FU 000 11101 | 111 11011 %0a   5: FU 101 11110 | 111 11000 %0a   6: FU 111 10110 | 110 10111 %0a>>>%0a%0a=]%0a%0a!!! Heterogeneous mating schemes%0a%0aDifferent groups of individuals in a population may have different mating patterns. For example, individuals with different properties can have varying fecundity, represented by different numbers of offspring generated per mating event. This can be extended to aged populations in which only adults (may be defined by age > 20 and age %3c 40) can produce offspring, where other individuals will either be copied to the offspring generation or die.%0a%0aA '''heterogeneous mating scheme''' (@@heteroMating@@) accepts a list of mating schemes that are applied to different subpopulation or virtual subpopulations. If multiple mating schemes are applied to the same subpopulation, each of them only population part of the offspring subpopulation. %0a%0aThis example applies two mating schemes to two VSPs defined by proportions of individuals. In this mating scheme, 20%25 of individuals go through self-mating and 80%25 of individuals go through random mating. This can be seen from the parental indexes of individuals in the offspring generation: individuals whose @@mother_idx@@ are -1 are genetically only derived from their fathers. %0a%0a=python [=%0a>>> pop = population(size=[1000], loci=[2],%0a...     infoFields=['father_idx', 'mother_idx'])%0a>>> pop.setVirtualSplitter(proportionSplitter([0.2, 0.8]))%0a>>> simu = simulator(pop, heteroMating(%0a...     matingSchemes = [%0a...         selfMating(subPop=(0, 0)),%0a...         randomMating(subPop=(0, 1))%0a...     ])%0a... )%0a>>> simu.evolve(%0a...     preOps = [initSex()],%0a...     ops= [parentsTagger()],%0a...     gen = 10%0a... )%0a(10,)%0a>>> pop = simu.extract(0)%0a>>> [ind.intInfo('father_idx') for ind in pop.individuals(0)][:15]%0a[162, 114, 155, 162, 105, 62, 83, 24, 185, 131, 168, 3, 6, 115, 35]%0a>>> [ind.intInfo('mother_idx') for ind in pop.individuals(0)][:15]%0a[119, -1, 46, 130, 101, 135, -1, 163, 55, 179, 152, 111, -1, 152, 188]%0a>>>%0a%0a=]%0a%0a
time=1232901535
title=Selected Examples
author:1232901535=
diff:1232901535:1232901515:=5d4%0a%3c %0a
host:1232901535=127.0.0.1
author:1232901515=
diff:1232901515:1232900541:=2,3d1%0a%3c %25rfloat newwin right text-align=right margin-top=0px margin-right=25px margin-bottom=0px margin-left=25px%25 http://simupop.sourceforge.net/images/examples.jpg%0a%3c %0a
host:1232901515=127.0.0.1
author:1232900541=
diff:1232900541:1232428617:=1,2d0%0a%3c (:title Selected Examples:)%0a%3c The following examples are excerpted from the simuPOP User's Guide for simuPOP version 0.9.2. Please refer to the most recent version of the [[http://simupop.sourceforge.net/manual/build/userGuide.html | simuPOP User's Guide]] for complete explanations of the concepts and functions involved.%0a
host:1232900541=127.0.0.1
author:1232428617=
diff:1232428617:1232375460:=
host:1232428617=127.0.0.1
author:1232375460=
diff:1232375460:1232374480:=64,65c64,65%0a%3c Different kinds of simulations require different kinds of individuals. Individuals with only genotype information are sufficient to simulate the basic ''Wright-Fisher model''. Sex is needed to simulate such a model in diploid populations with sex. Individual fitness may be needed if selection is induced, and age may be needed if the population is age-structured. In addition, different types of quantitative traits or affection status may be needed to study the impact of genotype on individual phenotype. Because it is infeasible to provide all such information to an individual, simuPOP keeps genotype, sex (Male or Female) and affection status as built-in properties of an individual, and all others as optional information fields (float numbers) attached to each individual.%0a%3c %0a---%0a> Different kinds of simulations require different kinds of individuals. Individuals with only genotype information are sufficient to simulate the basic Wright-Fisher model. Sex is needed to simulate such a model in diploid populations with sex. Individual fitness may be needed if selection is induced, and age may be needed if the population is age-structured. In addition, different types of quantitative traits or affection status may be needed to study the impact of genotype on individual phenotype. Because it is infeasible to provide all such information to an individual, simuPOP keeps genotype, sex (Male or Female) and affection status as built-in properties of an individual, and all others as optional information fields (float numbers) attached to each individual.%0a> %0a175d174%0a%3c %0a178,179c177,178%0a%3c This is usually enough when only the present generation is of interest. However, parental generations can provide useful information on how genotype and other information are passed from parental to offspring generations. simuPOP provides a mechanism to store and access arbitrary number of ''ancestral generations'' in a population object. Applications of this feature include pedigree tracking, reconstruction, and pedigree ascertainments.%0a%3c %0a---%0a> This is usually enough when only the present generation is of interest. However, parental generations can provide useful information on how genotype and other information are passed from parental to offspring generations. simuPOP provides a mechanism to store and access arbitrary number of ancestral generations in a population object. Applications of this feature include pedigree tracking, reconstruction, and pedigree ascertainments.%0a> %0a256,260c255,259%0a%3c A simuPOP life cycle (a generation) can be divided into pre-mating, during-mating and post-mating. In the pre-mating stage, the present generation is the parental generation. In the during-mating stage, an offspring generation is populated from the parental generation. In the post-mating stage, the offspring generation has become the present generation. An operator can be applied at one or more stages at a life cycle. However, each operator has its own default value for the stage parameter and changes to this parameter are not always allowed. For example, a @@recombinator@@ can only be applied @@DuringMating@@ and it will ignore your attemp to apply it at another stage.%0a%3c %0a%3c Operators that are passed to the ops parameter of the @@simulator::evolve@@ function are, by default, applied to all generations during an evolutionary process. This can be changed using the begin, end, step and at parameters. As their names indicate, these parameters control the starting generation (@@begin@@), ending generation (@@end@@), generations between two applicable generations (@@step@@), and an explicit list of applicable generations (@@at@@, a single generation number is also acceptable). Other parameters will be ignored if at is specified. It is worth noting that, if the simulator has an ending generation, negative generations numbers are allowed. They are counted backward from the ending generation.%0a%3c %0a%3c %0a---%0a> A simuPOP life cycle (a generation) can be divided into pre-mating, during-mating and post-mating. In the pre-mating stage, the present generation is the parental generation. In the during-mating stage, an offspring generation is populated from the parental generation. In the post-mating stage, the offspring generation has become the present generation. An operator can be applied at one or more stages at a life cycle. However, each operator has its own default value for the stage parameter and changes to this parameter are not always allowed. For example, a recombinator can only be applied DuringMating and it will ignore your attemp to apply it at another stage.%0a> %0a> Operators that are passed to the ops parameter of the simulator::evolve function are, by default, applied to all generations during an evolutionary process. This can be changed using the begin, end, step and at parameters. As their names indicate, these parameters control the starting generation (begin), ending generation (end), generations between two applicable generations (step), and an explicit list of applicable generations (at, a single generation number is also acceptable). Other parameters will be ignored if at is specified. It is worth noting that, if the simulator has an ending generation, negative generations numbers are allowed. They are counted backward from the ending generation.%0a> %0a> %0a288,289c287,288%0a%3c All operators we have seen, except for the @@savePopulation@@ operator in an previous example, write their output to the standard output, namely your terminal window. However, it would be much easier for bookkeeping and further analysis if these output can be redirected to disk files. Parameter @@output@@ is designed for this purpose.%0a%3c %0a---%0a> All operators we have seen, except for the savePopulation operator in Example [stageAndGen], write their output to the standard output, namely your terminal window. However, it would be much easier for bookkeeping and further analysis if these output can be redirected to disk files. Parameter output is designed for this purpose.%0a> %0a411,414c410,413%0a%3c * If fixed subpopulation sizes are given to parameter @@subPopSize@@. A mating scheme will generation an offspring generation with specified sizes even if an operator has changed parental population sizes.%0a%3c %0a%3c * A demographic function can be specified to parameter @@subPopSize@@. This function should take two parameters: the generation number and the current subpopulation sizes, and return an array of new subpopulation sizes. A single number can be returned if there is only one subpopulation.%0a%3c %0a---%0a> * If fixed subpopulation sizes are given to parameter subPopSize. A mating scheme will generation an offspring generation with specified sizes even if an operator has changed parental population sizes.%0a> %0a> * A demographic function can be specified to parameter subPopSize. This function should take two parameters: the generation number and the current subpopulation sizes, and return an array of new subpopulation sizes. A single number can be returned if there is only one subpopulation.%0a> %0a449,450c448,449%0a%3c * If a tuple (or list) with more than one numbers is given, the first number must be one of @@GeometricDistribution@@, @@PoissonDistribution@@, @@BinomialDistribution@@ and @@UniformDistribution@@, with one or two additional parameters. The number of offspring will then follow a specific statistical distribution. Note that all these distributions are adjusted so that the minimal number of offspring is 1.%0a%3c %0a---%0a> * If a tuple (or list) with more than one numbers is given, the first number must be one of GeometricDistribution, PoissonDistribution, BinomialDistribution and UniformDistribution, with one or two additional parameters. The number of offspring will then follow a specific statistical distribution. Note that all these distributions are adjusted so that the minimal number of offspring is 1.%0a> %0a509,510c508,509%0a%3c • @@sexMode=NoSex@@: Sex is not simulated so everyone is Male. This is the default mode where offspring can be Male or Female with equal probability.%0a%3c %0a---%0a> • sexMode=NoSex: Sex is not simulated so everyone is Male. This is the default mode where offspring can be Male or Female with equal probability.%0a> %0a553,559c552,558%0a%3c ''Monogamous mating'' (monogamy) in simuPOP refers to mating schemes in which each parent mates only once. In an asexual setting, this implies parents are chosen without replacement. In sexual mating schemes, this means that parents are chosen without replacement, they have only one spouse during their life time so that all siblings have the same parents (no half-sibling).%0a%3c %0a%3c simuPOP provides a diploid sexual monogamous mating scheme @@monogamousMating@@. However, without careful planning, this mating scheme can easily stop working due to the lack of parents. For example, if a population has 40 males and 55 females, only 40 successful mating events can happen and result in 40 offspring in the offspring generation. monogamousMating will exit if the offspring generation is larger than 40.%0a%3c %0a%3c This example demonstrates one scenario of using a monogamous mating scheme where sex of parents and offspring are strictly specified so that parents will not be exhausted. The sex initializer initSex assigns exactly 10 males and 10 females to the initial population. Because of the use of @@numOffspring=2@@, @@sexMode=(NumOfMale, 1)@@, each mating event will produce exactly one male and one female. Unlike a random mating scheme that only about 80%25 of parents are involved in the production of an offspring population with the same size, this mating scheme makes use of all parents.%0a%3c %0a%3c %0a---%0a> Monogamous mating (monogamy) in simuPOP refers to mating schemes in which each parent mates only once. In an asexual setting, this implies parents are chosen without replacement. In sexual mating schemes, this means that parents are chosen without replacement, they have only one spouse during their life time so that all siblings have the same parents (no half-sibling).%0a> %0a> simuPOP provides a diploid sexual monogamous mating scheme monogamousMating. However, without careful planning, this mating scheme can easily stop working due to the lack of parents. For example, if a population has 40 males and 55 females, only 40 successful mating events can happen and result in 40 offspring in the offspring generation. monogamousMating will exit if the offspring generation is larger than 40.%0a> %0a> This example demonstrates one scenario of using a monogamous mating scheme where sex of parents and offspring are strictly specified so that parents will not be exhausted. The sex initializer initSex assigns exactly 10 males and 10 females to the initial population. Because of the use of numOffspring=2, sexMode=(NumOfMale, 1), each mating event will produce exactly one male and one female. Unlike a random mating scheme that only about 80%25 of parents are involved in the production of an offspring population with the same size, this mating scheme makes use of all parents.%0a> %0a> %0a587,590c586,587%0a%3c Male individuals in a haplodiploid population are derived from unfertilized eggs and thus have only one set of chromosomes. Mating in such a population is handled by a special mating scheme called @@haplodiplodMating@@. This mating scheme chooses a pair of parents randomly and produces some offspring. It transmit maternal chromosomes and paternal chromosomes (the only copy) to female offspring, and only maternal chromosomes to male offspring. %0a%3c %0a%3c This example demonstrates how to use this mating scheme. It uses three initializers because sex has to be initialized before two other intializers can initialize genotype by sex.%0a%3c %0a---%0a> Male individuals in a haplodiploid population are derived from unfertilized eggs and thus have only one set of chromosomes. Mating in such a population is handled by a special mating scheme called haplodiplodMating. This mating scheme chooses a pair of parents randomly and produces some offspring. It transmit maternal chromosomes and paternal chromosomes (the only copy) to female offspring, and only maternal chromosomes to male offspring. Example [haplodiploidMating] demonstrates how to use this mating scheme. It uses three initializers because sex has to be initialized before two other intializers can initialize genotype by sex.%0a> %0a621,624c618,621%0a%3c A '''heterogeneous mating scheme''' (@@heteroMating@@) accepts a list of mating schemes that are applied to different subpopulation or virtual subpopulations. If multiple mating schemes are applied to the same subpopulation, each of them only population part of the offspring subpopulation. %0a%3c %0a%3c This example applies two mating schemes to two VSPs defined by proportions of individuals. In this mating scheme, 20%25 of individuals go through self-mating and 80%25 of individuals go through random mating. This can be seen from the parental indexes of individuals in the offspring generation: individuals whose @@mother_idx@@ are -1 are genetically only derived from their fathers. %0a%3c %0a---%0a> A heterogeneous mating scheme (heteroMating) accepts a list of mating schemes that are applied to different subpopulation or virtual subpopulations. If multiple mating schemes are applied to the same subpopulation, each of them only population part of the offspring subpopulation. %0a> %0a> This example applies two mating schemes to two VSPs defined by proportions of individuals. In this mating scheme, 20%25 of individuals go through self-mating and 80%25 of individuals go through random mating. This can be seen from the parental indexes of individuals in the offspring generation: individuals whose mother_idx are -1 are genetically only derived from their fathers. %0a> %0a
host:1232375460=127.0.0.1
author:1232374480=
diff:1232374480:1232340988:=291,302c291,302%0a%3c * @@''@@ (an empty string): No output.%0a%3c %0a%3c * @@'>'@@: Write to standard output.%0a%3c %0a%3c * @@'filename'@@ or @@'>filename'@@: Write the output to a file named filename. If multiple operators write to the same file, or if the same operator writes to the file file several times, only the last write operation will succeed.%0a%3c %0a%3c * @@'>>filename'@@: Append the output to a file named filename. The file will be opened at the beginning of evolve function and closed at the end. An existing file will be cleared.%0a%3c %0a%3c * @@'>>>filename'@@: This is similar to the '>>' form but the file will not be cleared at the beginning of the evolve function.%0a%3c %0a%3c * @@'!expr'@@: @@expr@@ is considered as a Python expression that will be evaluated at a population's local namespace whenever an output string is needed. For example, @@'!”%25d.txt” %25 gen'@@ would return 0.txt, 1.txt etc at generation 0, 1, ....%0a%3c %0a---%0a> * '' (an empty string): No output.%0a> %0a> * '>': Write to standard output.%0a> %0a> * 'filename' or '>filename': Write the output to a file named filename. If multiple operators write to the same file, or if the same operator writes to the file file several times, only the last write operation will succeed.%0a> %0a> * '>>filename': Append the output to a file named filename. The file will be opened at the beginning of evolve function and closed at the end. An existing file will be cleared.%0a> %0a> * '>>>filename': This is similar to the '>>' form but the file will not be cleared at the beginning of the evolve function.%0a> %0a> * '!expr': expr is considered as a Python expression that will be evaluated at a population's local namespace whenever an output string is needed. For example, '!”%25d.txt” %25 gen' would return 0.txt, 1.txt etc at generation 0, 1, ....%0a> %0a338,341c338,341%0a%3c A '''hybrid operator''' is an operator that calls a user-defined function when its applied to a population. The number and meaning of input parameters and return values vary from operator to operator. For example, a hybrid mutator sends a to-be-mutated allele to a user-defined function and use its return value as a mutant allele. A hybrid selector uses the return value of a user defined function as individual fitness. Such an operator handles the routine part of the work (e.g. scan through a chromosome and determine which allele needs to be mutated), and leave the creative part to users. Such a mutator can be used to implement complicated genetic models such as an asymmetric stepwise mutation model for microsatellite markers.%0a%3c %0a%3c This example defines a three-locus heterogeneity penetrance model  that yields positive penetrance only when at least two disease susceptibility alleles are available. The underlying mechanism of this operator is that for each individual, simuPOP will collect genotype at specified loci (parameter loci) and send them to function @@myPenetrance@@ and evaluate. The return values are used as the penetrance value of the individual, which is then interpreted as the probability that this individual will become affected.%0a%3c %0a---%0a> A hybrid operator is an operator that calls a user-defined function when its applied to a population. The number and meaning of input parameters and return values vary from operator to operator. For example, a hybrid mutator sends a to-be-mutated allele to a user-defined function and use its return value as a mutant allele. A hybrid selector uses the return value of a user defined function as individual fitness. Such an operator handles the routine part of the work (e.g. scan through a chromosome and determine which allele needs to be mutated), and leave the creative part to users. Such a mutator can be used to implement complicated genetic models such as an asymmetric stepwise mutation model for microsatellite markers.%0a> %0a> This example defines a three-locus heterogeneity penetrance model  that yields positive penetrance only when at least two disease susceptibility alleles are available. The underlying mechanism of this operator is that for each individual, simuPOP will collect genotype at specified loci (parameter loci) and send them to function myPenetrance and evaluate. The return values are used as the penetrance value of the individual, which is then interpreted as the probability that this individual will become affected.%0a> %0a372,381c372,381%0a%3c If hybrid operators are still not flexible enough, you can always resort to a pure-Python operator @@pyOperator@@. This operator has full access to the evolving population (or parents and offspring when @@stage=DuringMating@@), and can therefore perform arbitrary operations.%0a%3c %0a%3c A pre- or post-mating @@pyOperator@@ expects a function in the form of%0a%3c %0a%3c ->@@func(pop [, param])@@%0a%3c %0a%3c where param is optional, depending on whether or not a parameter is passed to the @@pyOperator()@@ constructor. Function func can perform arbitrary action to pop and must return True or False. The evolution of pop will be stopped if this function returns False.%0a%3c %0a%3c This example defines such a function. It accepts a cutoff value and two mutation rates as parameters. It then calculate the frequency of allele 1 at each locus and apply a two-allele model at high mutation rate if the frequency is lower than the cutoff and a low mutation rate otherwise. The @@KamMutate@@ function is the function form of a mutator @@kamMutator@@.%0a%3c %0a---%0a> If hybrid operators are still not flexible enough, you can always resort to a pure-Python operator pyOperator. This operator has full access to the evolving population (or parents and offspring when stage=DuringMating), and can therefore perform arbitrary operations.%0a> %0a> A pre- or post-mating pyOperator expects a function in the form of%0a> %0a> ->@@func(pop [, param])%0a> %0a> where param is optional, depending on whether or not a parameter is passed to the pyOperator() constructor. Function func can perform arbitrary action to pop and must return True or False. The evolution of pop will be stopped if this function returns False.%0a> %0a> This example defines such a function. It accepts a cutoff value and two mutation rates as parameters. It then calculate the frequency of allele 1 at each locus and apply a two-allele model at high mutation rate if the frequency is lower than the cutoff and a low mutation rate otherwise. The KamMutate function is the function form of a mutator kamMutator.%0a> %0a
host:1232374480=127.0.0.1
author:1232340988=
diff:1232340988:1232339943:=134,141c134,135%0a%3c !!! Virtual subpopulations%0a%3c %0a%3c simuPOP subpopulations can be further divided into '''virtual subpopulations''' (VSP), which are groups of individuals who share certain properties. For example, all male individuals, all unaffected individuals, all individuals with information field age > 20, all individuals with genotype 0, 0 at a given locus, can form VSPs. VSPs do not have to add up to the whole subpopulation, nor do they have to be non-overlapping. Unlike subpopulations that have strict boundaries, VSPs change easily with the changes of individual properties.%0a%3c %0a%3c VSPs are defined by '''virtual splitters'''. A splitter defines the same number of VSPs in all subpopulations, although sizes of these VSPs vary across subpopulations due to subpopulation differences. For example, a @@sexSplitter()@@ defines two VSPs, the first with all male individuals and the second with all female individuals, and a @@infoSplitter(field='x', values=[1, 2, 4])@@ defines three VSPs whose members have values 1, 2 and 4 at information field x, respectively. If different types of VSPs are needed, a combined splitter can be used to combine VSPs defined by several splitters.%0a%3c %0a%3c A VSP is represented by a @@[spID, vspID]@@ pair. Its name and size can be obtained using functions @@subPopName()@@ and @@subPopSize()@@. Example @@[virtualSplitter]@@ demonstrates how to apply virtual splitters to a population, and how to check VSP names and sizes.%0a%3c %0a---%0a> !!! %0a> %0a143,171c137%0a%3c >>> import random%0a%3c >>> pop = population(size=[200, 400], loci=[30], infoFields=['x'])%0a%3c >>> # assign random information fields%0a%3c >>> pop.setIndInfo([random.randint(0, 3) for x in range(pop.popSize())], 'x')%0a%3c >>> # define a virtual splitter by information field 'x'%0a%3c >>> pop.setVirtualSplitter(infoSplitter(field='x', values=[0, 1, 2, 3]))%0a%3c >>> pop.numVirtualSubPop()    # Number of defined VSPs%0a%3c 4%0a%3c >>> pop.subPopName([0, 0])    # Each VSP has a name%0a%3c 'unnamed - x = 0'%0a%3c >>> pop.subPopSize([0, 0])    # Size of VSP 0 in subpopulation 0%0a%3c 57%0a%3c >>> pop.subPopSize([1, 0])    # Size of VSP 0 in subpopulation 1%0a%3c 100%0a%3c >>> # use a combined splitter that defines additional VSPs by sex%0a%3c >>> InitSex(pop)%0a%3c >>> pop.setSubPopName('subPop 1', 0)%0a%3c >>> pop.setVirtualSplitter(combinedSplitter([%0a%3c ...     infoSplitter(field='x', values=[0, 1, 2, 3]),%0a%3c ...     sexSplitter()])%0a%3c ... )%0a%3c >>> pop.numVirtualSubPop()    # Number of defined VSPs%0a%3c 6%0a%3c >>> pop.subPopName([0, 4])    # VSP 4 is the first VSP defined by the sex splitter%0a%3c 'subPop 1 - Male'%0a%3c >>> pop.subPopSize([0, 4])    # Number of male individuals%0a%3c 94%0a%3c >>>%0a%3c %0a---%0a> %0a173,180c139,140%0a%3c %0a%3c !!! Ancestral generations%0a%3c A simuPOP population usually holds individuals in one generation. During evolution, an offspring generation will replace the parental generation and become the present generation (population), after it is populated from a parental population. The parental generation is discarded.%0a%3c %0a%3c This is usually enough when only the present generation is of interest. However, parental generations can provide useful information on how genotype and other information are passed from parental to offspring generations. simuPOP provides a mechanism to store and access arbitrary number of ancestral generations in a population object. Applications of this feature include pedigree tracking, reconstruction, and pedigree ascertainments.%0a%3c %0a%3c In this example, a population is created and is initialized with allele frequency 0.5. Its ancestral depth is set to 2 at the beginning of generation 18 so that it can hold parental generations at generation 18 and 19. The allele frequency at each generation is calculated and displayed, both during evolution using a stat operator, and after evolution using the function form this operator. Note that setting the ancestral depth at the end of an evolutionary process is a common practice because we are usually only interested in the last few generations.%0a%3c %0a---%0a> !!!%0a> %0a182,210c142%0a%3c >>> simu = simulator(population(500, loci=[1]), randomMating())%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initByFreq([0.5, 0.5])],%0a%3c ...     ops = [%0a%3c ...         # start recording ancestral generations at generation 18%0a%3c ...         setAncestralDepth(2, at=[-2]),%0a%3c ...         stat(alleleFreq=[0], begin=-3),%0a%3c ...         pyEval(r"'%25.3f\n' %25 alleleFreq[0][0]", begin=-3)%0a%3c ...     ],%0a%3c ...     gen = 20%0a%3c ... )%0a%3c 0.436%0a%3c 0.455%0a%3c 0.450%0a%3c (20,)%0a%3c >>> pop = simu.population(0)%0a%3c >>> # start from current generation%0a%3c >>> for i in range(pop.ancestralGens(), -1, -1):%0a%3c ...   pop.useAncestralGen(i)%0a%3c ...   Stat(pop, alleleFreq=[0])%0a%3c ...   print '%25d   %25.3f' %25 (i, pop.dvars().alleleFreq[0][0])%0a%3c ... %0a%3c 2   0.436%0a%3c 1   0.455%0a%3c 0   0.450%0a%3c >>> # restore to the current generation  %0a%3c >>> pop.useAncestralGen(0)  %0a%3c >>>%0a%3c %0a---%0a> %0a212,218c144,145%0a%3c %0a%3c !!! Population variables%0a%3c %0a%3c Each simuPOP population has a Python dictionary that can be used to store arbitrary Python variables. These variables are usually used by various operators to share information between them. For example, the stat operator calculates population statistics and stores the results in this Python dictionary. Other operators such as the @@pyEval@@ and @@terminateIf@@ read from this dictionary and act upon its information.%0a%3c %0a%3c simuPOP provides two functions, namely @@population::vars()@@ and @@population::dvars()@@ to access a population dictionary. These functions return the same dictionary object but dvars() returns a wrapper class so that you can access this dictionary as attributes. For example, @@pop.vars()['alleleFreq'][0]@@ is equivalent to @@pop.dvars().alleleFreq[0]@@. Because dictionary subPop[spID] is frequently used by operators to store variables related to a particular (virtual) subpopulation, function pop.vars(subPop) is provided as a shortcut to @@pop.vars()['subPop'][spID]@@. This example demonstrates how to set and access Population variables.%0a%3c %0a---%0a> !!!%0a> %0a220,250c147%0a%3c >>> from pprint import pprint%0a%3c >>> pop = population(100, loci=[2])%0a%3c >>> InitByFreq(pop, [0.3, 0.7])%0a%3c >>> print pop.vars()    # No variable now%0a%3c {}%0a%3c >>> pop.dvars().myVar = 21%0a%3c >>> print pop.vars()%0a%3c {'myVar': 21}%0a%3c >>> Stat(pop, popSize=1, alleleFreq=[0])%0a%3c >>> # pprint prints in a less messy format%0a%3c >>> pprint(pop.vars())%0a%3c {'alleleFreq': [[0.32500000000000001, 0.67500000000000004]],%0a%3c  'alleleNum': [[65, 135]],%0a%3c  'myVar': 21,%0a%3c  'numSubPop': 1,%0a%3c  'popSize': 100,%0a%3c  'subPop': [{'alleleFreq': [[0.32500000000000001, 0.67500000000000004]],%0a%3c              'alleleNum': [[65, 135]],%0a%3c              'popSize': 100}],%0a%3c  'subPopSize': [100],%0a%3c  'virtualPopSize': [100]}%0a%3c >>> # print number of allele 1 at locus 0%0a%3c >>> print pop.vars()['alleleNum'][0][1]%0a%3c 135%0a%3c >>> # use the dvars() function to access dictionary keys as attributes%0a%3c >>> print pop.dvars().alleleNum[0][1]%0a%3c 135%0a%3c >>> print pop.dvars().alleleFreq[0]%0a%3c [0.32500000000000001, 0.67500000000000004]%0a%3c >>>%0a%3c %0a---%0a> %0a252,259c149,150%0a%3c %0a%3c !!! Applicable stages and generations of operators%0a%3c %0a%3c A simuPOP life cycle (a generation) can be divided into pre-mating, during-mating and post-mating. In the pre-mating stage, the present generation is the parental generation. In the during-mating stage, an offspring generation is populated from the parental generation. In the post-mating stage, the offspring generation has become the present generation. An operator can be applied at one or more stages at a life cycle. However, each operator has its own default value for the stage parameter and changes to this parameter are not always allowed. For example, a recombinator can only be applied DuringMating and it will ignore your attemp to apply it at another stage.%0a%3c %0a%3c Operators that are passed to the ops parameter of the simulator::evolve function are, by default, applied to all generations during an evolutionary process. This can be changed using the begin, end, step and at parameters. As their names indicate, these parameters control the starting generation (begin), ending generation (end), generations between two applicable generations (step), and an explicit list of applicable generations (at, a single generation number is also acceptable). Other parameters will be ignored if at is specified. It is worth noting that, if the simulator has an ending generation, negative generations numbers are allowed. They are counted backward from the ending generation.%0a%3c %0a%3c %0a---%0a> !!!%0a> %0a261,282c152%0a%3c >>> simu = simulator(population(100, loci=[20]), randomMating())%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initByFreq([0.2, 0.8])],%0a%3c ...     ops = [%0a%3c ...         stat(alleleFreq=[0], begin=80, step=10),%0a%3c ...         pyEval(r"'After gen %25d: allele freq: %25.2f\n' %25 (gen, alleleFreq[0][0])",%0a%3c ...             begin=80, step=10),%0a%3c ...         pyEval(r"'Around gen %25d: allele Freq: %25.2f\n' %25 (gen, alleleFreq[0][0])",%0a%3c ...             at = [-10, -1], stage=PrePostMating)%0a%3c ...     ],%0a%3c ...     postOps = [savePopulation(output='sample.pop')],%0a%3c ...     gen=100%0a%3c ... )%0a%3c After gen 80: allele freq: 0.28%0a%3c Around gen 90: allele Freq: 0.28%0a%3c After gen 90: allele freq: 0.19%0a%3c Around gen 90: allele Freq: 0.19%0a%3c Around gen 99: allele Freq: 0.19%0a%3c Around gen 99: allele Freq: 0.19%0a%3c (100,)%0a%3c >>>%0a%3c %0a---%0a> %0a284,302c154,155%0a%3c %0a%3c !!! Operator output%0a%3c %0a%3c All operators we have seen, except for the savePopulation operator in Example [stageAndGen], write their output to the standard output, namely your terminal window. However, it would be much easier for bookkeeping and further analysis if these output can be redirected to disk files. Parameter output is designed for this purpose.%0a%3c %0a%3c Parameter output can take the following values:%0a%3c %0a%3c * '' (an empty string): No output.%0a%3c %0a%3c * '>': Write to standard output.%0a%3c %0a%3c * 'filename' or '>filename': Write the output to a file named filename. If multiple operators write to the same file, or if the same operator writes to the file file several times, only the last write operation will succeed.%0a%3c %0a%3c * '>>filename': Append the output to a file named filename. The file will be opened at the beginning of evolve function and closed at the end. An existing file will be cleared.%0a%3c %0a%3c * '>>>filename': This is similar to the '>>' form but the file will not be cleared at the beginning of the evolve function.%0a%3c %0a%3c * '!expr': expr is considered as a Python expression that will be evaluated at a population's local namespace whenever an output string is needed. For example, '!”%25d.txt” %25 gen' would return 0.txt, 1.txt etc at generation 0, 1, ....%0a%3c %0a---%0a> !!!%0a> %0a304,331c157%0a%3c >>> from simuPOP import *%0a%3c >>> simu = simulator(population(size=1000, loci=[2]), randomMating(), rep=3)%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initByValue([1, 2, 2, 1])],  %0a%3c ...     ops = [%0a%3c ...         recombinator(rate=0.01),%0a%3c ...         stat(LD=[0, 1]),%0a%3c ...         pyEval(r"'%25.2f\t' %25 LD[0][1]", step=20, output='>>LD.txt'),%0a%3c ...         pyOutput('\n', rep=-1, step=20, output='>>LD.txt'),%0a%3c ...         pyEval(r"'%25.2f\t' %25 R2[0][1]", output='R2.txt'),%0a%3c ...         pyEval(r"'%25.2f\t' %25 LD[0][1]", step=20, output="!'>>LD_%25d.txt' %25 rep"),%0a%3c ...     ],%0a%3c ...     gen=100%0a%3c ... )%0a%3c (100, 100, 100)%0a%3c >>> print open('LD.txt').read()%0a%3c 0.25	0.24	0.24	%0a%3c 0.20	0.21	0.19	%0a%3c 0.15	0.16	0.16	%0a%3c 0.15	0.15	0.12	%0a%3c 0.11	0.12	0.10	%0a%3c %0a%3c >>> print open('R2.txt').read()    # Only the last write operation succeed.%0a%3c 0.07	%0a%3c >>> print open('LD_2.txt').read()  # Each replicate writes to a different file.%0a%3c 0.24	0.19	0.16	0.12	0.10	%0a%3c >>>%0a%3c %0a---%0a> %0a333,341c159,160%0a%3c %0a%3c !!! Hybrid operators%0a%3c %0a%3c Despite the large number of built-in operators, it is obviously not possible to implement every genetics models available. For example, although simuPOP provides several penetrance models, a user may want to try a customized one. In this case, one can use a hybrid operator.%0a%3c %0a%3c A hybrid operator is an operator that calls a user-defined function when its applied to a population. The number and meaning of input parameters and return values vary from operator to operator. For example, a hybrid mutator sends a to-be-mutated allele to a user-defined function and use its return value as a mutant allele. A hybrid selector uses the return value of a user defined function as individual fitness. Such an operator handles the routine part of the work (e.g. scan through a chromosome and determine which allele needs to be mutated), and leave the creative part to users. Such a mutator can be used to implement complicated genetic models such as an asymmetric stepwise mutation model for microsatellite markers.%0a%3c %0a%3c This example defines a three-locus heterogeneity penetrance model  that yields positive penetrance only when at least two disease susceptibility alleles are available. The underlying mechanism of this operator is that for each individual, simuPOP will collect genotype at specified loci (parameter loci) and send them to function myPenetrance and evaluate. The return values are used as the penetrance value of the individual, which is then interpreted as the probability that this individual will become affected.%0a%3c %0a---%0a> !!!%0a> %0a343,367c162%0a%3c >>> def myPenetrance(geno):%0a%3c ...     'A three-locus heterogeneity penetrance model'%0a%3c ...     if sum(geno) %3c 2:%0a%3c ...         return 0%0a%3c ...     else:%0a%3c ...         return sum(geno)*0.1%0a%3c ... %0a%3c >>> simu = simulator(population(1000, loci=[20]*3), randomMating())%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initByFreq([0.8, 0.2])],%0a%3c ...     ops = [%0a%3c ...         pyPenetrance(func=myPenetrance, loci=[10, 30, 50]),%0a%3c ...         stat(numOfAffected=True),%0a%3c ...         pyEval(r"'%25d: %25d\n' %25 (gen, numOfAffected)")%0a%3c ...     ],%0a%3c ...     gen = 5%0a%3c ... )%0a%3c 0: 78%0a%3c 1: 74%0a%3c 2: 76%0a%3c 3: 83%0a%3c 4: 79%0a%3c (5,)%0a%3c >>>%0a%3c %0a---%0a> %0a369,646d163%0a%3c %0a%3c !!! Python Operators%0a%3c %0a%3c If hybrid operators are still not flexible enough, you can always resort to a pure-Python operator pyOperator. This operator has full access to the evolving population (or parents and offspring when stage=DuringMating), and can therefore perform arbitrary operations.%0a%3c %0a%3c A pre- or post-mating pyOperator expects a function in the form of%0a%3c %0a%3c ->@@func(pop [, param])%0a%3c %0a%3c where param is optional, depending on whether or not a parameter is passed to the pyOperator() constructor. Function func can perform arbitrary action to pop and must return True or False. The evolution of pop will be stopped if this function returns False.%0a%3c %0a%3c This example defines such a function. It accepts a cutoff value and two mutation rates as parameters. It then calculate the frequency of allele 1 at each locus and apply a two-allele model at high mutation rate if the frequency is lower than the cutoff and a low mutation rate otherwise. The KamMutate function is the function form of a mutator kamMutator.%0a%3c %0a%3c =python [=%0a%3c #!/usr/bin/env python%0a%3c from simuPOP import *%0a%3c rng().setSeed(12345)%0a%3c %0a%3c def dynaMutator(pop, param):%0a%3c     '''This mutator mutates commom loci with low mutation rate and rare%0a%3c     loci with high mutation rate, as an attempt to raise allele frequency%0a%3c     of rare loci to an higher level.'''%0a%3c     # unpack parameter%0a%3c     (cutoff, mu1, mu2) = param;%0a%3c     Stat(pop, alleleFreq=range(pop.totNumLoci()))%0a%3c     for i in range(pop.totNumLoci()):%0a%3c         # Get the frequency of allele 1 (disease allele)%0a%3c         if pop.dvars().alleleFreq[i][1] %3c cutoff:%0a%3c             KamMutate(pop, maxAllele=1, rate=mu1, loci=[i])%0a%3c         else:%0a%3c             KamMutate(pop, maxAllele=1, rate=mu2, loci=[i])%0a%3c     return True%0a%3c =]%0a%3c %0a%3c %0a%3c !!! Demographic models%0a%3c %0a%3c A mating scheme goes through each subpopulation and populates the subpopulations of an offspring generation sequentially. The number of offspring in each subpopulation is determined by the mating scheme, following the following rules:%0a%3c %0a%3c * A simuPOP mating scheme, by default, produces an offspring generation that has the same subpopulation sizes as the parental generation. This does not guarantee a constant population size because some operators, such as a migrator, can change population or subpopulation sizes.%0a%3c %0a%3c * If fixed subpopulation sizes are given to parameter subPopSize. A mating scheme will generation an offspring generation with specified sizes even if an operator has changed parental population sizes.%0a%3c %0a%3c * A demographic function can be specified to parameter subPopSize. This function should take two parameters: the generation number and the current subpopulation sizes, and return an array of new subpopulation sizes. A single number can be returned if there is only one subpopulation.%0a%3c %0a%3c This example uses a demographic function to control the subpopulation size of the offspring generation. This example implements a linear population expansion model but arbitrarily complex demographic model can be implemented similarly.%0a%3c %0a%3c =python [=%0a%3c >>> def demo(gen, oldSize=[]):%0a%3c ...     return [500 + gen*10, 1000 + gen*10]%0a%3c ... %0a%3c >>> simu = simulator(%0a%3c ...     population(size=[500, 1000], infoFields=['migrate_to']),%0a%3c ...     randomMating(subPopSize=demo))%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initSex()],%0a%3c ...     ops = [%0a%3c ...         migrator(rate=[[0.8, 0.2], [0.4, 0.6]]),%0a%3c ...         stat(popSize=True),%0a%3c ...         pyEval(r'"%25s\n" %25 subPopSize')%0a%3c ...     ],%0a%3c ...     gen = 3%0a%3c ... )%0a%3c [500, 1000]%0a%3c [510, 1010]%0a%3c [520, 1020]%0a%3c (3,)%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Determine number of offspring during mating%0a%3c %0a%3c simuPOP by default produces only one offspring per mating event. Because more parents are involved in the production of offspring, this setting leads to larger effective population sizes than mating schemes that produce more offspring at each mating event. However, various situations require a larger family size or even varying family sizes. In these cases, parameter @@numOffspring@@ can be used to control the number of offspring that are produced at each mating event. This parameter takes the following types of inputs%0a%3c %0a%3c * If a single number is given, @@numOffspring@@ offspring are produced at each mating event.%0a%3c %0a%3c * If a Python function is given, this function will be called each time when a mating event happens. Generation number will be passed to this function, which allows different numbers of offspring at different generations.%0a%3c %0a%3c * If a tuple (or list) with more than one numbers is given, the first number must be one of GeometricDistribution, PoissonDistribution, BinomialDistribution and UniformDistribution, with one or two additional parameters. The number of offspring will then follow a specific statistical distribution. Note that all these distributions are adjusted so that the minimal number of offspring is 1.%0a%3c %0a%3c =python [=%0a%3c >>> def checkNumOffspring(ms):%0a%3c ...     '''Check the number of offspring for each family using%0a%3c ...        information field father_idx%0a%3c ...     '''%0a%3c ...     simu = simulator(%0a%3c ...         population(size=[30], infoFields=['father_idx', 'mother_idx']),%0a%3c ...         matingScheme=ms)%0a%3c ...     simu.evolve(%0a%3c ...         preOps = [initSex()],%0a%3c ...         ops=[parentsTagger()],%0a%3c ...         gen=1)%0a%3c ...     # get the parents of each offspring%0a%3c ...     parents = [(x, y) for x, y in zip(simu.population(0).indInfo('mother_idx'),%0a%3c ...         simu.population(0).indInfo('father_idx'))]%0a%3c ...     # Individuals with identical parents are considered as siblings.%0a%3c ...     famSize = []%0a%3c ...     lastParent = (-1, -1)%0a%3c ...     for parent in parents:%0a%3c ...         if parent == lastParent:%0a%3c ...             famSize[-1] += 1%0a%3c ...         else:%0a%3c ...             lastParent = parent%0a%3c ...             famSize.append(1)%0a%3c ...     return famSize%0a%3c ... %0a%3c >>> # Case 1: produce the given number of offspring%0a%3c >>> checkNumOffspring(randomMating(numOffspring=2))%0a%3c [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]%0a%3c >>> # Case 2: Use a Python function%0a%3c >>> import random%0a%3c >>> def func(gen):%0a%3c ...     return random.randint(5, 8)%0a%3c ... %0a%3c >>> checkNumOffspring(randomMating(numOffspring=func))%0a%3c [7, 8, 6, 7, 2]%0a%3c >>> # Case 3: A geometric distribution%0a%3c >>> checkNumOffspring(randomMating(numOffspring=(GeometricDistribution, 0.3)))%0a%3c [2, 1, 16, 4, 2, 3, 2]%0a%3c >>> # Case 4: A Possition distribution%0a%3c >>> checkNumOffspring(randomMating(numOffspring=(PoissonDistribution, 3)))%0a%3c [4, 2, 4, 4, 5, 4, 1, 2, 4]%0a%3c >>> # Case 5: A Binomial distribution%0a%3c >>> checkNumOffspring(randomMating(numOffspring=(BinomialDistribution, 0.1, 10)))%0a%3c [4, 1, 2, 2, 1, 3, 2, 3, 2, 1, 4, 3, 2]%0a%3c >>> # Case 6: A uniform distribution%0a%3c >>> checkNumOffspring(randomMating(numOffspring=(UniformDistribution, 2, 6)))%0a%3c [2, 4, 4, 2, 5, 3, 2, 5, 3]%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Control offspring sex%0a%3c %0a%3c Because sex can influence how genotypes are transmitted (e.g. sex chromosomes, haplodiploid population), simuPOP determines offspring sex before it passes an offspring to a genotype transmitter (during-mating operator) to transmit genotype from parents to offspring. The default sexMode in almost all mating schemes is RandomSex, in which case simuPOP assign Male or Female to offspring with equal probability.%0a%3c %0a%3c Other sex determination methods are also available:%0a%3c %0a%3c • sexMode=NoSex: Sex is not simulated so everyone is Male. This is the default mode where offspring can be Male or Female with equal probability.%0a%3c %0a%3c * @@sexMode=(ProbOfMale, prob)@@: Produce males with given probability.%0a%3c %0a%3c * @@sexMode=(NumOfMale, n)@@: The first n offspring in each family will be Male. If the number of offspring at a mating event is less than or equal to n, all offspring will be male. %0a%3c %0a%3c * @@sexMode=(NumOfFemale, n)@@: The first n offspring in each family will be Female.%0a%3c %0a%3c This example demonstrates how to use parameter sexMode. In this example, a function checkSexMode is defined. It takes a mating scheme as its input parameter and use it to evolve a population with 40 individuals. After evolving a population for one generation, sexes of all offspring are returned as a string.%0a%3c %0a%3c =python [=%0a%3c >>> def checkSexMode(ms):%0a%3c ...     '''Check the assignment of sex to offspring'''%0a%3c ...     simu = simulator(%0a%3c ...         population(size=[40]),%0a%3c ...         matingScheme=ms)%0a%3c ...     simu.evolve(preOps = [initSex()], ops=[], gen=1)%0a%3c ...     # return individual sex as a string%0a%3c ...     return ''.join([ind.sexChar() for ind in simu.population(0).individuals()])%0a%3c ... %0a%3c >>> # Case 1: NoSex (all male, randomMating will not continue)%0a%3c >>> checkSexMode(randomMating(sexMode=NoSex))%0a%3c 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM'%0a%3c >>> # Case 2: RandomSex (Male/Female with probability 0.5)%0a%3c >>> checkSexMode(randomMating(sexMode=RandomSex))%0a%3c 'FMFFFMFFFMFFFMFMMFFMFFFMMFMFMMFFMFFMFMMM'%0a%3c >>> # Case 3: ProbOfMale (Specify probability of male)%0a%3c >>> checkSexMode(randomMating(sexMode=(ProbOfMale, 0.8)))%0a%3c 'FMMMMMFFMMMMFMMMMMMMMFFMMMMMMMMFMMFMMMMM'%0a%3c >>> # Case 4: NumOfMale (Specify number of male in each family)%0a%3c >>> checkSexMode(randomMating(numOffspring=3, sexMode=(NumOfMale, 1)))%0a%3c 'MFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFMFFM'%0a%3c >>> # Case 5: NumOfFamel (Specify number of female in each family)%0a%3c >>> checkSexMode(randomMating(%0a%3c ...     numOffspring=(UniformDistribution, 4, 6),%0a%3c ...     sexMode=(NumOfFemale, 2))%0a%3c ... )%0a%3c 'FFMMMFFMMMMFFMMMFFMMMFFMMMFFMMMFFMMMFFMM'%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Monogamous mating%0a%3c %0a%3c Monogamous mating (monogamy) in simuPOP refers to mating schemes in which each parent mates only once. In an asexual setting, this implies parents are chosen without replacement. In sexual mating schemes, this means that parents are chosen without replacement, they have only one spouse during their life time so that all siblings have the same parents (no half-sibling).%0a%3c %0a%3c simuPOP provides a diploid sexual monogamous mating scheme monogamousMating. However, without careful planning, this mating scheme can easily stop working due to the lack of parents. For example, if a population has 40 males and 55 females, only 40 successful mating events can happen and result in 40 offspring in the offspring generation. monogamousMating will exit if the offspring generation is larger than 40.%0a%3c %0a%3c This example demonstrates one scenario of using a monogamous mating scheme where sex of parents and offspring are strictly specified so that parents will not be exhausted. The sex initializer initSex assigns exactly 10 males and 10 females to the initial population. Because of the use of numOffspring=2, sexMode=(NumOfMale, 1), each mating event will produce exactly one male and one female. Unlike a random mating scheme that only about 80%25 of parents are involved in the production of an offspring population with the same size, this mating scheme makes use of all parents.%0a%3c %0a%3c %0a%3c =python [=%0a%3c >>> simu = simulator(population(20, infoFields=['father_idx', 'mother_idx']),%0a%3c ...     monogamousMating(numOffspring=2, sexMode=(NumOfMale, 1)))%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initSex(sex=(Male, Female))],%0a%3c ...     ops = [parentsTagger()],%0a%3c ...     gen = 5%0a%3c ... )%0a%3c (5,)%0a%3c >>> pop = simu.extract(0)%0a%3c >>> [ind.sex() for ind in pop.individuals()]%0a%3c [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]%0a%3c >>> [ind.intInfo('father_idx') for ind in pop.individuals()]%0a%3c [18, 18, 6, 6, 0, 0, 10, 10, 8, 8, 4, 4, 2, 2, 16, 16, 14, 14, 12, 12]%0a%3c >>> [ind.intInfo('mother_idx') for ind in pop.individuals()]%0a%3c [17, 17, 19, 19, 5, 5, 1, 1, 7, 7, 3, 3, 13, 13, 11, 11, 9, 9, 15, 15]%0a%3c >>> # count the number of distinct parents%0a%3c >>> len(set(pop.indInfo('father_idx')))%0a%3c 10%0a%3c >>> len(set(pop.indInfo('mother_idx')))%0a%3c 10%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Mating in haplodiploid populations%0a%3c %0a%3c Male individuals in a haplodiploid population are derived from unfertilized eggs and thus have only one set of chromosomes. Mating in such a population is handled by a special mating scheme called haplodiplodMating. This mating scheme chooses a pair of parents randomly and produces some offspring. It transmit maternal chromosomes and paternal chromosomes (the only copy) to female offspring, and only maternal chromosomes to male offspring. Example [haplodiploidMating] demonstrates how to use this mating scheme. It uses three initializers because sex has to be initialized before two other intializers can initialize genotype by sex.%0a%3c %0a%3c =python [=%0a%3c >>> pop = population(size=[2,5], ploidy=Haplodiploid, loci=[3, 5])%0a%3c >>> InitByFreq(pop, [0.3, 0.7])%0a%3c >>> Dump(pop)%0a%3c Ploidy: 2 (haplodiploid)%0a%3c Chromosomes:%0a%3c 1: chrom1 (Autosome, 3 loci)%0a%3c   loc1-1 (1), loc1-2 (2), loc1-3 (3)%0a%3c 2: chrom2 (Autosome, 5 loci)%0a%3c   loc2-1 (1), loc2-2 (2), loc2-3 (3), loc2-4 (4), loc2-5 (5)%0a%3c population size: 7 (2 subpopulations with 2, 5 individuals)%0a%3c Number of ancestral populations: 0%0a%3c %0a%3c Subpopulation 0 (unnamed), 2 individuals:%0a%3c    0: FU 111 11110 | 100 10101 %0a%3c    1: MU 111 10111 | ___ _____ %0a%3c Subpopulation 1 (unnamed), 5 individuals:%0a%3c    2: FU 110 10110 | 111 00001 %0a%3c    3: FU 110 11110 | 111 01001 %0a%3c    4: FU 000 11101 | 111 11011 %0a%3c    5: FU 101 11110 | 111 11000 %0a%3c    6: FU 111 10110 | 110 10111 %0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Heterogeneous mating schemes%0a%3c %0a%3c Different groups of individuals in a population may have different mating patterns. For example, individuals with different properties can have varying fecundity, represented by different numbers of offspring generated per mating event. This can be extended to aged populations in which only adults (may be defined by age > 20 and age %3c 40) can produce offspring, where other individuals will either be copied to the offspring generation or die.%0a%3c %0a%3c A heterogeneous mating scheme (heteroMating) accepts a list of mating schemes that are applied to different subpopulation or virtual subpopulations. If multiple mating schemes are applied to the same subpopulation, each of them only population part of the offspring subpopulation. %0a%3c %0a%3c This example applies two mating schemes to two VSPs defined by proportions of individuals. In this mating scheme, 20%25 of individuals go through self-mating and 80%25 of individuals go through random mating. This can be seen from the parental indexes of individuals in the offspring generation: individuals whose mother_idx are -1 are genetically only derived from their fathers. %0a%3c %0a%3c =python [=%0a%3c >>> pop = population(size=[1000], loci=[2],%0a%3c ...     infoFields=['father_idx', 'mother_idx'])%0a%3c >>> pop.setVirtualSplitter(proportionSplitter([0.2, 0.8]))%0a%3c >>> simu = simulator(pop, heteroMating(%0a%3c ...     matingSchemes = [%0a%3c ...         selfMating(subPop=(0, 0)),%0a%3c ...         randomMating(subPop=(0, 1))%0a%3c ...     ])%0a%3c ... )%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initSex()],%0a%3c ...     ops= [parentsTagger()],%0a%3c ...     gen = 10%0a%3c ... )%0a%3c (10,)%0a%3c >>> pop = simu.extract(0)%0a%3c >>> [ind.intInfo('father_idx') for ind in pop.individuals(0)][:15]%0a%3c [162, 114, 155, 162, 105, 62, 83, 24, 185, 131, 168, 3, 6, 115, 35]%0a%3c >>> [ind.intInfo('mother_idx') for ind in pop.individuals(0)][:15]%0a%3c [119, -1, 46, 130, 101, 135, -1, 163, 55, 179, 152, 111, -1, 152, 188]%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a
host:1232340988=127.0.0.1
author:1232339943=
diff:1232339943:1232339530:=3,163c3%0a%3c !!! Genotypic structure%0a%3c %0a%3c '''Genotypic structure''' refers to structural information shared by all individuals in a population, including number of homologous copies of chromosomes (c.f. @@ploidy()@@, @@ploidyName()@@), chromosome types and names (c.f. @@numChrom()@@, @@chromType()@@, @@chromName()@@), position and name of each locus (c.f. @@numLoci(ch)@@, @@locusPos(loc)@@, @@locusName(loc)@@), and axillary information attached to each individual (c.f. @@infoField(idx)@@, @@infoFields()@@). In addition to property access functions, a number of utility functions are provided to, for example, look up the index of a locus by its name (c.f. @@locusByName()@@, @@chromBegin()@@, @@chromLocusPair()@@).%0a%3c %0a%3c A genotypic structure can be retrieved from ''individual'' and ''population'' objects. Because a population consists of individuals of the same type, genotypic information can only be changed for all individuals at the population level. Populations in a simulator usually have the same genotypic structure because they are created by as replicates, but their structure may change during evolution.%0a%3c %0a%3c =python [=%0a%3c >>> pop = population(size=[2, 3], ploidy=2, loci=[5, 10],%0a%3c ...     lociPos=[range(0, 5), range(0, 20, 2)], chromNames=['Chr1', 'Chr2'],%0a%3c ...     alleleNames=['A', 'C', 'T', 'G'])%0a%3c >>> # access genotypic information from the population%0a%3c >>> pop.ploidy()%0a%3c 2%0a%3c >>> pop.ploidyName()%0a%3c 'diploid'%0a%3c >>> pop.numChrom()%0a%3c 2%0a%3c >>> pop.locusPos(2)%0a%3c 2.0%0a%3c >>> pop.alleleName(1)%0a%3c 'C'%0a%3c >>> # access from an individual%0a%3c >>> ind = pop.individual(2)%0a%3c >>> ind.numLoci(1)%0a%3c 10%0a%3c >>> ind.chromName(0)%0a%3c 'Chr1'%0a%3c >>> ind.locusName(1)%0a%3c 'loc1-2'%0a%3c >>> # utility functions%0a%3c >>> ind.chromBegin(1)%0a%3c 5%0a%3c >>> ind.chromByName('Chr2')%0a%3c 1%0a%3c >>>%0a%3c =]%0a%3c %0a%3c !!! Chromosome types%0a%3c %0a%3c The default chromosome type is autosome, which is the normal chromosomes in diploid, and in haploid populations. simuPOP supports three other types of chromosomes, namely ''ChromosomeX'', ''ChromosomeY'' and ''Customized''. Sex chromosomes are only valid in haploid populations where chromosomes X and Y are used to determine the sex of an offspring. Customized chromosomes rely on user defined functions and operators to be passed from parents to offspring.%0a%3c %0a%3c This example shows how to specify different chromosome types, and how genotypes of these special chromosomes are arranged.%0a%3c %0a%3c =python [=%0a%3c >>> pop = population(size=6, ploidy=2, loci=[3, 3, 6, 4, 4, 4],%0a%3c ...     chromTypes=[Autosome]*2 + [ChromosomeX, ChromosomeY] + [Customized]*2)%0a%3c >>> InitByFreq(pop, [0.3, 0.7])%0a%3c >>> Dump(pop, structure=False) # does not display genotypic structure information%0a%3c Subpopulation 0 (unnamed), 6 individuals:%0a%3c    0: FU 000 111 111101 ____ 1001 1011 | 000 010 100110 ____ 1111 1110 %0a%3c    1: MU 011 111 010111 ____ 0010 1010 | 111 110 ______ 1111 1111 0001 %0a%3c    2: FU 111 110 011111 ____ 0100 0111 | 110 111 111111 ____ 1111 1111 %0a%3c    3: FU 111 111 111110 ____ 0001 1111 | 011 111 011101 ____ 0000 1110 %0a%3c    4: MU 111 111 111011 ____ 1101 0111 | 110 110 ______ 0011 0111 0011 %0a%3c    5: FU 001 111 011110 ____ 1100 1011 | 111 111 111110 ____ 1100 1011 %0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Information fields%0a%3c %0a%3c Different kinds of simulations require different kinds of individuals. Individuals with only genotype information are sufficient to simulate the basic Wright-Fisher model. Sex is needed to simulate such a model in diploid populations with sex. Individual fitness may be needed if selection is induced, and age may be needed if the population is age-structured. In addition, different types of quantitative traits or affection status may be needed to study the impact of genotype on individual phenotype. Because it is infeasible to provide all such information to an individual, simuPOP keeps genotype, sex (Male or Female) and affection status as built-in properties of an individual, and all others as optional information fields (float numbers) attached to each individual.%0a%3c %0a%3c Information fields can be specified when a population is created, or added later using relevant function. They are essential for the function of many simuPOP operators. For example, all selection operators require information field fitness to store evaluated fitness values for each individual. Operator migrator uses information field migrate_to to store the ID of subpopulation an individual will migrate to. An error will be raised if these operators are applied to a population without needed information fields.%0a%3c %0a%3c =python [=%0a%3c >>> pop = population(10, loci=[20], ancGen=1,%0a%3c ...     infoFields=['father_idx', 'mother_idx'])%0a%3c >>> simu = simulator(pop, randomMating())%0a%3c >>> simu.evolve(%0a%3c ...     preOps = [initByValue([0]*20+[1]*20)],%0a%3c ...     ops = [%0a%3c ...         parentsTagger(),%0a%3c ...         recombinator(rate=0.01)%0a%3c ...     ],%0a%3c ...     gen = 1%0a%3c ... )%0a%3c (1,)%0a%3c >>> pop = simu.extract(0)%0a%3c >>> pop.indInfo('mother_idx')  # mother of all offspring%0a%3c (7.0, 7.0, 4.0, 4.0, 8.0, 0.0, 2.0, 7.0, 6.0, 6.0)%0a%3c >>> ind = pop.individual(0)%0a%3c >>> mom = pop.ancestor(ind.intInfo('mother_idx'), 1)%0a%3c >>> print ind.genotype(0)%0a%3c [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]%0a%3c >>> print mom.genotype(0)%0a%3c [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]%0a%3c >>> print mom.genotype(1)%0a%3c [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! Subpopulations%0a%3c A simuPOP population consists of one or more subpopulations. Subpopulations serve as barriers of individuals in the sense that mating only happens between individuals in the same subpopulation. A number of functions are provided to merge, remove, resize subpopulations, and move individuals between subpopulations (migration). You will rarely get a chance to use them directly because such operations are usually handled by operators.%0a%3c %0a%3c =python [=%0a%3c >>> pop = population(size=[3, 4, 5], ploidy=1, loci=[1], infoFields=['x'])%0a%3c >>> # individual 0, 1, 2, ... will have an allele 0, 1, 2, ...%0a%3c >>> pop.setGenotype(range(pop.popSize()))%0a%3c >>> #%0a%3c >>> pop.subPopSize(1)%0a%3c 4%0a%3c >>> # merge subpopulations%0a%3c >>> pop.mergeSubPops([1, 2])%0a%3c >>> # split subpopulations%0a%3c >>> pop.splitSubPop(1, [2, 7])%0a%3c >>> pop.subPopSizes()%0a%3c (3, 2, 7)%0a%3c >>> # set information field to each individual's new subpopulation ID%0a%3c >>> pop.setIndInfo([0, 1, 2, -1, 0, 1, 2, -1, -1, 0, 1, 2], 'x')%0a%3c >>> # this manually triggers an migration, individuals with negative values%0a%3c >>> # at this information field are removed.%0a%3c >>> pop.setSubPopByIndInfo('x')%0a%3c >>> Dump(pop, width=2, structure=False)%0a%3c Subpopulation 0 (unnamed), 3 individuals:%0a%3c    0: MU  0 |  0%0a%3c    1: MU  4 |  0%0a%3c    2: MU  9 |  0%0a%3c Subpopulation 1 (unnamed), 3 individuals:%0a%3c    3: MU  1 |  1%0a%3c    4: MU  5 |  1%0a%3c    5: MU 10 |  1%0a%3c Subpopulation 2 (unnamed), 3 individuals:%0a%3c    6: MU  2 |  2%0a%3c    7: MU  6 |  2%0a%3c    8: MU 11 |  2%0a%3c >>>%0a%3c %0a%3c =]%0a%3c %0a%3c !!! %0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a%3c !!!%0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a%3c !!!%0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a%3c !!!%0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a%3c !!!%0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a%3c !!!%0a%3c %0a%3c =python [=%0a%3c %0a%3c =]%0a---%0a> !!%0a\ No newline at end of file%0a
host:1232339943=127.0.0.1
author:1232339530=
diff:1232339530:1232339530:=1,3d0%0a%3c (:toc:)%0a%3c %0a%3c !!%0a\ No newline at end of file%0a
host:1232339530=127.0.0.1
